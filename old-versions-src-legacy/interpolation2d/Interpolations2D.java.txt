package net.algart.arrays.interpolation;

import net.algart.arrays.*;

/**
 * <p>Implementations of {@link Interpolation2D} interface.</p>
 *
 * <p>AlgART Laboratory 2007-2008</p>
 *
 * @author Daniel Alievsky
 * @version 1.1
 * @since JDK 1.5
 */
public class Interpolations2D {
    private Interpolations2D() {}

    /**
     * Returns an implementation with {@link Interpolation2D#get get} method that returns the element
     * of the passed matrix at the position <tt>(ix,iy)</tt>,
     * where <tt>ix=(long)x</tt>, <tt>iy=(long)y</tt>.
     *
     * <p>The indexes are not checked by that method; so, the result will be incorrect
     * if {@code ix < 0 || iy < 0 || ix >= nx || iy >= ny}.
     * (Note: if the index in the underlying AlgART array is less than 0 or greater that its length,
     * <tt>IndexOutOfBoundsException</tt> may be thrown, but also may be not thrown.)
     *
     * @param m the AlgART matrix that will be processed by {@link Interpolation2D#get get} method.
     * @return  an instance of this class processing the given matrix.
     */
    public static Interpolation2D getTrivialInstance(Matrix<? extends PArray> m) {
        if (m.isDirectAccessible() && !m.isCopyOnNextWrite()) {
            DirectAccessible da = (DirectAccessible)m.array();
            Object arr = da.javaArray();
            int ofs = da.javaArrayOffset();
            //[[Repeat() byte ==> char,,short,,int,,long,,float,,double;;
            //           Byte ==> Char,,Short,,Int,,Long,,Float,,Double]]
            if (arr instanceof byte[]) {
                return new TrivialByteInterpolation2D((byte[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else //[[Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! ]]
            if (arr instanceof char[]) {
                return new TrivialCharInterpolation2D((char[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof short[]) {
                return new TrivialShortInterpolation2D((short[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof int[]) {
                return new TrivialIntInterpolation2D((int[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof long[]) {
                return new TrivialLongInterpolation2D((long[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof float[]) {
                return new TrivialFloatInterpolation2D((float[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof double[]) {
                return new TrivialDoubleInterpolation2D((double[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else //[[Repeat.AutoGeneratedEnd]]
                return new TrivialInterpolation2D(m);
        } else {
            return new TrivialInterpolation2D(m);
        }
    }

    /**
     * Returns an implementation with {@link Interpolation2D#get get} method that returns the element
     * of the passed matrix at the position <tt>(ix,iy)</tt>,
     * where <tt>ix=(long)x</tt>, <tt>iy=(long)y</tt>.
     *
     * <p>If {@code ix < 0 || iy < 0 || ix >= nx || iy >= ny}, that method returns <tt>outsideValue</tt>
     * and never throws an exception. This check slows down the algorithm a little.
     *
     * @param m            the AlgART matrix that will be processed by {@link Interpolation2D#get get} method.
     * @param outsideValue the value returned if the position is outside the matrix sizes.
     * @return             an instance of this class processing the given matrix.
     */
    public static Interpolation2D getTrivialInstance(Matrix<? extends PArray> m, double outsideValue) {
        if (m.isDirectAccessible() && !m.isCopyOnNextWrite()) {
            DirectAccessible da = (DirectAccessible)m.array();
            Object arr = da.javaArray();
            int ofs = da.javaArrayOffset();
            //[[Repeat() byte ==> char,,short,,int,,long,,float,,double;;
            //           Byte ==> Char,,Short,,Int,,Long,,Float,,Double]]
            if (arr instanceof byte[]) {
                return new CheckedTrivialByteInterpolation2D((byte[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else //[[Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! ]]
            if (arr instanceof char[]) {
                return new CheckedTrivialCharInterpolation2D((char[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof short[]) {
                return new CheckedTrivialShortInterpolation2D((short[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof int[]) {
                return new CheckedTrivialIntInterpolation2D((int[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof long[]) {
                return new CheckedTrivialLongInterpolation2D((long[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof float[]) {
                return new CheckedTrivialFloatInterpolation2D((float[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof double[]) {
                return new CheckedTrivialDoubleInterpolation2D((double[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else //[[Repeat.AutoGeneratedEnd]]
                return new CheckedTrivialInterpolation2D(m, outsideValue);
        } else {
            return new CheckedTrivialInterpolation2D(m, outsideValue);
        }
    }

    /**
     * Returns an implementation with {@link Interpolation2D#get get} method that returns the element
     * of the passed matrix at the position <tt>(ix,iy)</tt>,
     * where <tt>ix=(long)x</tt>, <tt>iy=(long)y</tt>.
     *
     * <p>If {@code ix < 0 || iy < 0 || ix >= nx || iy >= ny}, that method always throws
     * <tt>IndexOutOfBoundsException</tt>. This check slows down the algorithm a little.
     *
     * @param m the AlgART matrix that will be processed by {@link Interpolation2D#get get} method.
     * @return  an instance of this class processing the given matrix.
     */
    public static Interpolation2D getCheckedTrivialInstance(Matrix<? extends PArray> m) {
        if (m.isDirectAccessible() && !m.isCopyOnNextWrite()) {
            DirectAccessible da = (DirectAccessible)m.array();
            Object arr = da.javaArray();
            int ofs = da.javaArrayOffset();
            //[[Repeat() byte ==> char,,short,,int,,long,,float,,double;;
            //           Byte ==> Char,,Short,,Int,,Long,,Float,,Double]]
            if (arr instanceof byte[]) {
                return new CheckedTrivialByteInterpolation2D((byte[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else //[[Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! ]]
            if (arr instanceof char[]) {
                return new CheckedTrivialCharInterpolation2D((char[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof short[]) {
                return new CheckedTrivialShortInterpolation2D((short[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof int[]) {
                return new CheckedTrivialIntInterpolation2D((int[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof long[]) {
                return new CheckedTrivialLongInterpolation2D((long[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof float[]) {
                return new CheckedTrivialFloatInterpolation2D((float[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof double[]) {
                return new CheckedTrivialDoubleInterpolation2D((double[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else //[[Repeat.AutoGeneratedEnd]]
                return new CheckedTrivialInterpolation2D(m, null);
        } else {
            return new CheckedTrivialInterpolation2D(m, null);
        }
    }

    /**
     * Returns an implementation with {@link Interpolation2D#get get} method that returns the value,
     * calculated on the base of 4 elements of the passed matrix,
     * as described in comments to {@link Interpolation2D#get get} method, by bilinear interpolation.
     *
     * <p>The indexes are not checked by that method; so, the result will be incorrect
     * if {@code ix < 0 || iy < 0 || ix >= nx-1 || iy >= ny-1}.
     * (Note: if the index in the underlying AlgART array is less than 0 or greater that its length,
     * <tt>IndexOutOfBoundsException</tt> may be thrown, but also may be not thrown.)
     *
     * @param m the AlgART matrix that will be processed by {@link Interpolation2D#get get} method.
     * @return  an instance of this class processing the given matrix.
     */
    public static Interpolation2D getBilinearInstance(Matrix<? extends PArray> m) {
        if (m.isDirectAccessible() && !m.isCopyOnNextWrite()) {
            DirectAccessible da = (DirectAccessible)m.array();
            Object arr = da.javaArray();
            int ofs = da.javaArrayOffset();
            //[[Repeat() byte ==> char,,short,,int,,long,,float,,double;;
            //           Byte ==> Char,,Short,,Int,,Long,,Float,,Double]]
            if (arr instanceof byte[]) {
                return new BilinearByteInterpolation2D((byte[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else //[[Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! ]]
            if (arr instanceof char[]) {
                return new BilinearCharInterpolation2D((char[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof short[]) {
                return new BilinearShortInterpolation2D((short[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof int[]) {
                return new BilinearIntInterpolation2D((int[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof long[]) {
                return new BilinearLongInterpolation2D((long[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof float[]) {
                return new BilinearFloatInterpolation2D((float[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else
            if (arr instanceof double[]) {
                return new BilinearDoubleInterpolation2D((double[])arr, ofs, (int)m.dimX(), (int)m.dimY());
            } else //[[Repeat.AutoGeneratedEnd]]
                return new BilinearInterpolation2D(m);
        } else {
            return new BilinearInterpolation2D(m);
        }
    }

    /**
     * Returns an implementation with {@link Interpolation2D#get get} method that returns the value,
     * calculated on the base of 4 elements of the passed matrix,
     * as described in comments to {@link Interpolation2D#get get} method, by bilinear interpolation.
     *
     * <p>If {@code ix < 0 || iy < 0 || ix >= nx || iy >= ny}, that method returns <tt>outsideValue</tt>
     * and never throws an exception. This check slows down the algorithm a little.
     *
     * @param m            the AlgART matrix that will be processed by {@link Interpolation2D#get get} method.
     * @param outsideValue the value returned if the position is outside the matrix sizes.
     * @return             an instance of this class processing the given matrix.
     */
    public static Interpolation2D getBilinearInstance(Matrix<? extends PArray> m, double outsideValue) {
        if (m.isDirectAccessible() && !m.isCopyOnNextWrite()) {
            DirectAccessible da = (DirectAccessible)m.array();
            Object arr = da.javaArray();
            int ofs = da.javaArrayOffset();
            //[[Repeat() byte ==> char,,short,,int,,long,,float,,double;;
            //           Byte ==> Char,,Short,,Int,,Long,,Float,,Double]]
            if (arr instanceof byte[]) {
                return new CheckedBilinearByteInterpolation2D((byte[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else //[[Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! ]]
            if (arr instanceof char[]) {
                return new CheckedBilinearCharInterpolation2D((char[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof short[]) {
                return new CheckedBilinearShortInterpolation2D((short[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof int[]) {
                return new CheckedBilinearIntInterpolation2D((int[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof long[]) {
                return new CheckedBilinearLongInterpolation2D((long[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof float[]) {
                return new CheckedBilinearFloatInterpolation2D((float[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else
            if (arr instanceof double[]) {
                return new CheckedBilinearDoubleInterpolation2D((double[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), outsideValue);
            } else //[[Repeat.AutoGeneratedEnd]]
                return new CheckedBilinearInterpolation2D(m, outsideValue);
        } else {
            return new CheckedBilinearInterpolation2D(m, outsideValue);
        }
    }

    /**
     * Returns an implementation with {@link Interpolation2D#get get} method that returns the value,
     * calculated on the base of 4 elements of the passed matrix,
     * as described in comments to {@link Interpolation2D#get get} method, by bilinear interpolation.
     *
     * <p>If {@code ix < 0 || iy < 0 || ix >= nx-1 || iy >= ny-1}, that method always throws
     * <tt>IndexOutOfBoundsException</tt>. This check slows down the algorithm a little.
     *
     * @param m the AlgART matrix that will be processed by {@link Interpolation2D#get get} method.
     * @return  an instance of this class processing the given matrix.
     */
    public static Interpolation2D getCheckedBilinearInstance(Matrix<? extends PArray> m) {
        if (m.isDirectAccessible() && !m.isCopyOnNextWrite()) {
            DirectAccessible da = (DirectAccessible)m.array();
            Object arr = da.javaArray();
            int ofs = da.javaArrayOffset();
            //[[Repeat() byte ==> char,,short,,int,,long,,float,,double;;
            //           Byte ==> Char,,Short,,Int,,Long,,Float,,Double]]
            if (arr instanceof byte[]) {
                return new CheckedBilinearByteInterpolation2D((byte[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else //[[Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! ]]
            if (arr instanceof char[]) {
                return new CheckedBilinearCharInterpolation2D((char[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof short[]) {
                return new CheckedBilinearShortInterpolation2D((short[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof int[]) {
                return new CheckedBilinearIntInterpolation2D((int[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof long[]) {
                return new CheckedBilinearLongInterpolation2D((long[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof float[]) {
                return new CheckedBilinearFloatInterpolation2D((float[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else
            if (arr instanceof double[]) {
                return new CheckedBilinearDoubleInterpolation2D((double[])arr, ofs,
                    (int)m.dimX(), (int)m.dimY(), null);
            } else //[[Repeat.AutoGeneratedEnd]]
                return new CheckedBilinearInterpolation2D(m, null);
        } else {
            return new CheckedBilinearInterpolation2D(m, null);
        }
    }

    private static class TrivialInterpolation2D implements Interpolation2D {
        final Matrix<? extends PArray> m;
        final long nx, ny;
        final PArray array;

        TrivialInterpolation2D(Matrix<? extends PArray> m) {
            if (m == null)
                throw new NullPointerException("Null m argument");
            this.m = m;
            this.nx = m.dimX();
            this.ny = m.dimY();
            this.array = m.array();
        }

        public double get(double x, double y) {
            long ix = (long)x;
            long iy = (long)y;
            return array.getDouble(iy * nx + ix);
        }
    }

    private static class CheckedTrivialInterpolation2D extends TrivialInterpolation2D {
        final Double outsideValue;

        CheckedTrivialInterpolation2D(Matrix<? extends PArray> m, Double outsideValue) {
            super(m);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            long ix = (long)x;
            long iy = (long)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " + m);
                else
                    return outsideValue;
            }
            return array.getDouble(iy * nx + ix);
        }
    }

    private static class BilinearInterpolation2D extends TrivialInterpolation2D {
        BilinearInterpolation2D(Matrix<? extends PArray> m) {
            super(m);
        }

        public double get(double x, double y) {
            final long ix = (long)x;
            final long iy = (long)y;
            long ofs1 = iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = array.getDouble(ofs1);
            final double b = array.getDouble(ofs1 + 1);
            final double c = array.getDouble(ofs2);
            final double d = array.getDouble(ofs2 + 1);
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearInterpolation2D extends CheckedTrivialInterpolation2D {
        CheckedBilinearInterpolation2D(Matrix<? extends PArray> m, Double outsideValue) {
            super(m, outsideValue);
        }

        public double get(double x, double y) {
            final long ix = (long)x;
            final long iy = (long)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " + m);
                else
                    return outsideValue;
            }
            long ofs1 = iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = array.getDouble(ofs1);
            final double b = array.getDouble(ofs1 + 1);
            final double c = array.getDouble(ofs2);
            final double d = array.getDouble(ofs2 + 1);
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    /*Repeat() byte ==> char,,short,,int,,long,,float,,double;;
               Byte ==> Char,,Short,,Int,,Long,,Float,,Double;;
               (\s*&\s*0xFF) ==> ,,$1FF,, ,, ...
     */
    private static class TrivialByteInterpolation2D implements Interpolation2D {
        final byte[] ja;
        final int ofs, nx, ny;

        TrivialByteInterpolation2D(byte[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null byte[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix] & 0xFF;
        }
    }

    private static class CheckedTrivialByteInterpolation2D extends TrivialByteInterpolation2D {
        final Double outsideValue;

        CheckedTrivialByteInterpolation2D(byte[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " byte[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix] & 0xFF;
        }
    }

    private static class BilinearByteInterpolation2D extends TrivialByteInterpolation2D {
        BilinearByteInterpolation2D(byte[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1] & 0xFF;
            final double b = ja[ofs1 + 1] & 0xFF;
            final double c = ja[ofs2] & 0xFF;
            final double d = ja[ofs2 + 1] & 0xFF;
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearByteInterpolation2D extends CheckedTrivialByteInterpolation2D {
        CheckedBilinearByteInterpolation2D(byte[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " byte[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1] & 0xFF;
            final double b = ja[ofs1 + 1] & 0xFF;
            final double c = ja[ofs2] & 0xFF;
            final double d = ja[ofs2 + 1] & 0xFF;
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }
    /*Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! */
    private static class TrivialCharInterpolation2D implements Interpolation2D {
        final char[] ja;
        final int ofs, nx, ny;

        TrivialCharInterpolation2D(char[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null char[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class CheckedTrivialCharInterpolation2D extends TrivialCharInterpolation2D {
        final Double outsideValue;

        CheckedTrivialCharInterpolation2D(char[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " char[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class BilinearCharInterpolation2D extends TrivialCharInterpolation2D {
        BilinearCharInterpolation2D(char[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearCharInterpolation2D extends CheckedTrivialCharInterpolation2D {
        CheckedBilinearCharInterpolation2D(char[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " char[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class TrivialShortInterpolation2D implements Interpolation2D {
        final short[] ja;
        final int ofs, nx, ny;

        TrivialShortInterpolation2D(short[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null short[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix] & 0xFFFF;
        }
    }

    private static class CheckedTrivialShortInterpolation2D extends TrivialShortInterpolation2D {
        final Double outsideValue;

        CheckedTrivialShortInterpolation2D(short[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " short[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix] & 0xFFFF;
        }
    }

    private static class BilinearShortInterpolation2D extends TrivialShortInterpolation2D {
        BilinearShortInterpolation2D(short[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1] & 0xFFFF;
            final double b = ja[ofs1 + 1] & 0xFFFF;
            final double c = ja[ofs2] & 0xFFFF;
            final double d = ja[ofs2 + 1] & 0xFFFF;
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearShortInterpolation2D extends CheckedTrivialShortInterpolation2D {
        CheckedBilinearShortInterpolation2D(short[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " short[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1] & 0xFFFF;
            final double b = ja[ofs1 + 1] & 0xFFFF;
            final double c = ja[ofs2] & 0xFFFF;
            final double d = ja[ofs2 + 1] & 0xFFFF;
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class TrivialIntInterpolation2D implements Interpolation2D {
        final int[] ja;
        final int ofs, nx, ny;

        TrivialIntInterpolation2D(int[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null int[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class CheckedTrivialIntInterpolation2D extends TrivialIntInterpolation2D {
        final Double outsideValue;

        CheckedTrivialIntInterpolation2D(int[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " int[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class BilinearIntInterpolation2D extends TrivialIntInterpolation2D {
        BilinearIntInterpolation2D(int[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearIntInterpolation2D extends CheckedTrivialIntInterpolation2D {
        CheckedBilinearIntInterpolation2D(int[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " int[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class TrivialLongInterpolation2D implements Interpolation2D {
        final long[] ja;
        final int ofs, nx, ny;

        TrivialLongInterpolation2D(long[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null long[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class CheckedTrivialLongInterpolation2D extends TrivialLongInterpolation2D {
        final Double outsideValue;

        CheckedTrivialLongInterpolation2D(long[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " long[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class BilinearLongInterpolation2D extends TrivialLongInterpolation2D {
        BilinearLongInterpolation2D(long[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearLongInterpolation2D extends CheckedTrivialLongInterpolation2D {
        CheckedBilinearLongInterpolation2D(long[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " long[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class TrivialFloatInterpolation2D implements Interpolation2D {
        final float[] ja;
        final int ofs, nx, ny;

        TrivialFloatInterpolation2D(float[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null float[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class CheckedTrivialFloatInterpolation2D extends TrivialFloatInterpolation2D {
        final Double outsideValue;

        CheckedTrivialFloatInterpolation2D(float[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " float[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class BilinearFloatInterpolation2D extends TrivialFloatInterpolation2D {
        BilinearFloatInterpolation2D(float[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearFloatInterpolation2D extends CheckedTrivialFloatInterpolation2D {
        CheckedBilinearFloatInterpolation2D(float[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " float[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class TrivialDoubleInterpolation2D implements Interpolation2D {
        final double[] ja;
        final int ofs, nx, ny;

        TrivialDoubleInterpolation2D(double[] ja, int ofs, int nx, int ny) {
            if (ja == null)
                throw new NullPointerException("Null double[] argument");
            this.ja = ja;
            this.nx = nx;
            this.ny = ny;
            this.ofs = ofs;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class CheckedTrivialDoubleInterpolation2D extends TrivialDoubleInterpolation2D {
        final Double outsideValue;

        CheckedTrivialDoubleInterpolation2D(double[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny);
            this.outsideValue = outsideValue;
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx || iy >= ny) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in "
                        + nx + "x" + ny + " double[] array");
                else
                    return outsideValue;
            }
            return ja[ofs + iy * nx + ix];
        }
    }

    private static class BilinearDoubleInterpolation2D extends TrivialDoubleInterpolation2D {
        BilinearDoubleInterpolation2D(double[] ja, int ofs, int nx, int ny) {
            super(ja, ofs, nx, ny);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }

    private static class CheckedBilinearDoubleInterpolation2D extends CheckedTrivialDoubleInterpolation2D {
        CheckedBilinearDoubleInterpolation2D(double[] ja, int ofs, int nx, int ny, Double outsideValue) {
            super(ja, ofs, nx, ny, outsideValue);
        }

        public double get(double x, double y) {
            final int ix = (int)x;
            final int iy = (int)y;
            if (ix < 0 || iy < 0 || ix >= nx - 1 || iy >= ny - 1) {
                if (outsideValue == null)
                    throw new IndexOutOfBoundsException("Illegal position (" + x + ", " + y + ") in " +
                        + nx + "x" + ny + " double[] array");
                else
                    return outsideValue;
            }
            int ofs1 = ofs + iy * nx + ix, ofs2 = ofs1 + nx;
            final double a = ja[ofs1];
            final double b = ja[ofs1 + 1];
            final double c = ja[ofs2];
            final double d = ja[ofs2 + 1];
            double v1 = (a - b) * (ix - x) + a;
            double v2 = (c - d) * (ix - x) + c;
            return (v1 - v2) * (iy - y) + v1;
        }
    }
    /*Repeat.AutoGeneratedEnd*/
}
