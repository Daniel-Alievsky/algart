<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!-- The original of this text is located at /simagis/trunk/bin/algorithm-lib/html/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<title>Теорема связности для параллельной скелетизации растрового изображения</title>
<link rel="stylesheet" type="text/css" href="../../print.css" media="print">
<link rel="stylesheet" type="text/css" href="../../default.css" media="screen">
</head>

<body>
<!-- wwinclude begin file="../../../service_files/prefix.inc" --><!-- wwinclude end -->

<h4><a href="http://algart.net/">AlgART</a> / <a href="../">Тексты</a></h4>

<h2>Теорема связности для параллельной скелетизации растрового изображения</h2>

<p align="right"><i>Даниэль Алиевский</i></p>

<h4>ОГЛАВЛЕНИЕ</h4>
<ul>
<li><a href="#intro">Введение</a></li>
<li><a href="#theoremConnectivity">Теорема связности: формулировка для скелетов 3x5</a></li>
<li><a href="#proofConnectivity">Теорема связности: доказательство для скелетов 3x5</a>
  <ul>
  <li><a href="#proofCommon">Общие замечания</a></li>
  <li><a href="#proofN3">Случай, когда кратчайшая цепочка, соединяющая разные компоненты, имеет длину <i>N</i>=3</a></li>
  <li><a href="#proofN4">Случай, когда кратчайшая цепочка, соединяющая разные компоненты, имеет длину <i>N</i>=4</a></li>
  </ul>
<li><a href="#example3x5">Примеры алгоритмов скелетизации с апертурой зависимости 3x5</a>
  <ul>
  <li><a href="#theoremThinnessA">Теорема тонкости для алгоритма A</a></li>
  <li><a href="#theoremThinnessB">Теорема тонкости для алгоритма B</a></li>
  </ul>
</li>
</ul>

<p>Традиционный подход к построению скелета (остова) растрового бинарного изображения основан на цикле итераций &laquo;истончения&raquo;. А именно, на каждой итерации изображение немного &laquo;истончается&raquo;, т.е. со всех сторон объектов, присутствующих на изображении, &laquo;снимается&raquo; однопиксельный граничный слой, если пока объект не превратится в набор тонких однопиксельных линий. Начиная с некоторой итерации на изображении остаются только тонкие однопиксельные линии, которые алгоритм скелетизации отказывается изменять (&laquo;истончать&raquo;) далее. С этого момента изображение перестает изменяться, и это служит критерием окончания цикла. Полученное изображение считается скелетом исходного изображения. Одно из важнейших применений скелетов &mdash; векторизация остова изображения, так как в системе тонких однопиксельных линий относительно легко распознать узловые точки и соединяющие их линии, которые можно аппроксимировать теми или иными кривыми.</p>

<p>В данной статье рассматривается фундаментальная проблема: связность скелета. Как правило, к скелетизирующему алгоритму предъявляется требование: один связный объект в результате скелетизации должен превратиться в связную систему тонких линий. Иначе говоря, алгоритм не должен &laquo;рвать&raquo; объект на несвязные части. Очевидно, достаточно гарантировать, что связность сохраняется на каждой итерации скелетизации. Мы сформулируем и докажем <i>теорему связности</i>, позволяющую механически (при помощи соответствующей переборной программы) гарантировать, что одна итерация скелетизации сохраняет связность. Теорема доказывается для случая параллельных алгоритмов обработки, т.е. допускающие параллельную обработку различных пикселов исходного изображения.</p>

<h3><a name="intro"></a>Введение</h3>

<p>Будем считать, что бинарное изображение представлено битовой матрицей: каждый пиксел представлен элементом матрицы 0 или 1, причем нулевые элементы представляют &laquo;фон&raquo;, а единичные &mdash; &laquo;объекты&raquo;. Как правило, биты хранятся в упакованной форме, по 32 или 64 бита в одном машинном слове. Это важно для экономии памяти при обработке больших изображений.</p>

<p>В соответствии с &laquo;компьютерной традицией&raquo;, будем считать, что ось <i>x</i> направлена вправо, а ось <i>y</i> вниз, т.е. &laquo;сверху&raquo; значит &laquo;в направлении уменьшения <i>y</i>&raquo;. Мы часто будем использовать такие выражения, как &laquo;пиксел справа дважды сверху&raquo; по отношению к пикселу (<i>x</i>,&nbsp;<i>y</i>), подразумевая пиксел с координатами (<i>x</i>+1,&nbsp;<i>y</i>&minus;2).</p>

<p>Говоря о &laquo;размерах&raquo; <i>A</i>x<i>B</i> матрицы, прямоугольной апертуры или окрестности, мы будем подразумевать, что горизонтальный размер равен <i>A</i>, а вертикальный размер равен <i>B</i>.</p>

<p>Если не оговорено противное, под <i>связностью</i> мы будем понимать 8-связность некоторого множества единичных пикселов. Иначе говоря, связной компонентой на изображении мы считаем такое множество единичных пикселов, что любые два его элемента можно соединить 8-связной цепочкой единичных пикселов из этого множества и в него больше нельзя добавить элементы без нарушения этого условия. При этом <i>8-связной цепочкой</i> называется такая цепочка, в которой соседние пикселы являются <i>соседями</i>: обе их координаты отличаются не более чем на 1. (У одного пиксела может быть не более 8 таких единичных соседей.) Связная компонента является формализациией понятия &laquo;объект на изображении&raquo;</p>

<p>Данная статья посвящена следующей проблеме: удостовериться, что некий скелетизирующий алгоритм не нарушает связность, т.е. что после выполнения одной итерации алгоритма на месте одной связной компоненты в матрице, получаемой в результате итерации, не возникает двух или более связных компонент.</p>

<p>Существует достаточно простой способ гарантировать связность. Нужно построить алгоритм &laquo;истончения&raquo;, принимающий решение об удалении (обнулении) конкретного граничного пиксела таким образом, чтобы в некоторой окрестности этого пиксела, например, 3x3 или 5x5, гарантировалось сохранение связности конфигурации внутри этой окрестности. Например, если 3x3-окрестность пиксела имеет вид</p>
<pre>
    0 1 1
    0 <b>1</b> 1
    0 0 0
</pre>
<p>то очевидно, что обнуление центрального пиксела не нарушит связности: связная компонента изображения, содержавшая ее, остается связной компонентой. А в конфигурации</p>
<pre>
    1 0 0
    0 <b>1</b> 1
    1 1 1
</pre>
<p>обнуление центрального пиксела приводит к &laquo;отрыву&raquo; левого верхнего пиксела от нижней половины, и есть риск, что связная компонента окажется разъединенной (&laquo;разорванной&raquo;) на две части.</p>

<p>Если есть алгоритм, принимающий решение об удалении конкретного пиксела, и этот алгоритм гарантирует, что в пределах окрестности определенного размера удаление центрального пиксела не нарушает связность, то мы можем последовательно, пиксел за пикселом, применить такой алгоритм ко всем пикселам изображения, всякий раз записывая результат (нулевой элемент) в исходную битовую матрицу. Поскольку на каждом шаге алгоритма связность не нарушается, то она не нарушается вообще.</p>

<p>Однако, такие последовательные алгоритмы обладают существенным недостатком: они принципиально медленные. За один шаг алгоритма модифицируется лишь один пиксел изображения, причем если пикселы хранятся упакованными в биты машинного слова, то отдельная операция коррекции пиксела &laquo;обходится&raquo; довольно дорого. Кроме того, такой алгоритм с трудом поддается распараллеливанию на многопроцессорных или многоядерных компьютерах.</p>

<p>В данной статье мы рассматриваем другой тип алгоритмов, которые естественно назвать <i>параллельными</i>. Мы называем параллельным алгоритм, преобразующий исходную битовую матрицу в результирующую битовую матрицу такого же размера, если результат преобразования в точке (<i>x</i><sub>0</sub>,&nbsp;<i>y</i><sub>0</sub>) является однозначной функцией от значений элементов исходной матрицы в некоторой апертуре, или окрестности точки (<i>x</i><sub>0</sub>,&nbsp;<i>y</i><sub>0</sub>) фиксированного размера (обычно 3x3, 3x5 или 5x5). Главное отличие от последовательного алгоритма: результат обработки зависит только от элементов исходной матрицы, но не зависит от пикселов результирующей матрицы (которые, возможно, были обнулены перед обработкой текущего пиксела). Параллельный алгоритм, во-первых, позволяет за одну машинную операцию обрабатывать все биты машинного слова, т.е. минимум 64 бита для большинства современных процессоров, причем такая операция обычно проще (эффективнее), чем доступ к отдельному биту в слове. Во-вторых, параллельный алгоритм, действительно, легко распараллеливается на многопроцессорных или многоядерных компьютерах: каждый процессор может обрабатывать свою часть матрицы. В итоге, ускорение по сравнению с простым последовательным алгоритмом на современных компьютерах может достигать сотен и даже тысяч раз.</p>

<p>Для параллельных алгоритмов поставленная проблема, т.е. доказательство связности получаемого скелета, становится нетривиальной. Например, в следующей конфигурации 3x5 нет очевидных причин, по которым нельзя удалить (обнулить) центральный пиксел &mdash; его удаление не нарушает связности конфигурации 3x5:</p>
<pre>
    0 1 1
    1 0 1
    0 <b>1</b> 1
    1 0 1
    0 1 1
</pre>
<p>Однако, если допустить удаление центрального пиксела в любой такой конфигурации 3x5, то в более сложной конфигурации 3x7</p>
<pre>
    0 1 1
    1 0 1
    0 <b>X</b> 1
    1 0 1
    0 <b>X</b> 1
    1 0 1
    0 1 1
</pre>
<p>центральный левый пиксел окажется &laquo;оторванным&raquo; и связная компонента распадется на две.</p>


<h3><a name="theoremConnectivity"></a>Теорема связности: формулировка для скелетов 3x5</h3>

<p>Итак, мы рассматриваем некоторую операцию преобразования исходной битовой матрицы в результирующую битовую матрицу такого же размера, такую, что результат преобразования в точке (<i>x</i><sub>0</sub>,&nbsp;<i>y</i><sub>0</sub>) является функцией от значений элементов исходной матрицы в некоторой <i>апертуре зависимости</i>:</p>
<blockquote>
<i>x</i><sub>0</sub>&minus;<i>a</i> &le; <i>x</i> &le; <i>x</i><sub>0</sub>+<i>b</i>,<br>
<i>y</i><sub>0</sub>&minus;<i>c</i> &le; <i>y</i> &le; <i>y</i><sub>0</sub>+<i>d</i>,
</blockquote>
<p>где <i>a</i>,<i>b</i>,<i>c</i>,<i>d</i> &mdash; некоторые неотрицательные константы (обычно 1 или 2). Эту операцию мы будем называть <i>итерацией скелетизации</i>. Если апертура имеет размеры <i>A</i>x<i>B</i> (<i>A</i>=<i>a</i>+<i>b</i>, <i>B</i>=<i>c</i>+<i>d</i>), то такой алгоритм мы будем называть <i>скелетом A</i>x<i>B</i>: например, при <i>a</i>=<i>b</i>=<i>c</i>=<i>d</i>=2 имеем <i>скелет 5x5</i>, при <i>a</i>=<i>b</i>=1, <i>c</i>=<i>d</i>=2 имеем <i>скелет 3x5</i>, при <i>a</i>=<i>b</i>=<i>c</i>=<i>d</i>=1 имеем <i>скелет 3x3</i>.</p>

<p>Неформально предполагается, что итерация удаляет (обнуляет) некоторые единичные элементы, находящиеся на границах &laquo;объектов&raquo; &mdash; связных компонент исходной матрицы.</p>

<p>Более того, мы будем неформально предполагать, что рассматриваемая итерация удаляет граничные пикселы конкретно <i>с левого края</i> объектов, не трогая &laquo;правые края&raquo;. Это требование (формализованное ниже в виде &laquo;условия левого края&raquo;) будет нужно для доказательства, но оно не ограничивает общность реальных алгоритмов. На практике обычно конструируются 4 отдельных алгоритма, удаляющих пикселы с левого, верхнего, правого и нижнего края объектов, совершенно идентичные с точностью до симметрии или поворота системы координат, и такие итерации применяются последовательно, обеспечивая равномерное &laquo;истончение&raquo; с разных сторон. Очевидно, достаточно доказать, что связность сохраняется в каком-то одном из 4 алгоритмов, и для определенности мы будем рассматривать алгоритмы &laquo;истончения слева&raquo;.</p>

<p>Будем говорить, что итерация скелетизации <i>сохраняет связность</i> данной связной компоненты <i>D</i> исходной матрицы, если множество единичных пикселов в матрице &mdash; результате итерации, &mdash; лежащих внутри <i>D</i>, состоит не более чем из одной связной компоненты. Наоборот, будем говорить, что итерация <i>разрушает связность</i> данной связной компоненты <i>D</i> исходной матрицы, если множество единичных пикселов в матрице &mdash; результате итерации, &mdash; лежащих внутри <i>D</i>, состоит из двух или более связных компонент. Заметим, что полное уничтожение (обнуление) связной компоненты не считается ее разрушением.</p>

<p>Следующая теорема позволяет механически, путем соответствующей программы перебора, проверить, что тот или иной алгоритм скелетизации, выполняющий определенные &laquo;разумные&raquo; условия, сохраняет связность.</p>

<p><i><b>Теорема связности</b>. Для определенного, заранее известного набора размеров Q<sub>x</sub><sup>i</sup></i>&nbsp;x&nbsp;<i>Q<sub>y</sub><sup>i</sup>, i=1,2,...,M, верно следующее: при выполнении алгоритмом определенных предположений (перечисленных далее условий), если итерация разрушает связность какой-нибудь связной компоненты, то существует прямоугольная область матрицы одного из указанного набора размеров, такая, что после обнуления всех пикселов вне этого прямоугольника в исходной матрице итерация по-прежнему разрушает связность какой-нибудь связной компоненты.</i></p>

<p>Таким образом, располагая набором размеров <i>Q<sub>x</sub><sup>i</sup></i>&nbsp;x&nbsp;<i>Q<sub>y</sub><sup>i</sup></i>, мы можем написать программу-тест, которая по очереди протестирует все возможные конфигурации таких размеров, дополненные со всех сторон достаточным количеством нулевых пикселов (в соответствии с размерами апертуры зависимости: <i>a</i> нулевых столбцов матрицы слева, <i>b</i> нулевых столбцов справа, <i>c</i> нулевых строк сверху, <i>d</i> нулевых строк снизу), и для каждой такой конфигурации проверит, что алгоритм скелетизации не разбивает на части ни одную из связных компонент, присутствующих в исходной матрице. Если это так, то теорема связности позволит сделать вывод: данный алгоритм скелетизации никогда не нарушает связности связных компонент, и циклическое повторение таких итераций скелетизации позволяет получить корректный связный скелет (остов) любой связной компоненты произвольного размера. Полное количество возможных конфигураций битов размером <i>Q<sub>x</sub><sup>i</sup></i>&nbsp;x&nbsp;<i>Q<sub>y</sub><sup>i</sup></i> составляет 2<sup><i>Q<sub>x</sub><sup>i</sup></i>&nbsp;x&nbsp;<i>Q<sub>y</sub><sup>i</sup></i></sup>, и если эти размеры не слишком велики, то полную проверку можно произвести за обозримое время от нескольких секунд до нескольких суток.</p>

<p>Соответствующий набор размеров выясняется в процессе доказательства. При тех предположениях, которые мы сформулируем ниже, теорема выполняется для набора, состоящего из двух вариантов размеров 3x7 и 4x6, что означает необходимость проверки всего лишь 2<sup>21</sup>+2<sup>24</sup> возможных конфигураций: при грамотной реализации это требует на современных компьютерах не более нескольких секунд.</p>

<p>Ниже приведен набор предположений (условий), которыми мы будем пользоваться.</p>

<p><b>Условие конечности</b>. Мы рассматриваем матрицы только конечного размера и считаем, что размеры любой связной компоненты конечны: &laquo;за пределами&raquo; матрицы пикселы предполагаются равными нулю. (На практике, чтобы не замедлять алгоритм лишними проверками, матрица обычно фактически дополняется по краям нужным числом нулевых битов, т.е. на 1 справа и слева и на 2 сверху и снизу, в соответствии с размером окрестности из приведенного ниже условия зависимости от апертуры 3x5.) Конечность нам понадобится, чтобы в самом начале доказательства обеспечить существование цепочки <i>L</i> минимальной меры.</p>

<p><b>Условие левого края</b>. Если единичный пиксел исходной матрицы обнуляется в результате итерации, то верно хотя бы одно из следующих утверждений:</p>

<ul>
<li>пиксел слева от него в исходной матрице был нулевым</li>
<li>или оба пиксела слева сверху и слева снизу от него в исходной матрице были нулевыми.</li>
</ul>

<p><b>Условие правой локальности</b>. Если единичный пиксел исходной матрицы обнуляется в результате итерации, то верно хотя бы одно из следующих утверждений:</p>

<ul>
<li>результат итерации содержит единичного соседа в одной 5 позиций справа сверху, справа снизу, сверху или снизу от этого пиксела,</li>
<li>или, быть может, этот единичный был <i>изолированным</i> пикселом, т.е. связной компонентой из 1 пиксела (все его 8 соседей в исходной матрице были нулевыми).</li>
</ul>

<p><b>Условие нерасширения</b>. Нулевой пиксел исходной матрицы всегда остается нулевым в результате итерации (соответственно, единичному пикселу результата всегда соответствует единичный пиксел в исходной матрице).</p>

<p><b>Условие зависимости от апертуры 3x5</b>. Результат итерации скелетизации в точке (<i>x</i><sub>0</sub>,&nbsp;<i>y</i><sub>0</sub>) зависит, максимум, от окрестности 3x5:
<i>x</i><sub>0</sub>&minus;1&nbsp;&le;&nbsp;<i>x</i>&nbsp;&le;&nbsp;<i>x</i><sub>0</sub>+1,
<i>y</i><sub>0</sub>&minus;2&nbsp;&le;&nbsp;<i>y</i>&nbsp;&le;&nbsp;<i>y</i><sub>0</sub>+2.</p>

<p>Условие правой локальности здесь наименее тривиально: оно означает, что скелетизация не является &laquo;слишком сильной&raquo; и не пытается &laquo;срезать&raquo; за один раз более чем однопиксельный &laquo;слой&raquo; единичных пикселов с левой стороны объектов. Оговорка насчет изолированных пикселов позволяет включить в рассмотрение скелетизирующие алгоритмы, которые не только истончают &laquo;толстые&raquo; объекты, но и укорачивают свободные концы тонких линий вплоть до полного их исчезновения &mdash; сохраняя, впрочем, замкнутые циклы (кольцевые линии).</p>

<p>Условие левого края означает, что мы работаем только с левым краем объектов &mdash; не пытаемся, в частности, удалять внутренние пикселы больших объектов. Чтобы оценить, насколько &laquo;сильное&raquo; это условие, заметим: если это условие не выполнено, а также не выполнены аналогичные условия верхнего края, правого края и нижнего края, получаемые при симметриях или поворотах системы координат &mdash; иначе говоря, если все 4 алгоритма &laquo;истончения&raquo;, удаляющих пикселы с левого, верхнего, правого и нижнего края объектов, не могут удалить пиксел из-за нарушения этого условия &mdash; то легко убедиться, что 3x3-окрестность данного пиксела в исходной матрице имеет один из следующих видов:</p>

<pre>
1 1 1    0 <b>1</b> 1  1 <b>1</b> 0  1 1 1  1 1 1    0 <b>1</b> 1  1 <b>1</b> 0
1 <b>1</b> 1    <b>1</b> <b>1</b> 1  1 <b>1</b> <b>1</b>  1 <b>1</b> <b>1</b>  <b>1</b> <b>1</b> 1    <b>1</b> <b>1</b> <b>1</b>  <b>1</b> <b>1</b> <b>1</b>
1 1 1    1 1 1  1 1 1  1 <b>1</b> 0  0 <b>1</b> 1    1 <b>1</b> 0  0 <b>1</b> 1
</pre>

<p>Во всех этих конфигурациях центральный пиксел лежит в каком-то смысле &laquo;глубоко внутри&raquo; большого единичного массива, и даже если у него есть нулевой диагональный сосед, то с неформальной точки зрения представляется гораздо разумнее вначале удалить смежного с этим нулевым пикселом соседа по горизонтали или вертикали, прежде чем пытаться обнулить центр. Действительно, из этих схем видно, что указанные соседи по горизонтали или вертикали (они выделены жирным шрифтом) ни в каком смысле не лежат на тонких однопиксельных линиях, которые хороший алгоритм скелетизации должен сохранять.</p>

<p>Условие нерасширения означает, что алгоритм не пытается добавлять единичные пикселы, т.е. это действительно &laquo;истончение&raquo;, а не &laquo;расширение&raquo;.</p>

<p>Условие зависимости от апертуры 3x5 ограничивает нас рассмотрением скелетизирующих алгоритмов, которые мы назвали выше &laquo;скелеты 3x5&raquo;. (Естественно, соответствующие итерации для истончения сверху и снизу, получаемые из данной итерации симметрией или поворотом системы координат, окажутся скелетами 5x3.) Конечно, тем самым мы включаем в рассмотрение также все скелеты с меньшей апертурой зависимости, например, 3x4 или 3x3. При желании, можно сформулировать и доказать аналогичную теорему для бо&#x0301;льших размеров апертуры зависимости, например, 5x5 или 5x7, что приведет к соответствующему увеличению размеров конфигураций <i>Q<sub>x</sub><sup>i</sup></i>&nbsp;x&nbsp;<i>Q<sub>y</sub><sup>i</sup></i>, подлежащих проверке. Но на практике вполне качественные скелетизирующие алгоритмы можно построить уже в рамках апертуры 3x5.</p>

<p>Разумеется, условия левого края, правой локальности и нерасширения можно проверить механически в соответствующей программе-тесте. Для условий левого края и нерасширения достаточно протестировать все возможные конфигурации пикселов 3x5 и проверить выполнение условия в случае изменения центрального пиксела. Для условия правой локальности достаточно проверить все возможные конфигурации 4x7, получаемые расширением базовой конфигурации 3x5 вправо, вверх и вниз на 1:</p>
<pre>
? ? ? ?
? ? ? ?
? n n ?
? <b>x</b> n ?
? n n ?
? ? ? ?
? ? ? ?
</pre>
<p>ибо 5 соседей пиксела &ldquo;<code>x</code>&rdquo;, поведение которых нуждается в проверке на соответствие условию правой локальности, помеченные выше буквой &ldquo;<code>n</code>&rdquo;, как и поведение самого пиксела &ldquo;<code>x</code>&rdquo;, полностью определяются пикселами указанной конфигурации 4x7. Тестирование всех 2<sup>28</sup> конфигураций 4x7, в отличие от проверки связности, практически не требует работы с отдельными битами и может быть выполнено на современных компьютерах за несколько секунд.</p>

<p>Вместо условия правой локальности можно сформулировать более слабое условие, которые является его непосредственным следствием и которое также можно механически проверить:</p>

<p><b>Условие локальности</b>. Если итерация обнуляет некий единичный пиксел, то в результат итерации сохраняется хотя бы один единичный среди всех 8 соседей этого пиксела (за исключением единственной возможной ситуации, когда этот пиксел был изолированным, т.е. представлял собой связную компоненту из 1 пиксела).</p>

<p>В некоторых местах доказательства нам будет достаточно этого более слабого условия.</p>



<h3><a name="proofConnectivity"></a>Теорема связности: доказательство для скелетов 3x5</h3>

<h4><a name="proofCommon"></a>Общие замечания</h4>

<p>Предположим, итерация скелетизации разрушила связность некоей связной компоненты <i>D</i>. Очевидно, что в этом случае компонента содержит более 1 пиксела. Пусть эта связная компонента <i>D</i> сократилась до подмножества <i>D</i>', состоящего из двух (или более) связных подмножеств <i>D</i>'<sub>1</sub>, <i>D</i>'<sub>2</sub>, <i>D</i>'<sub>3</sub>, ... Чтобы доказать теорему, нам нужно либо прийти к противоречию, либо найти конкретную прямоугольную область (апертуру) <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, такую, что после обнуления всех пикселов вне этого прямоугольника связность хотя бы одной связной компоненты по-прежнему разрушается.</p>

<p>Будем рассматривать 8-связные цепочки пикселов <nobr><i>L</i> = <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,...,<i>L<sub>N</sub></i> = (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>), (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>), ..., (<i>x<sub>N</sub></i>, <i>y<sub>N</sub></i>)</nobr>, соединяющие пары компонент <i>D</i>'<sub>I</sub> и <i>D</i>'<sub>J</sub> внутри исходной компоненты <i>D</i>, т.е. такие, что первый элемент цепочки <i>L</i><sub>1</sub> принадлежит <i>D</i>'<sub>I</sub>, последний <i>L<sub>N</sub></i> принадлежит <i>D</i>'<sub>J</sub> и все элементы принадлежат <i>D</i>. Очевидно, что число точек в цепочке <i>N</i> не может быть меньше 3 &mdash; иначе компоненты соприкоснулись бы и не были бы разными связными компонентами.</p>

<p>Будем для краткости писать &laquo;цепочка <i>A</i>x<i>B</i>&raquo;, имея в виду, что максимальная разница <i>x</i>-координат равна <i>A</i>, а максимальная разница <i>y</i>-координат равна <i>B</i>. Будем называть <i>A</i> шириной цепочки, а <i>B</i> высотой. Например, цепочка 2x0 &mdash; три последовательных пиксела по горизонтали, ширина 2, высота 0.</p>

<p>Введем следующее отношение порядка (&laquo;выгодности&raquo;) для цепочек.</p>

<ol>
<li>Будем считать, что одна цепочка выгоднее другой, если в ней меньше точек (<i>N</i>).</li>
<li>Будем считать, что среди цепочек с равным числом точек выгоднее та, у которой меньше высота.</li>
<li>Будем считать, что при равном числе точек и равной высоте более выгодна та цепочка, у которой центр тяжести расположен правее, т.е. та, у которой среднее арифметическое всех <i>x</i>-координат больше (не меньше, а именно больше).</li>
</ol>

<p>Легко видеть, что &laquo;выгодность&raquo; цепочки и обратной ей цепочки <i>L<sub>N</sub></i>,<i>L</i><sub><i>N</i>&minus;1</sub>,...,<i>L</i><sub>2</sub>,<i>L</i><sub>1</sub> одинаковы, т.е. одинаковы все указанные величины.</p>

<p>Введем для удобства какую-нибудь вещественную положительную <i>меру</i> цепочки, такую, что у более выгодных цепочек эта мера меньше, а если ни одна не выгоднее другой, то мера одинакова. Такую меру можно ввести благодаря конечности наших матриц (&laquo;условие конечности&raquo;); один из возможных способов &mdash; <nobr><i>NM</i><sup>2</sup>+<i>BM</i>+(<i>M</i>&minus;<i>x</i><sub>C</sub>)</nobr>, где <i>M</i> есть максимум из ширины и высоты матрицы, <i>B</i> есть высота цепочки и <i>x</i><sub>C</sub> есть среднее арифметическое всех <i>x</i>-координат.</p>

<p>Выберем какую-нибудь цепочку пикселов <nobr><i>L</i> = <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,...,<i>L<sub>N</sub></i></nobr> минимальной меры, соединяющую разные связные компоненты <i>D</i>'<sub>I</sub> и <i>D</i>'<sub>J</sub>: <i>L</i><sub>1</sub> принадлежит <i>D</i>'<sub>I</sub>, <i>L<sub>N</sub></i> принадлежит <i>D</i>'<sub>J</sub> и все элементы принадлежат <i>D</i>. Очевидно, эта цепочка также самая кратчайшая по числу элементов <i>N</i>. Так как мера симметрична по отношению к перенумеровке, то ради удобства мы всегда можем поменять местами <i>L</i><sub>1</sub> и <i>L<sub>N</sub></i> с соответствующей перенумерацией остальных элементов в обратном порядке, например, предположить, что <i>y</i><sub>1</sub>&le;<i>y<sub>N</sub></i> или <i>x</i><sub>1</sub>&le;<i>x<sub>N</sub></i> &mdash; при этом просто нужно будет переобозначить I&nbsp;и&nbsp;J.</p>

<p>Введем следующую систему обозначений пикселов:</p>
<blockquote>
<table cellpadding="0" cellspacing="0" border="0">
<tr><td><code>0</code></td> <td>равен 0 в исходной матрице, 0 в результате итерации (по полной исходной матрице);</td></tr>
<tr><td><code>x</code></td> <td>равен 1 в исходной матрице, 0 в результате итерации;</td></tr>
<tr><td><code>1</code></td> <td>равен 1 в исходной матрице, 1 в результате итерации;</td></tr>
<tr><td><code>-</code> (знак минус)&nbsp;&nbsp;</td> <td>равен 1 в исходной матрице, неизвестно значение в результате итерации (т.е. либо &ldquo;<code>x</code>&rdquo;, либо &ldquo;<code>1</code>&rdquo;);</td></tr>
<tr><td><code>o</code></td> <td>неизвестно значение в исходной матрице, 0 в результате итерации (т.е. либо &ldquo;<code>x</code>&rdquo;, либо &ldquo;<code>0</code>&rdquo;);</td></tr>
<tr><td><code>=</code></td> <td>неизвестно, чему равен, но одинаковое значение до и после итерации;</td></tr>
<tr><td><code>.</code> (точка)&nbsp;&nbsp;</td> <td>все остальные случаи (ничего не известно);</td></tr>
<tr><td><code>I</code></td> <td>то же, что 1, если мы уверены, что это первый элемент цепочки <i>L</i><sub>1</sub>;</td></tr>
<tr><td><code>J</code></td> <td>то же, что 1, если мы уверены, что это последний элемент цепочки <i>L<sub>N</sub></i>;</td></tr>
<tr><td><code>i</code></td> <td>то же, что 1, если мы уверены, что эта точка принадлежит связной компоненте <i>D</i>'<sub>I</sub> (той же, что и <i>L</i><sub>1</sub>);</td></tr>
<tr><td><code>j</code></td> <td>то же, что 1, если мы уверены, что эта точка принадлежит связной компоненте <i>D</i>'<sub>J</sub> (той же, что и <i>L<sub>N</sub></i>);</td></tr>
<tr><td><code>I?I?I?</code> и т.п.&nbsp;&nbsp;</td> <td>один из этой серии пикселов &ldquo;<code>I</code>&rdquo; (<i>L</i><sub>1</sub>), остальные &ldquo;<code>.</code>&rdquo;</td></tr>
</table>
</blockquote>

<p>Далее мы будем работать с некоторыми апертурами (прямоугольными областями) на исходной матрице и соответствующей ей матрице &mdash; результате итерации скелетизации. При этом мы будем ставить восклицательный знак <code>!</code> справа от пикселов, находящихся в <i>центральной области</i> рассматриваемой апертуры, т.е. той области, в которой результат итерации скелетизации не зависит от пикселов вне апертуры. В силу условия зависимости от апертуры 3x5, это пикселы, удаленные как минимум на 1 от левого и правого края апертуры и как минимум на 2 от верхнего и нижнего края. Для минимальной апертуры 3x5 это единственный центральный пиксел.</p>

<p>Иногда вместо точки &ldquo;<code>.</code>&rdquo; мы будем ставить вопросительный знак &ldquo;<code>?</code>&rdquo;, чтобы отметить, какой пиксел мы в данный момент исследуем.</p>

<p>Заметим, что вариант, когда 0 превращается в 1, невозможен (условие нерасширения). Таким образом, следующие наборы вариантов являются взаимоисключающими:</p>
<blockquote>
&ldquo;<code>0</code>&rdquo; или &ldquo;<code>x</code>&rdquo; или &ldquo;<code>1</code>&rdquo;;<br>
&ldquo;<code>0</code>&rdquo; или &ldquo;<code>&minus;</code>&rdquo;,<br>
&ldquo;<code>o</code>&rdquo; или &ldquo;<code>1</code>&rdquo;.
</blockquote>
<p>Заметим также, что &ldquo;<code>=</code>&rdquo; равносильно &ldquo;<code>0</code>&rdquo; или &ldquo;<code>1</code>&rdquo; и несовместимо с &ldquo;<code>x</code>&rdquo;.</p>

<p>Пользуясь введенными обозначениями, можно заменить условие левого края следующими утверждениями, которые мы обычно и будем применять на практике (первое из них является просто иной формулировкой условия левого края):</p>

<ul>
<li><b>P1</b>: если пиксел &ldquo;<code>x</code>&rdquo;, то слева от него &ldquo;<code>0</code>&rdquo; либо и слева сверху, и слева снизу &ldquo;<code>0</code>&rdquo;;</li>
<li><b>P2</b>: если два пиксела один под другим оба &ldquo;<code>&minus;</code>&rdquo;, &ldquo;<code>1</code>&rdquo; или &ldquo;<code>x</code>&rdquo;, то оба пиксела справа от них суть &ldquo;<code>=</code>&rdquo; (иными словами, &ldquo;<code>0</code>&rdquo;&nbsp;или&nbsp;&ldquo;<code>1</code>&rdquo;). Очевидно, то же самое можно сказать про вертикальный ряд пикселов большей длины.</li>
</ul>

<p>Также мы будем пользоваться следующими простыми леммами:</p>

<p><b>Лемма Sa</b>. В случае горизонтальной цепочки &ldquo;<code>x&nbsp;x</code>&rdquo;, над и под левым &ldquo;<code>x</code>&rdquo; пикселы по P1 всегда &ldquo;<code>0</code>&rdquo;:<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;0 .</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;x x</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;0 .</code></p>

<p><b>Лемма Sb</b>. Горизонтальная цепочка &ldquo;<code>x&nbsp;x&nbsp;x</code>&rdquo; невозможна &mdash; ибо в силу P1 над и под левым и центральным &ldquo;<code>x</code>&rdquo; придется поставить &ldquo;<code>0</code>&rdquo;, и условие правой локальности окажется нарушено для левого &ldquo;<code>x</code>&rdquo;.</p>


<p>Мы будем рассматривать различные прямоугольные области некоторого размера <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, внутри которых, как правило, по предположению присутствуют пикселы из разных связных компонент <i>D</i>'<sub>K</sub>; мы будем также называть эти области апертурами. Мы будем обнулять пикселы в исходной матрице вне апертуры и проверять: может ли в результате итерации скелетизации из-за такого обнуления добавиться новая связь-цепочка, соединяющая разные связные компоненты, сохранившиеся после обнуления (т.е. может ли там быть связь, если мы знаем, что до обнуления связи не было). Если не может, значит, мы докажем теорему для случая размера области <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i> и заодно обнаружим очередной размер <i>Q<sub>x</sub><sup>i</sup></i>&nbsp;x&nbsp;<i>Q<sub>y</sub><sup>i</sup></i>, который надо тестировать. Уточним это неформальное рассуждение.</p>

<p>Для краткости будем называть матрицу, которая получается из исходной матрицы после обнуления всех пикселов вне рассматриваемой апертуры <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, <i>обнуленной</i> (в противоположность <i>исходной</i>).</p>

<p>Заметим, что пикселы типов &ldquo;<code>0</code>&rdquo; (в том числе &ldquo;<code>0!</code>&rdquo;), &ldquo;<code>x!</code>&rdquo; и &ldquo;<code>o!</code>&rdquo; обладают прекрасным свойством: они не могут изменить своего поведения ни при каких коррекциях других пикселов в матрице вне рассматриваемой апертуры. А именно, в результате итерации на обнуленной матрице они точно так же будут нулевыми.</p>

<p>Назовем <i>забором</i> любую 4-связную цепочку, состоящую из пикселов указанных типов &ldquo;<code>0</code>&rdquo; (в том числе &ldquo;<code>0!</code>&rdquo;), &ldquo;<code>x!</code>&rdquo; или &ldquo;<code>o!</code>&rdquo; , если такая цепочка обоими концами упирается в край апертуры, разбивая ее тем самым на две несвязные части. Подчеркиваем, что в отличие от цепочки <i>L</i> забор должен быть именно 4-связной цепочкой, т.е. такой, в которой смежные элементы отличаются на 1 только по одной координате &mdash; 4-связность обеспечивает разбиение апертуры на несвязные, в обычном 8-связном смысле, области. Будем говорить, что забор <i>отгораживает</i> или <i>разделяет</i> два пиксела <i>A</i> и <i>B</i> типа &ldquo;<code>1</code>&rdquo;, принадлежащие разным связным компонентам результата скелетизации <i>D</i>'<sub><i>A</i></sub> и <i>D</i>'<sub><i>B</i></sub> и лежащие в нашей апертуре, если эти два пиксела находятся по разные стороны забора. Вот пример:</p>
<pre>
  . . . . <b>0</b> . .
  . . <i>A</i> . <b>0</b> . .
  . 1!<b>o!x!o!</b>. .
  <b>0</b> <b>o!o!</b>. x!1!.
  . . . . . <i>B</i> .
  . . . . . . .
</pre>
<p>Предположим, до итерации пикселы <i>A</i> и <i>B</i>, лежащие по разные стороны забора, были соединены какой-либо связью в рамках апертуры (8-связной цепочкой из пикселов типа &ldquo;<code>1</code>&rdquo;, &ldquo;<code>x</code>&rdquo;, &ldquo;<code>&minus;</code>&rdquo;; в нашем примере это диагональная цепочка &ldquo;<code><i>A</i>&nbsp;x!&nbsp;x!&nbsp;<i>B</i></code>&rdquo;). Обозначим <i>С</i>' пересечение исходной связной компоненты <i>D</i> с этой апертурой (это уже не обязательно одна связная компонента). Далее, пикселы <i>A</i> и <i>B</i> принадлежат <i>С</i>' и при этом, по предположению, связаны между собой на исходной матрице в рамках апертуры; обозначим <i>C</i> связную компоненту <i>С</i>', содержащую эти пикселы.</p>

<p>Очевидно, забор разделяет компоненту <i>C</i> на две заведомо не связанные друг с другом части <i>C<sub>A</sub></i> и <i>C<sub>B</sub></i>: <i>A</i> принадлежит одной части <i>C<sub>A</sub></i>, а <i>B</i> другой части <i>C<sub>B</sub></i>. После итерации на обнуленной матрице, конечно, точка <i>А</i> может исчезнуть (если только она не лежит в центральной области, где результат итерации не зависит от пикселов вне апертуры). Но в этом случае, в силу условия локальности, у нее сохранится единичный сосед, также принадлежавший до итерации связной компоненте <i>C</i> (как и любой единичный сосед любого элемента <i>C</i>). Действительно, легко видеть, что исключительная ситуация, оговоренная в условии локальности, не имеет места: <i>A</i> не была изолированной одноточечной связной компонентой (напротив, в содержавшей ее связной компоненте <i>C</i> было не менее 3 пикселов <i>A</i>, <i>B</i> и пикселы соединявшей их цепочки). Причем сохранившийся единичный сосед не может оказаться на самом заборе: забор после итерации скелетизации состоит только из нулей как для исходной, так и для обнуленной матрицы. Не может он оказаться и по другую сторону забора, ибо забор 4-связен &mdash; соседние пикселы не могут лежать по разные стороны такого забора. То же самое справедливо в отношении точки <i>B</i>. Значит, после итерации (уже на обнуленной матрице) по обе стороны забора сохранятся либо сами пикселы <i>А</i> и <i>B</i>, либо их непосредственные соседи. До итерации эти пикселы входили в одну связную компоненту <i>C</i>, а после итерации оказались не связанными друг с другом.</p>

<p>Отсюда следует: <i>если в случае исходной матрицы до итерации скелетизации пикселы A и B типа</i> &ldquo;<code>1</code>&rdquo;<i>, лежащие по разные стороны некоторого забора, были соединены какой-либо связью в рамках апертуры (8-связной цепочкой из пикселов типа</i> &ldquo;<code>1</code>&rdquo;<i>, </i>&ldquo;<code>x</code>&rdquo;<i>, </i>&ldquo;<code>&minus;</code>&rdquo;<i>), то в случае обнуленной матрицы итерация скелетизации нарушает связность некоторой связной компоненты (а именно, связной компоненты C)</i>.</p>

<p>В последующих рассуждениях, обнаруживая забор, мы будем уточнять, какой связью были соединены <i>A</i> и <i>B</i> внутри апертуры, а именно, будем говорить, что забор <i>рвет</i> эту связь. Заметим, что если апертура содержит всю цепочку <i>L</i>&nbsp;=&nbsp;<i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,...,<i>L<sub>N</sub></i> (чаще всего мы будем рассматривать именно такие апертуры), а пикселы <i>A</i> и <i>B</i> &mdash; либо сами <i>L</i><sub>1</sub> и <i>L<sub>N</sub></i>, либо связаны с ними 8-связными цепочками единиц (&ldquo;<code>1</code>&rdquo;) в рамках нашей апертуры, то наличие связи очевидно &mdash; ее обеспечивает сама наша цепочка <i>L</i>.</p>

<p>Наша цель: показать, что во всех возможных вариантах цепочки <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,...,<i>L<sub>N</sub></i> либо получается противоречие с одним из предположенных выше условий (в частности, что эта цепочка самая выгодная), либо обнаруживается апертура некоторого размера <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, в которой два пиксела типа &ldquo;<code>1</code>&rdquo; из разных связных компонент <i>D</i>'<sub><i>A</i></sub> и <i>D</i>'<sub><i>B</i></sub> разделены забором, но соединены 8-связной цепочкой из пикселов типа &ldquo;<code>1</code>&rdquo;, &ldquo;<code>x</code>&rdquo;, &ldquo;<code>&minus;</code>&rdquo;. Это будет означать, что существует конфигурация <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i> с нулевыми точками снаружи, в которой итерация нарушает связность. Запомнив набор размеров <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, которые нам встретятся при обнаружении заборов, мы докажем теорему для этого набора размеров.</p>

<p>Разумеется, нет смысла отдельно запоминать размеры <i>Q'<sub>x</sub></i>&nbsp;x&nbsp;<i>Q'<sub>y</sub></i>, если мы и так включаем в набор какие-то размеры <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, большие либо равные по обоим координатам (<i>Q'<sub>x</sub></i>&le;<i>Q<sub>x</sub></i>, <i>Q'<sub>y</sub></i>&le;<i>Q<sub>y</sub></i>) &mdash; конфигурации <i>Q'<sub>x</sub></i>&nbsp;x&nbsp;<i>Q'<sub>y</sub></i> будут протестированы среди конфигураций <i>Q<sub>x</sub></i>&nbsp;x&nbsp;<i>Q<sub>y</sub></i>, когда все дополнительные элементы равны 0.</p>

<p>Изучим возможные конфигурации цепочки <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,...,<i>L<sub>N</sub></i>. Очевидно, все элементы цепочки, кроме <i>L</i><sub>1</sub> и <i>L<sub>N</sub></i>, лежат вне <i>D</i>'<sub>I</sub>, <i>D</i>'<sub>J</sub> и всех прочих компонент, иначе цепочка не была бы кратчайшей по числу элементов. Иначе говоря, в наших обозначениях они имеют тип &ldquo;<code>x</code>&rdquo;. По тем же причинам &laquo;внутренние&raquo; элементы цепочки <nobr><i>L</i><sub>3</sub>, <i>L</i><sub>4</sub>, ..., <i>L</i><sub><i>N</i>&minus;2</sub></nobr> не имеют соседей ни в одной из компонент &mdash; иначе можно было бы заменить либо начальную часть, либо конечную цепочки (не менее 2 элементов) единственным элементом из такой компоненты и получить более выгодную цепочку (по числу элементов).</p>

<p>Отсюда следует, что если <i>N</i>&ge;5, то в точке <i>L</i><sub>3</sub> нарушается условие локальности: у такого пиксела после итерации нет соседей. Следовательно, можно считать, что <i>N</i>=3 или <i>N</i>=4. Разберем все возможные случаи.</p>

<p>Заметим: до этого момента мы не использовали условие правой локальности, а пользовались лишь общим (более слабым) условием локальности.</p>


<h4><a name="proofN3"></a>Случай, когда кратчайшая цепочка, соединяющая разные компоненты, имеет длину <i>N</i>=3</h4>

<p>Пусть вначале самая выгодная цепочка, соединяющая разные связные компоненты <i>D</i>'I и <i>D</i>'J, имеет длину N=3 элемента.</p>

<p>Рассмотрим апертуру 3x5 с центром в точке <i>L</i><sub>2</sub>. Возможны следующие варианты.</p>

<p><b>3.1)</b> |<i>y</i><sub>3</sub>&minus;<i>y</i><sub>1</sub>|=2. Для определенности будем считать, что <i>y</i><sub>3</sub>=<i>y</i><sub>1</sub>+2 &mdash; в противном случае перенумеруем цепочку в обратном порядке и переобозначим <i>D</i>'<sub>I</sub> и <i>D</i>'<sub>J</sub>.</p>

<p>Очевидно, для <i>y</i><sub>2</sub> есть лишь одна возможность <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>+1:</p>
<pre>
. . .
I?I?I?
. x!.
J?J?J?
. . .
</pre>
<p>(<i>L</i><sub>1</sub> и <i>L</i><sub>3</sub> могут пока занимать любое из 3 положений).</p>

<p>Высота нашей цепочки равна 2, так что мы вправе предполагать отсутствие трехэлементных цепочек 2x1 и 2x0, соединяющих разные связные компоненты (они были бы более выгодными).</p>

<p>Рассмотрим варианты. Слева от центра может быть &ldquo;<code>0</code>&rdquo;,&ldquo;<code>1</code>&rdquo;,&ldquo;<code>x</code>&rdquo;, справа также &ldquo;<code>0</code>&rdquo;,&ldquo;<code>1</code>&rdquo;,&ldquo;<code>x</code>&rdquo;, всего 9 вариантов: 3.1.1&ndash;9.</p>

<p><b>3.1.1&ndash;5)</b> Пусть слева или справа &ldquo;<code>1</code>&rdquo; (5 вариантов: &ldquo;<code>1</code>&rdquo; и &ldquo;<code>0</code>&rdquo;, &ldquo;<code>1</code>&rdquo; и &ldquo;<code>x</code>&rdquo;, &ldquo;<code>0</code>&rdquo; и &ldquo;<code>1</code>&rdquo;, &ldquo;<code>x</code>&rdquo; и &ldquo;<code>1</code>&rdquo;, &ldquo;<code>1</code>&rdquo; и &ldquo;<code>1</code>&rdquo;).</p>
<p>Например, слева:</p>
<pre>
. . .
I?I?I?
1 x!.
J?J?J?
. . .
</pre>
<p>Пиксел слева не может принадлежать одновременно обоим связным компонентам <i>D</i>'<sub>I</sub> (содержащей <i>L</i><sub>1</sub>) и <i>D</i>'<sub>J</sub> (содержащей <i>L</i><sub>3</sub>). Проведем от него цепочку к <i>L</i><sub>3</sub>, если он принадлежит <i>D</i>'<sub>I</sub>, и к <i>L</i><sub>1</sub>, если принадлежит любой другой связной компоненте. Эта цепочка 2x1, очевидно, выгоднее нашей по высоте. Совершенно аналогичен случай, когда &ldquo;<code>1</code>&rdquo; справа: цепочка от него либо к <i>L</i><sub>1</sub>, либо к <i>L</i><sub>3</sub> соединяет разные связные компоненты и при этом выгоднее нашей.</p>

<p><b>3.1.6)</b> Справа &ldquo;<code>0</code>&rdquo;, слева &ldquo;<code>0</code>&rdquo;. Сразу получается забор из 3 пикселов &ldquo;<code>0&nbsp;x!&nbsp;0</code>&rdquo;, разделяющий <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub>.</p>

<p>Заметим: пример забора, состоящего из центрального пиксела &ldquo;<code>x</code>&rdquo; и серии нулей &ldquo;<code>0</code>&rdquo; и рвущего исходную цепочку уже в конфигурации 3x5, также означает, что алгоритм скелетизации нарушает простейшее условие &mdash; удаление одного только центрального единичного пиксела не должно разрушать связность конфигурации 3x5. (Обратное не обязательно верно: если указанное условие нарушено, то, конечно, забор разрывает некую конфигурацию 3x5, но не очевидно, что разъединившиеся точки действительно сохранятся в результате итерации скелетизации, а в данной конкретной области полной матрицы &mdash; что при этом они попадут в разные связные компоненты.)</p>

<p>Выполнение указанного требования достаточно, чтобы гарантировать отсутствие подобных заборов, и его легко обеспечить уже на этапе построения алгоритма. Однако наше доказательство обходится без него.</p>

<p>Более сложные заборы, которые будут появляться далее для расширенных апертур, иллюстрируют более тонкие проблемы, когда удаление одного центрального пиксела, возможно, еще не приводит к потере связности, но параллельное удаление сразу серии пикселов может привести к этому.</p>

<p><b>3.1.7)</b> Справа &ldquo;<code>x</code>&rdquo;, слева &ldquo;<code>x</code>&rdquo;: такая конфигурация невозможна по лемме Sb, так как мы предполагаем условие правой локальности.</p>

<p><b>3.1.8)</b> Справа &ldquo;<code>0</code>&rdquo;, слева &ldquo;<code>x</code>&rdquo;. Применяем лемму Sa:</p>
<pre>
. . .
0 I?I?
x x!0
0 J?J?
. . .
</pre>
<p>Расширим апертуру влево до 4x5:</p>
<pre>
. - . .
- 0 I?I?
- x!x!0
- 0 J?J?
. - . .
</pre>
<p>Минусы поставлены потому, что &ldquo;<code>0</code>&rdquo; на месте любого из них порождает разделяющий забор уже на этой апертуре 4x5, рвущий цепочку &ldquo;<i>L</i><sub>1</sub>&nbsp;<code>x!</code>&nbsp;<i>L</i><sub>3</sub>&rdquo;. Но три левых минуса вступают в противоречие с P1.</p>

<p><b>3.1.9)</b> Справа &ldquo;<code>x</code>&rdquo;, слева &ldquo;<code>0</code>&rdquo;. Применяем лемму Sa:</p>
<pre>
. . .
. 0 .
0 x!x
. 0 .
. . .
</pre>
<p>Здесь <i>L</i><sub>1</sub> &mdash; это либо точка слева сверху, либо минус справа сверху; аналогично <i>L</i><sub>3</sub>.</p>

<p>В силу условия правой локальности, одна их точек справа сверху или справа снизу (над или под правым &ldquo;<code>x</code>&rdquo;) является &ldquo;<code>1</code>&rdquo;. Эти ситуации разбираются совершенно аналогично, с точностью до симметрии по вертикали.</p>

<p>Для определенности, предположим первый вариант: точка справа сверху есть &ldquo;<code>1</code>&rdquo;. Тогда это &ldquo;<code>i</code>&rdquo;, ибо в противном случае (если эта единица входит в иную связную компоненту, нежели <i>L</i><sub>1</sub>) для <i>L</i><sub>1</sub> остается лишь позиция слева сверху, и цепочка-&laquo;уголок&raquo; 2x1 от этой единицы до <i>L</i><sub>1</sub> оказывается более выгодной по высоте. Таким образом:</p>
<pre>
. . .
. 0 i
0 x!x
. 0 .
. . .
</pre>

<p>Возможно, это &ldquo;<code>i</code>&rdquo; и есть <i>L</i><sub>1</sub>, а может быть, <i>L</i><sub>1</sub> расположено слева сверху &mdash; для дальнейшего рассмотрения это неважно.</p>

<p><i>L</i><sub>3</sub> не может располагаться справа снизу, ибо иначе вертикальная цепочка 0x2 от правого верхнего &ldquo;<code>i</code>&rdquo; до <i>L</i><sub>3</sub> окажется выгоднее, чем <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,<i>L</i><sub>3</sub>: у нее такая же высота, но центр тяжести расположен правее. Значит, <i>L</i><sub>3</sub> находится слева снизу:</p>
<pre>
. . .
. 0 i
0 x!x
J 0 .
. . .
</pre>

<p>Более того, точка справа снизу (под правым &ldquo;<code>x</code>&rdquo;) вообще не может быть &ldquo;<code>1</code>&rdquo;, ибо если такая единица входит в ту же связную компоненту, что и <i>L</i><sub>3</sub>, т.е. является &ldquo;<code>j</code>&rdquo;, то мы вновь получаем более выгодную вертикальную цепочку 0x2 &ldquo;<code>i&nbsp;x&nbsp;j</code>&rdquo; с центром тяжести, расположенным правее центра тяжести исходной цепочки, а если такая единица входит в иную связную компоненту, нежели <i>L</i><sub>3</sub>, то мы получаем более выгодную по высоте цепочку-&laquo;уголок&raquo; от нее к <i>L</i><sub>3</sub>. Таким образом, точка справа снизу есть &ldquo;<code>0</code>&rdquo; или &ldquo;<code>x</code>&rdquo;. Если &ldquo;<code>0</code>&rdquo;, то очевиден зигзагообразный забор уже на этой апертуре, рвущий исходную цепочку:</p>
<pre>
  . . .
  . 0 i
  0 x!x
  J 0 0
  . . .
</pre>

<p>Остается предположить, что точка справа снизу есть &ldquo;<code>x</code>&rdquo;:</p>
<pre>
. . .
. 0 i
0 x!x
J 0 x
. - .
</pre>

<p>Минус дважды снизу поставлен, ибо иначе образуется забор-&laquo;уголок&raquo; &ldquo;<code>0&nbsp;x!&nbsp;0&nbsp;0</code>&rdquo; уже на этой апертуре, рвущий исходную цепочку &ldquo;<i>L</i><sub>1</sub>&nbsp;<code>x!</code>&nbsp;<i>L</i><sub>3</sub>&rdquo;.</p>

<p>Но если этот минус на самом деле &ldquo;<code>x</code>&rdquo;, то слева от него, по P1, будет &ldquo;<code>0</code>&rdquo;, и мы получаем забор-&laquo;скобку&raquo; при расширении вниз до 3x7, рвущий цепочку &ldquo;<i>L</i><sub>1</sub>&nbsp;<code>x!</code>&nbsp;<i>L</i><sub>3</sub>&rdquo;:</p>
<pre>
  . . .
  . 0 i
  0 x!x
  J 0!x
  0 x!.
  . . .
  . . .
</pre>
<p>Так что остается рассмотреть случай, когда этот минус на самом деле &ldquo;<code>1</code>&rdquo;, т.е. &ldquo;<code>j</code>&rdquo;:</p>

<pre>
. . .
. 0 i
0 x!x
J 0 x
. j .
</pre>


<p>Расширяем апертуру вправо до 4x5:</p>
<pre>
. . . .
. 0 i .
0 x!x!=
J 0 x .
. j . .
</pre>

<p>Знак &ldquo;<code>=</code>&rdquo; дважды справа, поставленный по P2, не может быть единицей, т.е. &ldquo;<code>i</code>&rdquo;, ибо в этом случае мы приходим к диагональной цепочке &ldquo;<code>j&nbsp;x&nbsp;i</code>&rdquo;, имеющей ту же высоту 2, центр тяжести которой, очевидно, смещенм вправо относительно центра тяжести исходной цепочки &mdash; т.е. к более выгодной цепочке.</p>

<p>Значит, &ldquo;<code>=</code>&rdquo; дважды справа есть &ldquo;<code>0</code>&rdquo;, и мы видим тривиальный горизонтальный забор уже на этой апертуре &ldquo;<code>0&nbsp;x!&nbsp;x!&nbsp;0</code>&rdquo;, рвущий нашу цепочку:</p>
<pre>
. . . .
. 0 i .
0 x!x!0
J 0 x .
. j . .
</pre>


<p><b>3.2)</b> |<i>y</i><sub>3</sub>&minus;<i>y</i><sub>1</sub>|=1. Тогда |<i>x</i><sub>3</sub>&minus;<i>x</i><sub>1</sub>| может быть равен только 2, иначе <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub> соприкоснутся. Для определенности будем считать, что <i>x</i><sub>3</sub>=<i>x</i><sub>1</sub>+2 &mdash; в противном случае перенумеруем цепочку в обратном порядке и переобозначим <i>D</i>'<sub>I</sub> и <i>D</i>'<sub>J</sub>. Очевидно, для <i>x</i><sub>2</sub> есть лишь одна возможность <i>x</i><sub>2</sub>=<i>x</i><sub>1</sub>+1.</p>

<p>Наша цепочка имеет размеры 2x1.</p>

<p>Для <i>y</i><sub>3</sub> есть два варианта: <i>y</i><sub>1</sub>&minus;1 и <i>y</i><sub>1</sub>+1. Для <i>y</i><sub>2</sub> тоже есть два варианта: <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub> или <i>y</i><sub>2</sub>=<i>y</i><sub>3</sub>. Всего 4 группы случаев. (Напомним, что мы ставим центр апертуры на точку <i>L</i><sub>2</sub>.)</p>
<p>Но мы вначале отдельно рассмотрим случай, когда <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub> находятся по разные стороны вертикального столбика из двух &ldquo;<code>x</code>&rdquo;, чтобы исключить далее его из рассмотрения. Обозначим этот случай цифрой 0.</p>

<p><b>3.2.0)</b> Пусть два пиксела между <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub>, имеющие промежуточную <i>x</i>-координату и <i>y</i>-координаты, равные <i>y</i><sub>1</sub> и <i>y</i><sub>3</sub>, оба содержат &ldquo;<code>x</code>&rdquo;. Сразу расширим апертуру до 3x6:</p>
<pre>
. . .
. . .
I?x!J?
I?x!J?
. . .
. . .
</pre>
<p>Слева или слева сверху от нижнего &ldquo;<code>x!</code>&rdquo;, по P1, должен быть &ldquo;<code>0</code>&rdquo;. Второй из пикселов, обозначенных &ldquo;<code>I?</code>&rdquo;, очевидно, <i>L</i><sub>1</sub> &mdash; возможностей для &ldquo;<code>x</code>&rdquo; в левой колонке не остается.</p>

<p>В силу P2, справа от обоих &ldquo;<code>x!</code>&rdquo; допустимо либо &ldquo;<code>1</code>&rdquo;, либо &ldquo;<code>0</code>&rdquo;, т.е. &ldquo;<code>=</code>&rdquo;. Причем один из этих &ldquo;<code>=</code>&rdquo;, очевидно, <i>L</i><sub>3</sub>, а второй &ldquo;<code>0</code>&rdquo; &mdash; ибо второй знак &ldquo;<code>=</code>&rdquo; находится как раз напротив <i>L</i><sub>1</sub>, и если он на самом деле &ldquo;<code>1</code>&rdquo; (т.е. &ldquo;<code>j</code>&rdquo;), то мы получаем более выгодную по высоте цепочку 2x0, которую мы рассмотрим позже (3.3.1).</p>

<p>Таким образом, мы имеем одну из двух конфигураций:</p>
<pre>
  . . .         . . .
  . . .         . . .
  0 x!J   или   I x!0
  I x!0         0 x!J
  . . .         . . .
  . . .         . . .
</pre>
<p>В обоих случаях очевиден зигзагообразный забор &ldquo;<code>0&nbsp;x!&nbsp;x!&nbsp;0</code>&rdquo;, рвущий исходную цепочку.</p>

<p>Теперь рассмотрим все 4 варианта расположения цепочки, исключая рассмотренные случаи вертикальной пары &ldquo;<code>x</code>&rdquo;, разделяющей <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub>. Это значит, что один из двух пикселов, расположенных между <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub>, равен &ldquo;<code>x</code>&rdquo; (это <i>L</i><sub>2</sub>), а второй обязательно &ldquo;<code>0</code>&rdquo; (единицей он быть не может, иначе компоненты оказались бы связанными).</p>

<p><b>3.2.1, 3.2.2)</b> Пусть <i>y</i><sub>3</sub>=<i>y</i><sub>1</sub>&plusmn;1, <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>.</p>
<pre>
. . .       . . .
0 0 J       0 - .
I x!-  или  I x!-
0 - .       0 0 J
. . .       . . .
</pre>
<p>&ldquo;<code>0</code>&rdquo; слева сверху и слева снизу поставлены по P1, а &ldquo;<code>0</code>&rdquo; сверху или снизу &mdash; в силу предварительного разбора случая 3.2.0.</p>
<p>Минусы поставлены, ибо иначе очевиден тривиальный забор, рвущий исходную цепочку &mdash; &laquo;скобка&raquo; или &laquo;зигзаг&raquo;. Но правый минус не может быть &ldquo;<code>x</code>&rdquo; в силу P2. Значит, правый минус на самом деле &ldquo;<code>1</code>&rdquo;, т.е. &ldquo;<code>j</code>&rdquo;: получаем более выгодную по высоте цепочку 2x0, которую мы рассмотрим позже (3.3.1).</p>

<p><b>3.2.3)</b> Пусть <i>y</i><sub>3</sub>=<i>y</i><sub>1</sub>&minus;1, <i>y</i><sub>2</sub>=<i>y</i><sub>3</sub>.</p>
<pre>
. . .
. . .
0 x!J
I 0 -
. - .
</pre>
<p>Слева &ldquo;<code>0</code>&rdquo; поставлен по P1, а снизу &ldquo;<code>0</code>&rdquo; поставлен в силу предварительного разбора случая 3.2.0.</p>
<p>Минусы поставлены потому, что &ldquo;<code>0</code>&rdquo; на месте любого из них порождает разделяющий забор уже на этой апертуре 3x5, рвущий цепочку &ldquo;<i>L</i><sub>1</sub>&nbsp;<code>x!</code>&nbsp;<i>L</i><sub>3</sub>&rdquo;.</p>
<p>Оба минуса не могут быть &ldquo;<code>1</code>&rdquo;, иначе компоненты оказались бы связанными.</p>
<p>Допустим, нижний минус на самом деле &ldquo;<code>x</code>&rdquo;. Тогда, по P1, слева от него &ldquo;<code>0</code>&rdquo;. Расширим вниз до 3x7:</p>
<pre>
  . . .
  . . .
  0 x!J
  I 0!-
  0 x!.
  . . .
  . . .
</pre>
<p>Видим забор-&laquo;скобку&raquo; вокруг <i>L</i><sub>1</sub>, рвущий цепочку &ldquo;<i>L</i><sub>1</sub>&nbsp;<code>x!</code>&nbsp;<i>L</i><sub>3</sub>&rdquo;.</p>

<p>Остается допустить, что нижний минус на самом деле &ldquo;<code>1</code>&rdquo;, т.е. &ldquo;<code>i</code>&rdquo;, соответственно правый минус на самом деле &ldquo;<code>x</code>&rdquo;:</p>
<pre>
. . .
. . .
0 x!J
I 0 x
. i .
</pre>
<p>Расширяем вправо до 4x5:</p>
<pre>
. . . .
. . . .
0 x!J!.
I 0 x =
. i . .
</pre>
<p>Знак &ldquo;<code>=</code>&rdquo; поставлен в силу P2.</p>
<p>Если это &ldquo;<code>0</code>&rdquo;, то очевиден зигзагообразный забор &ldquo;<code>0&nbsp;x!&nbsp;0!&nbsp;x!&nbsp;0</code>&rdquo; при расширении вниз до 4x6.</p>
<p>Если это &ldquo;<code>1</code>&rdquo;, т.е. &ldquo;<code>j</code>&rdquo;, то мы видим более выгодную цепочку 2x1 с центром тяжести, смещенным вправо относительно центра тяжести исходной цепочки.</p>

<p><b>3.2.4)</b> Пусть <i>y</i><sub>3</sub>=<i>y</i><sub>1</sub>+1, <i>y</i><sub>2</sub>=<i>y</i><sub>3</sub>.</p>
<pre>
. - .
I 0 -.
0 x!J
. . .
. . .
</pre>
<p>Разбирается абсолютно аналогично случаю 3.2.3, с точностью до вертикальной симметрии.</p>


<p><b>3.3)</b> |<i>y</i><sub>3</sub>&minus;<i>y</i><sub>1</sub>|=0, т.е. <i>y</i><sub>1</sub>=<i>y</i><sub>3</sub>. Тогда |<i>x</i><sub>3</sub>&minus;<i>x</i><sub>1</sub>| может быть равен только 2, иначе <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub> соприкоснутся. Для определенности будем считать, что <i>x</i><sub>3</sub>=<i>x</i><sub>1</sub>+2 &mdash; в противном случае перенумеруем цепочку в обратном порядке и переобозначим <i>D</i>'<sub>I</sub> и <i>D</i>'<sub>J</sub>. Очевидно, для <i>x</i><sub>2</sub> есть лишь одна возможность <i>x</i><sub>2</sub>=<i>x</i><sub>1</sub>+1.</p>

<p>Для <i>y</i><sub>2</sub> есть три варианта: <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>&minus;1, <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>+1. (Напомним, что мы ставим центр апертуры на точку <i>L</i><sub>2</sub>.)</p>

<p><b>3.3.1)</b> Пусть <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>.</p>
<pre>
. . .
0 o .
I x!J
0 o .
. . .
</pre>
<p>Cлева сверху и слева снизу поставлены &ldquo;<code>0</code>&rdquo; по P1, а сверху и снизу &ldquo;<code>o</code>&rdquo;, ибо &ldquo;<code>1</code>&rdquo; соединила бы <i>L</i><sub>1</sub> и <i>L</i><sub>3</sub>.</p>
<p>Очевидно, что при расширении вверх и вниз до 3x7 получим забор-&laquo;скобку&raquo; &ldquo;<code>0&nbsp;o!&nbsp;x!&nbsp;o!&nbsp;0</code>&rdquo;, рвущий исходную цепочку:</p>
<pre>
  . . .
  . . .
  0 o!.
  I x!J
  0 o!.
  . . .
  . . .
</pre>


<p><b>3.3.2)</b> Пусть <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>&minus;1.</p>
<pre>
. . .
. . .
0 x!.
I 0 J
. o .
</pre>
<p>Слева ставим &ldquo;<code>0</code>&rdquo; по P1.</p>
<p>Внизу (между I и J) ставим &ldquo;<code>0</code>&rdquo;, ибо &ldquo;<code>1</code>&rdquo; невозможен (компоненты оказались бы связанными), а &ldquo;<code>x</code>&rdquo; приведет к только что разобранному случаю 3.3.1 (забор при расширении до 3x7).</p>
<p>Дважды внизу стоит &ldquo;<code>o</code>&rdquo;, иначе компоненты оказались бы связанными.</p>
<p>Если это &ldquo;<code>0</code>&rdquo;, то очевиден забор-&laquo;уголок&raquo; уже на этой апертуре, рвущий исходную цепочку.</p>
<p>А если &ldquo;<code>x</code>&rdquo;, то слева от него, по P1, стоит &ldquo;<code>0</code>&rdquo;, и забор, рвущий исходную цепочку, возникает при расширении вниз до 3x7:</p>
<pre>
  . . .
  . . .
  0 x!.
  I 0!J
  0 x!.
  . . .
  . . .
</pre>
<p><b>3.3.3)</b> Пусть <i>y</i><sub>2</sub>=<i>y</i><sub>1</sub>+1.</p>
<pre>
. o .
I 0 J
0 x!.
. . .
. . .
</pre>
<p>Разбирается абсолютно аналогично случаю 3.3.2, с точностью до вертикальной симметрии.</p>
<p>Разбор всех случаев, когда N=3, закончен.</p>


<h4><a name="proofN4"></a>Случай, когда кратчайшая цепочка, соединяющая разные компоненты, имеет длину <i>N</i>=4</h4>

<p>Пусть теперь самая выгодная цепочка, соединяющая разные связные компоненты <i>D</i>'I и <i>D</i>'J, имеет длину N=4 элемента.</p>

<p>Так как по условию наша цепочка <nobr><i>L</i> = <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,<i>L</i><sub>3</sub>,<i>L</i><sub>4</sub></i></nobr> самая выгодная, мы вправе предполагать отсутствие 3-элементных цепочек, соединяющих разные связные компоненты <i>D</i>'. В частности, мы можем утверждать, что <i>L</i><sub>1</sub> не является соседом <i>L</i><sub>3</sub> (ибо иначе получается 3-элементная цепочка <i>L</i><sub>1</sub>,<i>L</i><sub>3</sub>,<i>L</i><sub>4</sub>), <i>L</i><sub>2</sub> не является соседом <i>L</i><sub>4</sub> (ибо иначе получается 3-элементная цепочка <i>L</i><sub>1</sub>,<i>L</i><sub>2</sub>,<i>L</i><sub>4</sub>) и, разумеется, <i>L</i><sub>1</sub> не является соседом <i>L</i><sub>4</sub> (ибо иначе <i>L</i><sub>1</sub> и <i>L</i><sub>4</sub> оказались бы в одной связной компоненте). Также мы можем утверждать, что никакой пиксел типа &ldquo;<code>1</code>&rdquo; не может быть соединен 3-элементной цепочкой (через пиксел типа &ldquo;<code>x</code>&rdquo;) или тем более 2-элементной цепочкой (т.е. быть соседом) одновременно с <i>L</i><sub>1</sub> и с <i>L</i><sub>4</sub>, ибо иначе одна из этих двух цепочек соединит разные связные компоненты и будет при этом более выгодной.</p>

<p>Для определенности будем считать, что среднее звено цепочки <i>L</i><sub>2</sub>&ndash;<i>L</i><sub>3</sub> направлено слева направо (по горизонтали или диагонали) или строго сверху вниз (по вертикали), т.е. либо <i>x</i><sub>3</sub>&gt;<i>x</i><sub>2</sub>, либо <i>x</i><sub>3</sub>=<i>x</i><sub>2</sub>, но <i>y</i><sub>3</sub>&gt;<i>y</i><sub>2</sub>. В противном случае перенумеруем цепочку в обратном порядке и переобозначим <i>D</i>'<sub>I</sub>&nbsp;и&nbsp;<i>D</i>'<sub>J</sub>.</p>

<p>С учетом сказанного, все возможные геометрии цепочки <i>L</i> описываются следующими четырьмя схемами, соответствующими четырем возможным направлениям звена <i>L</i><sub>2</sub>&ndash;<i>L</i><sub>3</sub>:</p>

<pre>
             I?I?I?    I?I?I?      J?J?J?
I? . . J?    . x .     I?x . J?  I?. x J?
I? x x J?    . x .     I?. x J?  I?x . J?
I? . . J?    J?J?J?      J?J?J?  I?I?I?
    A          B           C         D
</pre>

<p>Здесь &ldquo;<code>I?</code>&rdquo; и &ldquo;<code>J?</code>&rdquo; обозначают все возможные позиции концов цепочки <i>L</i><sub>1</sub> и <i>L</i><sub>4</sub>, причем в группах C и D следует исключить по 2 случая, когда <i>L</i><sub>1</sub> и <i>L</i><sub>4</sub> оказываются соседями по диагонали.</p>

<p>Рассмотрим все эти группы вариантов.</p>

<p><b>4.A)</b> Линия <i>L</i><sub>2</sub>&ndash;<i>L</i><sub>3</sub> горизонтальна:</p>
<pre>
I? 0 . J?
I? x x J?
I? 0 . J?
</pre>

<p>Нули над и под левым &ldquo;<code>=</code>&rdquo; поставлены по лемме Sa. Условие правой локальности, примененное к левому &ldquo;<code>x</code>&rdquo;, требует считать, что либо над, либо под правым &ldquo;<code>x</code>&rdquo; стоит единица. Мы имеем максимум 3-элементные цепочки, ведущие от этой единицы как к <i>L</i><sub>1</sub>, так и к <i>L</i><sub>4</sub>, и одна из них будет более выгодной цепочкой, соединяющей разные связные компоненты.</p>

<p><b>4.B)</b> Линия <i>L</i><sub>2</sub>&ndash;<i>L</i><sub>3</sub> идет вертикально. Рассмотрим следующую апертуру 3x6:</p>
<pre>
. . .
I?I?I?
. x!=
. x!=
J?J?J?
. . .
</pre>
<p>Знаки &ldquo;<code>=</code>&rdquo; поставлены по P2.</p>

<p>Ни справа, ни слева от наших двух &ldquo;<code>x</code>&rdquo; (<i>L</i><sub>2</sub> и <i>L</i><sub>3</sub>) не может быть единиц, иначе мы получим максимум 3-элементные цепочки, ведущие от такой единицы как к <i>L</i><sub>1</sub>, так и к <i>L</i><sub>4</sub>, и одна из них будет более выгодной цепочкой, соединяющей разные связные компоненты. Значит, наши &ldquo;<code>=</code>&rdquo; на самом деле &ldquo;<code>0</code>&rdquo;, а слева мы имеем два &ldquo;<code>o</code>&rdquo;:</p>
<pre>
. . .
I?I?I?
o x!0
o x!0
J?J?J?
. . .
</pre>
<p>Но P1 требует поставить &ldquo;<code>0</code>&rdquo; слева от одного из &ldquo;<code>o</code>&rdquo;, и мы получаем тривиальный горизонтальный забор в этой апертуре, рвущий исходную цепочку.</p>

<p><b>4.C)</b> Линия <i>L</i><sub>2</sub>&ndash;<i>L</i><sub>3</sub> идет вправо вниз. Рассмотрим апертуру 3x5 в центром в точке <i>L</i><sub>3</sub>:</p>
<pre>
I?I?I?.
I?x o J?
I?0 x!J?
  J?J?J?
  . . .
</pre>
<p>Мы поставили слева &ldquo;<code>0</code>&rdquo; в силу P1. Мы поставили сверху &ldquo;<code>o</code>&rdquo;, так как &ldquo;<code>1</code>&rdquo; на этой позиции приводит к максимум 3-элементным цепочкам от этой единицы как к <i>L</i><sub>1</sub>, так и к <i>L</i><sub>4</sub>, и одна из них будет более выгодной цепочкой, соединяющей разные связные компоненты.</p>

<p>Применяя условие правой локальности к левому верхнему &ldquo;<code>x</code>&rdquo;, мы видим, что как минимум один из двух правых пикселов &ldquo;<code>I?</code>&rdquo; сверху действительно является единицей, причем именно типа &ldquo;<code>i</code>&rdquo; (из той же связной компоненты, что и <i>L</i><sub>1</sub>) &mdash; в противном случае мы получим максимум 3-элементную цепочку от этой единицы к <i>L</i><sub>1</sub>, соединяющую разные связные компоненты. Применяя условие правой локальности к &ldquo;<code>x!</code>&rdquo; (центру апертуры), мы видим, что как минимум один из четырех правых пикселов &ldquo;<code>J?</code>&rdquo; сверху действительно является единицей, причем именно типа &ldquo;<code>j</code>&rdquo; (из той же связной компоненты, что и <i>L</i><sub>4</sub>) &mdash; в противном случае мы получим максимум 3-элементную цепочку от этой единицы к <i>L</i><sub>4</sub>, соединяющую разные связные компоненты.</p>

<p>С этого момента нас уже не интересуют истинные позиции <i>L</i><sub>1</sub> и <i>L</i><sub>4</sub> &mdash; нам достаточно, что один из двух пикселов, обозначенных ниже &ldquo;<code>i?</code>&rdquo;, действительно имеет тип &ldquo;<code>i</code>&rdquo;, а один из четырех пикселов, обозначенных ниже &ldquo;<code>j?</code>&rdquo;, действительно имеет тип &ldquo;<code>j</code>&rdquo;:</p>
<pre>
i?i?.
x o!j?
0 x j?
. j?j?
. . .
</pre>

<p>Допустим вначале, что правый &ldquo;<code>i?</code>&rdquo; на самом деле не &ldquo;<code>i</code>&rdquo;, а &ldquo;<code>o</code>&rdquo;. Тогда оставшийся &ldquo;<code>i?</code>&rdquo; (левый) обязан быть единицей:</p>
<pre>
  i o .
  x o j?
  0 x!j?
  . j?j?
  . . .
</pre>
<p>Но теперь, в силу P2, оба &ldquo;<code>o!</code>&rdquo; можно заменить на &ldquo;<code>0</code>&rdquo;:</p>
<pre>
  i 0 .
  x 0 j?
  0 x!j?
  . j?j?
  . . .
</pre>
<p>и мы видим забор-&laquo;уголок&raquo; уже на этой апертуре, рвущий цепочку &ldquo;<code>i&nbsp;x&nbsp;x!&nbsp;j</code>&rdquo;.</p>

</pre>
<p>Таким образом, можно считать, что правый &ldquo;<code>i?</code>&rdquo; действительно &ldquo;<code>i</code>&rdquo;. В этом случае значение левого &ldquo;<code>i?</code>&rdquo; нам неважно, и мы поставим в этом месте точку:</p>
<pre>
. i .
x o ?
0 x!j?
. j?j?
. . .
</pre>

<p>Вопросительный знак справа сверху не может быть &ldquo;<code>1</code>&rdquo;, ибо тогда это &ldquo;<code>i</code>&rdquo; и получается максимум 3-элементная цепочка оттуда до &ldquo;<code>j</code>&rdquo;. (Поэтому мы более не обозначем этот пиксел как &ldquo;<code>J?</code>&rdquo;.)</p>
<p>Если вопросительный знак справа сверху есть &ldquo;<code>0</code>&rdquo;, то при расширении апертуры вверх до 3x6 мы увидим забор &ldquo;<code>0&nbsp;x!&nbsp;o!&nbsp;0</code>&rdquo;, рвущий цепочку &ldquo;<code>i&nbsp;x!&nbsp;x!&nbsp;j</code>&rdquo;:</p>
<pre>
  . . .
  . i .
  x o!0
  0 x!j?
  . j?j?
  . . .
</pre>

<p>Остается допустить, что вопросительный знак справа сверху есть &ldquo;<code>x</code>&rdquo;:</p>
<pre>
. i .
x o x
0 x!?
. j?j?
. . .
</pre>

<p>Новый вопросительный знак справа не может быть &ldquo;<code>1</code>&rdquo;, ибо тогда мы получим максимум 3-элементные цепочки, ведущие от этой единицы как к верхнему &ldquo;<code>i</code>&rdquo;, так и к &ldquo;<code>j</code>&rdquo;, и одна из них будет более выгодной цепочкой, соединяющей разные связные компоненты. (Поэтому мы более не обозначем этот пиксел как &ldquo;<code>J?</code>&rdquo;.)</p>
<p>Если этот новый вопросительный знак есть &ldquo;<code>0</code>&rdquo;, то мы видим тривиальный горизонтальный забор &ldquo;<code>0&nbsp;x!&nbsp;0</code>&rdquo; уже на этой апертуре, рвущий цепочку &ldquo;<code>i&nbsp;x!&nbsp;x!&nbsp;j</code>.</p>
<p>Остается допустить, что новый вопросительный знак справа тоже есть &ldquo;<code>x</code>&rdquo;:</p>
<pre>
. i .
x o x
0 x!x
. j?j?
. . .
</pre>
<p>Расширяем апертуру вправо до 4x5:</p>
<pre>
. i . .
x o x .
0 x!x!=
. j?j?.
. . . .
</pre>
<p>Если знак &ldquo;<code>=</code>&rdquo;, поставленный по P2, есть &ldquo;<code>0</code>&rdquo;, то мы видим тривиальный горизонтальный забор &ldquo;<code>0&nbsp;x!&nbsp;x!&nbsp;0</code>&rdquo; уже на этой апертуре, рвущий цепочку &ldquo;<code>i&nbsp;x!&nbsp;x!&nbsp;j</code>&rdquo;.</p>
<p>Остается предположить, что это &ldquo;<code>1</code>&rdquo;:</p>
<pre>
. i . .
x o x .
0 x!x!1
  j?j?.
. . . .
</pre>
<p>Мы видим максимум 3-элементные цепочки, ведущие от новой единицы справа как к верхнему &ldquo;<code>i</code>&rdquo;, так и к нижнему &ldquo;<code>j</code>&rdquo;, и одна из них будет более выгодной цепочкой, соединяющей разные связные компоненты.</p>


<p><b>4.D)</b> Линия <i>L</i><sub>2</sub>&ndash;<i>L</i><sub>3</sub> идет вправо вверх. Рассмотрим апертуру 3x5 в центром в точке <i>L</i><sub>3</sub>:</p>
<pre>
  . . .
  J?J?J?
I?0 x!J?
I?x o J?
I?I?I?.
</pre>
<p>Эта ситуация разбирается абсолютно аналогично случаю 4.С, с точностью до вертикальной симметрии.</p>

<p>Разбор всех случаев, когда N=4, закончен.</p>
<p>Теорема доказана.</p>


<h3><a name="example3x5"></a>Примеры алгоритмов скелетизации с апертурой зависимости 3x5</h3>

<p>Приведем пример параллельного алгоритма скелетизации, дающего достаточно качественные скелеты при апертуре зависимости 3x5 и удовлетворяющего всем условиям теоремы связности.</p>

<p>Для каждого пиксела с координатами (<i>x</i><sub>0</sub>,&nbsp;<i>y</i><sub>0</sub>) рассмотрим апертуру зависимости 3x5 <nobr><i>x</i><sub>0</sub>&minus;1 &le; <i>x</i> &le; <i>x</i><sub>0</sub>+1</nobr>, <nobr><i>y</i><sub>0</sub>&minus;2 &le; <i>y</i> &le; <i>y</i><sub>0</sub>+2</nobr>. Значения пикселов исходной битовой матрицы в этой апертуре обозначим следующим образом:</p>

<pre>
<i>a</i><sub>0</sub> <i>b</i><sub>0</sub> <i>c</i><sub>0</sub>
<i>a</i><sub>1</sub> <i>b</i><sub>1</sub> <i>c</i><sub>1</sub>
<i>a</i><sub>2</sub> <b><i>b</i><sub>2</sub></b> <i>c</i><sub>2</sub>
<i>a</i><sub>3</sub> <i>b</i><sub>3</sub> <i>c</i><sub>3</sub>
<i>a</i><sub>4</sub> <i>b</i><sub>4</sub> <i>c</i><sub>4</sub>
</pre>

<p>Таким образом, <i>a</i><sub>0</sub> есть элемент (<i>x</i><sub>0</sub>&minus;1,<i>y</i><sub>0</sub>&minus;2) исходной матрицы, <i>b</i><sub>2</sub> есть элемент (<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>) исходной матрицы.</p>

<p>Алгоритм вычисляет определенную логическую функцию <nobr>&fnof;(<i>a</i><sub>0</sub>, <i>b</i><sub>0</sub>, <i>c</i><sub>0</sub>, ..., <i>a</i><sub>4</sub> <i>b</i><sub>4</sub> <i>c</i><sub>4</sub>)</nobr> и помещает результат в новую битовую матрицу, называемую <i>результатом итерации скелетизации</i>. Эта операция называется <i>итерацией скелетизации слева</i>. Кроме этой, используются также 3 другие итерации скелетизации &mdash; <i>сверху</i>, <i>справа</i> и <i>снизу</i>, абсолютно аналогичные данной, но выполняемые не в обычной системе координат (ось <i>x</i> направлена вправо, ось <i>y</i> направлена вниз), а в системах координат, получаемых из этой поворотом по часовой стрелке на 90&deg;, 180&deg; и 270&deg; соответственно. Фактически, это означает вычисление других 3 функций от элементов апертуры 5x3, 3x5 и 5x3 в обычной системе кординат.</p>

<p>Полный алгоритм скелетизации последовательно применяет 4 итерации скелетизации слева, сверху, справа и снизу &mdash; при этом исходной матрицей для новой итерации является результат предыдущей итерации &mdash; до тех пор, пока битовая матрица не перестанет изменяться. Детали программной реализации такого алгоритма мы не приводим, но заметим, что в случае упакованного хранения битовых матриц (64 элемента в одном 64-битовом слове) любую логическую функцию &fnof; можно вычислить, построив не более 3*5&minus;1=14 вспомогательных матриц, получаемых из исходной сдвигом, и применив к ним и к исходной матрице традиционные побитовые операции, имеющиеся во всех процессорах и в большинстве языков программирования: побитовое &laquo;и&raquo;, &laquo;или&raquo;, &laquo;не&raquo;. Это возможно благодаря тому, что описанный алгоритм параллельный, т.е. результат итерации в точке (<i>x</i><sub>0</sub>,&nbsp;<i>y</i><sub>0</sub>) зависит только от элементов исходной матрицы в апертуре зависимости. Таким образом, при вычислении итерации скелетизации можно обрабатывать все биты машинного слова одновременно, а при наличии нескольких процессоров или процессорных ядер можно любым удобным образом разбить матрицу на части и обработать эти части параллельно.</p>

<p>Остается описать необходимую функцию &fnof;, обеспечивающую, с неформальной точки зрения, истончение объектов слева и удовлетворяющую условиям теоремы связности.</p>

<p>Я предлагаю логическую функцию <nobr>&fnof;(<i>a</i><sub>0</sub>, <i>b</i><sub>0</sub>, <i>c</i><sub>0</sub>, ..., <i>a</i><sub>4</sub> <i>b</i><sub>4</sub> <i>c</i><sub>4</sub>)</nobr>, соответствующую следующему набору правил (для наглядности сформулируем их на псевдо-языке программирования):</p>

<ol type="I">
<li><b><i>если b</i><sub>2</sub>=0, то &fnof;</i>=0<sub>2</sub></b> (гарантируем условие нерасширения);</li>
<li><b><i>иначе, если c</i><sub>2</sub>=0<i>, то &fnof;</i>=1</b>;</li>
<li><b><i>иначе</i></b> (мы уверены, что центральный пиксел единичный и справа от него тоже единица):
  <ol>
  <li><b><i>если a</i><sub>2</sub>=0</b> (левый край, вероятная ситуация для истончения: удаления центрального пиксела)<b><i>, то</i></b>:
    <ul type="disc">
    <li><b><i>если a</i><sub>1</sub>=1 <i>и если неверно, что b</i><sub>1</sub>=1</b> (т.е. <i>b</i><sub>1</sub>=0)<b><i>, то &fnof;</i>=1</b> (это означает, что точка <i>a</i><sub>1</sub>=1 сверху &laquo;отрывается&raquo; в <nobr>3x3-апертуре</nobr>);</li>
    <li><b><i>иначе, если a</i><sub>3</sub>=1 <i>и если неверно, что (b</i><sub>3</sub>=1 <i>или (b</i><sub>4</sub>=1 <i>и c</i><sub>3</sub>=1<i>)), то &fnof;</i>=1</b> (это означает, что точка <i>a</i><sub>3</sub>=1 снизу &laquo;отрывается&raquo; как в 3x3, так и в <nobr>3x5-апертуре</nobr>);</li>
    <li><b><i>иначе, если b</i><sub>1</sub>=0 <i>и c</i><sub>1</sub>=0 <i>и b</i><sub>3</sub>=0 <i>и c</i><sub>3</sub>=0<i>, то &fnof;</i>=1</b> (это означает, что отрезок <i>c</i><sub>2</sub>&mdash;<i>b</i><sub>2</sub> предствляет собой левое окончание тонкой однопиксельной линии, которую наш алгоритм уже не трогает &mdash; не пытается укорачивать);</li>
    <li><b><i>иначе &fnof;</i>=0</b> (удаляем центральный пиксел);</li>
    </ul>
  </li>
  <li><b><i>иначе &fnof;</i>=1</b> (воздерживаемся от истончения).</li>
  </ol>
</li>
</ol>

<p>Соответствующий алгоритм скелетизации (с добавлением 3 итераций, получаемых поворотами системы координат) мы назовем <b><i>aлгоритм A</i></b>. Такой алгоритм обеспечивает достаточно качественные скелеты, при этом никогда не пытается удалять единичный пиксел, если слева от него единица (это более сильное требование, чем сформулированное в теореме условие левого края). Иначе говоря, он не пытается &laquo;делать дырки&raquo;. Однако, расплатой за такое сильное требование является возможное появление в окончательном скелете &laquo;толстых узлов&raquo; 2x3, 3x2 и даже 3x3 (единичных областей, которые невозможно &laquo;истончить&raquo; далее):</p>

<pre>
<b>1</b> 0 0 0 0 <b>1</b>    <b>1</b> 0 0 <b>1</b> 0 0 <b>1</b>    <b>1</b> 0 0 <b>1</b> 0 0 <b>1</b>
0 <b>1</b> 0 0 <b>1</b> 0    0 <b>1</b> 0 <b>1</b> 0 <b>1</b> 0    0 <b>1</b> 0 <b>1</b> 0 <b>1</b> 0
0 0 <b>1</b> <b>1</b> 0 0    0 0 <b>1</b> <b>1</b> <b>1</b> 0 0    0 0 <b>1</b> <b>1</b> <b>1</b> 0 0
<b>1</b> <b>1</b> <b>1</b> <b>1</b> <b>1</b> <b>1</b>    0 0 <b>1</b> <b>1</b> <b>1</b> 0 0    <b>1</b> <b>1</b> <b>1</b> <b>1</b> <b>1</b> <b>1</b> <b>1</b>
0 0 <b>1</b> <b>1</b> 0 0    0 <b>1</b> 0 <b>1</b> 0 <b>1</b> 0    0 0 <b>1</b> <b>1</b> <b>1</b> 0 0
0 <b>1</b> 0 0 <b>1</b> 0    <b>1</b> 0 0 <b>1</b> 0 0 <b>1</b>    0 <b>1</b> 0 <b>1</b> 0 <b>1</b> 0
<b>1</b> 0 0 0 0 <b>1</b>                     <b>1</b> 0 0 <b>1</b> 0 0 <b>1</b>
</pre>

<p>Если существование в скелете единичных областей 3x2, 2x3 и 3x3 является неприемлемым, то можно &laquo;усилить&raquo; приведенную выше функцию &fnof;, добавив после проверки 1 следующую ветку:</p>

<blockquote>
<ol>
  <li><b><i>если a</i><sub>2</sub>=0</b>... (то же самое);</li>
  <li><b><i>иначе, если a</i><sub>1</sub>=0 <i>и a</i><sub>3</sub>=0 <i>и b</i><sub>0</sub>=0 <i>и b</i><sub>4</sub>=0 <i>и при этом все 8 пикселов a</i><sub>0</sub><i>, a</i><sub>2</sub><i>, a</i><sub>4</sub><i>, b</i><sub>1</sub><i>, b</i><sub>3</sub><i>, c</i><sub>1</sub><i>, c</i><sub>2</sub><i>, c</i><sub>3</sub><i> равны </i>1<i>, то &fnof;</i>=0</b> (распознаем &laquo;проблемные&raquo; ситуации, приведенные на схеме выше, и в порядке исключения &laquo;делаем дырку&raquo; на месте присоединения левой горизонтальной линии в вертикальному массиву единичных пикселов);</li>
  <li><b><i>иначе &fnof;</i>=1</b> (как и раньше, воздерживаемся от истончения).</li>
</ol>
</blockquote>

<p>Полученный алгоритм мы назовем <b><i>aлгоритм B</i></b>.</p>

<p>Оба алгоритма A и B удовлетворяют всем условиям теоремы связности и не нарушают связность ни на одной конфигурации 3x7 или 4x6, что можно проверить соответствующими переборными программами. Таким образом, существует гарантия, что приведенные алгоритмы скелетизации сохраняют связность 8-связных компонент исходного изображения.</p>

<p>Что касается качества получаемых итоговых скелетов, справедливы следующие <i>теоремы тонкости</i>.</p>


<p><a name="theoremThinnessA"></a><i><b>Теорема тонкости для алгоритма A</b>. В окончательном скелете, получаемом алгоритмом A (с добавлением 3 итераций, получаемых поворотами системы координат), прямоугольные области 2x3, 3x2 и 3x3, заполненные единицами, могут появиться только в центре следующих конфигураций 4x5, 5x4 и 5x5:</i></p>

<pre>
1 0 0 1    1 0 1 0 1    1 0 1 0 1
0 <b>1</b> <b>1</b> 0    0 <b>1</b> <b>1</b> <b>1</b> 0    0 <b>1</b> <b>1</b> <b>1</b> 0
1 <b>1</b> <b>1</b> 1    0 <b>1</b> <b>1</b> <b>1</b> 0    1 <b>1</b> <b>1</b> <b>1</b> 1
0 <b>1</b> <b>1</b> 0    1 0 1 0 1    0 <b>1</b> <b>1</b> <b>1</b> 0
1 0 0 1                 1 0 1 0 1
</pre>

<p>Иначе говоря, приведенные выше примеры плохих случаев являются единственно возможными, если говорить о возможных значениях соседних пикселов, окружающих заполненный единицами прямоугольник 2x3, 3x2 или 3x3. В частности, в окончательном скелете не могут сохраниться заполненные единицами прямоугольники размеров 2x4, 4x2, 3x4, 4x3 или бо&#x0301;льшие.</p>

<p>Как и теорема связности, эта теорема доказывается тестирующей программой перебора. А именно, поведение пикселов в области 3x3, в случае итерации скелетизации слева, полностью определяется апертурой исходной матрицы 5x7:</p>

<pre>
? ? ? ? ?
? ? ? ? ?
? <b>r</b> <b>r</b> <b>r</b> ?
? <b>r</b> <b>r</b> <b>r</b> ?
? <b>r</b> <b>r</b> <b>r</b> ?
? ? ? ? ?
? ? ? ? ?
</pre>

<p>Мы обозначили буквой &ldquo;<code>r</code>&rdquo; значения пикселов в результате итерации скелетизации. Таким образом, достаточно перебрать 2<sup>5*7</sup>=2<sup>35</sup> возможных битовых конфигураций, чтобы получить список всех центральных конфигураций 3x3, которые могут оказаться устойчивыми к итерации скелетизации слева хотя бы при каких-то конфигурациях окружающих пикселов. Конфигурацию 5x7, целиком состояющую из единиц и, очевидно, дающую в центре единичный квадрат 3x3, следует исключить из рассмотрения: если в итоговом скелете существует прямоугольник некоторого размера, заполненный единицами, то существует такой же прямоугольник с наименьшей <i>x</i>-координатой, и у него будет хотя бы один нулевой сосед. (Напоминаем, что пикселы за пределами матрицы мы считаем равными нулю, поэтому вырожденный случай бесконечной матрицы, заполненной единицами, мы не рассматриваем.) Тестирующая программа выполняет такой анализ для всех 4 вариантов итерации скелетизации слева, сверху, справа и снизу и получает два списка конфигураций 3x3: конфигурации из первого списка при определенном внешнем окружении могут оказаться устойчивыми ко всем 4 итерациям скелетизации, конфигурации же из второго списка заведомо невозможны в итоговом скелете, ибо разрушаются при всех вариантах внешнего окружения.</p>

<p>Конфигурации 3x3 из первого списка могут потребовать дальнейшего анализа, если мы не сумеем найти такого окружения 5x7 или 7x5, при котором не только центральная область 3x3, но и вся конфигурация в целом (будучи дополнена снаружи нулями) стабильна по отношению ко всем 4 итерациям скелетизации, т.е. представляет собой готовый пример стабильного окончательного скелета. В таком случае нет гарантии, что такая конфигурация 3x3 может действительно встретиться в итоговом скелете. В этой ситуации (сравнительно редкой на практике) тестирующая программа должна всеми возможными способами дополнить &laquo;проблемную&raquo; конфигурацию 3x3 до конфигурации 5x5 с тем же центром. Заметим: мы сразу можем сказать, что такая дополненная конфигурация 5x5 не может встретиться в итоговом скелете, если хотя бы одна из 9 ее под-областей 3x3 попала во второй список заведомо невозможных конфигураций 3x3. В противном случае, поведение пикселов в конфигурации 5x5, в свою очередь, полностью определяется апертурой исходной матрицы 7x9:</p>
<pre>
? ? ? ? ? ? ?
? ? ? ? ? ? ?
? <b>r</b> <b>r</b> <b>r</b> <b>r</b> <b>r</b> ?
? <b>r</b> <b>r</b> <b>r</b> <b>r</b> <b>r</b> ?
? <b>r</b> <b>r</b> <b>r</b> <b>r</b> <b>r</b> ?
? <b>r</b> <b>r</b> <b>r</b> <b>r</b> <b>r</b> ?
? <b>r</b> <b>r</b> <b>r</b> <b>r</b> <b>r</b> ?
? ? ? ? ? ? ?
? ? ? ? ? ? ?
</pre>

<p>в случае итерации скелетизации слева/справа или аналогичной апертурой 9x7 в случае итерации скелетизации сверху/снизу. Перебрав все возможные конфигурации такого размера, содержащие в центре все проверяемые конфигурации 5x5, мы либо отыщем искомый итоговый скелет, стабильный по отношению ко всем 4 итерациям скелетизации, либо убедимся, что все конфигурации 5x5, содержащие изучаемую центральную конфигурацию 3x3 (а значит, и сама центральная конфигурация 3x3) невозможны для итогового скелета, ибо разрушаются при всех вариантах внешнего окружения, либо, в свою очередь, обнаружим &laquo;проблемные&raquo; конфигурации 5x5: такие, что они сохраняются при всех вариантах окружения 9x7 или 7x9, но среди всех таких конфигураций 9x7 или 7x9 нет ни одной, представляющей собой (при дополнении снаружи нулями) готовый пример стабильного скелета. К счастью, реальная тестирующая программа показывает, что подобная ситуация не происходит для описанных выше алгоритмов A и B.</p>

<p>В случае алгоритма A описанное тестирование показывает, что единственные конфигурации 3x3, содержащие полностью единичную прямоугольную область 2x3 или 3x2, которые могут встретиться в итоговом скелете, суть</p>

<pre>
0 1 1    0 1 0    1 1 0    1 1 1    1 1 1
1 1 1    1 1 1    1 1 1    1 1 1    1 1 1
0 1 1    1 1 1    1 1 0    0 1 0    1 1 1
</pre>

<p>Чтобы доказать теорему, тестирующая программа вновь должна дополнить эти конфигурации всеми возможными способами до конфигурации 5x5 с тем же центром, проверяя при этом, что ни одна из 9 ее под-областей 3x3 не попадает в список заведомо невозможных конфигураций 3x3. Заметим: сейчас мы можем включить в этот список также те конфигурации 3x3, которые были &laquo;проблемными&raquo; на первом этапе тестирования, если углубленный анализ путем дополнения до конфигураций 5x5 показал, что они все-таки невозможны в итоговом скелете. Как и ранее, перебираем все возможные конфигурации размера 7x9 или 9x7, получаемые дальшейшим расширением такой конфигурации 5x5, и получаем полный список всех возможных, невозможных и &laquo;проблемных&raquo; конфигураций 5x5, содержащих в центре одну из указанных пяти конфигураций 3x3. Реальная тестирующая программа не обнаруживает в этом случае &laquo;проблемных&raquo; конфигураций 5x5, а все возможные конфигурации 5x5, которые хотя бы при одном внешнем окружении устойчивы ко всем 4 итерациям скелетизации, действительно, содержат указанные в теореме конфигурации соседей единичного прямоугольника 2x3, 3x2 или 3x3.</p>

<p>Заметим: описанный алгоритм тестирования лишь иллюстрирует общую идею построения тестирующей программы. Буквальная реализация описанного метода на типичных современных компьютерах приведет к очень большому времени выполнения: каждую из конфигураций 5x5 можно дополнить до конфигурации 7x9 2<sup>38</sup>~275 миллиардами способов, а таких конфигураций 5x5 придется проанализировать многие десятки тысяч. Однако, грамотная реализация тестирующей программы позволяет значительно сократить перебор и доказать теорему за несколько минут процессорного времени персонального компьютера.</p>


<p><a name="theoremThinnessB"></a><i><b>Теорема тонкости для алгоритма B</b>. В окончательном скелете, получаемом алгоритмом B (с добавлением 3 итераций, получаемых поворотами системы координат), не могут встретиться прямоугольные области 2x3, 3x2 или 3x3, заполненные единицами.</i></p>

<p>Эта теорема доказывается той же самой тестирующей программой перебора, что и теорема тонкости для алгоритма A. После изучения всех конфигураций 3x3 выясняется, что как целиком единичная конфигурация 3x3, так и конфигурации 3x3, содержащие целиком единичные прямоугольники 2x3 или 3x2, оказываются невозможными.</p>

<p>Таким образом, самая большая прямоугольная область, заполненная единицами, которая может существовать в результате алгоритма B, есть квадрат 2x2. Ниже приведен полный список всех возможных конфигураций 4x4, в центре которых может встретиться такой квадрат 2x2 (для краткости не приводятся конфигурации, которые можно получить из других конфигураций симметрией или поворотом системы координат):</p>

<pre>
1 0 0 1    0 1 0 1    0 1 0 1
0 <b>1 1</b> 0    1 <b>1 1</b> 0    1 <b>1 1</b> 0
0 <b>1 1</b> 0    0 <b>1 1</b> 0    0 <b>1 1</b> 1
1 0 0 1    1 0 0 1    1 0 1 0
</pre>



<p align="right"><i>Ноябрь 2010 г.</i></p>

<p><br><br><br><i>Комментарии по поводу статьи можно оставить на моем блоге, тема &laquo;Теорема связности&raquo;: <noindex><nobr><a href="http://danielalievsky.livejournal.com/22441.html">http://danielalievsky.livejournal.com/22441.html</a></nobr></noindex>.</i></p>


<!-- wwinclude begin file="../../../service_files/postfix.inc" --><!-- wwinclude end -->
</body>
</html>