<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Библиотеки AlgART: отчет на апрель 2008 г.</title>
<style type="text/css">
    dt {font-style: italic}
    dd {margin-bottom: 15px}
</style>
</head>

<body>
<h1>Библиотеки AlgART для обработки массивов: отчет на апрель 2008 г.</h1>

<p align="right"><i>Даниил Алиевский</i></p>

<p>Далее перечислены и кратно описаны основные блоки, готовые на данный момент.
Автор всех разработок Д.Алиевский, кроме специально оговоренных блоков,
реализованных А.Вылегжаниным и А.Пятковым.</p>

<h3>Базовая платформа (системное ядро)</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Основной низкоуровневый блок, реализующий понятие массива AlgART.</dd>

<dt>Размещение</dt>
<dd>Пакет net.algart.arrays (тесты &mdash; в подпакете net.algart.arrays.demo).</dd>

<dt>Основные возможности</dt>
<dd><b>63-битовая адресация:</b> длина AlgART-массива ограничена лишь
    пределом 2<sup>63</sup>~9*10<sup>18</sup> элементов.
    (Все классические средства организовать массив или матрицу, поддерживаемые Java,
    ограничены пределом 2<sup>31</sup> элементов на один массив, т.е. 2 GB в случае байтов,
    даже в 64-разрядных версиях Java.)</dd>
<dd><b>Концепция моделей памяти:</b> массив может храниться в обычной памяти, на дисковом файле или как-то еще.
    Дисковые модели (LargeMemoryModel) позволяют фактически преодолеть предел 2 GB,
    причем как в 32-битовых, так и в 64-битовых версиях Java.
    Модель для обычной памяти (SimpleMemoryModel) позволяет обеспечить максимальную эффективность,
    когда обрабатываемый массив (скажем, промежуточный буфер) реально не очень велик.
    Реализованные дисковые модели памяти могут опираться как на стандартные средства ввода-вывода,
    так и на прямое отображение файлов в память (мапирование).
    Последний вариант более эффективен, но его реализация компанией Sun некоторые проблемы
    в Java 1.6, полностью отсутствующие лишь в 64-разрядной Java 1.7.
    Для пользователей библиотек это означает снижение эффективности в Java 1.6
    и необходимость аккуратно и вовремя освобождать ресурсы в 32-разрядных Java.</dd>
<dd><b>Любые типы элементов:</b> 8 примитивных типов Java либо произвольные объекты.
    В последнем случае AlgART-массив напоминает стандартный класс ArrayList.
    Набор примитивных типов: bit (упакованный битовый массив), byte (8 бит),
    short (16 бит), char (практически идентичен short), int (32 бита), long (64 бита),
    float (вещественный, 32 бита), double (вещественный, 64 бита).</dd>
<dd><b>Изменяемый размер</b> для одномерных массивов.</dd>
<dd><b>Поддержка многомерных массивов (матриц)</b> с любым числом размерностей.</dd>
<dd><b>Возможность эффективно упаковывать объекты любого типа в "нижележащие" массивы примитивных типов.</b>
    Это значит, что массив, который для программиста выглядит как массив сложных структур данных,
    например, окружностей или узлов графа, в действительности хранится эффективно упакованным
    в один или несколько AlgART-массивов, например, типа int.
    Это единственный способ эффективно работать с большими массивами структур данных:
    все существующие в Java способы создать массив структур (вроде окружностей)
    чрезвычайно расточительны по памяти и при этом ограничены все тем же 2 GB пределом.
    Данная возможность &mdash; пример применения концепции моделей памяти (упаковку-распаковку
    данных реализует специальная модель памяти).</dd>
<dd><b>Продуманные стратегии управления ресурсами:</b> автоматическое удаление временных файлов,
    возможность отобразить массив на существующий файл,
    возможность отреагировать на освобождение файла и т.д.</dd>
<dd><b>Базовая низкоуровневая функциональность для работы с массивами и матрицами:</b>
    доступ к элементам, выделение подмассива или подматрицы, копирование, сортировка,
    вставка/удаление элементов для одномерых массивов переменной длины.
    Для удобного и эффективного поблочного доступа к данным предусмотрена
    специальная архитектура "буфера данных" (DataBuffer), автоматизирующая
    классический подход к обработке больших массивов, особенно дисковых:
    прочитать блок данных в локальный массив (обычный, не AlgART),
    обработать соответствующим циклом, если надо, записать обратно.</dd>
<dd><b>Исчерпывающая документация</b> в стандарте JavaDoc на английском языке.
    Прокомментированы абсолютно все классы и методы, доступные программисту,
    вплоть до точного смысла каждого параметра.
    Имеются также обзорные комментарии, описывающую те или иные концепции,
    в том числе общий комментарий-статья к пакету net.algart.arrays.</dd>
<dd><b>Набор тестов:</b> несколько бессистемный, но позволяющий автоматически
    протестировать и проверить все основные компоненты.</dd>

<dt>Сроки реализации</dt>
<dd>С 6 августа 2006 по 30 апреля 2007. Промежуточные сроки:
    <ul>
    <li>Ноябрь 2006. Первые работающие версии, которые можно было начинать использовать.
    В этих версиях еще не было дисковых моделей, т.е. не было фактического способа
    создать массив более 2 GB. Предполагалось, что программы, работающиие пока на
    простую модель памяти, в будущем будут тривиально переключены на большие модели.
    Так и получилось в отношении пакета тестов.
    Кроме того, еще не были реализованы матрицы &mdash; только одномерные массивы.</li>
    <li>31 января 2007. Первая полная работающая версия, уже с матрицами и дисковыми моделями.</li>
    <li>Февраль и март 2007. Отладка, улучшения архитектуры, оптимизация.
    Общение с компанией Sun &mdash;
    они исправили ошибки (в Java 1.7), делавшие невозможными применение мапирования
    в библиотеках AlgART.</li>
    <li>Апрель 2007. Документирование (тех частей, документация которых была оставлена "на потом"),
    оптимизация и отладка. Добавлена концепция DataBuffer.</li>
    </ul>
    </dd>
</dl>


<h3>Первичная интеграция с SIMAGIS</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Вспомогательные классы и дополнительные концепции, позволяющие применить
библиотеки для обработки изображений SIMAGIS.</dd>

<dt>Размещение</dt>
<dd>Пакеты net.algart.contexts, algart.lib, отдельные модули в других пакетах.</dd>

<dt>Основные компоненты</dt>
<dd><b>Переходник между двумерной AlgART-матрицей или тройкой матриц
    и классом AImage из библиотек 2000 года.</b>
    Позволяет создать виртуальную AlgART-матрицу, доступ к которой автоматически
    транслируется в доступ к соответствующим элементам AImage.
    С этого момента стало возможным применять новые функции к старым изображениям и наоборот.</dd>
<dd><b>Концепция <i>контекста</i>.</b> Контекст описывает среду,
    в которой исполняется алгоритм, и позволяет алгоритму узнать различные необходимые вещи:
    как вывести проценты своего исполнения, когда следует прерваться по желанию пользователя,
    сколько ядер процессора и как именно разрешено использовать,
    в каком каталоге необходимо размещать временные файлы и т.д.
    Без такой концепции применение новых библиотек в SIMAGIS было практически невозможно.
    Реализовано в виде пакета net.algart.contexts.</dd>
<dd><b>Класс Matrix2D: "матрица SIMAGIS".</b> (Разработано в основном Алексеем,
    но потребовало и от меня доводок архитектуры.)
    Реализует матрицу AlgART, хранимую в виде отображаемого файла в некотором
    подкаталоге простого формата. Такая матрица, подобно AImage,
    может храниться в ячейке SIMAGIS и передаваться в качестве параметра плагинам SIMAGIS.
    С этого момента стало возможным в принципе составить таблицу, содержащую лишь изображения
    в виде матриц AlgART и обрабатывающиую их с помощью новых функций.
    Позднее Matrix2D был заменен более мощным Image2D.</dd>
<dd>Самые первые прикладные функции, позволяющиие "проверить идею":
    расчет суммы элементов массива (матрицы), а также минимума и максимума.</dd>

<dt>Сроки реализации</dt>
<dd>С 1 мая по 10 июня 2007.</dd>
</dl>


<h3>Базовая прикладная функциональность (прикладное ядро)</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Универсальный набор базовых функций и архитектурных решений, необходимый практически для любых
    алгоритмов обработки AlgART-массивов и матриц.</dd>

<dt>Размещение</dt>
<dd>Пакеты net.algart.arrays, net.algart.math.functions.</dd>

<dt>Основные компоненты</dt>
<dd><b>Концепция абстрактных массивов:</b> почти готовые реализации "полновесного" массива AlgART,
    для окончательной реализации которых достаточно реализовать всего один метод
    получения элемента по индексу (в случае изменяемых массивов &mdash; также записи элемента по индексу).
    Таким образом можно легко создать массив, который выглядит как самый обычный (чаще всего неизменяемый)
    AlgART-массив, а на деле обращение к его элементам вызывает те или иные вычисления.
    Именно на этой идее построено 99% прикладных алгоритмов обработки AlgART-массивов и матриц.</dd>
<dd><b>Ленивые функциональные вычисления:</b> мощная и универсальная архитектура,
    позволяющая легко реализовывать практически любые поэлементные операции над массивом.
    Определяется очень простой класс "математическая функция", умеющий сделать всего одно действие:
    по набору вещественных чисел вычислить новое вещественное число.
    Этот класс передается в специальный универсальный метод asFuncArray
    (чрезвычайно сложно устроенный внутри) вместе с несколькими AlgART-массивами (или матрицами).
    В результате формируется ленивый массив (матрица), любое чтение элементов которого
    приводит к вычислению указанной функции применительно к соответствующим элементам массивов-аргументов.
    При этом автоматически производятся все необходимые конверсии типа элементов,
    организуются максимально эффективные (для той или иной функции) циклы перебора элементов,
    анализируются случаи, когда к элементам возможен особо быстрый доступ, и т.д.
    То есть метод asFuncArray берет на себя всю черновую работу по применению операции к отдельным элементам.
    Пример: если вызвать asFuncArray для стандартной функции MIN, вычисляющей минимум из нескольких
    вещественных чисел, но при этом передать в asFuncArray упакованные битовые массивы,
    метод asFuncArray "сообразит", что в данной ситуации можно использовать параллельную побитовую операцию
    "логическое И".
    Система таких оптимизаций чрезвычайно обширна, но совершенно "скрыта" от прикладного программиста.
    В частности, в этом блоке реализован полный набор логических побитовых операций для битов,
    упакованных в 64-битовые long-значения, с максимальной возможной для Java оптимизацией:
    это ядро будущей битовой морфологии.</dd>
<dd><b>Параллельное копирование в контексте.</b> В силу ленивой архитектуры большинства
    новых вычислений, реальный способ что-либо вычислить сводится к копированию ленивого массива
    в свежесозданный новый массив. Реализован универсальный метод для такого копирования,
    разбивающий массив на части, чтобы задействовать несколько ядер процессора,
    и взаимодействующий с контекстами, чтобы показывать проценты исполнения, останавливаться и т.д.</dd>
<dd><b>Дополнительные прикладные функции.</b> Не все операции можно свести к построению
    ленивого функционального массива и последующему копированию (см. предыдущие пункты).
    Наиболее важные из таких операций реализованы отдельными процедурами.
    А именно: asShifted (псевдоциклический сдвиг массива на сколько-то элементов,
    "сердце" любых апертурных фильтров), asConcatenation (цепочка линейных массивов
    виртуально сцепляются и "выглядит" как единый массив),
    реализованные ранее функции суммирования элементов и поиска минимума и максимума.
    Позднее (в апреле 2008) была добавлена функция расчета гистограммы по массиву histogramOf
    (работа на 2 дня, специально не отраженная в отчете).
    Этот блок продолжает немного расширяться и сейчас.</dd>
<dd><b>Исчерпывающие тесты всех новых функций</b>
    со случайным перебором всех мыслимых комбинаций параметров.</dd>
<dd><b>Первые демонстрационные плагины и таблицы SIMAGIS, использующие перечисленные возможности.</b>
    В частности, реализована полная поэлементная арифметика над изображениями, а также,
    на уровне демонстрации &mdash; первые работающие дилатация (как поэлементный максимум
    из нескольких циклически сдвинутых массивов), эрозия и линейное сглаживание
    (поэлементной суммирование сдвинутых массивов).</dd>

<dt>Сроки реализации</dt>
<dd>С 10 июня по 31 июля 2007.</dd>
</dl>


<h3>Морфологические фильтры</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Базовый набор морфологический операций над AlgART-матрицами.</dd>

<dt>Размещение</dt>
<dd>Пакеты net.algart.arrays.morphology, net.algart.math.patterns.</dd>

<dt>Основные компоненты</dt>
<dd><b>Шаблоны</b>: новый пакет, реализующий понятие Pattern (множество целых точек в n-мерном пространстве).
    Пакет предлагает большое разнообразие шаблонов и крайне нетривиальные алгоритмы разложения
    шаблонов в суммы Минковского и теоретико-множественные объединения,
    позволяющие оптимизировать дилатацию и эрозию.</dd>
<dd><b>Собственно морфология</b>: пакет, умеющий выполнять дилатацию и эрозию n-мерной матрицы
    на произвольный шаблон, а также другие операции, тривиально выражаемые через дилатацию и эрозию.
    Для большинства сложных шаблонов, благодаря новым алгоритмам, новые морфологические операции
    "обогнали" реализации 2000 года во много раз, иногда даже в сотни раз.
    Морфология представлена в виде абстрактного интерфейса и конкретной реализации:
    в будущем тот же интерфейс можно будет реализовать иначе, например, в виде ранговой морфологии.</dd>
<dd><b>Класс Image2D:</b> практически полная замена AImage, также умеющий размещаться в ячейках SIMAGIS.
    (Разработано Алексеем.)
    Этот класс, в отличие от своего предшественника Matrix2D, поддерживает цвет RGB
    и не требует от плагинов "ничего знать" о модулях SIMAGIS.
    Кроме того, при необходимости Image2D "прозрачно" для разработчика таблицы
    конвертируется в старый AImage и обратно. С этого момент стало возможным
    свободно "смешивать" в таблицах старые и новые функции.
    Кроме того, для Image2D написан первый редактор (Андрей Пятков),
    позволяющий нормальной визуализировать новые изображения без конверсии в AImage.
    Фактически, это начало "эры новых библиотек" в SIMAGIS.
    Отныне их применение сдерживается лишь недостатком функций,
    и в этом случае приходится вставлять старые функции, помня об их меньшей эффективности,
    ограничениях по памяти и затратах на автоконверсию AImage &lt;-&gt; Image2D.</dd>
<dd><b>Демонстрационный плагин и таблицы SIMAGIS, реализующие базовую морфологию.</b>
    Позволяет проверить морфологию и освоиться с новыми возможностями,
    но пока "сыроват" для прямой вставки с базовую библиотеку.</dd>

<dt>Сроки реализации</dt>
<dd>С 1 августа по 3 октября 2007.</dd>
</dl>


<h3>Учебник по библиотекам</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Вводный курс по библиотекам на русском языке, рассчитанный на обучение новичков.</dd>

<dt>Размещение</dt>
<dd>На сайте AlgART: <a href="http://algart.net/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html"
>http://algart.net/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html</a>.</dd>

<dt>Основные компоненты</dt>
<dd>Пока написаны Введение и Часть I (см. учебник).
    В будущих частях предполагается подробно рассмотреть "пластику" работы с ленивыми массивами
    (asFuncArray/asFuncMatrix)
    и практику "правильного" написания прикладных алгоритмов уровня морфологии.</dd>

<dt>Сроки реализации</dt>
<dd>С 8 октября по 28 октября 2007.</dd>
</dl>


<h3>Ленивая заливка больших массивов</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Возможность создать копию большого AlgART-массива, размещенного в дисковом файле,
    "ленивым" образом, т.е. без фактического копирования.</dd>

<dt>Размещение</dt>
<dd>Пакет net.algart.arrays.</dd>

<dt>Основные компоненты</dt>
<dd><b>Метод newLazyCopy</b> для дисковой модели памяти.
    В отличие от обычного копирования, в случае дисковой модели этот метод лишь
    создает новый файл, но не выполняет фактического копирования.
    Вместо этого, подсистема, реализующая дисковую модель, запоминает, что при первом обращении
    к элементам их следует брать из другого, исходного AlgART-массива, и лишь
    при фактическом изменении данных реально записывать изменившиеся кластеры на диск.
    Это необходимо в любом редакторе, оперирующем многогигабайтными картинками:
    иначе любая попытка отредактировать копию изображения привела бы к "умиранию" пользовательского
    интерфейса вплоть до полного копирования файла.</dd>

<dt>Сроки реализации</dt>
<dd>С 14 декабря по 29 декабря 2007.</dd>
</dl>


<h3>Тестирование и отладка ядра библиотек на 4-ядерных компьютерах</h3>

<p>(По идее, это блок должен был быть часть разработки системного и прикладного ядра,
но тогда у меня не было мощного многоядерного компьютера, и многие ошибки остались незамеченными.)</p>

<dl>
<dt>Краткая характиристика</dt>
<dd>Отладка и реальное задействование многоядерной архитектуры.</dd>

<dt>Размещение</dt>
<dd>Пакет net.algart.arrays.</dd>

<dt>Основные компоненты</dt>
<dd>В основном речь идет об отладке обнаруженных ошибок. Наиболее серьезные переделки потребовались
    в связи с многоядерностью. Реализация 2007 года работала корректно, но чересчур "перестраховывалась"
    с синхронизацией, в результате чего в большинстве алгоритмов фактически работал максимум один
    процессор.</dd>

<dt>Сроки реализации</dt>
<dd>С 9 января по 8 февраля 2008.</dd>
</dl>


<h3>Плагины SIMAGIS для базовых операций и морфологии</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Демонстрационные плагины для поэлементной обработки и морфологических операций
    заменены окончательными, библиотечными плагинами, работающими с Image2D и
    пригодными для использования в прикладных таблицах.</dd>

<dt>Размещение</dt>
<dd>Пакет com.simagis.p3.images.</dd>

<dt>Основные компоненты</dt>
<dd><b>Плагин Functions:</b> все мыслимые поэлементные операции над двумя изображениями,
    от суммирования до наложения маски.</dd>
<dd><b>Плагин Conversions:</b> простейшие операции выделения компонент R, G, B, I (grayscale)
    и сборки изображения Image2D из компонент. Также сюда входит операция пороговой сегментации
    (конверсия в бит); все прочие варианты смены разрядности (бит в байт, байт в double и т.п.)
    обеспечиваются тривиальной функцией плагина Functions.</dd>
<dd><b>Плагин SimpleMorphology:</b> основные морфологические операций.</dd>
<dd><b>Демонстрационные таблицы</b> для этих плагинов (templates/test, категория AlgART).
    Такие таблицы создавались и к последующим плагинам; это далее не оговаривается.</dd>

<dt>Сроки реализации</dt>
<dd>С 14 февраля по 21 февраля 2008.</dd>
</dl>


<h3>Операция выделения подматрицы (crop)</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Функция, позволяющая в произвольной матрице виртуально выделить прямоугольный фрагмент.
    Если фрагмент выходит за пределы матрицы, "лишние" элементы можно дополнить константой.</dd>

<dt>Размещение</dt>
<dd>Пакет net.algart.arrays.</dd>

<dt>Основные компоненты</dt>
<dd><b>Mетоды subMatrix и sumMatr в интерфейсе Matrix.</b> Реализация оказалась
    достаточно сложной из-за многомерности и требования виртуальности: подматрица
    выделяется "лениво", без фактических вычислений, но последующие обращения к ее элементам
    транслируются в обращения к соответствующим элементам исходной матрицы.
    С этого момента стало возможным &mdash; и было сделано &mdash; во всех алгоритмах выбрать
    не псевдоциклическое (тороидальное) продолжение матриц, но дополнение произвольной константой.
    (Для этого достаточно заменить матрицу ее "подматрицей" большего размера: так как операция "ленивая",
    это не требует ни дополнительной памяти, ни времени.)
    Это важно, например, в некоторых применениях битовой морфологии или в скелетизации.</dd>
<dd><b>Плагин Geometry</b>, позволяющий извлекать или заливать некоторым цветом прямоугольный фрагмент.
    В будущем сюда будут добавлены другие геометрические операции, такие как поворот или сжатие/растяжение.</dd>

<dt>Сроки реализации</dt>
<dd>С 22 февраля по 29 февраля 2008.</dd>
</dl>


<h3>Скелетизация и общие итеративные алгоритмы</h3>

<dl>
<dt>Краткая характиристика</dt>
<dd>Операции построения скелета на битовых изображениях,
    а также итеративные эрозия и открытие (гранулометрия).</dd>


<dt>Размещение</dt>
<dd>Пакеты net.algart.arrays и net.algart.arrays.bitgeom.skeletons.
(25 августа 2008 второй пакет переименован в net.algart.arrays.bitskeletons.)</dd>

<dt>Основные компоненты</dt>
<dd><b>Архитектура IterativeMatrixProcessor.</b> Новый универсальый интерфейс,
    позволяющий удобно описывать итеративные алгоритмы обработки матрицы.
    Стандартная универсальная реализация "берет на себя" заботу о контекстах:
    вычисление и визуализацию процента готовности, а также позволяет "сцеплять"
    несколько последовательных итеративных алгоритмов в один.
    Все скелеты являются частными случаями этого интерфейса.</dd>
<dd><b>4 реализации алгоритмов скелетизация.</b> Две из них повторяют то,
    что было в библиотеках 2000 года, но благодаря многоядерности и
    удалению лишних операций (были и такие, увы нам) работают почти в 10 раз быстрее.
    Два новых алгоритма позволяют строить (с той же скоростью)
    значительно более качественные скелеты, лишенные недостатков типа "толстых узлов",
    которыми страдали прежние скелеты. Предполагается повсеместно отказаться
    от старой скелетизации в пользу новой.</dd>
<dd><b>Итеративные эрозия и открытие</b> на увеличивающийся шаблон.
    (Ранее это называлось эрозионным и гранулометрическим преобразованиями.)
    В случае непрямоугольного шаблона новые алгоритмы работают во много раз быстрее старых
    (для открытия возможно и в сотни раз).</dd>
<dd><b>Полный набор морфологических операций.</b> Теперь реализованы не только базовые,
    но практически все морфологические операции, когда-либо применявшиеся в SIMAGIS:
    выметания, заполнения, поиски кратеров и долин, и т.д.
    Доказана теорема о маскированной дилатации-эрозии ("выметание"),
    проясняющая смысл этой операции: см. комментарии к морфологии в JavaDoc.</dd>
<dd><b>Новые плагин Skeletonization.</b> Также расширен плагин SimpleMorphology.</dd>

<dt>Сроки реализации</dt>
<dd>С 4 марта по 14 апреля 2008.</dd>
</dl>

</body>
</html>