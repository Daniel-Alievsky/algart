<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractUniformGridPattern
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractUniformGridPattern";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/AbstractUniformGridPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractUniformGridPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_net.algart.math.patterns.AbstractPattern">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.math.patterns</FONT>
<BR>
Class AbstractUniformGridPattern</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">net.algart.math.patterns.AbstractPattern</A>
      <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.math.patterns.AbstractUniformGridPattern</STRONG>
</PRE>
<DL>
<DT><STRONG>All Implemented Interfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>, <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>AbstractUniformGridPattern</STRONG>
extends <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A>
implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></PRE>

<P>
<p>A skeletal implementation of the <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface to minimize
 the effort required to implement this interface.</p>

 <p>All non-abstract methods are completely implemented here and may be not overridden in subclasses.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.math.patterns.AbstractPattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from class net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount">dimCount</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.math.patterns.Pattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from interface net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE">MAX_COORDINATE</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Constructor Summary table, listing constructors, and an explanation">
<CAPTION CLASS="TableCaption">
Constructor Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Constructor and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#AbstractUniformGridPattern(net.algart.math.Point, double[], boolean)">AbstractUniformGridPattern</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;originOfGrid,
                           double[]&nbsp;stepsOfGrid,
                           boolean&nbsp;trivialUnionDecomposition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a uniform grid pattern with the given origin and steps of the grid.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation uses a common algorithm that usually provide good results.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#carcass()">carcass</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TODO!! - that it checks isActuallyRectangular()
 This method is fully implemented in this class and usually should not be overridden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#coordRange(int)">coordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexArea()">gridIndexArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>AbstractPattern.dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexes()">gridIndexes</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of all <i>grid indexes</i> <i>i</i><sub><i>j</i></sub> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexMax()">gridIndexMax</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>AbstractPattern.dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexMin()">gridIndexMin</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>AbstractPattern.dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexPattern()">gridIndexPattern</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()"><CODE>ordinary</CODE></A> integer pattern with the same set of <i>grid indexes</i>
 <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup> as this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)">gridIndexRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal <i>grid index</i> <i>i</i><sub><i>j</i></sub>
 among all points of this pattern
 for the specified coordinate index <i>j</i>==<tt>coordIndex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridToString()">gridToString</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns
 <tt><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A>.size()&gt;1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isActuallyRectangular()">isActuallyRectangular</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt>true</tt> if and only if
 <tt><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()"><CODE>pointCount()</CODE></A>=</tt><i>r</i><sub>0</sub><i>r</i><sub>1</sub>...<tt>&lt;Long.MAX_VALUE</tt>,
 where <i>r<sub>i</sub></i><tt>=<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(<i>i</i>)</CODE></A>.<A HREF="../../../../net/algart/math/IRange.html#size()"><CODE>size()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isAllowedGridIndex(net.algart.math.IPoint)">isAllowedGridIndex</A></STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;gridIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isAllowedGridIndexRange(net.algart.math.IRange)">isAllowedGridIndexRange</A></STRONG>(<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A>&nbsp;gridIndexRange)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isOrdinary()">isOrdinary</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this uniform-grid pattern is an <i>ordinary integer pattern</i>,
 i&#46;e&#46; if the grid origin <b>o</b> is the origin of coordinates (0,0,...,0)
 and all grid steps <i>d</i><sub><i>j</i></sub> are 1.0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isSurelyInteger()">isSurelyInteger</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and checks, whether all returned points are integer,
 i&#46;e&#46; <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>Point.isInteger()</CODE></A> method returns <tt>true</tt> for all elements the returned set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#lowerSurface(int)">lowerSurface</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>lower boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the backward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#maxBound(int)">maxBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TODO!! - write that it checks isActuallyRectangular()
 This method is fully implemented in this class and usually should not be overridden.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minBound(int)">minBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop on all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method in both patterns
 and always returns the <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>simple pattern</CODE></A>
 consisting of sums of all point pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt>Collections.&lt;Pattern&gt;singletonList(thisInstance)</tt>
 for non-rectangular patterns or a good decomposition if <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isActuallyRectangular()"><CODE>isActuallyRectangular()</CODE></A> method
 returns <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop on all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A>
 method in both patterns
 and always returns the <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>simple pattern</CODE></A>
 consisting of sums of all point pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#multiply(double)">multiply</A></STRONG>(double&nbsp;multiplier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation creates Java array <tt>double[]</tt> by the call
 "<nobr><tt>a = new double[<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount"><CODE>AbstractPattern.dimCount</CODE></A>]</tt></nobr>", fills all its elements by
 <tt>multiplier</tt> argument and then calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#scale(double...)"><CODE>scale(a)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#originOfGrid()">originOfGrid</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns the grid origin, specified in the constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()">pointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of points in this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#points()">points</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the projection of this pattern along the given axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#round()">round</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()"><CODE>AbstractPattern.roundedPoints()</CODE></A> method and constructs a new integer pattern on the base
 of this set, like as it is performed in <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#roundedPoints()">roundedPoints</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and returns a new set, built from the returned set of
 real points by conversion of every point to an integer point via <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method,
 as written in
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>comments to this method in Pattern interface</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#scale(double...)">scale</A></STRONG>(double...&nbsp;multipliers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multipliers along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#shift(net.algart.math.Point)">shift</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, shifted by the argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#shiftGridIndexes(net.algart.math.IPoint)">shiftGridIndexes</A></STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns another uniform-grid pattern, identical to this one with the only difference, that
 the grid index
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 for each point #<i>k</i> of the result is shifted by the argument of this method via the call
 <b>i</b><sup>(<i>k</i>)</sup><tt>.<A HREF="../../../../net/algart/math/IPoint.html#add(net.algart.math.IPoint)"><CODE>add</CODE></A>(shift)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#stepOfGrid(int)">stepOfGrid</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the grid <i>step</i> <i>d</i><sub><i>j</i></sub> along the coordinate #<i>j</i> of this pattern
 along the coordinate #<i>j</i>=<tt>coordIndex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#stepsOfGrid()">stepsOfGrid</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns a new copy of Java array of grid steps, specified in the constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)">stepsOfGridEqual</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether the other uniform-grid pattern has the same grid steps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#surface()">surface</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set-theoretical union of all patterns, returned by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>UniformGridPattern.lowerSurface(int)</CODE></A>
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A> methods for all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#symmetric()">symmetric</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#upperSurface(int)">upperSurface</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>upper boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the forward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.algart.math.patterns.AbstractPattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#checkCoordIndex(int)">checkCoordIndex</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordArea()">coordArea</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordMax()">coordMax</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordMin()">coordMin</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()">dimCount</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isAllowedCoordRange(net.algart.math.Range)">isAllowedCoordRange</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isAllowedPoint(net.algart.math.Point)">isAllowedPoint</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isPointCountVeryLarge()">isPointCountVeryLarge</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelySinglePoint()">isSurelySinglePoint</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#largePointCount()">largePointCount</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedCoordArea()">roundedCoordArea</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedCoordRange(int)">roundedCoordRange</A>, <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#unionDecomposition(int)">unionDecomposition</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.algart.math.patterns.Pattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from interface net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()">coordArea</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()">coordMax</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()">coordMin</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()">dimCount</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">isSurelySinglePoint</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()">largePointCount</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()">roundedCoordArea</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)">roundedCoordRange</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)">unionDecomposition</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Constructor Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractUniformGridPattern(net.algart.math.Point, double[], boolean)"><!-- --></A><H3>
AbstractUniformGridPattern</H3>
<PRE>
protected <STRONG>AbstractUniformGridPattern</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;originOfGrid,
                                     double[]&nbsp;stepsOfGrid,
                                     boolean&nbsp;trivialUnionDecomposition)</PRE>
<DL>
<DD>Creates a uniform grid pattern with the given origin and steps of the grid.

 <p>The <tt>trivialUnionDecomposition</tt> determines behavior of
 <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#unionDecomposition(int)"><CODE>AbstractPattern.unionDecomposition(int)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#allUnionDecompositions(int)"><CODE>allUnionDecompositions(int)</CODE></A> methods.
 If it is <tt>false</tt>, they will perform some common algorithm
 suitable for most patterns, that have no good Minkowski decompositions (alike spheres).
 If it is <tt>true</tt>, they will return degenerated decomposition
 consisting of this pattern as the only element.
 You should use <tt>true</tt> argument in inheritors that have
 a good Minkowski decomposition.

 <p>The passed <tt>stepsOfGrid</tt> argument is cloned by this method: no references to it
 are maintained by the created pattern.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>originOfGrid</CODE> - the <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#originOfGrid()"><CODE>origin of the grid</CODE></A>.</DD><DD><CODE>stepsOfGrid</CODE> - the <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#stepsOfGrid()"><CODE>steps of the grid</CODE></A>.</DD><DD><CODE>trivialUnionDecomposition</CODE> - whether this pattern has the degenerated union decomposition.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>originOfGrid</tt> or <tt>stepsOfGrid</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>originOfGrid.<A HREF="../../../../net/algart/math/Point.html#coordCount()"><CODE>coordCount()</CODE></A>!=stepsOfGrid.length</tt>, or if one of the passed steps
                                  is zero (<tt>==0.0</tt>).</DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="originOfGrid()"><!-- --></A><H3>
originOfGrid</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>originOfGrid</STRONG>()</PRE>
<DL>
<DD>This implementation returns the grid origin, specified in the constructor.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()">originOfGrid</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the origin <b>o</b> of the uniform grid of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepsOfGrid()"><!-- --></A><H3>
stepsOfGrid</H3>
<PRE>
public double[] <STRONG>stepsOfGrid</STRONG>()</PRE>
<DL>
<DD>This implementation returns a new copy of Java array of grid steps, specified in the constructor.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()">stepsOfGrid</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an array containing all grid steps of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepOfGrid(int)"><!-- --></A><H3>
stepOfGrid</H3>
<PRE>
public double <STRONG>stepOfGrid</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns the grid <i>step</i> <i>d</i><sub><i>j</i></sub> along the coordinate #<i>j</i> of this pattern
 along the coordinate #<i>j</i>=<tt>coordIndex</tt>.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>UniformGridPattern.stepsOfGrid()</CODE></A>[coordIndex]</tt>, but works faster.

 <p>There is a guarantee, that this method always works very quickly
 (maximally <i>O</i>(<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)">stepOfGrid</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the grid step of this pattern along the specified coordinate axis.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)"><!-- --></A><H3>
stepsOfGridEqual</H3>
<PRE>
public boolean <STRONG>stepsOfGridEqual</STRONG>(<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A>&nbsp;pattern)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Indicates whether the other uniform-grid pattern has the same grid steps.
 In other words, returns <tt>true</tt> if and only if
 both patterns have the same dimension count (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>)
 and the corresponding grid steps <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid((k)</CODE></A> are equal for every <tt>k</tt>.

 <p>Note: this method does not compare the origin of grid.

 <p>Equality of grid steps is important, for example, while calculation of a Minkowski sum
 of this and another patterns by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A> method.
 If two uniform-grid patterns have identical grid steps, then a Minkowski sum of them
 can be also represented by uniform-grid pattern (with same grid steps).
 In other case, it is usually impossible &mdash; the Minkowski sum, returned by
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A>, will not implement <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)">stepsOfGridEqual</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pattern</CODE> - another uniform-grid pattern,
                the grid steps of which should be compared with grid steps of this one.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified pattern has the same steps of grid.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexes()"><!-- --></A><H3>
gridIndexes</H3>
<PRE>
public abstract java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt; <STRONG>gridIndexes</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns a set of all <i>grid indexes</i> <i>i</i><sub><i>j</i></sub> of this pattern.
 Namely, the elements of the returned set contain grid indexes
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 of all points <nobr><b>x</b><sup>(<i>k</i>)</sup> = (<i>x</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 of this pattern:
 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface must be
 immutable).

 <p>The returned set is always non-empty,
 and the number of its elements is always equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.
 This method surely fails (throws one of these exception), if the total number of points
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&gt;Integer.MAX_VALUE</tt>, because Java <tt>Set</tt> object
 cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.

 <p>For example, implementations of the <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>
 allow to successfully define a very large 3D parallelepiped
 <nobr><i>n</i> x <i>n</i> x <i>n</i></nobr>.
 Fur such pattern, this method will require a lot of memory
 for <i>n</i>=1000 and will fail (probably with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>)
 for <i>n</i>=2000 (2000<sup>3</sup>&gt;<tt>Integer.MAX_VALUE</tt>).

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>Note: if you do not really need to get a Java collection of all grid indexes,
 you can use <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>UniformGridPattern.gridIndexPattern()</CODE></A> method, which returns the same result in a form
 of another (integer) pattern. That method, unlike this one, never spends extreme amount of memory
 and time and has no risk to fail with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()">gridIndexes</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all grid indexes of this pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>UniformGridPattern.gridIndexPattern()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexRange(int)"><!-- --></A><H3>
gridIndexRange</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A> <STRONG>gridIndexRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns the minimal and maximal <i>grid index</i> <i>i</i><sub><i>j</i></sub>
 among all points of this pattern
 for the specified coordinate index <i>j</i>==<tt>coordIndex</tt>.
 The minimal grid index will be <tt>r.<A HREF="../../../../net/algart/math/IRange.html#min()"><CODE>min()</CODE></A></tt>,
 the maximal grid index will be <tt>r.<A HREF="../../../../net/algart/math/IRange.html#max()"><CODE>max()</CODE></A></tt>,
 where <tt>r</tt> is the result of this method.
 See the <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A> for more details.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>Moreover, all patterns, implemented in this package, have very quick implementations of this method
 (<i>O</i>(1) operations). Also, the implementations of this method in this package never throw exceptions.

 <p>It is theoretically possible, that in custom implementations of this interface
 (outside this package) this method will work slowly, up to <i>O</i>(<i>N</i>) operations,
 <i>N</i> is the number of points in this pattern.
 However, even in such implementations this method <i>must not</i> lead to
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>, like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)">gridIndexRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index <i>j</i> of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal grid index <i>i</i><sub><i>j</i></sub>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMin()"><CODE>UniformGridPattern.gridIndexMin()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMax()"><CODE>UniformGridPattern.gridIndexMax()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexArea()"><CODE>UniformGridPattern.gridIndexArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexArea()"><!-- --></A><H3>
gridIndexArea</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A> <STRONG>gridIndexArea</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>AbstractPattern.dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexArea()">gridIndexArea</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal coordinate for all space dimensions.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexMin()"><!-- --></A><H3>
gridIndexMin</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A> <STRONG>gridIndexMin</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>AbstractPattern.dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMin()">gridIndexMin</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>minimal grid index for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexMax()"><!-- --></A><H3>
gridIndexMax</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A> <STRONG>gridIndexMax</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>AbstractPattern.dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMax()">gridIndexMax</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>maximal grid index for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isOrdinary()"><!-- --></A><H3>
isOrdinary</H3>
<PRE>
public final boolean <STRONG>isOrdinary</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if and only if this uniform-grid pattern is an <i>ordinary integer pattern</i>,
 i&#46;e&#46; if the grid origin <b>o</b> is the origin of coordinates (0,0,...,0)
 and all grid steps <i>d</i><sub><i>j</i></sub> are 1.0.
 Equivalent to
 <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>UniformGridPattern.originOfGrid()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#isOrigin()"><CODE>isOrigin()</CODE></A>
 && <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange</CODE></A>(0)==1.0
 && <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange</CODE></A>(1)==1.0
 &&&nbsp;...</tt>
 Ordinary integer patterns are a simplest form of <i>integer</i> pattern:
 see comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface, section "Uniform-grid patterns".

 <p>There is a guarantee, that this method always works very quickly
 (maximally <i>O</i>(<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()">isOrdinary</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether the grid origin <b>o</b>=(0,0,...,0) and also all grid steps <i>d</i><sub><i>j</i></sub>=1.0.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isActuallyRectangular()"><!-- --></A><H3>
isActuallyRectangular</H3>
<PRE>
public boolean <STRONG>isActuallyRectangular</STRONG>()</PRE>
<DL>
<DD>This implementation returns <tt>true</tt> if and only if
 <tt><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()"><CODE>pointCount()</CODE></A>=</tt><i>r</i><sub>0</sub><i>r</i><sub>1</sub>...<tt>&lt;Long.MAX_VALUE</tt>,
 where <i>r<sub>i</sub></i><tt>=<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(<i>i</i>)</CODE></A>.<A HREF="../../../../net/algart/math/IRange.html#size()"><CODE>size()</CODE></A></tt>.

 <p>This method caches its results: the following calls will work faster.

 <p>This method does not provide correct result, if a pattern contains <tt>&ge;Long.MAX_VALUE</tt> points.

 <p>This method should be overridden for rectangular patterns, implementing <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 interface, or for patterns that surely are not rectangular.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isActuallyRectangular()">isActuallyRectangular</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this pattern is <i>n</i>-dimensional rectangular parallelepiped.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexPattern()"><!-- --></A><H3>
gridIndexPattern</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>gridIndexPattern</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns an <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()"><CODE>ordinary</CODE></A> integer pattern with the same set of <i>grid indexes</i>
 <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup> as this pattern.
 In other words, if this pattern is a set of points

 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>(<i>k</i>=0,1,...,<i>N</i>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>), then the returned pattern
 consists of points

 <blockquote>
 <i>y</i><sub>0</sub><sup>(<i>k</i>)</sup> = <tt>(double)</tt><i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><br>
 <i>y</i><sub>1</sub><sup>(<i>k</i>)</sup> = <tt>(double)</tt><i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><br>
 . . .<br>
 <i>y</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <tt>(double)</tt><i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>
 </blockquote>

 <p>Note: here is a guarantee, that all grid indexes <i>i</i><sub><i>j</i></sub> will be strictly
 represented by <tt>double</tt> type.
 Moreover, there is a guarantee that the returned pattern is correct, i.e. will be successfully built
 without a risk of <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.
 See the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>
 and the section "Grid index restrictions" in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface.

 <p>You can use this method to get a set of all grid indexes (integer values):
 it is enough to call <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> in the returned pattern.
 The results will be the same as the result of <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>UniformGridPattern.gridIndexes()</CODE></A> method.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>This method works quickly enough: in the worst case,
 it can require <i>O</i>(<i>N</i>) operations (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>).
 <!--
 It is really so in our implementation of DirectPointSetUniformGridPattern:
 we do not eliminate checking of all coordinates -->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()">gridIndexPattern</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an ordinary integer pattern, consisting of all grid indexes of this pattern (represented
         by <tt>double</tt> values).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>UniformGridPattern.gridIndexes()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="shiftGridIndexes(net.algart.math.IPoint)"><!-- --></A><H3>
shiftGridIndexes</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>shiftGridIndexes</STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;shift)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shiftGridIndexes(net.algart.math.IPoint)">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns another uniform-grid pattern, identical to this one with the only difference, that
 the grid index
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 for each point #<i>k</i> of the result is shifted by the argument of this method via the call
 <b>i</b><sup>(<i>k</i>)</sup><tt>.<A HREF="../../../../net/algart/math/IPoint.html#add(net.algart.math.IPoint)"><CODE>add</CODE></A>(shift)</tt>.

 In other words, if this pattern is a set of points

 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>(<i>k</i>=0,1,...,<i>N</i>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>), then the returned pattern
 has the same <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>grid oridin</CODE></A>, the same <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>grid steps</CODE></A>
 and consists of points

 <blockquote>
 <i>y</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>+<tt>shift.<A HREF="../../../../net/algart/math/IPoint.html#coord(int)"><CODE>coord</CODE></A>(0)</tt>)*<i>d</i><sub>0</sub><br>
 <i>y</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + (<i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>+<tt>shift.<A HREF="../../../../net/algart/math/IPoint.html#coord(int)"><CODE>coord</CODE></A>(1)</tt>)*<i>d</i><sub>1</sub><br>
 . . .<br>
 <i>y</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + (<i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>+<tt>shift.<A HREF="../../../../net/algart/math/IPoint.html#coord(int)"><CODE>coord</CODE></A>(<i>n</i>&minus;1)</tt>)*<i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all grid indexes via
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>UniformGridPattern.gridIndexes()</CODE></A> call, correcting them and forming a new pattern via
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#newUniformGridPattern(net.algart.math.Point, double[], java.util.Collection)"><CODE>Patterns.newUniformGridPattern(Point, double[], java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface,
 section "Coordinate restrictions", and in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>Note: the similar results can be got with help of <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shift(net.algart.math.Point)"><CODE>UniformGridPattern.shift(Point)</CODE></A> method
 with a corresponding floating-point shift. However, this method
 guarantees that the returned pattern has the same origin of the grid, but corrected <i>grid indexes</i>.
 Unlike this, a good implementation of <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shift(net.algart.math.Point)"><CODE>UniformGridPattern.shift(Point)</CODE></A> method just corrects the grid origin,
 but does not change grid indexes. This difference is important, if you are going to get
 the grid indexes from the shifted pattern via <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>UniformGridPattern.gridIndexPattern()</CODE></A> or <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>UniformGridPattern.gridIndexes()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shiftGridIndexes(net.algart.math.IPoint)">shiftGridIndexes</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift of the grid indexes.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="lowerSurface(int)"><!-- --></A><H3>
lowerSurface</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>lowerSurface</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns the <i>lower boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the backward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, the point
 <nobr><i>A</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 belongs to the returned pattern if and only if it belongs to this pattern and the point
 <nobr><i>B</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>&minus;<i>d</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 (corresponding to decreasing the <i>grid index</i> <i>i</i><sub><i>j</i></sub> by 1)
 does not belong to this pattern.

 <p>Please compare with <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#minBound(int)"><CODE>UniformGridPattern.minBound(int)</CODE></A> method. This method can return a pattern
 containing more points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#minBound(int)"><CODE>UniformGridPattern.minBound(int)</CODE></A>, in particular, if this pattern contains some "holes".</p>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>Note: if this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.
 However, this situation is possible only in custom implementation of this interface &mdash;
 all implementations, provided by this package, implement either <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 or <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)">lowerSurface</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lower boundary" of this pattern: new pattern consisting of all points of this pattern,
         which have no leftward neighbour along the given coordinate.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="upperSurface(int)"><!-- --></A><H3>
upperSurface</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>upperSurface</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns the <i>upper boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the forward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, the point
 <nobr><i>A</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 belongs to the returned pattern if and only if it belongs to this pattern and the point
 <nobr><i>B</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>+<i>d</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 (corresponding to increasing the <i>grid index</i> <i>i</i><sub><i>j</i></sub> by 1)
 does not belong to this pattern.

 <p>Please compare with <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)"><CODE>UniformGridPattern.maxBound(int)</CODE></A> method. This method can return a pattern
 containing more points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)"><CODE>UniformGridPattern.maxBound(int)</CODE></A>, in particular, if this pattern contains some "holes".</p>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>Note: if this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.
 However, this situation is possible only in custom implementation of this interface &mdash;
 all implementations, provided by this package, implement either <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 or <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)">upperSurface</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "upper boundary" of this pattern: new pattern consisting of all points of this pattern,
         which have no rightward neighbour along the given coordinate.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="surface()"><!-- --></A><H3>
surface</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>surface</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#surface()">UniformGridPattern</A></CODE></STRONG></DD>
<DD>Returns the set-theoretical union of all patterns, returned by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>UniformGridPattern.lowerSurface(int)</CODE></A>
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A> methods for all coordinates.
 In other words, the returned pattern contains full "boundary" of this pattern.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>Note: if this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.
 However, this situation is possible only in custom implementation of this interface &mdash;
 all implementations, provided by this package, implement either <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 or <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#surface()">surface</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the "boundary" of this pattern: new pattern consisting of all points of this pattern,
         which have no leftward or rightward neighbour along at least one coordinate.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pointCount()"><!-- --></A><H3>
pointCount</H3>
<PRE>
public abstract long <STRONG>pointCount</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the number of points in this pattern.
 This value is always positive (&gt;=1).
 If the number of points is greater than <tt>Long.MAX_VALUE</tt>, returns <tt>Long.MAX_VALUE</tt>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points (result of this method).
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then the result of this method is not greater than <tt>Integer.MAX_VALUE</tt>.

 <p>Note: if this method returns some value greater than <tt>Integer.MAX_VALUE</tt>,
 it means that you cannot use <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> methods,
 because Java <tt>Set</tt> object cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">pointCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()">pointCount</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>points</CODE></A> in this pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>Pattern.largePointCount()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>Pattern.isSurelySinglePoint()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="points()"><!-- --></A><H3>
points</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt; <STRONG>points</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">Pattern</A></CODE></STRONG></DD>
<DD>Returns a set of all points of this pattern.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of this interface must be
 immutable).

 <p>The returned set is always non-empty,
 and the number of its elements is always equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.
 This method surely fails (throws one of these exception), if the total number of points
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&gt;Integer.MAX_VALUE</tt>, because Java <tt>Set</tt> object
 cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.

 <p>For example, implementations of the <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>
 allow to successfully define a very large 3D parallelepiped
 <nobr><i>n</i> x <i>n</i> x <i>n</i></nobr>.
 Fur such pattern, this method will require a lot of memory
 for <i>n</i>=1000 and will fail (probably with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>)
 for <i>n</i>=2000 (2000<sup>3</sup>&gt;<tt>Integer.MAX_VALUE</tt>).

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>Note: this method works very quickly (<i>O</i>(1) operations) in <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">points</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()">points</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedPoints()"><!-- --></A><H3>
roundedPoints</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt; <STRONG>roundedPoints</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and returns a new set, built from the returned set of
 real points by conversion of every point to an integer point via <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method,
 as written in
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>comments to this method in Pattern interface</CODE></A>.
 Please override this method if there is more efficient way to get all rounded points.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()">roundedPoints</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()">roundedPoints</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern, rounded to the nearest integer points.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordRange(int)"><!-- --></A><H3>
coordRange</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A> <STRONG>coordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.
 The minimal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#min()"><CODE>min()</CODE></A></tt>,
 the maximal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#max()"><CODE>max()</CODE></A></tt>,
 where <tt>r</tt> is the result of this method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>Moreover, all patterns, implemented in this package, have very quick implementations of this method
 (<i>O</i>(1) operations). Also, the implementations of this method in this package never throw exceptions.

 <p>It is theoretically possible, that in custom implementations of this interface
 (outside this package) this method will work slowly, up to <i>O</i>(<i>N</i>) operations,
 <i>N</i> is the number of points in this pattern.
 However, even in such implementations this method <i>must not</i> lead to
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>, like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">coordRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)">coordRange</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)"><CODE>Pattern.roundedCoordRange(int)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>Pattern.coordMin()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>Pattern.coordMax()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyInteger()"><!-- --></A><H3>
isSurelyInteger</H3>
<PRE>
public boolean <STRONG>isSurelyInteger</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelyInteger()">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and checks, whether all returned points are integer,
 i&#46;e&#46; <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>Point.isInteger()</CODE></A> method returns <tt>true</tt> for all elements the returned set.
 If all points, returned by <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> call, are integer, this method returns <tt>true</tt>,
 in other case it returns <tt>false</tt>.

 <p>This method caches its results: the following calls will work faster.

 <p>Note: according the <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()"><CODE>comments to this method in Pattern interface</CODE></A>,
 such implementation is correct only if <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiDecomposition(int)"><CODE>AbstractPattern.minkowskiDecomposition(int)</CODE></A>,
 <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#unionDecomposition(int)"><CODE>AbstractPattern.unionDecomposition(int)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#allUnionDecompositions(int)"><CODE>AbstractPattern.allUnionDecompositions(int)</CODE></A> methods
 have default implementations (not overridden). If some of them are overridden and
 return some non-trivial results, this method <i>must</i> be also overridden.

 <p>Note: according the <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()"><CODE>comments to this method in Pattern interface</CODE></A>,
 this method <i>must</i> be overridden if the number of points can be very large and a call of
 <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method leads to a risk of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In particular, this method should be usually overridden in implementations of <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()">isSurelyInteger</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelyInteger()">isSurelyInteger</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this pattern assuredly contain only <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>integer</CODE></A> points.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="round()"><!-- --></A><H3>
round</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>round</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#round()">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()"><CODE>AbstractPattern.roundedPoints()</CODE></A> method and constructs a new integer pattern on the base
 of this set, like as it is performed in <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A> method.
 Please override this method if there is more efficient way to round this pattern,
 for example, if this pattern is already an integer one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#round()">round</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#round()">round</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the integer pattern, geometrically nearest to this one.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="projectionAlongAxis(int)"><!-- --></A><H3>
projectionAlongAxis</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>projectionAlongAxis</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the projection of this pattern along the given axis.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is less by 1, than in this one.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the projection of this pattern (its <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is equal to
         <tt>thisInstance.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>-1</tt>).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minBound(int)"><!-- --></A><H3>
minBound</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>minBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minBound(int)">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.
 Please override this method if there is more efficient way to find the result,
 for example, if this pattern is a rectangular one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">minBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#minBound(int)">minBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minBound(int)">minBound</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the minimal boundary of this pattern for the given axis.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)"><CODE>Pattern.maxBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxBound(int)"><!-- --></A><H3>
maxBound</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>maxBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#maxBound(int)">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>AbstractPattern.points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.
 Please override this method if there is more efficient way to find the result,
 for example, if this pattern is a rectangular one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">maxBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)">maxBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#maxBound(int)">maxBound</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal boundary of this pattern for the given axis.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)"><CODE>Pattern.minBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="carcass()"><!-- --></A><H3>
carcass</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>carcass</STRONG>()</PRE>
<DL>
<DD>//TODO!! - that it checks isActuallyRectangular()
 This method is fully implemented in this class and usually should not be overridden.
 If you override it, you must override <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#maxCarcassMultiplier()"><CODE>maxCarcassMultiplier()</CODE></A> also,
 because that method returns the private field calculated by this one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">carcass</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#carcass()">carcass</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#carcass()">carcass</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the <i>carcass</i> of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxCarcassMultiplier()"><!-- --></A><H3>
maxCarcassMultiplier</H3>
<PRE>
public int <STRONG>maxCarcassMultiplier</STRONG>()</PRE>
<DL>
<DD>//TODO!! - write that it checks isActuallyRectangular()
 This method is fully implemented in this class and usually should not be overridden.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal multiplier, for which the calculation of the Minkowski multiple can be optimized
         by using the <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#carcass()"><CODE>carcass</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shift(net.algart.math.Point)"><!-- --></A><H3>
shift</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>shift</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, shifted by the argument.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call <tt>point.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(shift)</tt>.

 <!--Repeat.SectionStart simple_corrections_features-->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.SectionEnd simple_corrections_features-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>However, <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> is impossible in many important cases, when
 this pattern is an <i>integer</i> pattern and each coordinate
 <nobr><i>X</i><sub><i>j</i></sub>=<tt>shift.<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(</tt><i>j</i><tt>)</tt></nobr>
 of the argument is equal to &minus;<i>x</i><sub><i>j</i></sub> for some some point
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 of this pattern.
 In particular, you can use this method for <i>integer</i> patterns without a risk of
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> in the following situations:
 <ul>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>p.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>, where <tt>p</tt> is
 some of the <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points</CODE></A> if this integer pattern.</li>
 </ul>
 <p>See more details in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", the theorem II.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">shift</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shift(net.algart.math.Point)">shift</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#shift(net.algart.math.Point)">shift</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="symmetric()"><!-- --></A><H3>
symmetric</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>symmetric</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#symmetric()">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.
 There are no reasons to override this method usually.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()">symmetric</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#symmetric()">symmetric</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#symmetric()">symmetric</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the symmetric pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="multiply(double)"><!-- --></A><H3>
multiply</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>multiply</STRONG>(double&nbsp;multiplier)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)">AbstractPattern</A></CODE></STRONG></DD>
<DD>This implementation creates Java array <tt>double[]</tt> by the call
 "<nobr><tt>a = new double[<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount"><CODE>AbstractPattern.dimCount</CODE></A>]</tt></nobr>", fills all its elements by
 <tt>multiplier</tt> argument and then calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#scale(double...)"><CODE>scale(a)</CODE></A>.
 There are no reasons to override this method usually.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)">multiply</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#multiply(double)">multiply</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)">multiply</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multiplier</CODE> - the scale along all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>Pattern.scale(double...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="scale(double...)"><!-- --></A><H3>
scale</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>scale</STRONG>(double...&nbsp;multipliers)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, scaled by the specified multipliers along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#scale(double...)"><CODE>scale</CODE></A>(multipliers)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large multipliers).
 However, such failure is obviously impossible, if all multipliers are
 in range <tt>-1.0&lt;=multipliers[k]&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">scale</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#scale(double...)">scale</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#scale(double...)">scale</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multipliers</CODE> - the scales along coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>Pattern.multiply(double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiAdd(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiAdd</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiAdd</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</PRE>
<DL>
<DD>This implementation is based on the loop on all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method in both patterns
 and always returns the <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>simple pattern</CODE></A>
 consisting of sums of all point pairs.
 This algorithm may be very slow for large patterns
 (<i>O</i>(<i>NM</i>) operations, <i>N</i>=<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()"><CODE>pointCount()</CODE></A>, <i>M</i>=added.<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and does not work at all if the number of resulting points is greater than <tt>Integer.MAX_VALUE</tt>.
 Please override this method if there is better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>added</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the Minkowski sum of this and another patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the numbers of space dimensions of both patterns are different.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiSubtract(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiSubtract(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiSubtract</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiSubtract</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</PRE>
<DL>
<DD>This implementation is based on the loop on all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A>
 method in both patterns
 and always returns the <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>simple pattern</CODE></A>
 consisting of sums of all point pairs.
 This algorithm may be very slow for large patterns
 (<i>O</i>(<i>NM</i>) operations, <i>N</i>=<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()"><CODE>pointCount()</CODE></A>, <i>M</i>=added.<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and does not work at all if the number of resulting points is greater than <tt>Integer.MAX_VALUE</tt>.
 Please override this method if there is better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>subtracted</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the erosion of this pattern by the specified pattern
         or <tt>null</tt> if this erosion is the empty set.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the numbers of space dimensions of both patterns are different.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiDecomposition(int)"><!-- --></A><H3>
minkowskiDecomposition</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>minkowskiDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>This implementation returns <tt>Collections.&lt;Pattern&gt;singletonList(thisInstance)</tt>
 for non-rectangular patterns or a good decomposition if <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#isActuallyRectangular()"><CODE>isActuallyRectangular()</CODE></A> method
 returns <tt>true</tt>.
 This method caches its results for several little values of the argument:
 the following calls will work faster.
 Please override this method if there is better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method does not try to decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.
                          In particular, if the minkowski sum of several patterns containing
                          less than <tt>minimalPointCount</tt> points, this method should return
                          this sum in the resulting list instead of its summands.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the decomposition of this pattern to Minkowski sum.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hasMinkowskiDecomposition()"><!-- --></A><H3>
hasMinkowskiDecomposition</H3>
<PRE>
public boolean <STRONG>hasMinkowskiDecomposition</STRONG>()</PRE>
<DL>
<DD>This implementation returns
 <tt><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A>.size()&gt;1</tt>.
 Please override this method if <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(int)</CODE></A> method
 works slowly and it's possible to know, whether the pattern has Minkowski decomposition, much faster.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the Minkowski decomposition contains 2 or more elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="allUnionDecompositions(int)"><!-- --></A><H3>
allUnionDecompositions</H3>
<PRE>
public java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt; <STRONG>allUnionDecompositions</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>This implementation uses a common algorithm that usually provide good results.
 This method caches its results for several little values of the argument:
 the following calls will work faster.
 Please override this method if the better implementation is known.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></CODE> in class <CODE><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - the minimal number of points in every pattern in all resulting decompositions:
                          all pattern containing less points should be joined into one element
                          of the resulting list.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>several good variants of decomposition of this pattern to the union of patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isAllowedGridIndex(net.algart.math.IPoint)"><!-- --></A><H3>
isAllowedGridIndex</H3>
<PRE>
public static boolean <STRONG>isAllowedGridIndex</STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;gridIndex)</PRE>
<HR>

<A NAME="isAllowedGridIndexRange(net.algart.math.IRange)"><!-- --></A><H3>
isAllowedGridIndexRange</H3>
<PRE>
public static boolean <STRONG>isAllowedGridIndexRange</STRONG>(<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A>&nbsp;gridIndexRange)</PRE>
<HR>

<A NAME="gridToString()"><!-- --></A><H3>
gridToString</H3>
<PRE>
protected java.lang.String <STRONG>gridToString</STRONG>()</PRE>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/AbstractUniformGridPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractUniformGridPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_net.algart.math.patterns.AbstractPattern">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
