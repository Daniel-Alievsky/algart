package net.algart.logging;

import java.util.Vector;

/**
 * <p><i>Logger</i>: a tool allowing algorithms to indicate their execution
 * or log some information messages.</p>
 *
 * <p>This <tt>Logger</tt> class is an analog of <tt>java.util.logging</tt> package.
 * The main differences are the following.</p>
 * <ol>
 * <li><tt>Logger</tt> is more simple and contains functions usually necessary while programming algorithms.</li>
 *
 * <li><tt>Logger</tt> is oriented to both functions:<ul>
 *     <li>logging messages (alike <tt>java.util.logging</tt>),</li>
 *     <li>indicating the progress of algorithm execution (showing percent of calculations,
 *     current iteration number, elapsed or estimated time, etc.)</li>
 * </ul></li>
 *
 * <li><tt>Logger</tt> allows any objects as messages (not only <tt>String</tt>).</li>
 *
 * <li>More important messages correspond to <b>less integer levels</b> here.
 * (The <tt>java.util.logging</tt> package, vice versa, supposes that more important messages
 * have greater integer levels.)</li>
 *
 * <li>Message levels may be any integer values, in addition to predefined constancts
 * {@link #MAJOR}, {@link #INFO}, {@link #MINOR}, {@link #UNIMPORTANT}.
 * (Standard <tt>java.util.logging</tt> package requires subclassing <tt>java.util.logging.Level</tt>,
 * if the predefined set of levels is not enough.)</li>
 *
 * <li>This package does not contain any non-trivial implementation of logging mechanism.
 * To perform logging (at files, console, etc.), you need to implement {@link Logger.Handler}
 * interface. For example, you may pass the messages to the standard <tt>java.util.logging.Logger</tt>.</li>
 *
 * <li><tt>Logger</tt> is not thread-safe (see below).</li>

 * <li><tt>Logger</tt> works under JDK 1.1+.</li>
 * </ol>
 *
 * <p><tt>Logger</tt> passes all messages to one or several <i>handlers</i>,
 * that implement {@link Logger.Handler} interface and should output the information
 * to some device (console, file, application status line).</p>
 *
 * <p>This class is not final and may be extended to provide additional
 * information about program execution (via additional fields and access methods).</p>
 *
 * <p>This class does not perform synchronization and <b>is not thread-safe</b>.
 * So, you should not use the same <tt>Logger</tt> instance in several threads:
 * you need to use a separate {@link #cloneLogger() clones} in each thread.
 * An exception: the set of {@link Logger.Handler handlers} is synchronized and
 * may be safely accessed from different threads.</p>
 *
 * <p>However, the {@link Logger.Handler handlers}, wich perform actual logging, are usually
 * shared between different threads and <b>must</b> be thread-safe.</p>
 *
 * @author Daniel Alievsky
 * @version 1.0
 * @since JDK 1.1
 */
public class Logger implements Log, Cloneable {
    private static Logger globalLogger = new Logger().addHandler(new BufferedConsole());
    private static Logger globalProgress = new Logger();

    /**
     * <p><i>Publishing Handler</i>: an interface that should actually perform
     * showing or logging the messages, passed to {@link #log(int, Object, boolean)} method.</p>
     *
     * <p>Publishing handlers are usually shared between different threads.
     * So, implementations of this interface <b>must</b> be made thread-safe
     * with help of necessary synchronization.</p>
     */
    public interface Handler {
        /**
         * Perform actual showing or logging the messages, passed to
         * {@link Logger#log(int, Object, boolean)} method.
         *
         * @param logger       the logger that calls the handler.
         * @param messageLevel the value of <tt>messageLevel</tt> argument of
         * {@link Logger#log(int, Object, boolean)} method.
         * @param message      the value of <tt>message</tt> argument of
         * {@link Logger#log(int, Object, boolean)} method.
         */
        public void publish(Logger logger, int messageLevel, Object message);

        /**
         * Flush any buffered output. This method is called by {@link Logger#flush()} method.
         * This method is never if all buffered output is already flushed (for example,
         * if you call {@link Logger#flush()} twice).
         *
         * @param logger     the logger that calls the handler.
         */
        public void flush(Logger logger);
    }

    /**
     * <p>This interface may be used for showing progress bar in an application.
     * To do this, an algorithm should use some logger, created by GUI application,
     * and messages, passed to this logger, should implement this interface.</p>
     */
    public interface MessagePercents {
        /**
         * Returns the estimated number of percents of algorithm execution.
         *
         * @return the estimated percents of execution (from <tt>0.0</tt> to <tt>100.0</tt>).
         */
        public double getPercent();
    }

    private boolean immutable = false;
    private int requiredLevel = MINOR;
    private Class sourceClass = null;
    private String sourceMethod = null;
    private Object sourceInstance = null;
    private Object sourceContext = null;
    private Vector handlers = new Vector(4); // built-in Vector synchronization is not important here
    private int lastMessageLevel = ANY;
    private Object lastMessage = null;
    private boolean dirty = false;
    private Logger parent = null;

    /**
     * Creates new logger. New created logger does not contain any {@link #addHandler(Handler)
     * publishing handlers}; so, logging methods do nothing.
     */
    public Logger() {
    }

    public final void logMajor(Object message) {
        log(MAJOR, message, false);
    }

    public final void log(Object message) {
        log(INFO, message, false);
    }

    public final void logMinor(Object message) {
        log(MINOR, message, false);
    }

    public final void logMinor(Object message, boolean flush) {
        log(MINOR, message, flush);
    }

    public final void log(int messageLevel, Object message) {
        log(messageLevel, message, false);
    }

    public void log(int messageLevel, Object message, boolean flush) {
        if (message == null)
            throw new NullPointerException("Null message argument");
        lastMessageLevel = messageLevel;
        lastMessage = message;
        if (messageLevel <= requiredLevel) {
            for (Logger lg = this; lg != null; lg = lg.parent) {
                for (int k = 0, n = lg.handlers.size(); k < n; k++) {
                    lg.dirty = true;
                    ((Handler)lg.handlers.elementAt(k)).publish(this, messageLevel, message);
                }
            }
        }
        if (flush || messageLevel <= INFO)
            flush();
    }

    public void flush() {
        for (Logger lg = this; lg != null; lg = lg.parent) {
            if (lg.dirty) {
                for (int k = 0, n = lg.handlers.size(); k < n; k++) {
                    ((Handler)lg.handlers.elementAt(k)).flush(this);
                }
                lg.dirty = false;
            }
        }
    }

    public int getLastMessageLevel() {
        return lastMessageLevel;
    }

    /**
     * Returns last message passed to one of <tt>log</tt> methods, or <tt>null</tt>
     * if these methods were never called yet.
     *
     * @return last message passed to one of <tt>log</tt> methods.
     */
    public Object getLastMessage() {
        return lastMessage;
    }

    /**
     * Sets the <i>maximal allowed message level</i>. The basic
     * {@link #log(int, Object, boolean) log(messageLevel, message)}
     * method will ignore a message if the passed
     * <tt>messageLevel</tt> is greater than the maximal allowed level.
     *
     * <p>By default, this level is {@link #MINOR}.
     *
     * @param value new maximal allowed message level.
     * @return      a reference to this logger.
     * @see #getRequiredLevel()
     */
    public final Logger setRequiredLevel(int value) {
        if (isImmutable())
            throw new IllegalStateException("Cannot set required level: "
                + "modifications of global loggers were disabled");
        this.requiredLevel = value;
        return this;
    }

    /**
     * Returns the current <i>maximal allowed message level</i>.
     * The basic {@link #log(int, Object, boolean) log(messageLevel, message)}
     * method will ignore a message if the passed
     * <tt>messageLevel</tt> is greater than the maximal allowed level.
     *
     * <p>By default, this level is {@link #MINOR}.
     *
     * @return the current maximal allowed message level.
     * @see #setRequiredLevel(int)
     */
    public final int getRequiredLevel() {
        return this.requiredLevel;
    }

    /**
     * Sets the <i>current class</i>: usually a Java class that contains a method
     * which calls this logger.
     *
     * <p>Handlers, which perform output of the message, may retrive
     * the current class via {@link #getSourceClass()} method of the logger
     * passed to their {@link Handler#publish(Logger, int, Object)} method.
     *
     * <p>Please see an example of setting a class in the comments to {@link #cloneLogger()} method.
     *
     * <p>Current class may be <tt>null</tt>: it is the default value.
     *
     * @param thisClass new current executed class.
     * @return          a reference to this logger.
     * @see #getSourceClass()
     */
    public final Logger setSourceClass(Class thisClass) {
        if (isImmutable())
            throw new IllegalStateException("Cannot set source class: "
                + "modifications of global loggers were disabled");
        this.sourceClass = thisClass;
        return this;
    }

    /**
     * Returns the current executed class of the logger.
     *
     * @return the current executed class.
     * @see #setSourceClass(Class)
     */
    public final Class getSourceClass() {
        return this.sourceClass;
    }

    /**
     * Sets the <i>current method</i>: usually a name of Java method
     * which calls this logger.
     *
     * <p>Handlers, which perform output of the message, may retrive
     * the current method via {@link #getSourceMethod()} method of the logger
     * passed to their {@link Handler#publish(Logger, int, Object)} method.
     *
     * <p>Please see an example of setting a class in the comments to {@link #cloneLogger()} method.
     *
     * <p>Current method may be <tt>null</tt>: it is the default value.
     *
     * @param methodName new current executed method.
     * @return           a reference to this logger.
     * @see #getSourceMethod()
     */
    public final Logger setSourceMethod(String methodName) {
        if (isImmutable())
            throw new IllegalStateException("Cannot set source method: "
                + "modifications of global loggers were disabled");
        this.sourceMethod = methodName;
        return this;
    }

    /**
     * Returns the current executed method of the logger.
     *
     * @return the current executed method.
     * @see #setSourceMethod(String)
     */
    public final String getSourceMethod() {
        return this.sourceMethod;
    }

    /**
     * Sets the <i>current instance</i>: usually an instance of Java object
     * which method calls this logger.
     *
     * <p>Handlers, which perform output of the message, may retrive
     * the current instance via {@link #getSourceInstance()} method of the logger
     * passed to their {@link Handler#publish(Logger, int, Object)} method.
     *
     * <p>Please see an example of setting a class in the comments to {@link #cloneLogger()} method.
     *
     * <p>Current method may be <tt>null</tt>: it is the default value.
     *
     * @param thisInstance new current executed method.
     * @return           a reference to this logger.
     * @see #getSourceInstance()
     */
    public final Logger setSourceInstance(Object thisInstance) {
        if (isImmutable())
            throw new IllegalStateException("Cannot set source instance: "
                + "modifications of global loggers were disabled");
        this.sourceInstance = thisInstance;
        return this;
    }

    /**
     * Returns the current instance of the logger.
     *
     * @return the current instance.
     * @see #setSourceInstance(Object)
     */
    public final Object getSourceInstance() {
        return this.sourceInstance;
    }

    /**
     * Sets the <i>current context</i>: some data structure describing the context of execution.
     * For example, it can be a reference to the window, where the algorithm is executed
     * and where this logger should show a status line.
     *
     * <p>Handlers, which perform output of the message, may retrive
     * the current context via {@link #getSourceContext()} method of the logger
     * passed to their {@link Handler#publish(Logger, int, Object)} method.
     *
     * <p>Please see an example of setting a context in the comments to {@link #clone()} method.
     *
     * <p>Current context may be <tt>null</tt>: it is the default value.
     *
     * @param value new current context.
     * @return      a reference to this logger.
     * @see #getSourceContext()
     */
    public final Logger setSourceContext(Object value) {
        if (isImmutable())
            throw new IllegalStateException("Cannot set source context: "
                + "modifications of global loggers were disabled");
        this.sourceContext = value;
        return this;
    }

    /**
     * Returns the current context of the logger.
     *
     * @return the current context.
     * @see #setSourceContext(Object)
     */
    public final Object getSourceContext() {
        return this.sourceContext;
    }

    /**
     * Register a <i>publishing handler</i> (a reference, not a clone)
     * to receive messages from this logger.
     * All messages passed to {@link Logger#log(int, Object, boolean)} method are
     * sent to all publishing handlers registered
     * in this logger and of all its {@link Logger#parent() parent} loggers.
     *
     * <p>There is no sence to add the same handler several times,
     * but if you will do this, this handler will receive all messages several times.
     *
     * @param handler a handler to receive messages from this logger.
     * @return        a reference to this logger.
     * @throws NullPointerException if the argument is <tt>null</tt>.
     * @see #removeHandler(Handler)
     * @see #setHandlers(Handler[])
     * @see #getHandlers()
     */
    public final Logger addHandler(Handler handler) {
        if (isImmutable())
            throw new IllegalStateException("Cannot add handler: "
                + "modifications of global loggers were disabled");
        synchronized(handlers) {
            if (handler == null)
                throw new NullPointerException("Null handler argument");
            handlers.addElement(handler);
        }
        return this;
    }

    /**
     * Removes a publishing handler registered in this logger.
     * Does nothing if the given handler is not found.
     *
     * <p>If the same handler was added several times,
     * this method removes the first from references to it.
     *
     * @param handler a handler to be removed.
     * @throws NullPointerException if the argument is <tt>null</tt>.
     * @see #addHandler(Handler)
     * @see #setHandlers(Handler[])
     * @see #getHandlers()
     */
    public final void removeHandler(Handler handler) {
        if (isImmutable())
            throw new IllegalStateException("Cannot remove handler: "
                + "modifications of global loggers were disabled");
        synchronized(handlers) {
            if (handler == null)
                throw new NullPointerException("Null handler argument");
            handlers.removeElement(handler);
        }
    }

    /**
     * Sets all publishing handlers associated with this logger.
     * All previous handlers are removed.
     *
     * @param newHandlers an array of all new handlers to be registered.
     * @see #addHandler(Handler)
     * @see #removeHandler(Handler)
     * @see #getHandlers()
     */
    public void setHandlers(Handler[] newHandlers) {
        if (isImmutable())
            throw new IllegalStateException("Cannot set handlers: "
                + "modifications of global loggers were disabled");
        synchronized(handlers) {
            if (newHandlers == null)
                throw new NullPointerException("Null newHandlers argument");
            for (int k = 0; k < newHandlers.length; k++)
                if (newHandlers[k] == null)
                    throw new NullPointerException("Null newHandlers[" + k + "]");
            handlers.removeAllElements();
            for (int k = 0; k < newHandlers.length; k++)
                handlers.addElement(newHandlers[k]);
        }
    }

    /**
     * Gets all publishing handlers associated with this logger.
     *
     * @return an array of all registered handlers.
     * @see #addHandler(Handler)
     * @see #removeHandler(Handler)
     * @see #setHandlers(Handler[])
     */
    public final Handler[] getHandlers() {
        synchronized(handlers) {
            Handler[] result = new Handler[handlers.size()];
            handlers.copyInto(result);
            return result;
        }
    }

    /**
     * If this logger was created via {@link #cloneLogger()} method,
     * returns a reference to the creator; in other case, returns <tt>null</tt>.
     *
     * <p>The publishing handlers may use the chain of parent logger
     * to get additional information about the message source.
     *
     * <p>Any logged messages are automatically delegated to all the chain
     * of parents (<tt>parent()</tt>, <tt>parent().parent()</tt>, etc.)
     * As a rule, only the root logger has some {@link #addHandler(Handler) publishing handlers}.
     * So, this mechanism guarantees that all messages are published
     * via the same set of handlers, that can be configured by application
     * (by {@link #setGlobalLoggerHandlers(Handler[])} and {@link #setGlobalProgressHandlers(Handler[])}
     * methods usually} even after creating logger clones by any classes.
     *
     * @return the parent logger which has created this one by {@link #cloneLogger()}.
     * @see #cloneLogger()
     */
    public final Logger parent() {
        return this.parent;
    }

    /**
     * Returns a clone of this object (created via standard <tt>clone</tt> method).
     * There are two difference from a usual deep clone:<ol>
     * <li>A reference to this object is stored in the new created logger
     * and can be retrieved via {@link #parent()} method.</li>
     * <li>The set of {@link #addHandler(Handler) publishing handlers} is not cloned:
     * the returned logger does not contain any handlers.
     * (Instead, all logged messages will be delegated to this logger:
     * see more details in the comment to {@link #parent()} method.)
     * </ol>
     *
     * <p>Usually, you need to call <tt>cloneLogger()</tt> if you need to specify some logger
     * characteristics inside current algorithmic package or method.
     * For example:<pre>
     * public class SomeAlgorithm {
     * &#32;   private Logger logger;
     *
     * &#32;   public void setLogger(Logger value) {
     * &#32;       this.logger = value.cloneLogger()
     * &#32;           .setSourceClass(getClass())
     * &#32;           .setSourceInstance(this);
     * &#32;       // Here we may clarify the current class and instance parameters,
     * &#32;       // without damaging the original value.
     * &#32;   }
     *
     * &#32;   public void mainAlgorithmicMethod(SomeAlgorithmContext context, ...) {
     * &#32;       Logger logger = logger.cloneLogger()
     * &#32;           .setSourceContext(context)
     * &#32;           .setSourceMethod("mainAlgorithmicMethod");
     * &#32;       // ...
     * &#32;       // using "logger" in this method, without damaging the "logger" field.
     * &#32;       // ...
     * &#32;   }
     * }</pre>
     *
     * @return an identical copy of this object.
     * @see #parent()
     */
    public final Logger cloneLogger() {
        try {
            Logger result = (Logger)clone();
            result.handlers = new Vector(4);
            result.parent = this;
            return result;
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e.toString());
        }
    }

    /**
     * Returns <tt>true</tt> if this logger is one of two basic global loggers
     * (for {@link #global() normal logging} and
     * for {@link #globalProgress() indicating progress}),
     * and if all global modifications were disabled by
     * {@link #disableGlobalModifications()} method.
     *
     * This method should be used by inheritors of this class:
     * any possible state modifications must be disabled when this method returns <tt>true</tt>.
     *
     * @return boolean if this logger cannot be modified.
     */
    public final boolean isImmutable() {
        synchronized(handlers) {
            return immutable;
        }
    }

    private void setImmutable() {
        synchronized(handlers) {
            immutable = true;
        }
    }


    /**
     * Returns a string representation of this object.
     *
     * <p>The result of this method may depend on implementation and usually contains
     * information aboud the {@link #setSourceClass(Class) source class},
     * {@link #setSourceMethod(String) executed method} and
     * {@link #setSourceInstance(Object) current instance}, if they were set.
     *
     * @return a string representation of this object.
     */
    public String toString() {
        return (this == globalLogger ? "Global logger" :
            this == globalProgress ? "Global progress" :
            "Logger @" + Integer.toHexString(System.identityHashCode(this)))
            + (sourceClass == null ? "" :
            " for " + sourceClass)
            + (sourceMethod == null ? "" :
            (sourceClass == null ? "for method " : ".") + sourceMethod)
            + (sourceInstance == null ? "" :
            " (instance: " + sourceInstance + ")");
    }

    /**
     * This implementation calls {@link #flush()} method.
     *
     * @throws Throwable if any exception occurred.
     */
    protected void finalize() throws Throwable {
        try {
            flush();
        } finally {
            super.finalize();
        }
    }

    /**
     * Sets the global logger used for logging
     * the algorithm execution (timing, report about non-standard situations,
     * debugging information).
     * The publishing handlers, registered in this logger,
     * usually output the message to the console by <tt>System.out.println()</tt>
     * or pass it to the standard <tt>java.util.logging.Logger</tt>.
     *
     * <p>By default, this global logger is an instance of {@link BufferedConsole}:
     * its logging methods print message via <tt>System.out.println</tt>
     * (with some buffering for optimization).
     *
     * <p><i>Usually, the only reason to call this method is overriding
     * this <tt>Logger</tt> class.</i> In this case, please call this method
     * in the very beginning of the application, before initialization of any other classes
     * (that may get own clones of this global logger via {@link #cloneGlobalLogger()}
     * in their static initialization section).
     * If you don't override <tt>Logger</tt>, it is usually enough to
     * use {@link #setGlobalLoggerHandlers(Handler[])} in the beginning of the application.
     *
     * @param logger new global logger for logging.
     * @throws NullPointerException if the passed argument is <tt>null</tt>.
     * @see #setGlobalProgress(Logger)
     * @see #cloneGlobalLogger()
     * @see #global()
     * @see #setGlobalLoggerHandlers(Handler[])
     */
    public static void setGlobalLogger(Logger logger) {
        if (globalLogger.isImmutable()) {
            throw new IllegalStateException("Cannot call " + Logger.class.getName()
                + ".setGlobalLogger: modifications of global loggers were disabled");
        }
        if (logger == null)
            throw new NullPointerException("Null logger argument");
        Logger.globalLogger = logger;
    }

    /**
     * Returns a clone (result of {@link #cloneLogger()} method)
     * of the current global logger used for logging
     * the algorithm execution.
     *
     * <p>It is the standard way to create new logger, which will be
     * customized and used in some class or package.
     *
     * @return a clone of current global logger used for logging.
     * @see #setGlobalLogger(Logger)
     * @see #global()
     */
    public static Logger cloneGlobalLogger() {
        return globalLogger.cloneLogger();
    }

    /**
     * Returns a reference to the current global logger used for normal logging
     * the algorithm execution.
     *
     * <p>It is the simplest way to log a message: for example,<pre>
     * Logger.global().log("Some message");</pre>
     *
     * <p>The same result will be returned by <tt>Logger.cloneGlobalLogger().parent()</tt> call.
     * But this method, unlike such a call, returns only {@link Log} interface,
     * that help to avoid illegal attempts to modify global logger settings
     * (that are usually allowed only to the main application method).
     *
     * @return a clone of current global logger used for logging.
     * @see #setGlobalLogger(Logger)
     * @see #cloneGlobalLogger()
     */
    public static Log global() {
        return globalLogger;
    }

    /**
     * Sets the global logger used for indicating
     * the progress of algorithm execution (showing percent of calculations,
     * current iteration number, elapsed or estimated time, etc.)
     * The publishing handlers, registered in this logger,
     * usually show messages at some application status line.
     * They also may "understand" some special classes or interfaces
     * for message object, for example, the {@link MessagePercents} interface.
     *
     * <p>By default, this global logger is empty: its logging methods do nothing.
     *
     * <p><i>Usually, the only reason to call this method is overriding
     * this <tt>Logger</tt> class.</i> In this case, please call this method
     * in the very beginning of the application, before initialization of any other classes
     * (that may get own clones of this global logger via {@link #cloneGlobalProgress()}
     * in their static initialization section).
     * If you don't override <tt>Logger</tt>, it is usually enough to
     * use {@link #setGlobalProgressHandlers(Handler[])} in the beginning of the application.
     *
     * @param progress new global logger for indicating the progress of execution.
     * @throws NullPointerException if the passed argument is <tt>null</tt>.
     * @see #setGlobalLogger(Logger)
     * @see #cloneGlobalProgress()
     * @see #globalProgress()
     * @see #setGlobalProgressHandlers(Handler[])
     */
    public static void setGlobalProgress(Logger progress) {
        if (globalProgress.isImmutable()) {
            throw new IllegalStateException("Cannot call " + Logger.class.getName()
                + ".setGlobalProgress: modifications of global loggers were disabled");
        }
        if (progress == null)
            throw new NullPointerException("Null progress argument");
        Logger.globalProgress = progress;
    }

    /**
     * Returns a clone (result of {@link #cloneLogger()} method)
     * of the current global logger used for indicating
     * the progress of algorithm execution.
     *
     * <p>It is the standard way to create new logger, which will be
     * customized and used in some class or package.
     *
     * @return a clone of current global logger for indicating the progress of execution.
     * @see #setGlobalProgress(Logger)
     * @see #globalProgress()
     */
    public static Logger cloneGlobalProgress() {
        return globalProgress.cloneLogger();
    }

    /**
     * Returns a reference to the current global logger used for indicating
     * the progress of algorithm execution.
     *
     * <p>It is the simplest way to show a status message: for example,<pre>
     * Logger.globalProgress().log("15% ready");</pre>
     *
     * <p>The same result will be returned by <tt>Logger.cloneGlobalProgress().parent()</tt> call.
     * But this method, unlike such a call, returns only {@link Log} interface,
     * that help to avoid illegal attempts to modify global logger settings
     * (that are usually allowed only to the main application method).
     *
     * @return a clone of current global logger used for logging.
     * @see #setGlobalLogger(Logger)
     * @see #cloneGlobalProgress()
     */
    public static Log globalProgress() {
        return globalProgress;
    }

    /**
     * Sets all publishing handlers associated with the {@link #setGlobalLogger(Logger) global logger}.
     * All previous handlers are removed.
     *
     * @param newHandlers an array of all new handlers to be registered.
     * @see #setHandlers(Handler[])
     */
    public static void setGlobalLoggerHandlers(Handler[] newHandlers) {
        globalLogger.setHandlers(newHandlers);
    }

    /**
     * Gets all publishing handlers associated with the {@link #setGlobalLogger(Logger) global logger}.
     *
     * @return an array of all registered handlers.
     * @see #getHandlers()
     */
    public static Handler[] getGlobalLoggerHandlers() {
        return globalLogger.getHandlers();
    }

    /**
     * Sets all publishing handlers associated with the {@link #setGlobalProgress(Logger)
     * global logger used for indicating the progress of execution}.
     * All previous handlers are removed.
     *
     * @param newHandlers an array of all new handlers to be registered.
     * @see #setHandlers(Handler[])
     */
    public static void setGlobalProgressHandlers(Handler[] newHandlers) {
        globalProgress.setHandlers(newHandlers);
    }

    /**
     * Gets all publishing handlers associated with the {@link #setGlobalProgress(Logger)
     * global logger used for indicating the progress of execution}.
     *
     * @return an array of all registered handlers.
     * @see #getHandlers()
     */
    public static Handler[] getGlobalProgressHandlers() {
        return globalProgress.getHandlers();
    }


    /**
     * Sets the {@link #setRequiredLevel(int) maximal allowed message level} for
     * the {@link #setGlobalLogger(Logger) global logger}.
     *
     * @param value new maximal allowed message level for the global logger.
     */
    public static void setGlobalLoggerRequiredLevel(int value) {
        globalLogger.setRequiredLevel(value);
    }

    /**
     * Returns the {@link #getRequiredLevel() maximal allowed message level} for
     * the {@link #setGlobalLogger(Logger) global logger}.
     *
     * @return the current maximal allowed message level for the global logger.
     * @see #getHandlers()
     */
    public static int getGlobalLoggerRequiredLevel() {
        return globalLogger.getRequiredLevel();
    }

    /**
     * Sets the {@link #setRequiredLevel(int) maximal allowed message level} for
     * the {@link #setGlobalProgress(Logger) global logger used for indicating the progress of execution}.
     *
     * @param value new current maximal allowed message level for the global logger
     * used for indicating the progress of execution.
     */
    public static void setGlobalProgressRequiredLevel(int value) {
        globalProgress.setRequiredLevel(value);
    }

    /**
     * Returns the {@link #getRequiredLevel() maximal allowed message level} for
     * the {@link #setGlobalProgress(Logger) global logger used for indicating the progress of execution}.
     *
     * @return the current maximal allowed message level for the global logger
     * used for indicating the progress of execution.
     */
    public static int getGlobalProgressRequiredLevel() {
        return globalProgress.getRequiredLevel();
    }

    /**
     * Disables any modifications in two basic global loggers: for {@link #global()
     * normal logging} and for {@link #globalProgress() indicating progress}.
     * After call of this method, any further attempts to modify these loggers
     * (set required level, source class, method, instance or context, or change publishing handlers),
     * as well as an attempt to call this method again,
     * will lead to <tt>IllegalStateException</tt>.
     *
     * @see #isImmutable()
     */
    public static void disableGlobalModifications() {
        if (globalLogger.isImmutable()) {
            throw new IllegalStateException("Cannot call " + Logger.class.getName()
                + ".disableGlobalModifications() more that 1 time");
        }
        globalLogger.setImmutable();
        globalProgress.setImmutable();
    }

    /**
     * Service method for building log message:
     * returns a string consisting the given character repeated <tt>count</tt> times.
     *
     * @param count the length of result string.
     * @param c     repeated character.
     * @return      a string consisting the given character repeated <tt>count</tt> times.
     */
    public static String dup(int count, char c) {
        char[] ca = new char[count];
        for (int k = 0; k < count; k++)
            ca[k] = c;
        return new String(ca);
    }

    /**
     * Service method for building log message:
     * returns the given string padded to the given length from the left side
     * by <tt>pad</tt> character.
     * Returns unchanged string if <tt>s.length() > length</tt>.
     * <p>Example:<pre>
     *    pad("123", 5, ' ') is "  123"
     * </pre>
     *
     * @param s      the string to be padded.
     * @param length minimal required length.
     * @param pad    character used for padding.
     * @return       the padded string.
     */
    public static String leftPad(String s, int length, char pad) {
        return s.length() > length ? s : dup(length - s.length(), pad) + s;
    }

    /**
     * Service method for building log message:
     * returns the given string padded to the given length from the right side
     * by <tt>pad</tt> character.
     * Returns unchanged string if <tt>s.length() > length</tt>.
     * <p>Example:<pre>
     *    pad("123", 5, ' ') is "123  "
     * </pre>
     *
     * @param s      the string to be padded.
     * @param length minimal required length.
     * @param pad    character used for padding.
     * @return       the padded string.
     */
    public static String rightPad(String s, int length, char pad) {
        return s.length() > length ? s : s + dup(length - s.length(), pad);
    }

    /**
     * Service method for building log message:
     * returns the string decimal representation of the double argument
     * with <tt>digitsInMantissa</tt> digits after the decimal point.
     * Special cases:<ul>
     * <li>if <tt>digitsInMantissa &lt; 0</tt> or if <tt>v</tt> is <tt>NaN</tt> or infinitity,
     * the method returns standard string representation of <tt>v</tt>
     * (i.e. <tt>String.valueOf(v)</tt>);
     * <li>if <tt>digitsInMantissa == 0</tt>, the mantissa is not included in the result
     * (i.e. the method returns <tt>String.valueOf(Math.round(v))</tt>).
     * </ul>
     *
     * <p>Examples:<pre>
     *    toString(100*Math.PI, 5) is "314.15927",
     *    toString(100.0/3.0, 1) is "33.3",
     *    toString(100.0/3.0, -1) is "33.333333333333336"
     * (any other negative <tt>digitsInMantissa</tt> leads to the same result),
     *    toString(-2.0/3.0, 0) is "-1"
     * </pre>
     *
     * <p>As for <tt>String.valueOf(v)</tt> call, the result is
     * always written in american (scientific) standard, regardless
     * of the current regional settings.
     *
     * @param v                the double number.
     * @param digitsInMantissa the number of digits after the decimal point.
     * @return                 the decimal representation of the given number.
     */
    public static String toString(double v, int digitsInMantissa) {
        if (Double.isNaN(v) || Double.isInfinite(v) || digitsInMantissa < -1)
            return String.valueOf(v);
        if (digitsInMantissa == 0)
            return String.valueOf(Math.round(v));
        for (int i = 1; i <= digitsInMantissa; i++)
            v *= 10;
        String s = String.valueOf(Math.round(Math.abs(v)));
        int len = s.length();
        while (len < digitsInMantissa + 1) {
            s = "0" + s; len++;
        } //it is needed when |v|<1.0
        return ((v < 0.0) ? "-" : "") + s.substring(0, len - digitsInMantissa)
            + "." + s.substring(len - digitsInMantissa, len);
    }

    /**
     * Returns the string hexadecimal unsigned representation of the <tt>byte</tt> argument.
     * The result is in upper case and left-padded by '0' character.
     *
     * <p>Examples:<pre>
     *    toHexString((byte)15) is "0F",
     *    toHexString((byte)-2) is "FE"
     * </pre>
     *
     * @param v the byte value.
     * @return  the hexadecimal representation of the given byte value.
     */
    public static String toHexString(byte v) {
        char[] s = new char[] {
            HEX_DIGITS[(v >>> 4) & 0xF], HEX_DIGITS[v & 0xF]
        };
        return new String(s);
    }

    /**
     * Returns the string hexadecimal unsigned representation of the <tt>short</tt> argument.
     * The result is in upper case and left-padded by '0' character.
     *
     * <p>Examples:<pre>
     *    toHexString((short)15) is "000F",
     *    toHexString((short)-2) is "FFFE"
     * </pre>
     *
     * @param v the short value.
     * @return  the hexadecimal representation of the given short value.
     */
    public static String toHexString(short v) {
        char[] s = new char[] {
            HEX_DIGITS[(v >>> 12) & 0xF], HEX_DIGITS[(v >>> 8) & 0xF],
            HEX_DIGITS[(v >>> 4) & 0xF], HEX_DIGITS[v & 0xF]
        };
        return new String(s);
    }

    /**
     * Returns the string hexadecimal unsigned representation of the <tt>int</tt> argument.
     * The result is in upper case and left-padded by '0' character.
     *
     * <p>Examples:<pre>
     *    toHexString((int)15) is "0000000F",
     *    toHexString((int)-2) is "FFFFFFE"
     * </pre>
     *
     * @param v the int value.
     * @return  the hexadecimal representation of the given int value.
     */
    public static String toHexString(int v) {
        char[] s = new char[] {
            HEX_DIGITS[v >>> 28], HEX_DIGITS[(v >>> 24) & 0xF],
            HEX_DIGITS[(v >>> 20) & 0xF], HEX_DIGITS[(v >>> 16) & 0xF],
            HEX_DIGITS[(v >>> 12) & 0xF], HEX_DIGITS[(v >>> 8) & 0xF],
            HEX_DIGITS[(v >>> 4) & 0xF], HEX_DIGITS[v & 0xF]
        };
        return new String(s);
    }

    /**
     * Returns the string hexadecimal unsigned representation of the <tt>long</tt> argument.
     * The result is in upper case and left-padded by '0' character.
     *
     * <p>Examples:<pre>
     *    toHexString((long)15) is "000000000000000F",
     *    toHexString((long)-2) is "FFFFFFFFFFFFFFFE"
     * </pre>
     *
     * @param v the long value.
     * @return  the hexadecimal representation of the given long value.
     */
    public static String toHexString(long v) {
        return toHexString((int)(v >>> 32)) + toHexString((int)v);
    }

    private final static char[] HEX_DIGITS = {
        '0', '1', '2', '3', '4', '5',
        '6', '7', '8', '9', 'A', 'B',
        'C', 'D', 'E', 'F'
    };

    /**
     * The standard sequence of characters that separates lines in text files and
     * console output. Depends on operating system: <tt>"\n"</tt> on Unix-like systems,
     * <tt>"\r\n"</tt> on DOS / Windows family, <tt>"\r"</tt> on Macintosh.
     *
     * <p>Standard <tt>System.out.println()</tt> call is equivalent to
     * <tt>System.out.print(Progress.LINE_SEPARATOR)</tt>.
     *
     * <p>If you want to print several lines on the console by a single call
     * of <tt>System.out.println</tt>, you <b>must always use
     * <tt>LINE_SEPARATOR</tt></b> to separate lines instead more simple
     * <tt>"\n"</tt>. For example, the call<pre>
     *     System.out.println("First line\nSecond line");</pre><b>is incorrect</b>
     * (unlike an analogous call in C/C++):
     * it may work incorrectly on all platforms besides Unix / Linux.
     * In particular, if you save all standard output in a text file,
     * this file will be shown incorrectly in Windows Notepad.

     * <p>The following call should be used instead:<pre>
     *     System.out.println("First line" + Progress.LINE_SEPARATOR + "Second line");</pre>
     *
     */
    public static final String LINE_SEPARATOR = getLineSeparator();

    private static String getLineSeparator() {
        // Maximal safe way to get line separator.
        // (Theoretically, some security managers may prohibit access to
        // System.getProperty("line.separator").)
        // We don't use BufferWriter to provide compatibility with Java 1.0
        // All known OS use characters <256 for line separators
        java.io.ByteArrayOutputStream byteArrayOutputStream = new java.io.ByteArrayOutputStream(8);
        java.io.PrintStream printStream = new java.io.PrintStream(byteArrayOutputStream);
        printStream.println();
        printStream.flush();
        printStream.close();
        byte[] bytes = byteArrayOutputStream.toByteArray();
        char[] chars = new char[bytes.length];
        for (int k = 0; k < bytes.length; k++)
            chars[k] = (char)(bytes[k] & 0xFF);
        // such a code provides compatibility with Java 1.0 and avoids deprecation warnings
        return String.valueOf(chars);
    }

}
