package net.algart.lib;

/**
 * <p>A collection of static methods providing advanced output
 * to <code>System.out</code>,  mostly for debugging needs.
 * In particular, implements:<ul>
 *
 * <li>different ways for converting objects to strings
 * in addition to standard <code>toString</code> method;
 *
 * <li>automatic conversion of "\n" character to correct
 * system-depended line separator;
 *
 * <li>buffering a lot of <code>println</code> calls.
 *
 * </ul>
 *
 * @version 1.0
 * @author  Daniel Alievsky
 * @since   JDK1.0
 */

public final class Out implements TrueStatic {
// TrueStatic is necessary because setPrintDelay() should be global

  // Don't let anyone instantiate this class
  private Out() {}

  /**
   * Returns a new string resulting from replacing all occurrences of
   * <code>oldSubstring</code> in the <code>s</code> source string
   * with <code>newSubstring</code>.
   *
   * <p>If <code>s == null</code>, no exceptions are thrown;
   * in this case, the method returns <code>null</code>.
   *
   * <p>If <code>oldSubstring</code> does not occur in the
   * the <code>s</code> source string, then a reference to <code>s</code>
   * object is returned.
   *
   * <p>This method can be a useful addition to the standard <code>String.replace</code>
   * method, especially for debug output. It works more quickly than
   * Java 1.4 <code>String.replaceAll</code> method, and is more simple in use.
   *
   * @param s             the string
   * @param oldSubstring  the old substring
   * @param newSubstring  the new substring
   * @return              a string derived from <code>s</code> string by replacing every
   *    occurrence of <code>oldSubstring</code> with <code>newSubstring</code>
   * @throws NullPointerException       if <code>oldSubstring == null</code> or <code>newSubstring == null</code>
   * @throws IllegalArgumentException   if <code>oldSubstring.length() == 0</code>
   */
  public static String replace(String s, String oldSubstring, String newSubstring) {
    if (s == null) return null;
    if (oldSubstring == null) throw new NullPointerException("Null oldSubstring argument in replace method");
    if (newSubstring == null) throw new NullPointerException("Null newSubstring argument in replace method");
    int len = s.length();
    int oldLen = oldSubstring.length();
    if (oldLen == 0) throw new IllegalArgumentException("Empty oldSubstring argument in replace method");
    int p = s.indexOf(oldSubstring);
    if (p == -1) return s;
    StringBuffer sb = new StringBuffer(len);
    sb.append(s.substring(0,p)).append(newSubstring);
    p += oldLen;
    for (; p < len; ) {
      int q = s.indexOf(oldSubstring,p);
      if (q == -1) break;
      sb.append(s.substring(p,q)).append(newSubstring);
      p = q + oldLen;
    }
    sb.append(s.substring(p));
    return sb.toString();
  }

  /**
   * Replace every char sequence "Exception" in the string <code>s</code> with
   * the char sequence "[[E]]xception".
   *
   * <p>It allows to avoid wrong signals generated by some IDEs
   * when they detect "Exception" word in the standard application
   * output while debugging the program. For example, Borland JavaBuilder(TM)
   * sounds a clank every time when the debugged application prints "Exception" into
   * <code>System.out</code> or <code>System.err</code>. It's a good idea usually,
   * when the application prints standard exception information (for
   * example, by <code>e.printStackTrace()</code> call). But it can be very
   * bad if you need to print some debugging text containing a lot of
   * "Exception" words while normal execution of the application.
   *
   * <p>This method is called internally by {@link #print(String)} and
   * {@link #println(String)} methods of this class.
   *
   * @param s   the corrected string; can be <code>null</code>
   * @return    <code>{@link #replace(String, String, String) replace}(s,"Exception","[[E]]xception")</code>;
   *    <code>null</code> if <code>s == null</code>
   * @see #print(String)
   * @see #println(String)
   */

  public static String avoidDebuggingSignalsForExceptions(String s) {
    return replace(s,"Exception","[[E]]xception");
  }
  /**
   * Replace every character "\n" in the string <code>s</code> with
   * {@link GlobalProperties#LINE_SEPARATOR} string.
   *
   * <p>It can simplify generation of a text with lines separated
   * by <code>GlobalProperties.LINE_SEPARATOR</code>.
   *
   * <p>This method is called internally by {@link #print(String)} and
   * {@link #println(String)} methods of this class.
   *
   * @param s   the corrected string; can be <code>null</code>
   * @return    <code>{@link #replace(String, String, String) replace}(s,"\n",GlobalProperties.LINE_SEPARATOR)</code>;
   *    <code>null</code> if <code>s == null</code>
   * @see #print(String)
   * @see #println(String)
   */
  public static String replaceLFToLineSeparator(String s) {
    return replace(s,"\\n",GlobalProperties.LINE_SEPARATOR);
  }

  /**
   * Returns a string consisting of <code>len</code> copies of the
   * specified character <code>c</code>.
   *
   * @param c     the character that is duplicated
   * @param len   the number of copies of <code>c</code> characters in the result string
   * @return      a string consisting of <code>len</code> characters, each character is equal to <code>c</code>
   */
  public static String dup(char c, int len) {
    char[] chars = new char[len];
    for (int k = 0; k < len; k++) chars[k] = c;
    return String.valueOf(chars);
  }

  /**
   * If <code>padLen &lt; s.length()</code>, returns a reference to the original
   * <code>s</code> string object; in other case, returns the <code>s</code>
   * padded leftward to <code>padLen</code> length by the space character:<pre>
   *    dup(' ', padLen - s.length()) + s
   * </pre>
   *
   * @param s       the string that should be padded
   * @param padLen  the minimal length of the resulting string
   * @return        the string padded leftward (if necessary) to the <code>padLen</code>
   *    length by the space character
   */
  public static String pad(String s, int padLen) {
    return pad(s,padLen,' ',false);
  }

  /**
   * If <code>padLen &lt; s.length()</code>, returns a reference to the original
   * <code>s</code> string object; in other case, returns the <code>s</code>
   * padded rightward to <code>padLen</code> length by the space character:<pre>
   *    s + dup(' ', padLen - s.length())
   * </pre>
   *
   * @param s       the string that should be padded
   * @param padLen  the minimal length of the resulting string
   * @return        the string padded rightward (if necessary) to the <code>padLen</code>
   *    length by the space character
   */
  public static String rightPad(String s, int padLen) {
    return pad(s,padLen,' ',true);
  }

  /**
   * If <code>padLen &lt; s.length()</code>, returns a reference to the original
   * <code>s</code> string object; in other case, returns the <code>s</code>
   * padded leftward or rightward to <code>padLen</code> length by the given <code>pad</code>
   * character:<pre>
   *    right? s + dup(pad, padLen - s.length()): dup(pad, padLen - s.length()) + s
   * </pre>
   *
   * @param s       the string that should be padded
   * @param padLen  the minimal length of the resulting string
   * @param pad     the character used for padding
   * @param right   if <code>true</code>, the string is padded rightward, else leftward
   * @return        the string padded (if necessary) to the <code>padLen</code>
   *    length by the <code>pad</code> character
   */
  public static String pad(String s, int padLen, char pad, boolean right) {
    if (s.length() >= padLen) return s;
    if (right)
      return s + dup(pad, padLen - s.length());
    else
      return dup(pad, padLen - s.length()) + s;
  }


  /*Repeat()
    integer ==> long ;;
    int v ==> long v
  */
  /**
   * Equivalent to<pre>
   *    pad(String.valueOf(v),padLen)
   * </pre>
   *
   * @param s       the integer number that should be converted to string and padded
   * @param padLen  the minimal number of characters of the resulting string
   * @return        a decimal representation of the givem number, padded leftward
   *    (if necessary) to the <code>padLen</code> length by the space character
   * @see #pad(String, int)
   */
  public static String pad(int v, int padLen) {
    return pad(String.valueOf(v),padLen);
  }/*Repeat.AutoGeneratedStart*/
                                                  /**
                                                   * Equivalent to<pre>
                                                   *    pad(String.valueOf(v),padLen)
                                                   * </pre>
                                                   *
                                                   * @param s       the long number that should be converted to string and padded
                                                   * @param padLen  the minimal number of characters of the resulting string
                                                   * @return        a decimal representation of the givem number, padded leftward
                                                   *    (if necessary) to the <code>padLen</code> length by the space character
                                                   * @see #pad(String, int)
                                                   */
                                                  public static String pad(long v, int padLen) {
                                                    return pad(String.valueOf(v),padLen);
                                                  }/*Repeat.AutoGeneratedEnd*/

  /**
   * Equivalent to<pre>
   *    deTab(s,tabLen,'\n')
   * </pre>
   *
   * @param s       the multiline text where all tab characters (\t) should be replaced with spaces
   * @param tabLen  every \t charater corresponds to <code>tabLen</code> positions
   * @return        an original text where all tab characters (\t) are replaced with spaces
   * @see #deTab(String, int, char)
   */

  public static String deTab(String s, int tabLen) {
    return deTab(s,tabLen,'\n');
  }

  /**
   * Performs standard <i>detab</i> operation with the given tabulation length.
   * All tab characters \t are replaced by corresponding number of spaces ' '.
   * This method assumes that the lines in the <code>s</code> text are separated
   * by one character '\n'; that is, the line position of the first character
   * after each '\n' is 1.
   *
   * <p>For example:<pre>
   *    deTab("\t",4) == "    "
   *    deTab("aa\tbb",4) == "aa  bb"
   *    deTab("aa\t\r\n\tbb",4) == "aa  \r\n    bb"
   * but
   *    deTab("aa\t\n\r\tbb",4) == "aa  \n\r   bb"
   * </pre>
   *
   * @param s       the multiline text where all tab characters (\t) should be replaced with spaces
   * @param tabLen  every \t charater corresponds to <code>tabLen</code> positions
   * @return        an original text where all tab characters (\t) are replaced with spaces
   */
  public static String deTab(String s, int tabLen, char lineSeparator) {
    if (tabLen <= 0) throw new IllegalArgumentException(Out.class.getName() + "deTab: illegal tabLen argument " + tabLen);
    if (s.indexOf('\t') == -1) return s;
    int len = s.length();
    StringBuffer sb = new StringBuffer(len);
    for (int k = 0, pos = 0; k < len; k++) {
      char c = s.charAt(k);
      if (c == lineSeparator) {
        sb.append(c); pos = 0;
      } else if (c == '\t') {
        do {
          sb.append(' '); pos++;
        } while (pos%tabLen != 0);
      } else {
        sb.append(c); pos++;
      }
    }
    return sb.toString();
  }

  public static String deTab(String s, int[] tabPositions) {
    return deTab(s,tabPositions,'\n');
  }
  public static String deTab(String s, int[] tabPositions, char lineSeparator) {
    if (s.indexOf('\t') == -1) return s;
    int len = s.length();
    StringBuffer sb = new StringBuffer(len);
    for (int k = 0, pos = 0, posIndex = 0; k < len; k++) {
      char c = s.charAt(k);
      if (c == lineSeparator) {
        sb.append(c); pos = 0; posIndex = 0;
      } else if (c == '\t') {
        do {
          sb.append(' '); pos++;
        } while (posIndex < tabPositions.length && pos < tabPositions[posIndex]);
        if (posIndex < tabPositions.length) posIndex++;
      } else {
        sb.append(c); pos++;
        while (posIndex < tabPositions.length && pos >= tabPositions[posIndex]) posIndex++;
      }
    }
    return sb.toString();
  }

  /*Repeat()
    byte ==> short,, int,, long ;;
    &0xFF ==> &0xFFFF,, ,, ;;
    2 ==> 4 ,, 8 ,, 16 ;;
    Integer ==> Integer,, Integer,, Long
  */
  /**
   * Returns a hexadecimal unsigned representation of the byte argument.
   * Unlike <code>Integer.toHexString(v)</code> call, the result is in
   * the upper case and always contains 2 digits (leaded by '0' if needed).
   *
   * @param v the byte argument
   * @return  its hexadecimal representation (2 characters)
   */
  public static String hex(byte v) {
    return pad(Integer.toHexString(v&0xFF),2,'0',false);
  }/*Repeat.AutoGeneratedStart*/
                                                  /**
                                                   * Returns a hexadecimal unsigned representation of the short argument.
                                                   * Unlike <code>Integer.toHexString(v)</code> call, the result is in
                                                   * the upper case and always contains 4 digits (leaded by '0' if needed).
                                                   *
                                                   * @param v the short argument
                                                   * @return  its hexadecimal representation (4 characters)
                                                   */
                                                  public static String hex(short v) {
                                                    return pad(Integer.toHexString(v&0xFFFF),4,'0',false);
                                                  }
                                                  /**
                                                   * Returns a hexadecimal unsigned representation of the int argument.
                                                   * Unlike <code>Integer.toHexString(v)</code> call, the result is in
                                                   * the upper case and always contains 8 digits (leaded by '0' if needed).
                                                   *
                                                   * @param v the int argument
                                                   * @return  its hexadecimal representation (8 characters)
                                                   */
                                                  public static String hex(int v) {
                                                    return pad(Integer.toHexString(v),8,'0',false);
                                                  }
                                                  /**
                                                   * Returns a hexadecimal unsigned representation of the long argument.
                                                   * Unlike <code>Long.toHexString(v)</code> call, the result is in
                                                   * the upper case and always contains 16 digits (leaded by '0' if needed).
                                                   *
                                                   * @param v the long argument
                                                   * @return  its hexadecimal representation (16 characters)
                                                   */
                                                  public static String hex(long v) {
                                                    return pad(Long.toHexString(v),16,'0',false);
                                                  }/*Repeat.AutoGeneratedEnd*/
  public static String dec(double v, int d) {
    return decOrExpPrivate(v,d,false);
  }
  public static String exp(double v, int d) {
    return decOrExpPrivate(v,d,true);
  }
  public static String dec(double v, int d, int padLen) {
    return pad(dec(v,d),padLen);
  }
  public static String exp(double v, int d, int padLen) {
    return pad(exp(v,d),padLen);
  }
  private static String decOrExpPrivate(double v, int d, boolean exponentForm) {
    StringBuffer ptn = new StringBuffer("0");
    if (d > 0) {
      ptn.append('.');
      for (; d > 0; d--) ptn.append('0');
    }
    if (exponentForm) ptn.append("E0");
    java.text.DecimalFormat f = new java.text.DecimalFormat(ptn.toString(),DECIMAL_FORMAT_SYMBOLS_US);
    return f.format(v);
  }

  public static String spaced(int v, char space) {
    return spaced((long)v,space);
  }
  public static String spaced(long v, char space) {
    return DECIMAL_FORMAT_SPACED_US.format(v).replace(',',space);
  }
  public static String abc(int v) {
    return abc((long)v);
  }
  public static String abc(long v) {
  // "A","B",...,"Z","AA","AB",...,"AZ","BA",...,"ZZ","AAA",...,"ZZZ","AAAA",...
    StringBuffer sb = new StringBuffer(8);
    int offset = 0;
    if (v < 0) {
      sb.append('-');
      v = -v;
      offset = 1;
    }
    for (; v >= 0; v = v/26-1) {
      sb.insert(offset,(char)('A' + (char)(v%26)));
    }
    return sb.toString();
  }
  public static long parseLongAbc(String s) throws NumberFormatException {
    int offset = 0;
    if (s.startsWith("-")) offset = 1;
    long result = -1, mult = 1;
    for (int p = s.length()-1; p >= offset; p--) {
      char c = s.charAt(p);
      int dig;
      if (c >= 'A' && c <= 'Z') dig=  c-'A';
      else if (c >= 'a' && c <= 'z') dig = c-'a';
      else throw new NumberFormatException("Illegal character: " + c);
      result += (dig + 1) * mult;
      mult *= 26;
    }
    if (mult == 1) throw new NumberFormatException("Empty string");
    if (offset == 1) result = -result;
    return result;
  }

  public static String join(Object o, String separator) {
    if (o == null) return "";
    if (o.getClass().isArray()) {
      int len = java.lang.reflect.Array.getLength(o);
      if (len == 0) return "";
      StringBuffer sb = new StringBuffer();
      for (int k = 0; k < len; k++) {
        if (k > 0) sb.append(separator);
        sb.append(String.valueOf(java.lang.reflect.Array.get(o,k)));
      }
      return sb.toString();
    }
    if (o instanceof net.algart.array.ImmArray) {
      return ((net.algart.array.ImmArray)o).toString(separator);
    }
    if (o instanceof ImmSet) {
      return ((ImmSet)o).toString(separator);
    }
    if (o instanceof ImmMap) {
      return ((ImmMap)o).toString(separator);
    }
    if (o instanceof java.util.Hashtable) {
      StringBuffer sb = new StringBuffer();
      java.util.Enumeration en = ((java.util.Hashtable)o).keys();
      if (!en.hasMoreElements()) return "";
      Object key = en.nextElement();
      Object value = ((java.util.Hashtable)o).get(key);
      sb.append(key).append("=").append(value);
      for (; en.hasMoreElements(); ) {
        key = en.nextElement();
        value = ((java.util.Hashtable)o).get(key);
        sb.append(separator).append(key).append("=").append(value);
      }
      return sb.toString();
    }
    if (o instanceof java.util.Iterator) {
      java.util.Iterator i = (java.util.Iterator)o;
      if (!i.hasNext()) return "";
      StringBuffer sb = new StringBuffer(String.valueOf(i.next()));
      for (; i.hasNext(); )
        sb.append(separator).append(String.valueOf(i.next()));
      return sb.toString();
    }
    if (o instanceof java.util.Collection) {
      return join(((java.util.Collection)o).iterator(),separator);
    }
    if (o instanceof java.util.Map) {
      return join(((java.util.Map)o).entrySet().iterator(),separator);
    }
    throw new IllegalArgumentException("Illegal argument type in " + Out.class.getName() + ".join method: " + o.getClass());
  }



  /**
   * Prints the given string on <code>System.out</code>. Unlike the standard
   * <code>System.out.print</code> method, this one perform the following
   * additional actions.<ol>
   *
   * <li>The replacements provided by {@link #replaceLFToLineSeparator(String)}
   * are performed ("<code>value&nbsp;=&nbsp;replaceLFToLineSeparator(value)</code>").
   * So, this method can be safely use for printing
   * several lines in one simple call, such as<pre>
   *    Out.print("First line\nSecond line")</pre>
   *
   * <li>Then, the replacements provided by {@link #avoidDebuggingSignalsForExceptions(String)}
   * are performed  ("<code>value&nbsp;=&nbsp;avoidDebuggingSignalsForExceptions(value)</code>").
   * So, this method can be safely used for printing texts
   * that can contain "Exception" words.
   *
   * <li>If some print delay was set by {@link #setPrintDelay(long)} call,
   * then the resulting string will not be printed immediately. Instead,
   * it will be added to an internal buffer that will be fully printed
   * (using <code>System.out.print(buffer)</code> call) after
   * the specified delay <i>following the last call of
   * this method</i> (or {@link #println(String)} method, or
   * {@link #printNoCorrections(String)}).
   * If no print delay was specified, the resulting string will
   * be just printed by <code>System.out.print(value)</code>
   * call. Such a delay can greatly increase output performance,
   * especially while debugging under some IDE.
   *
   * @param a   the printed string; if <code>null</code>, the <code>"null"</code>
   *    string will be printed
   * @see #replaceLFToLineSeparator(String)
   * @see #avoidDebuggingSignalsForExceptions(String)
   * @see #flush()
   * @see #setPrintDelay(long)
   * @see #println(String)
   */
  public static void print(String value) {
    printNoCorrections(avoidDebuggingSignalsForExceptions(replaceLFToLineSeparator(value)));
  }
  /**
   * A brief equivalent of <code>{@link #println(String) println}("")</code>
   * call (or <code>{@link #print(String) print}("\n")</code>: remind that
   * {@link #print(String) print} method automatically replaces "\n"
   * with {@link GlobalProperties#LINE_SEPARATOR}).
   *
   * @param value   the printed string
   * @see #print(String)
   * @see #println(String)
   */
  public static void println() {
    print("\n");
  }
  /**
   * This method differs from <code>System.out.println</code> in the same
   * respects as the {@link print(String)} method differs from
   * <code>System.out.print</code>. It's equivalent to<pre>
   *    print(value + "\n");
   * </pre>call. ({@link #print(String) print} call here automatically replaces "\n"
   * with {@link GlobalProperties#LINE_SEPARATOR}.)
   *
   * @param a   the printed string (followed by {@link GlobalProperties#LINE_SEPARATOR line separator}).
   * @see #replaceLFToLineSeparator(String)
   * @see #avoidDebuggingSignalsForExceptions(String)
   * @see #flush()
   * @see #setPrintDelay(long)
   * @see #print(String)
   */
  public static void println(String value) {
    print(value + "\n");
  }


  /**
   * An analog of {@link #print(String)} method that doesn't perform any
   * replacements in the <code>value</code> string. So, it only
   * performs a delay before printing (if it was set by
   * {@link #setPrintDelay(long)} call) in addition to standard
   * <code>System.out.print</code> actions.
   *
   * @param value   the printed string
   * @see #print(String)
   */
  public static synchronized void printNoCorrections(String value) {
    if (printDelay <= 0) {
      System.out.print(value); return;
    }
    if (printBuffer == null) printBuffer= new StringBuffer(value);
    else                     printBuffer.append(value);
    if (timerPrint != null) timerPrint.cancel();
    timerPrint = new java.util.Timer(false);
    timerPrint.schedule(new java.util.TimerTask() {
      public synchronized void run() {
        Out.flush();
      }
    },printDelay);
  }


  /**
   * Immediately flushs the buffer filled by previous calls of {@link #print(String)},
   * {@link #println(String)},
   * {@link #printNoCorrections(String)}
   * to the <code>System.out</code>.
   * Does nothing if no positive delay was specified by
   * {@link #setPrintDelay(long)} call.
   *
   * <p>This method is useful only if you need to synchronize
   * the output performed by this class and the standard
   * output tools such as direct <code>System.out.println</code>
   * calls or printing to <code>System.err</code> (that is
   * not buffered by this class at all).
   *
   * @see #print(String)
   * @see #println(String)
   * @see #setPrintDelay(long)
   */
  public synchronized static void flush() {
    if (timerPrint != null) {
      timerPrint.cancel();
      timerPrint = null;
    }
    if (printDelay <= 0) return;
    if (printBuffer != null) System.out.print(printBuffer);
    printBuffer = null;
  }
  /**
   * Returns the print delay set by the last {@link #setPrintDelay(long)} call.
   * Return (<code>0</code> before the first call of {@link #setPrintDelay(long)}.
   *
   * @return  the print delay set by the last {@link #setPrintDelay(long)} call
   */
  public static synchronized long getPrintDelay() {
    return printDelay;
  }
  /**
   * Sets the delay performed after the last call of {@link #print(String)},
   * {@link #println(String)},
   * {@link #printNoCorrections(String)}
   * methods until the moment when the printed text will
   * be really sent to <code>System.out</code> (by <code>System.out.print</code>
   * call). This value is global for this class and usually should be set only
   * once at the start of your application.
   *
   * @param ms  new delay in milliseconds; <code>0</code> value (which is default)
   *    means that no delay will be performed
   * @throws IllegalArgumentException   if <code>ms &lt; 0</code>
   * @see #print(String)
   * @see #println(String)
   * @see #flush()
   */
  public static synchronized void setPrintDelay(long ms) {
    if (ms < 0) throw new IllegalArgumentException("Negative argument in " + Out.class.getName() + ".setPrintDelay method");
    Out.flush();
    printDelay = ms;
  }


  private static final java.text.DecimalFormatSymbols DECIMAL_FORMAT_SYMBOLS_US = new java.text.DecimalFormatSymbols(java.util.Locale.US);
  private static final java.text.DecimalFormat DECIMAL_FORMAT_SPACED_US = new java.text.DecimalFormat("#,###",DECIMAL_FORMAT_SYMBOLS_US);
  private static java.text.DecimalFormatSymbols getDecimalFormatSymbolsUS() {
    return (java.text.DecimalFormatSymbols)DECIMAL_FORMAT_SYMBOLS_US.clone();
  }
  private static long printDelay = 0;
  private static StringBuffer printBuffer = null;
  private static java.util.Timer timerPrint = null;
}