<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<base href="http://algart.net/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html">
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta http-equiv=Content-Language content=ru>
<title>AlgART и обработка изображений: некоторые элементарные приемы</title>
<link rel=stylesheet type=text/css href=../../../../default.css><script language=JavaScript><!--
window.___ww_urlbase= "http://algart.net/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html";
window.___ww_cpc="819402613,625520";
window.___ww_gmt="10,5,108";
//--></script>
<script language=JavaScript src=http://algart.net/ww/~WWServiceScriptGZ/wwserv.js></script>
</head>
<body>

<script id=noww type=text/javascript
src=http://webwarper.net/wwgz/optimizepage.js></script>
<div id=ad_top_google align=center>
<script type=text/javascript><!--
google_ad_client = "pub-6340524491670971";
/* ad algart.net, created 5/24/08 */
google_ad_slot = "4726790607";
google_ad_width = 728;
google_ad_height = 90;
if (window.___ww) ___ww_flush();
//--></script>
<script type=text/javascript
src=http://algart.net/ww/~clientscriptgz/pagead2.googlesyndication.com/pagead/show_ads.js>
</script>
<script type=text/javascript><!--
google_ad_client = "pub-6340524491670971";
/* link algart.net, created 5/24/08 */
google_ad_slot = "7778622983";
google_ad_width = 728;
google_ad_height = 15;
if (window.___ww) ___ww_flush();
//--></script>
<script type=text/javascript
src=http://algart.net/ww/~clientscriptgz/pagead2.googlesyndication.com/pagead/show_ads.js>
</script></div>
<div id=content>
<h4><a href=http://algart.net/ww/0/>AlgART</a> / <a href=http://algart.net/ww/0/java/AlgART/>Java libraries</a></h4>
<h2>AlgART и обработка изображений: некоторые элементарные приемы</h2>
<p align=right><i>Даниил Алиевский, 2007</i></p>
<h4><a name=Content></a>ОГЛАВЛЕНИЕ</h4>
<ul><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#introduction>Введение</a></li><ol><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Array>AlgART-массивы</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Matrix>AlgART-матрицы</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#generics>Матрицы и generics: extends или не extends?</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Image2D>Двумерные изображения: Image2D</a></li></ol><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#SimplestTutorialDemo>Часть I. Чтение и создание изображения: класс SimplestTutorialDemo</a></li><ol><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#toGrayscale>Конверсия RGB-изображения в полутоновое</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_1>Вычисление средней яркости самым плохим способом: покоординатный цикл</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_2>Вычисление средней яркости чуть менее плохим способом: цикл по массиву</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_3>Вычисление средней яркости: пора вспомнить о пользователе</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_4>Вычисление средней яркости: учимся писать эффективно</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_5>Вычисление средней яркости: библиотечная функция все-таки лучше</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_1>Генерация константного изображения простейшим способом: цикл по массиву</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_2>Генерация константного изображения: произвольная разрядность результата</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_3>Генерация константного изображения: да здравствует лень!</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_4>Генерация константного изображения: ленимся грамотно</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_5>Генерация константного изображения: сколько можно лениться?</a></li><li><a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_6>Генерация константного изображения: да будет цвет!</a></li></ol>
</ul>
<h3 style="margin-bottom: 0px"><a name=introduction></a>Введение</h3>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Array>Следующий раздел</a></div>
<p>В этой статье мы рассмотрим некоторые простейшие приемы применения библиотек AlgART
на примере нескольких Java-классов &mdash; специально написанных примеров,
анализирующих и обрабатывающих двумерные растровые изображения.
Речь пойдет, главным образом, о пакете <b><code>net.algart.arrays</code></b> &mdash;
"сердце" библиотек AlgART.</p>
<p>Надо сразу сказать: библиотеки AlgART нетривиальны и обширны.
С помощью нескольких примеров вполне овладеть ими нельзя,
но можно "почувствовать" и научиться решать элементарные задачи.
Исчерпывающую информацию об AlgART API можно найти в комментариях JavaDoc.
Создавая библиотеки, я старался делать JavaDoc-комментарии максимально подробными
и, по-возможности, снабжал простейшими примерами кода.</p>
<p>Ниже, при разборе примеров, я буду давать нужные пояснения к используемым
классам, интерфейсам и методам.
Однако при чтении рекомендуется иметь "под рукой" полный справочник JavaDoc
и просматривать комментарии к разбираемым методам.
Кроме того, рекомендуется в самом начале просмотреть обзорный комментарий к пакету
<code>net.algart.arrays</code> (package summary).</p>
<p>Перед тем, как двигаться дальше, я вкратце опишу три основных сущности (объекта),
необходимых для работы с изображениями средствами AlgART.
Это <i>линейный массив</i>, <i>матрица</i> и собственно <i>изображение</i>,
представленные соответственно интерфейсами <code>Array</code>, <code>Matrix&lt;? extends Array&gt;</code>
и <code>Image2D</code>.</p>
<h4 style="margin-bottom: 0px"><a name=Array></a>1. AlgART-массивы</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#introduction>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Matrix>Следующий раздел</a></div>
<p>Интерфейс <code>Array</code> &mdash; базовый интерфейс библиотеки <code>net.algart.arrays</code>,
описывающий так называемый <i>AlgART-массив</i>.
(Далее под "массивом" мы почти всегда будем пониимать именно AlgART-массив.)
Его можно рассматривать как далеко развитый аналог таких стандартных классов,
как <code>ArrayList</code> и <code>java.nio.Buffer</code>.
В AlgART-массиве можно хранить любые типы данных, причем в отличие от <code>ArrayList</code>
хранение примитивных типов будет эффективным.
Адресация массива 63-битовая: все индексы и размеры имеют тип <code>long</code>.
Соответственно, размеры AlgART-массивов не ограничены лимитом 2 GB.
Даже на 32-разрядных OS библиотека позволяет легко создавать массивы произвольного размера:
для этого автоматически и прозрачно для программиста задействуются дисковые файлы.
Массивы могут хранить произвольные типы элементов (например, строки),
но для обработки изображений нас будут интересовать исключительно массивы,
элементы которых принадлежат к одному из 8 стандартных примитивных типов:
<code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>,
<code>int</code>, <code>long</code>, <code>float</code> и <code>double</code>.
Да, даже <code>long</code> и <code>double</code>:
хоть и маловероятно, что для описания яркости пиксела потребуется такая точность,
однако проще и естественнее универсально отработать все разрядности Java, чем
вводить искусственные ограничения. На деле тип <code>char</code> в данном случае совершенно бесполезен
(в нашей библиотеке он равнозначен <code>short</code>), однако для полноты поддерживается и он.</p>
<p>В иерархии интерфейсов пакета <code>net.algart.arrays</code> такие массивы представлены
следующими подинтерфейсами интерфейса <code>Array</code>:</p>
<ul><li><code>PArray</code> (обеспечивает доступ к массиву только на чтение) и</li><li><code>UpdatablePArray</code> (расширяет <code>PArray</code>, добавляя возможности модификации элементов).</li></ul>
<p>У этих интерфейсов, в свою очередь, есть подинтерфейсы для представления каждого конкретного примитивного типа,
например, <code>BitArray</code> (массив boolean-элементов, т.е. битов),
<code>ByteArray</code>, <code>ShortArray</code> или <code>UpdatableFloatArray</code>, <code>UpdatableCharArray</code>.
Есть даже подинтерфейсы, описывающие группы примитивных типов, например, <code>PFixedArray</code>:
массив элементов любого из 6 примитивных типов boolean, char, byte, short, int, long.
Однако чаще всего мы будем использовать базовые интерфейсы
<code>PArray</code> и <code>UpdatablePArray</code>,
обеспечивающие универсальную обработку данных любого типа и разрядности.
(Есть также и подинтерфейсы, обеспечивающие, подобно <code>ArrayList</code>, изменение длины массива,
но при обработки изображений они требуется редко.)</p>
<p>Про AlgART-массивы можно рассказывать очень долго &mdash; почти вся библиотека "выстроена" именно вокруг них.
Однако нам пора переходить к следующему понятию - <i>матрице</i>.
Желающие узнать про основные возможности массивов &mdash; читайте package summary к пакету
<code>net.algart.arrays</code> и документацию к конкретным классам и интерфейсам.</p>
<h4 style="margin-bottom: 0px"><a name=Matrix></a>2. AlgART-матрицы</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Array>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#generics>Следующий раздел</a></div>
<p>Как это и принято, растровые изображения, при использовании библиотек AlgART,
будут представлены <i>матрицами</i>. В отличие от сложной и обширной концепции AlgART-массива,
AlgART-матрица &mdash; очень простое понятие, представленное единственным интерфейсом <code>Matrix</code>.
Матрица в библиотеке AlgART всегда хранится в линейном массиве,
строка за строкой (по аналогии с такими языками программирования, как C или Pascal).
Соответственно, чтобы перейти от понятия линейному массива к понятию матрицы, достаточно "добавить"
к массиву набор размерностей вдоль каждой координаты.
В библиотеке AlgART такое "добавление" производится простейшим возможным способом:
композицией. А именно, AlgART-матрица представляет собой всего-навсего <i>пару</i>:</p>
<ol><li><i>AlgART-массив</i> (хранящий элементы матрицы);</li><li><i>набор размеров</i> матрицы.</li></ol>
<p>Соответствующий интерфейс <code>Matrix</code> весьма лаконичен:
он предоставляет доступ к этому массиву и к набору размеров,
а также содержит минимальный набор полезных методов, например,
для вычисления линейного индекса в массиве по индексам в матрице.</p>
<p>Пора заметить: AlgART-матрицы (как и массивы языков C и Паскаль) изначально <i>многомерны</i>.
Для работы с изображениями, конечно, нужны двумерные матрицы.
Однако хорошо написанные алгоритмы обработки матриц
чаще всего не содержат кода, специфического для случая именно двух измерений.
Например, фильтры, сглаживающие изображение, можно без изменений применить
к трехмерным матрицам, описывающим некую физическую среду,
и даже к четырехмерным матрицам, описывающим нечто совсем таинственное.
Возможен и вырожденный случай &mdash; одномерные матрицы.
Они могут использоваться, например, когда модуль, обрабатывающий тип <code>Matrix</code>,
нужно применить к обычному линейному массиву.</p>
<p>Размеры матрицы, как и длина линейного массива, представлены типом
<code>long</code>. Не потому, что это реально необходимо
(хотя теоретически можно представить себе потребность в 30-гигабайтной матрице
3x10&nbsp;000&nbsp;000&nbsp;000),
а потому, что так проще: меньше приходится приводить типы.
Наступление эпохи 64-разрядных процессоров, вероятно, очень скоро сделает операции с типом <code>long</code>
такими же быстрыми, как и с типом <code>int</code>;
так зачем же вводить лишние ограничения?</p>
<p>Впрочем, посвеместное применение типа <code>long</code> требует повышенной аккуратности:
<i>будьте бдительны</i>!
Следует помнить, что при сложении, вычитании или умножении размеров или адресов
возможно целочисленное переполнение с получением нелепого результата.
По этой причине, скажем, в классе <code>Arrays</code>,
содержащем библиотеку "полезных" методов, предусмотрена специальная функция <code>longMul</code>
для перемножения <code>long</code>-чисел с проверкой на переполнение.
Применяйте ее! При сложении и вычитании обычно все проще: так, при сложении 2 неотрицательных
чисел типа <code>long</code> однозначным признаком переполнения является отрицательность суммы.</p>
<p>Все размерности матрицы можно получить соответствующими методами
интерфейса <code>Matrix</code>.
Конечно же, контракт интерфейса <code>Matrix</code>
(заявленный в JavaDoc и свято соблюдаемый в реализациях)
гарантирует, что длина AlgART-массива, хранящего элементы матрицы,
всегда равна произведению размерностей.
Линейный индекс любого элемента матрицы в этом массиве вычисляется по формуле ix+iy*dimX+iz*dimX*dimY+...,
где ix, iy, iz, ... &mdash; индексы элемента в многомерной матрице,
а dimX, dimY, ... &mdash; соответствующие размерности.
Для двумерного случая формула упрощается до ix+iy*dimX.
Имеется метод <code>index</code>, вычисляющий линейный индекс по этой формуле.</p>
<h4 style="margin-bottom: 0px"><a name=generics></a>3. Матрицы и generics: extends или не extends?</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Matrix>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Image2D>Следующий раздел</a></div>
<p>Последнее, что следует сказать про матрицы: интерфейс <code>Matrix</code> обладает
generics-параметром &mdash; типом хранимого массива. Так, матрица элементов примитивного типа описывается как
<code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>,
а матрица, допускающая изменение элементов, как
<code>Matrix&lt;?&nbsp;extends&nbsp;UpdatablePArray&gt;</code>.
Применение generics, как обычно, позволяет улучшить контроль типов и свести к минимуму
необходимость явных приведений типов.</p>
<p>Тут у читателя, особенно недостаточно владеющего технологией generics, может возникнуть резонный вопрос.
Почему <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>, а не просто <code>Matrix&lt;PArray&gt;</code>?
На первый взгляд кажется, что второй, более очевидный вариант вполне равноценен первому.
Ведь, действительно, с переменной типа <code>Matrix&lt;PArray&gt;</code>
можно делать в точности то же самое, что и с <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>:
а именно, извлекать массив типа <code>PArray</code>.</p>
<p>На самом деле равноценность кажущаяся.
Попробуйте создать список <code>java.util.ArrayList</code>, содержащий несколько матриц.
(На практике такие списки, действительно, частенько необходимы &mdash; в алгоритмах,
обрабатывающих сразу серию матриц.)
Вы убедитесь, что
<code>List&lt;Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;&gt;</code> и
<code>List&lt;Matrix&lt;PArray&gt;&gt;</code> &mdash;
вещи совершенно разные и <i>несовместимые</i> друг с другом.
Список первого типа нельзя присвоить переменной второго типа (и наоборот).
Список первого типа нельзя передать в метод, аргумент которого объявлен как список второго типа (и наоборот).
В список второго типа нельзя добавить матрицу типа <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>
(правда, можно наоборот).
Это поведение подробно разбирается в хороших учебниках по Java.</p>
<p>Что же предпочесть: вариант с обобщающим "? extends" или более простые "с виду"
<code>Matrix&lt;PArray&gt;</code> и <code>Matrix&lt;UpdatablePArray&gt;</code>?</p>
<p>Представьте себе функцию, которая принимает матрицу на входе, обрабатывает
и возвращает другую матрицу на выходе.
(Кстати, это типичная ситуация при обработке изображений.)
Хотя бы вот эту:</p>
<pre>
    public Matrix&lt;PArray&gt; myFunction(Matrix&lt;PArray&gt; m) {
        return m; // что может быть проще
    }
</pre>
<p>Написав такую функцию, вы быстро убедитесь, что не можете применить ее
ни к матрице типа <code>Matrix&lt;UpdatablePArray&gt;</code>, ни к матрице конкретного байтового типа
<code>Matrix&lt;ByteArray&gt;</code>.
Иначе говоря, общее правило должно быть таким:
<i>в качестве аргументов методов всегда лучше использовать конструкцию "? extends"</i>.</p>
<p>Для <i>результатов</i> методов, а также при объявлении переменных ситуация не столь однозначна.
Формально, нет никаких проблем, если метод, например, вернет конкретный
<code>Matrix&lt;UpdatablePArray&gt;</code>:
безусловно, такой результат можно будет использовать повсюду, где "подошел" бы тип
<code>Matrix&lt;?&nbsp;extends&nbsp;UpdatablePArray&gt;</code>.
Однако библиотеки AlgART предпочитают и в этом случае использовать
более общий тип с "? extends", и мы в наших у будем следовать этому примеру.</p>
<p>Почему? По той же причине, по которой в языке Java принято максимально строго
контролировать типы &mdash; для минимизации будущих ошибок.
Если бы метод какого-нибудь полезного интерфейса (вроде <code>Image2D</code>,
к которому мы сейчас перейдем) вернул результат конкретный типа
<code>Matrix&lt;UpdatablePArray&gt;</code> или
<code>Matrix&lt;PArray&gt;</code>, возник бы соблазн присвоить
его переменной такого же типа. Далее сей соблазн мог бы "распространиться":
если большинство переменных вашего класса или пакета имеют тип <code>Matrix&lt;PArray&gt;</code>,
почему бы не объявить где-нибудь метод с аргументом такого типа?
Более того, по мере развития вашего кода могут появиться списки матриц,
скажем, <code>List&lt;Matrix&lt;PArray&gt;&gt;</code>.
Все будет замечательно до тех пор, пока не понадобится применить ваши классы
к матрице с массивом другого типа.
Вероятнее всего, это окажется передача в метод, принимающий аргумент
<code>Matrix&lt;PArray&gt;</code>, матрицы <code>Matrix&lt;UpdatablePArray&gt;</code>.
Или, еще хуже, попытка построить список из матриц более частного типа,
скажем, занести в список <code>List&lt;Matrix&lt;PArray&gt;&gt;</code>
конкретную <code>Matrix&lt;BitArray&gt;</code>.
И в этот момент весь ваш код придется переписывать &mdash;
переводить его на "правильные" рельсы <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>.
Автор, между прочим, в процессе разработки библиотек пару раз "наступал" на эти грабли.</p>
<p>Гораздо лучше ограничить себя с самого начала и <i>всегда</i>
применять конструкцию "? extends". Что и сделано в библиотеках AlgART.</p>
<p>Подробнее про матрицы читайте JavaDoc-документацию к интерфейсу <code>Matrix</code>.
<h4 style="margin-bottom: 0px"><a name=Image2D></a>4. Двумерные изображения: Image2D</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#generics>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#SimplestTutorialDemo>Следующий раздел</a></div>
<p>Вообще говоря, абстракции матрицы уже достаточно, чтобы создавать практически
любые алгоритмы обработки изображений.</p>
<p>(Обращаю внимание: я говорю не разработке графических пакетов типа Photoshop, где работа с цветом
исключительно важна, а о математических алгоритмах, предназначенных для обработки и анализа
изображений. Именно таким алгоритмам посвящена данная статья.
Алгоритмы, как правило, работают именно с матрицами.)</p>
<p>Действительно, полутоновое изображение (наиболее популярный тип для задач анализа и распознавания)
всегда можно представить числовой матрицей, содержащей яркости пикселов.
Цветное изображение очевидным образом представляется несколькими "параллельными" матрицами одинакового размера,
содержащими цветовые составляющие для каждого пиксела.
Так, RGB-изображение можно представить как систему из 3 матриц,
содержащих red-, green- и blue-компоненты.
Прочие цветовые модели &mdash; HSL, HSV, ARGB, CMYK, YUV, XYZ, ... &mdash;
также сводятся к системе матриц, как правило, 3 или 4.
Соответственно, для представления любого изображения можно всегда использовать либо переменную типа
<code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code> (в случае полутонового изображения),
либо (в зависимости от алгоритма) 3 или 4 такие переменные,
либо очень простой класс с 3 или 4 полями типа <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>,
созданный специально для группы алгоритмов, нетривиально обрабатывающих цветность
(например, конвертирующих HLS в RGB).</p>
<p>На самом деле, в рамках пакета <code>net.algart.arrays</code> и его подпакетов так оно и есть.
Все базовые алгоритмы, рассчитанные на работу с изображениями и реализованные в этом пакете и подпакетах,
как правило, работают с единственной матрицей, представляющей полутоновое изображение.
При желании, эти методы можно вызвать для любой выбранной цветовой
компоненты или для всех цветовых компонент по очереди.
Скажем, простейшее сглаживание цветной RGB-картинки (удаление мелкого аддитивного шума)
сводится к применению соответствующего библиотечного метода по очереди к трем матрицам,
представляющим цветовые компоненты.</p>
<p>Иначе говоря, я вынужден огорчить пользователей, привыкших к пакетам типа java.awt или JAI.
В библиотеках AlgART <i>отсутствует</i> поддержка цветности.
Такую цену пришлось заплатить за алгоритмическую мощь и универсальность библиотек
применительно к массивам и матрицам.
По-настоящему качественная, современная реализация понятия цветности сделала бы сроки
выхода библиотек AlgART абсолютно неприемлемыми.
Надо сказать, что изображения и не являются основной и единственной областью применения библиотек.
AlgART-массивы и матрицы с тем же успехом могут использоваться практически в <i>любых</i>
численных расчетах: например, при решении систем линейных уравнений или физическом моделировании.</p>
<p>Однако, если все же говорить о применении библиотек AlgART к обработке изображений,
то совсем игнорировать цветность было бы неправильно.
Большая часть изображений, встречающихся в реальной жизни &mdash; полученные,
например, со сканера, фотоаппарата или видеокамеры &mdash; как правило, цветные.
Было бы неудобно, если бы <i>вообще</i> отсутствовал какой-либо стандартный класс,
позволяющий хранить такое изображение и передавать его универсальным алгоритмам,
рассчитанным на обработку AlgART-матриц (например, фильтрующим помехи или выделяющим контура частиц).
Такой класс &mdash; точнее, интерфейс &mdash; действительно существует.
Это интерфейс <code>Image2D</code>,
расположенный в отдельном пакете <code>com.simagis.images.color</code>
и описывающий либо полутовое, либо цветное двумерное изображение.</p>
<p>Данный интерфейс расположен вне пакета <code>net.algart</code>:
формально он не входит в состав библиотек AlgART.
Иначе говоря, автор библиотек AlgART старательно открещивается от всяких упреков
по поводу этого интерфейса. Если он покажется вам убогим, почему бы вам не написать свой?</p>
<p>Интерфейс <code>Image2D</code> практически тривиален.
<code>Image2D</code> &mdash; это просто либо одна AlgART-матрица
<code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>
(содержащая яркости пикселов полутонового изображения),
либо три таких матрицы (R, G и B-компоненты) с идентичными размерами, объединенные в одном объекте.
Имеются методы извлечения матриц <code>i()</code>, <code>r()</code>, <code>g()</code>, <code>b()</code>
и метод <code>isGrayscale()</code>, возвращаюший логическое значение: является ли изображение
полутоновым. Это практически все.</p>
<p>Никакие другие модели, кроме RGB, не поддерживаются.
Единственная цель существования интерфейса &mdash;
обеспечить простой способ хранения изображений
и применения к ним алгоритмов, умеющих обрабатывать матрицы.
Для RGB-картинок такое применение практически тривиально:
как правило, это либо простой покомпонентый вызов метода,
рассчитанного на тип <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>,
для каждой из 3 матриц R, G, B, либо &mdash; что более типично для задач анализа &mdash;
получение матрицы яркостей пикселов по стандартной формуле 0.299r+0.587g+0.114b
и применение метода уже к ней.
Такую матрицу яркостей, в случае цветного изображения,
автоматически возвращает метод <code>i()</code>.</p>
<p>Интерфейса <code>Image2D</code> достаточно для большинства алгоритмов обработки и анализа,
включая всевозможную фильтрацию, выделение границ, структуры, анализа частиц и других геометрических объектов.
Алгоритмы, которые нуждаются в специальном анализе других типов цветности,
например, HLS, оперируют другими классами, обычно аналогичными <code>Image2D</code>.</p>
<p>Далее в этой статье мы будем рассмотривать примеры алгоритмов,
обрабатывающих объекты типа <code>Image2D</code>.</p>
<h3 style="margin-bottom: 0px"><a name=SimplestTutorialDemo></a>Часть I.
Чтение и создание изображения: класс SimplestTutorialDemo</h3>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Image2D>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#toGrayscale>Следующий раздел</a></div>
<p>Далее мы рассмотрим &mdash; с душераздирающей подробностью &mdash;
маленький и очень простой класс <code>SimplestTutorialDemo</code>.
Это специально написанный учебный класс, состоящий из static-методов
и решающий настолько тривиальные задачи, насколько я смог придумать.
Зато он решает их множеством способов, начиная с самых простых и кончая самыми правильными.
В процессе совершенствования способа решения вы сможете шаг за шагом
ознакомиться с фундаментальными концепциями библиотек AlgART.</p>
<p>Если есть возможность, рекомендую открыть исходник этого класса в какой-нибудь оболочке,
позволяющей легко получать JavaDoc-комментарии к любому вызываемому библиотечному методу:
изучение этих комментариев может помочь пониманию.
Исходный файл класса доступен здесь:
<a href=SimplestTutorialDemo.java>SimplestTutorialDemo.java</a>.</p>
<p>Прежде чем начинать разбор класса, надо сделать одно замечание.
Все методы этого класса (и прочих учебных классов, рассматриваемых в этой статье),
используют специальную аннотацию <code>@Name</code>, импортируемую из пакета
<code>com.simagis.plugin3</code>.
Об этом следует упомянуть, главным образом, для того, чтобы вы не обращали на нее внимания.
Никакого влияния на исполнение кода она не оказывает,
и никакого значения для понимания используемых приемов она не имеет.
На самом деле эта аннотация нужна для единственной цели:
приписать параметрам методов символьные имена,
которые, в отличие от обычных имен аргументов методов, сохраняются в скомпилированном байт-коде
и доступны для внешнего приложения, вызывающего этот класс.
Благодаря информации об именах параметров, такое приложение может упростить запуск методов,
предоставляя визуальный интерфейс для настройки конкретных параметров.</p>
<p>Примером такого приложения является <a href=http://algart.net/ww/simagis.com/>SIMAGIS</a>:
система обработки изображений, ради которой, в значительной степени, создавались обсуждаемые библиотеки.
Эта система позволяет также создавать и визуализировать изображения типа <code>Image2D</code>,
что, как легко видеть, довольно полезно, если вы хотите проверить рассматриваемые методы на практике.</p>
<h4 style="margin-bottom: 0px"><a name=toGrayscale></a>1. Конверсия RGB-изображения в полутоновое</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#SimplestTutorialDemo>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_1>Следующий раздел</a></div>
<p>Не думайте, что я на самом деле собираюсь описывать, как решается такая задача.
Пока рано. Речь идет всего лишь о вызове готового метода, предусмотренного
в интерфейсе <code>Image2D</code>.</p>
<p>Итак, вот наш первый пример:</p>
<pre>
    public static Image2D toGrayscale(Context context, @Name("image")Image2D image) {
        ImageContext imageContext = context.as(ImageContext.class);
        Matrix&lt;? extends PArray&gt; m = image.i();
        Image2D result = imageContext.newGrayscaleImage2D(m);
        return result;
    }
</pre>
<p>Уже декларация метода требует от нас остановиться и внимательно рассмотреть его первый параметр.
Что это за <code>Context</code>?</p>
<p>Имею честь представить концепцию <i>контекста</i>, реализованную в библиотечном пакете
<code>net.algart.contexts</code>.
Расскажу о контекстах в двух словах. Как обычно, желающие могут прочитать обстоятельные
JavaDoc-комментарии в документации к пакету.</p>
<p>Если очень коротко, <i>контекст алгоритма</i>
(или, в общем случае, <i>контекст</i> произвольных вычислений или других операций) &mdash;
это информация, которая не настолько важна, чтобы служить входными данными или параметрами алгоритма,
но которая в то же время способна оказать влияние на его работу.</p>
<p>Наверно, самый очевидный пример контекста &mdash; сама Java-машина
(или операционная система в языках типа C/C++). Именно она отвечает за
исполнение любого оператора <code>new</code>, отводящего блок памяти,
а без такого оператора затруднительно написать даже самый простейший алгоритм.
Внутренняя информация JVM, прежде всего, доступный объем памяти в "куче",
безусловно, влияет на работу любого алгоритма, хотя формально не содержится в его входных параметрах.
Действительно, при одном количестве памяти алгоритм выдаст <code>OutOfMemoryError</code>,
а при другом &mdash; сработает нормально.
Это означает, что в принципе можно считать JVM неявным параметром,
передаваемым каждому алгоритму. (Кстати, неявное становится явным,
когда мы пишем native-метод Java-класса на языке C:
каждому native-методу передается указатель на среду исполнения Java-машины.)</p>
<p>JVM и ее память &mdash; контекст <i>глобальный</i>, общий для всего Java-приложения.
Такой контекст не надо как-то специально передавать в библиотечные классы,
решающие те или иные задачи.
Другим примером глобального контекста может служить файловая система:
с помощью системного свойства (<code>System.getProperty</code>)
алгоритм, требующий непомерных объемов временных данных,
может узнать каталог временных файлов операционной системы
и сохранить наиболее "тяжелые" временные объекты на диске.
Еще один пример &mdash; логгеры <code>java.util.logging</code>:
они настраиваются глобально для всего приложения и при этом иногда используются внутри алгоритмов.
Если вы прочитали package summary к пакету <code>net.algart.arrays</code>,
вы могли обратить внимание, что эта библиотека использует немало контекстной информации подобного рода,
передаваемой через системные свойства (system properties).</p>
<p>К сожалению, не всякую информацию, полезную для исполнения алгоритма, можно передать "глобально",
настраивая те или иные системные свойства, глобальные константы и т.п.
Скажем, рассмотрим типичную проблему: показать пользователю ход исполнения алгоритма.
Ведь не все алгоритмы заканчивают работу в долю секунды.
Что, если решаемая задача требует нескольких минут или даже часов?
Еще хуже, если требуемое время сильно и сложным образом зависит от параметров.
В этом случае, когда пользователь выбрал неудачные параметры алгоритма, надо дать ему понять, что
задача будет решаться не меньше часа и неплохо бы ее прервать (или пойти обедать).</p>
<p>Как "научить" абстрактный математический алгоритм, например,
решающий систему уравнений или фильтрующий изображение,
показывать проценты своего исполнения?
Глобальные настройки приложения (вроде каталога временных файлов) здесь не спасают:
у приложения может быть несколько окон, и в каждом может параллельно исполняться свой алгоритм,
требующий отдельного визуального элемента для вывода процентов.
Можно, конечно, передать функции (или классу) специальный параметр, скажем, JProgressBar,
если вам не жаль уродовать изящную архитектуру чисто алгоритмического модуля
столь "приземленными" деталями.
Но что делать, если, кроме процента выполнения, понадобится что-то еще?
Например, специальный слушатель, реагирующий на кнопку Stop и останавливающий расчеты?
(Стандартный вызов Thread.interrupt, увы, в текущей версии Java несовместим
с библиотекой <code>net.algart.arrays</code>: об этом можно прочесть в JavaDoc.)
Возникает ситуация, напоминающая причины, по которым в современные языки добавили механизм исключений.
А именно: чтобы предусмотреть передачу алгоритму всех возможных полезных ему вещей,
нужно загромоздить простой и ясный API вызова алгоритма передачей всех этих вещей.</p>
<p>Интерфейс <code>Context</code>, передаваемый первым параметром в наш самый первый метод &mdash;
это в меру изящное (будем надеяться) решение, предлагаемое библиотеками AlgART.</p>
<p>Сам по себе интерфейс <code>Context</code> почти тривиален
и не позволяет алгоритму узнать ничего "полезного".
Основной метод этого интерфейса выглядит так:</p>
<pre>
    public &lt;T extends Context&gt; T as(Class&lt;T&gt; contextClass);
</pre>
<p>Этот метод &mdash; своего рода "шлюз", позволяющий алгоритму узнать практически все, что угодно.
Идея в том, что метод <code>as</code> возвращает некий
<i>частный</i> контекст &mdash; экземпляр некоторого наследника <code>Context</code>.
А вот этот наследник уже может иметь практически полезные методы, необходимые алгоритму.
Предполагается, что вызывающий код
(в нашем случае приложение, вызывающее методы <code>SimplestTutorialDemo</code>)
передаст такую реализацию <code>Context</code>, которая сможет вернуть все необходимые
алгоритму частные контексты. Создаются такие реализации достаточно просто.
Более того, набор поддерживаемых контекстов может загружаться в виде сервис-провайдеров
и определяться уже после компиляции конечного приложения.
Желающие могут посмотреть JavaDoc к пакету <code>net.algart.contexts</code>
или исходники законченных примеров, такие, как <code>SimpleImageContext</code>.</p>
<p>Первая же строчка вызываемого метода выполняет операцию извлечения частного контекста.
Это вызов метода второго варианта <code>as</code>:</p>
<pre>
        ImageContext imageContext = context.as(ImageContext.class);
</pre>
<p>Методу <code>as</code> передается класс <code>ImageContext.class</code>
&mdash; конкретный частный контекст, нужный нашему алгоритму.
Единственная его задача &mdash; создание экземпляра <code>Image2D</code> по имеющейся AlgART-матрице
или набору AlgART-матриц. Что и делается в конце нашего метода <code>toGrayscale</code>:</p>
<pre>
        Image2D result = imageContext.newGrayscaleImage2D(m);
</pre>
<p>Что произойдет, если реализация <code>Context</code>, переданная приложением в наш метод,
"не умеет" возвращать экземпляры <code>ImageContext</code>?
В этой ситуации будет возбуждено необъявляемое исключение <code>UnsupportedContextException</code>.
Если вернуться к аналогии с виртуальной машиной (в качестве "неявного" контекста),
эту ошибку можно сравнить с ситуацией, когда мы исполняем Java-приложение на виртуальной
машине, не поддерживающей нужный набор библиотечных классов (скажем,
на если мы запускаем программу на устаревшей версии JVM,
или если мы пытаемся выполнить J2EE-программу на виртуальной машине J2SE).</p>
<p>Правильно документированный класс должен декларировать
в JavaDoc-комментариях полный набор необходимых ему контекстов &mdash;
так же, как обычно декларируется необходимая классу версия Java.
(Наш учебный класс, ради простоты, вообще не снабжен документитацией.)
Большинство классов требуют, как минимум, поддержки стандартых контекстов,
реализуемых стандартным классом <code>DefaultContext</code> (см. JavaDoc).</p>
<p><code>ImageContext</code> &mdash; типичный пример частного контекста-фабрики.
Мы и далее будем сталкиваться с ситуациями, когда для генерации экземпляров абстрактных интерфейсов
привлекаются частные контексты-фабрики.
(Сравните: первым рассмотренным выше примером контекста была JVM, реализующая оператор <code>new</code>,
т.е. базовый оператор-фабрику языка Java.)
Такой подход значительно повышает гибкость системы.
Приложение, вызывающее алгоритмический метод, который должен вернуть некую сущность
&mdash; реализацию интерфейса,
может передать через контекст такую фабрику, которая будет создавать экземпляры наиболее
удобного для приложения типа.
Так, реализация <code>ImageContext</code>, передаваемая системой <a href=http://algart.net/ww/simagis.com/>SIMAGIS</a>,
создает такие <code>Image2D</code>, которые изначально "умеют" храниться в ячейках таблиц SIMAGIS.
Это значительно упрощает интеграцию в систему классов вроде нашего
<code>SimplestTutorialDemo</code> (в терминах SIMAGIS они называются "плагинами").</p>
<p>Фабрики &mdash; далеко не единственный пример контекстной информации.
В дальнейших методах мы увидим, как из параметра типа <code>Context</code>,
как "чертики из коробочки", "выскакивают" самые различные частные контексты,
сообщающие алгоритму необходимые дополнительные сведения или позволяющие сделать
другие полезные вещи.</p>
<p>Собственно, мы рассмотрели почти весь метод <code>toGrayscale</code>.
Он ведь абсолютно тривиален. Все, что здесь происходит, помимо
получения контекста и возврата результата, это выделение яркостной компоненты изображения:</p>
<pre>
        Matrix&lt;? extends PArray&gt; m = image.i();
</pre>
<p>Если входное изображение <code>image</code> было цветое (RGB),
то матрица <code>m</code> будет содержать
яркости каждого пиксела, рассчитанные по формуле 0.299r+0.587g+0.114b.
Если полутоновое, то <code>m</code> будет содержать непосредственно значения интенсивности пикселов.
Как в действительноти это реализовано, мы пока рассматривать не будем:
решение подобных задач будет темой одной из следующих глав.
После получения <code>m</code>, метод контекста <code>newGrayscaleImage2D</code> превращает
полученную матрицу обратно в экземпляр <code>Image2D</code>, уже заведомо полутоновой.
Он и возвращается методом.</p>
<h4 style="margin-bottom: 0px"><a name=meanOf_1></a>2. Вычисление средней яркости самым плохим способом: покоординатный цикл</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#toGrayscale>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_2>Следующий раздел</a></div>
<p>Надо полагать, читатель уже изрядно устал.
Уже столько всего рассказано, а мы ведь до сих пор не сделали ровно ничего интересного.
Мы даже пока не пробовали решить столь простую задачу,
как чтение численного значения яркости конкретного пиксела.</p>
<p>Что ж, вот наш следующий метод:</p>
<pre>
    public static double meanOf_1(Context context, @Name("image")Image2D image) {
        Matrix&lt;? extends PArray&gt; m = image.i();
        PArray a = m.array();
        long dimX = m.dimX();
        long dimY = m.dimY();
        double sum = 0.0;
        for (long i = 0; i &lt; dimY; i++) {
            for (long j = 0; j &lt; dimX; j++) {
                long index = m.index(j, i);
                sum += a.getDouble(index);
            }
        }
        return sum / (dimX * dimY);
    }
</pre>
<p>Вычисление средней яркости всех пикселов &mdash; наверно, самая простая
возможная задача анализа изображения. Попробуем разобрать приведенный
выше пример решения этой задачи: наверно, самый очевидный из всех возможных
(правда &mdash; забегая вперед &mdash; и чуть ли не самый худший).</p>
<p>Как и раньше, в качестве первого параметра здесь передается контекст.
Однако он никак не используется. На самом деле это редчайшее исключение.
В реальных, не учебных методах контекст нужен почти всегда.
Параметр <code>Context</code> в декларации метода сохранен "на всякий случай".
Когда вы сами будете писать практические методы, если даже вам покажется,
что контекст не нужен, на всякий случай всегда включайте его в список параметров.
Вполне возможно, что по мере будущего развития и усложнения метода контекст все же понадобится,
а изменить декларацию будет уже нельзя по соображениям совместимости.</p>
<p>Кстати, заметим: по негласной традиции, контекст всегда должен передаваться самым первым параметром.</p>
<p>Первый оператор метода нам уже знаком: это получение матрицы интенсивностей <code>m</code>.
В случае цветного изображения, это фактически означает автоматическую конверсию в
"ближайшее по яркости" полутоновое изображение.
Очень многие промышленные алгоритмы анализа и распознавания изображений
начинаются с такого оператора: достаточно редко цветовая информация настолько важна,
что реально помогает проанализировать (например, измерить) изображенные предметы.</p>
<p>Следующим оператором мы "спускаемся" еще на один шаг по иерархии вложенных объектов:
получаем из матрицы <code>m</code> линейный AlgART-массив <code>a</code>, хранящий
(строка за строкой) все элементы матрицы. Напомню, что AlgART-матрица
&mdash; <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Matrix>всего-навсего пара</a> "AlgART-массив" + "набор размерностей".
Поэтому метод извлечения массива, <code>array()</code>, встречается весьма часто.
Равно как и следующие два метода, извлекающие размеры матрицы по горизонтали и вертикали:
<code>dimX</code> и <code>dimY</code>.</p>
<p>Посмотрим на следующий далее цикл.
Для каждой пары координат <code>i</code> и <code>j</code> вычисляется индекс в линейном
массиве <code>a</code>, и затем по индексу из массива извлекается вещественное числа,
которое прибавляется к общей сумме <code>sum</code>:</p>
<pre>
                long index = m.index(j, i);
                sum += a.getDouble(index);
</pre>
<p>(Напоминаю: все индексы и размеры в AlgART-массивах и AlgART-матрицах 63-разрядные,
поэтому используется тип <code>long</code>.)</p>
<p>На что здесь надо обратить внимание? Прежде всего, на порядок аргументов метода <code>index</code>.
Первым идет индекс по x-координате (т.е. <code>j</code>), вторым &mdash; по y (т.е. <code>i</code>).
Если бы мы имели дело с трехмерной матрицей, следующим аргументом был бы индекс по z.
Это необходимо запомнить.
Если бы матрица хранилась в двумерном Java-массиве <code>m[][]</code>,
то, вероятно, порядок употребления индексов был бы обратный: <code>m[i][j]</code>
(хотя, разумеется, это вопрос вкуса программиста).</p>
<p>Далее, обратите внимание на число аргументов метода <code>index</code>.
Если вы заглянете в интерфейс <code>Matrix</code>, вы увидите, что это &mdash;
метод с переменным числом параметров (vararg).
Что произойдет, если вы случайно укажете недостаточное или слишком большое количество аргументов?</p>
<p>Согласно JavaDoc-комментариям к <code>Matrix</code>, методы этого интерфейса,
в том числе <code>index</code>, ведут себя так, как будто число измерений матрицы <i>бесконечено</i>.
Но при этом все размеры матрицы "за пределами" истинного числа размерностей считаются равными 1,
а все недостающие аргументы метода <code>index</code> подразумеваются равными 0.
Так, наша двумерная матрица "очень похожа" на трехмерную матрицу
<code>dimX&nbsp;x&nbsp;dimY&nbsp;x&nbsp;1</code> и на четырехмерную матрицу
<code>dimX&nbsp;x&nbsp;dimY&nbsp;x&nbsp;1&nbsp;x&nbsp;1</code>.
Мы имеем право вместо <code>m.index(j,&nbsp;i)</code> написать
<code>m.index(j,&nbsp;i,&nbsp;0)</code> или даже
<code>m.index(j,&nbsp;i,&nbsp;0,&nbsp;0)</code>:
результат будет точно такой же.
Можем мы написать и так: <code>m.index(j)</code>:
это будет то же самое, что и <code>m.index(j,&nbsp;0)</code>.
А вот если мы попытаемся 3-м или 4-м аргументом передать ненулевое число,
произойдет ошибка <code>IndexOutOfBoundsException</code>:
у нашей матрицы если только одна, нулевая "плоскость" в трехмерном пространстве
и только одна, нулевая "гиперплоскость" в четырехмерном.</p>
<p>Перейдем теперь к следующему оператору: <code>sum&nbsp;+=&nbsp;a.getDouble(index)</code>.
Сразу возникает очевидный вопрос: почему double?
Мы ведь еще нигде не говорили о разрядности нашего изображения.
Нашему методу можно передать 8-битовое, 16-битовое, вещественное или даже 1-битовое (бинарное) изображение.
Декларация <code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code> говорит о том,
что мы имеем дело с любым из 8 примитивных типов Java.</p>
<p>Интерфейс <code>PArray</code> &mdash; общий предок всех частных интерфейсов,
описывающих массивы конкретных примитивных типов. В тех интерфейсах,
например, <code>ByteArray</code>, имеются специальные методы для получения значений нужной разрядности:
<code>getByte</code> для <code>ByteArray</code>, <code>getBit</code> (результат <code>boolean</code>)
для <code>BitArray</code>, и т.д.
Но уже в самом общем интерфейсе <code>PArray</code> объявлены методы <code>getDouble</code>
и <code>getLong</code>, позволяющие прочитать числовое значение любой разрядности, с автоматической
конверсией к типу <code>double</code>.</p>
<p>Правила конверсии четко специфицированы в JavaDoc.
Обратите на них внимание: их надо запомнить!
Наиболее важно для нас следующее:
<i>по соглашению библиотеки AlgART, типы данных <code>byte</code> и <code>short</code>
везде, где возможно, интерпретируются как беззнаковые</i>.
Иначе говоря, cчитается, что каждый элемент AlgART-массива <code>ByteArray</code>
содержит целое число от 0 до 2<sup>8</sup>-1=255,
а каждый элемент AlgART-массива <code>ShortArray</code>
содержит целое число от 0 до 2<sup>16</sup>-1=65535.
(Однако, типы <code>int</code> и <code>long</code> считаются <i>знаковыми</i>:
изменяющимися от -2<sup>31</sup> до 2<sup>31</sup>-1 и от -2<sup>63</sup> до 2<sup>63</sup>-1
соответственно.)
В частности, для элемента байтового массива,
содержащего двоичное число 11111111, метод <code>getDouble</code> <i>возвращает 255</i>
(а не -1, как можно было бы подумать).</p>
<p>Да, это противоречит традиции языка Java, в котором все
целочисленные типы данных всегда знаковые.
Но это намного удобнее почти во всех алгоритмах,
имеющих дело с массивами 8- или 16-битовых целых чисел.
В частности, это удобно при работе с изображениями.
Ведь яркость пиксела описывается неотрицательным числом.
При разрядности <code>int</code> или <code>long</code> вполне можно "пожертвовать"
последним 32-м (64-м) битом и представлять пикселы неотрицательными значениями
Java-типов <code>int</code> и <code>long</code>. И действительно,
для реальных изображений при такой разрядности наш объект <code>Image2D</code> всегда
будет содержать 0 в старшем (знаковом) бите каждого элемента.
Однако 8- и даже 16-битовая точность не настолько велика, чтобы игнорировать один бит.
Здесь гораздо удобнее использовать для представления неотрицательной яркости все 8 или 16 битов.</p>
<p>Разумеется, при необходимости (и желании) вам ничто не мешает проинтерпретировать
8- и 16-битовые элементы AlgART-массивов и матриц в классическом смысле,
как знаковые величины. Это потребовало бы некоторого усложения кода:
проверки, что мы имеем дело с конкретным частным подинтерфейсом,
и соответствующим приведением типа. Например:</p>
<pre>
                long index = m.index(j, i);
                double value;
                if (a instanceof ByteArray) {
                    value = (byte)((ByteArray)a).getByte();
                    // getByte() возвращает тип int, а не byte, причем
                    // этот int-результат неотрицательный (0..255),
                    // в соответствии с соглашениями библиотеки.
                    // Поэтому необходим дополнительный оператор
                    // приведения типа: (byte)(...)
                } else if (a instanceof ShortArray) {
                    value = (short)((ShortArray)a).getShort();
                    // getShort(), аналогично, возвращает неотрицательный
                    // int (0..65535), поэтому необходим оператор
                    // приведения типа: (short)(...)
                } else {
                    value = a.getDouble(index);
                }
                sum += value;
</pre>
<p>На практике, однако, такая необходимость вряд ли будет встречаться сколько-нибудь часто.</p>
<p>На этом мы заканчиваем разбор метода. Последний его оператор вполне тривиален:
конечно, средняя яркость есть сумма всех элементов, деленная на их количество,
т.е. на dimX&nbsp;*&nbsp;dimY.</p>
<h4 style="margin-bottom: 0px"><a name=meanOf_2></a>3. Вычисление средней яркости чуть менее плохим способом: цикл по массиву</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_1>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_3>Следующий раздел</a></div>
<p>Пора заняться усовершенствованием нашего алгоритма.
На самом деле, наш цикл, который смотрелся бы вполне уместно при обработке
классического двумерного массива Java,
при обработке AlgART-матрицы &mdash; одно из наихудших решений в плане эффективности.
Рассмотренный только что пример полезен с точки зрения обучения, так как знакомит
с некоторыми важными концепциями доступа к элементам.
Но на практике так писать не следует почти никогда &mdash;
разве что если быстродействие вас совершенно не интересует.</p>
<p>Самый очевидный недостаток цикла "бросается в глаза", даже если ничего не знать
об архитектуре AlgART-массивов. Раз все равно все элементы хранятся в линейном массиве,
зачем делать вложенные циклы по x и по y?
Ведь их можно просуммировать одним циклом по линейному массиву?</p>
<p>Исправим это:</p>
<pre>
    public static double meanOf_2(Context context, @Name("image")Image2D image) {
        Matrix&lt;? extends PArray&gt; m = image.i();
        PArray a = m.array();
        long length = a.length();
        double sum = 0.0;
        for (long k = 0; k &lt; length; k++) {
            sum += a.getDouble(k);
        }
        return sum / length;
    }

</pre>
<p>Здесь мы вообще игнорируем размерности матрицы, а сразу извлекаем исходный AlgART-массив
и работаем исключительно с ним. Как результат, исчез вызов метода <code>index</code>.</p>
<p>Хотя метод <code>index</code> кажется тривиальным, он все-таки тратил определенное время.
Не только на вычисление индекса (j+dimX*i), но и на проверку аргументов:
как всякий добропорядочный метод, он проверяет, что переданные покоординатные индексы корректны
(не отрицательны и меньше соответствующих размеров матрицы).
В итоге, на моем компьютере новая версия обрабатывает большую 8-битовую картинку
примерно на 30% быстрее.</p>
<p>Заметим, что метод <code>index</code> в действительности используется весьма редко,
особенно во внутренних циклах алгоритма.
Чаще всего элементы "перебираются" последовательно, и на каждой итерации достаточно
просто перейти к следующему элементу линейного AlgART-массива.
И даже когда нужен более сложный порядок анализа элементов,
обычно эффективнее работать непосредственно с индексом в линейном массиве:
например, прибавлять к нему заранее заготовленные смещения, соответствующие тем или иным
сдвигам координтат в матрице.</p>
<p>Дополнительным преимуществом нового алгоритма оказалась нечувствительность к числу измерений.
Без каких-либо изменений такой цикл способен вычислить среднее значение и 3-мерной матрицы,
и 1-мерного массива. Как уже говорилось, такая универсальность присуща
очень многим профессиональным алгоритмам обработки AlgART-матриц.</p>
<h4 style="margin-bottom: 0px"><a name=meanOf_3></a>4. Вычисление средней яркости: пора вспомнить о пользователе</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_2>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_4>Следующий раздел</a></div>
<p>Наш метод решает слишком простую задачу, чтобы выполняться долго.
Тем не менее, последняя его реализация еще достаточно плоха, и поэтому способна
продемонстрировать проблемы, возникающие у сложных "долгоиграющих" алгоритмов.
По крайней мере, если передать нашему методу матрицу, сравнимую по размерам
с оперативной памятью компьютера, алгоритм "задумается" весьма ощутимо.
Может быть, на несколько секунд или даже минут.</p>
<p>Что может предпринять пользователь в это время? Да ничего.
Или сидеть и ждать, или переключиться на другую задачу.
Наш цикл не содержит никаких операторов, которые позволили бы его прервать или хотя
бы показать, какой процент работы уже готов.</p>
<p>Перед тем как переходить к дальнейшей оптимизации метода,
вспомним про контексты и ликвидируем указанные недостатки.
А именно, "научим" алгоритм прерываться и показывать проценты исполнения.
На самом деле, правила хорошего тона требуют, чтобы такие вещи умел практически
любой профессиональый алгоритм &mdash; за исключением гарантированно быстрых методов,
вроде решения одного квадратного уравнения или вставки одного элемента
в сбалансированное дерево.</p>
<p>Итак:</p>
<pre>
    public static double meanOf_3(Context context, @Name("image")Image2D image) {
        ProgressUpdater pu = context.as(ProgressUpdater.class);
        InterruptionContext ic = context.as(InterruptionContext.class);
        Matrix&lt;? extends PArray&gt; m = image.i();
        PArray a = m.array();
        long length = a.length();
        double sum = 0.0;
        for (long k = 0; k &lt; length; k++) {
            sum += a.getDouble(k);
            if ((k &amp; 0xFFFF) == 0) { // equivalent to k%65536==0
                ic.checkInterruption();
                pu.updateProgress((double)(k + 1) / (double)length, false);
            }
        }
        return sum / length;
    }
</pre>
<p>Здесь мы получаем два частных контекста:
<i>контекст прогресса</i> <code>ProgressUpdater</code> и
<i>контекст прерываний</i> <code>InterruptionContext</code>,
и используем их, чтобы решить две задачи:
визуализацию хода исполнения и возможность прерывания алгоритма.</p>
<p>Если мы вызовем метод <code>meanOf_3</code> из "доброжелательной" системы,
такой, как <a href=http://algart.net/ww/simagis.com/>SIMAGIS</a>,
предоставляющей "умные" реализации всех стандартных и многих нестандартных частных контекстов,
то система сможет "красиво" показать исполнение нашего цикла в виде &mdash; например,
"полоски прогресса" (JProgressBar) &mdash; и остановить наш цикл при помощи соответствующей кнопки
в пользовательском интерфейсе.</p>
<p><a name=DefaultContext></a>Но что делать, если же мы захотим вызвать этот метод из более
простой программы, в которой не предусмотрены средства для визуализации
хода исполнения и прерывания работы?</p>
<p>В этом случае к нашим услугам "<i>контекст-заглушка</i>",
возвращаемый методом <code>DefaultContext.getInstance()</code>.
Это метод возвращает экземпляр почти тривиального класса <code>DefaultContext</code>,
реализующего сразу несколько стандартных, общеупотребительных частных контекстов,
которые предусмотрены в пакете <code>net.algart.contexts</code> и могут понадобиться
практически в любой задаче.
Нужные нам сейчас <code>ProgressUpdater</code> и <code>InterruptionContext</code>
относятся к их числу и поддерживаются объектом <code>DefaultContext.getInstance()</code>.
Реализация, предлагаемая этим объектом, на практике почти бесполезна: это именно "заглушка".
Если передать <code>DefaultContext.getInstance()</code> в наш метод,
то частный контекст <code>ProgressUpdater</code> не покажет никаких процентов исполнения,
а частный контекст <code>InterruptionContext</code> не поможет остановить вычисления.
Однако наш метод, по крайней мере, не выдаст исключения и решит свою задачу.</p>
<p>(Впрочем, на самом деле контекст-заглушка не совсем тривиален.
Если он используется для получения стандартных контекстов, реализуемых классом
<code>DefaultContext</code>, то, и правда, возвращаемые контексты не делают ничего "умного".
Но если мы потребуем от контекста-заглушки вернуть <i>нестандартный</i> контекст,
такой как использованный в первом нашем примере <code>ImageContext</code>,
то контекст-заглушка предпримет дополнительную попытку обслужить запрос,
обратившись к набору так называемых сервис-провайдеров.
С помощью этой техники внешнее приложение способно обеспечить "заглушками"
даже нестандартные контексты, возможно, применяемые в библиотечных модулях.
Подробнее см. JavaDoc-комментарии к классам <code>AbstractContext</code> и
<code>DefaultContext</code>.)</p>
<p>Теперь рассмотрим, как <code>ProgressUpdater</code> и
<code>InterruptionContext</code> используются в алгоритме.
В нашем методе мы время от времени,
а именно, раз в 65536 итераций, обращаемся к методам этих интерфейсов:</p>
<pre>
            if ((k &amp; 0xFFFF) == 0) { // equivalent to k%65536==0
                ic.checkInterruption();
                pu.updateProgress((double)(k + 1) / (double)length, false);
            }
</pre>
<p>Метод <code>checkInterruption()</code> в правильно реализованном контексте прерываний
<code>InterruptionContext</code> проверяет тот факт, что пользователь пытается
остановить вычисления: например, что была нажата кнопка Stop.
В этом случае метод выбрасывает исключение <code>net.algart.contexts.InterruptionException</code>,
в результате чего метод естественным образом завершается.
Программа может отловить это исключение, чтобы удостовериться, что метод действительно был прерван
и, например, сообщить об этом пользователю.</p>
<p>Обратите внимание: в отличие от стандартного <code>InterruptedException</code>,
исключение <code>InterruptionContext</code> <i>необъявляемое</i>. Это не случайно.
Вспомните: по определению, контекст &mdash; это <i>дополнительная</i>,
факультативная информация, не настолько важная, чтобы влиять на контракт метода.
Быть может, мы захотим применять данный метод для обработки сравнительно небольших изображений,
где он работает считанные миллисекунды. В этом случае возможность прервать его
не только не нужна, но может даже оказаться вредной, нарушающей логику вызывающего кода.
(Наш метод, кстати, действительно работает почти мгновенно для любого
изображения "добропорядочных" размеров, скажем, 1024x1024.)
В такой ситуации нормальным решением является передача контекста, не умеющего прерываться,
например <code>DefaultContext.getInstance()</code>.
Но если бы исключение <code>InterruptionException</code> было объявляемым,
его пришлось бы добавить в декларацию метода и тем самым потребовать
от пользователей обработки &mdash; например, перехвата.
Получилось бы крайне нелогично:
программа вызывает наш метод с полной гарантией, что <code>InterruptionException</code>
произойти не может, а тем не менее анализировать это исключение необходимо.
Пришлось бы писать код наподобие следующего, категорически осуждаемого
всеми учебниками по Java:</p>
<pre>
    double mean;
    try {
        mean = SimplestTutorialDemo.meanOf_3(DefaultContext.getInstance(), image);
        // "пустышка" DefaultContext.getInstance()
        // заведомо не позволит методу прерваться
    } catch (InterruptionException ex) {
        // страшное и ужасное решение: игнонируем исключение
    }
</pre>
<p>Чтобы не нужно было писать такие ужасы, исключение
<code>InterruptionException</code> сделано необъявляемым (RuntimeException).</p>
<p>Перейдем к методу <code>updateProgress()</code>. Этот метод интерфейса <code>ProgressUpdater</code>
объявлен следующим образом:</p>
<pre>
    public void updateProgress(double readyPart, boolean force);
</pre>
<p>Смысл его достаточно прост: хорошая реализация контекста прогресса
должна в этом методе показать пользователю, что готовая часть вычислений составляет
<code>readyPart</code> (величина от 0.0 до 1.0).
В самом простейшем случае, данный метод может вывести на экран надпись вроде следующей:
<code>Math.round(readyPart*100.0)+"%"</code>.</p>
<p>Параметр <code>force</code> не столь очевиден.
Дело в том, что алгоритмы, работающие с контекстом прогресса,
обычно вызывают метод <code>updateProgress</code> <i>часто</i>.
Как правило, нет никакого смысла при <i>каждом</i> вызове реально обновлять
соответствующий графический элемент, такой как <code>JProgressBar</code>.
Не только нет смысла, но и опасно: так можно "из лучших побуждений" замедлить
алгоритм в сотни раз.</p>
<p>Передавая в качестве этого параметра значение <code>false</code>,
алгоритм "говорит" приложению:</p>
<blockquote><code>данное обновление прогресса можно проигнорировать,
так как я скоро либо снова вызову updateProgress, либо закончу вычисления</code></blockquote>
<p>В этом случае считается, что приложение имеет право пропустить очередное
обновление экранного элемента, <i>если с последнего обновления прошло мало времени</i>
(скажем, меньше 10 миллисекунд).</p>
<p>Как правило, это совершенно нормальное поведение, и поэтому чаще всего
в качестве параметра <code>force</code> передается <code>false</code>.
Но существуют ситуации, когда это не так. А именно, может оказаться, что алгоритм собирается
выполнить какую-то "долгоиграющую" операцию, <i>не сопровождающуюся</i>
регулярным обращением к контексту прогресса.
Например, это может быть выделение большого блока памяти, или обращение к
"долгому" методу сторонней библиотеки, не поддерживающей контексты AlgART.
В этом случае полезно гарантировать, что визуальный элемент, показывающий прогресс
выполнения, обновится, и индикатор <code>JProgressBar</code> не "застрянет"
в каком-то случайном предыдущем положении. Для этого достаточно вызвать
<code>updateProgress</code> с параметром <code>force=true</code>.
Например, в нашем методе можно было бы гарантировать такой вызов при последней
итерации цикла:</p>
<pre>
            if ((k &amp; 0xFFFF) == 0 || k == length - 1) {
                ic.checkInterruption();
                pu.updateProgress((double)(k + 1) / (double)length, k == length - 1);
            }
</pre>
<p>Напоследок заметим, что "не слишком частое" обращение к контекстам &mdash; это общее правило,
которому рекомендуется всегда следовать. Было бы грубой ошибкой
вызывать методы <code>ic.checkInterruption</code> и <code>pu.updateProgress</code>
при каждой итерации внутреннего цикла, которая, в нашем случае,
требует лишь считанных тактов процессора.
Да, качественная реализация контекста, наверно, предоставит достаточно быстродействующие методы,
но вряд ли они будут работать совсем "мгновенно".
Умеренным решением является обращение к таким контекстам, как
<code>ProgressUpdater</code> и <code>InterruptionContext</code>,
не реже, чем каждые 10-100 миллисекунд &mdash; чтобы обеспечить плавное изменение "полоски прогресса"
и практически мгновенную останвку вычислений &mdash; но и не чаще, чем, скажем, раз в несколько микросекунд.
Вызов один раз в 65536 итераций простого суммирования &mdash; подходящий компромисс.</p>
<h4 style="margin-bottom: 0px"><a name=meanOf_4></a>5. Вычисление средней яркости: учимся писать эффективно</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_3>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_5>Следующий раздел</a></div>
<p>Наши предыдушие решения базировались на методе <code>getDouble</code>.
Это простой путь, поэтому мы начали именно с него.
Но, к сожалению, это не очень эффективно.
Как мы увидим в данном разделе, нашу задачу можно решить в десятки раз быстрее.</p>
<p>Метод <code>getDouble</code>, а также его "близнецы" из частных интерфейсов,
описывающих конкретные типы массивов &mdash;
<code>ByteArray.getByte</code>, <code>ShortArray.getShort</code> и т.д. &mdash;
в современной реализации, в среднем, расходуют до сотни тактов процессора.
На сегодняшних персональных компьютерах это означает десятки наносекунд.
(Это средняя цифра для случая последовательного чтения массива.
Обращение "вразброс" к элементам большого массива может работать значительно медленнее.)
Для сравнения, простое обращение к обычному массиву Java,
благодаря оптимизатору Java HotSpot,
обычно требует считанных тактов, может быть, даже одного такта
(если нужный элемент "попадает" в кэш процессора).
Операция суммирования &mdash; основное действие, выполняемое нашим циклом &mdash;
тоже укладывается в несколько тактов, даже для вещественных чисел.</p>
<p>Почему же метод <code>getDouble</code> такой медленный?</p>
<p>Тут полезно немного отвлечься от нашего алгоритма вычисления средней яркости
и рассказать кое-что о том,
что стоит "за кулисами" внешне простого метода <code>getDouble</code>.
Вспомните: AlgART-массивы имеют 63-битовую адресацию (индексы типа <code>long</code>).
Один массив способен хранить практически сколь угодно большой объем данных,
ограниченный лишь оперативной и дисковой памятью.
И это достаточно важно: уже сегодня объемы оперативной памяти в несколько гигабайтов
для простой "персоналки" вполне типичны, и эту память надо уметь эффективно использовать.
Даже обычные "плоские" изображения в некоторых случаях превышают по объему гигабайт,
а для трехмерных, пространственных моделей такие объемы &mdash; норма.
Для адресации же байтового массива, более длинного, чем 2 Гб,
32-битовый тип <code>int</code> оказывается недостаточным.</p>
<p>В отличие от AlgART-массивов, все стандартные структуры языка Java,
предназначенные для хранения последовательности элементов,
имеют 31-битовую адресацию (тип индекса <code>int</code>) и изначально ограничены
примерно 2 миллиардами элементов. Это касается и стандартных массивов языка,
и класса <code>ByteBuffer</code> из <code>java.nio</code>, и коллекций из <code>java.util</code>.
Есть только одно очевидное исключение: классы для работы с файлами,
такие как <code>RandomAccessFile</code>.</p>
<p>Все это означает, что 63-битовая адресация AlgART-массивов, реализованная в рамках
языка Java, достигается далеко не бесплатно.
Чтобы преодолеть 2-миллиардный лимит, библиотака AlgART ассоциирует массив
с дисковым файлом (как правило, временным, удаляемым при завершении программы).
Файл делится на относительно небольшие блоки, размером по несколько мегабайтов.
Всякий раз, когда происходит обращение к AlgART-массиву, в частности, через метод <code>getDouble</code>,
система определяет соответствующий блок файла и <i>мапирует</i> его, вызовом <code>FileChannel.map</code>,
в буфер типа <code>ByteBuffer</code>.
Затем обращение переадресуется к методам
класса <code>ByteBuffer</code> (или его аналогов для других примитивных типов:
<code>ShortBuffer</code>, <code>IntBuffer</code>, и т.д.).</p>
<p>Заметим: даже для файлов, не превышающих (предельного для Java) объема 2 Гб,
используются сравнительно маленькие блоки, не более нескольких мегабайтов.
Это необходимо на 32-разрядных операционных системах, которые,
независимо от объема RAM, ограничивают доступное адресное пространства
одной программы лимитом порядка 2 гигабайтов.
Если бы мы попытались отобразить (мапировать) файл размером, скажем, 1 Гб
в единственный <code>ByteBuffer</code>,
вместо того чтобы "дробить" его на маленькие блоки,
то несколько таких AlgART-массивов уже переполнили бы адресное пространство, доступное
всей виртуальной машине Java.</p>
<p>Разумеется, несколько наиболее часто используемых блоков файла кэшируются.
Экземпляры <code>ByteBuffer</code>, отображенные на самые "популярные" блоки,
используются многократно. Переотображение (вызов <code>FileChannel.map</code>)
происходит лишь тогда, когда требуется доступ к новому участку AlgART-массива,
отсутствующему в кэше.</p>
<p>Реальный алгоритм кэширования и переотображения довольно сложен.
Каждый раз, когда мы обращаемся хотя бы к одному элементу массива,
приходится выполнить ряд проверок и, возможно, коррекций внутренних структур данных.
Более того, эти операции обычно <i>синхронизуются</i>,
чтобы сделать возможной параллельную обработку одного AlgART-массива из нескольких потоков.
(Далее мы увидим, что распараллеливание действительно очень полезно и реально повсеместно
применяется библиотеками AlgART на многопроцессорных или многоядерных компьютерах.)
Неудивительно, что вызов <code>getDouble</code> требует некоторого времени.
Возможно, это время сократится в будущих версиях библиотек AlgART и компиляторов Java,
но, вероятнее всего, методы типа <code>getDouble</code>
всегда будут значительно проигрывать простому обращению к Java-массиву
вроде <code>byte[]</code> или <code>short[]</code>.</p>
<p><a name=meanOf_4_dataBuffer></a>Каков же выход из положения?
Для последовательных алгоритмов вроде нашего,
просматривающих массив элемент за элементом, решение вполне традиционно &mdash;
<i>блочный</i> доступ: чтение за один вызов достаточно длинного блока элементов
с размещением их в обычном массиве Java. Такой вызов в библиотеках AlgART
работает с максимальной эффективностью и дает практически такую же скорость,
какую можно было бы получить при прямой работе с Java-массивом (или указателем языка&nbsp;C).</p>
<p>Даже при беглом взгляде на базовый интерфейс <code>Array</code>,
вероятно, вы обратите внимание на метод <code>getData</code>,
который позволяет обеспечить блочный доступ: читает целый блок последовательных элементов.
Однако, необходимо предупредить читателя:
<i>это не тот метод</i>, который, скорее всего, понадобится вам в прикладных алгоритмах
последовательной обработки массива.
Метод <code>getData</code> (и его "близнец" <code>getBits</code>
из интерфейса <code>BitArray</code>) действительно бывает нужен в низкоуровневых,
сложных методах, реализующих некоторые нетривиальные алгоритмы и абстракции.
Но для прикладных задач, как правило, удобнее &mdash; и эффективнее &mdash;
применять другую технологию, называемую "<i>буфер данных</i>".</p>
<p><i>Буфер данных</i> представлен в пакете <code>net.algart.arrays</code>
интерфейсом <code>DataBuffer</code>.
(Не путайте с классом <code>Buffer</code> из <code>java.nio</code>:
между ним и <code>DataBuffer</code> нет ничего общего.)
Экземпляр такого интерфейса возвращается методами <code>buffer</code>,
расположенными в базовом интерфейсе <code>Array</code>.
Подобно самим AlgART-массивам, буфера данных имеют частные разновидности,
соответствующие конкретным типам и представленные 9-ю наследниками <code>DataBuffer</code>:
а именно, <code>DataByteBuffer</code>, <code>DataShortBuffer</code> и т.д.</p>
<p>Я настоятельно рекомендую внимательно изучить JavaDoc-комментарий
к интерфейсу <code>DataBuffer</code>.
В этом комментарии подробно описаны основные понятия и приемы, связанные
с использованием буферов данных.
Полное понимание концепции <code>DataBuffer</code> весьма важно
для правильного использования этого удобного и мощного инструмента.</p>
<p><a name=meanOf_4_impl></a>Итак, рассмотрим четвертую реализацию алгоритма подсчета средней яркости,
опирающуюся на применение <code>DataBuffer</code>:</p>
<pre>
    public static double meanOf_4(Context context, @Name("image")Image2D image) {
        ProgressUpdater pu = context.as(ProgressUpdater.class);
        InterruptionContext ic = context.as(InterruptionContext.class);
        Matrix&lt;? extends PArray&gt; m = image.i();
        PArray a = m.array();
        DataBuffer buf = a.buffer(DataBuffer.AccessMode.READ);
        double sum = 0.0;
        for (buf.map(0); buf.hasData(); buf.mapNext()) {
            ic.checkInterruption();
            pu.updateProgress((double)buf.position() / (double)a.length(), false);
            if (a instanceof BitArray) {
                long[] data = (long[])buf.data();
                sum += PackedBitArrays.cardinality(data,
                    buf.fromIndex(), buf.toIndex());
            } else if (a instanceof CharArray) {
                char[] data = (char[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k];
            } else if (a instanceof ByteArray) {
                byte[] data = (byte[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k] &amp; 0xFF;
            } else if (a instanceof ShortArray) {
                short[] data = (short[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k] &amp; 0xFFFF;
            } else if (a instanceof IntArray) {
                int[] data = (int[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k];
            } else if (a instanceof LongArray) {
                long[] data = (long[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k];
            } else if (a instanceof FloatArray) {
                float[] data = (float[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k];
            } else if (a instanceof DoubleArray) {
                double[] data = (double[])buf.data();
                for (int k = buf.from(), kMax = buf.to(); k &lt; kMax; k++)
                    sum += data[k];
            } else {
                throw new AssertionError("Must not occur");
            }
        }
        return sum / a.length();
    }
</pre>
<p>Сразу бросается в глаза, что размер метода резко увеличился.
В нем появилось 8 веток, отвечающих за обработку разных примитивных типов элементов.
Раньше универсальная поддержка всех примитивных типов была "спрятана" в методе
<code>getDouble</code>, имеющемся в интерфейсе <code>PArray</code>.
Конверсия элементов прочих типов в число типа <code>double</code>
занимает так мало времени по сравнению с прочей "кухней", реализуемой
методом <code>getDouble</code> (как и другими методами доступа к одному элементу),
что затратами на конверсию можно было пренебречь.</p>
<p>Но буфера данных <code>DataBuffer</code>, в отличие от методов доступа к одному элементу,
не поддерживают автоконверсии типов.
Это оправдано: буфера данных разработаны для реализации максимально эффективных алгоритмов,
где, как правило, неявное преобразование типов всех элемента нежелательно.
Ценой эффективности является усложнение кода: необходимость повторения почти одинакового кода
для разных примитивных типов.</p>
<p>Код с ветвлением по 8 типам присущ многим алгоритмам, которые хотят эффективно
обработать числовые AlgART-массивы, не теряя при этом универсальности:
применимости к любому из восьми примитивных типов.
Может быть, когда-нибудь в языке появятся средства, позволяющие упростить
написание такого кода для примитивных типов (вроде tempalates языка C++).
Но пока приходится писать 8 веток.
Впрочем, как мы увидим в дальнейших главах, при программировании
обработки изображений редко приходится "опускаться" до таких приземленных
вещей, как работа с отдельными элементами матрицы.</p>
<p>Перейдем к анализу приведенного кода.
Рассмотрим первый новый для нас оператор:</p>
<pre>
        DataBuffer buf = a.buffer(DataBuffer.AccessMode.READ);
</pre>
<p>Смысл оператора достаточно прост: для заданного AlgART-массива <code>a</code>
возвращается буфер данных, соответствующий этому массиву и предназначенный для чтения данных.
Примерно так же, как для коллекции <code>java.util</code>
можно получить соответствующий ей объект <code>Iterator</code>.</p>
<p>Здесь стоит обратить внимание на две вещи. Во-первых, мы явно указываем
режим доступа <code>READ</code>. Зачем?
Это &mdash; "подсказка" библиотеке, что нам не понадобится модифицировать массив.
Можно было бы и обойтись без такой подсказки.
Имеется перегруженная версия метода <code>buffer</code> без аргументов, выбирающая
режим автоматически.
Однако существуют ситуации (хоть и не очень типичные),
когда буфер данных с режимом доступа, выбранным по умолчанию, будет работать
<i>медленнее</i>, чем буфер с режимом <code>READ</code>.
Правилом "хорошего тона" является всегда явно указывать, какой режим работы
с буфером данных нам необходим &mdash; благо это ничего не стоит.
Кроме возможной оптимизации, это улучшает читабельность кода, ибо явно
указывает на намерения программиста.</p>
<p>Надо заметить, что режим доступа <code>DataBuffer.AccessMode.READ</code>
&mdash; это <i>не более чем</i> "<i>подсказка</i>". Такой режим никоим образом <i>не гарантирует</i>,
что возвращенный буфер данных не позволит изменить элементы массива.
(Для получения таких гарантий нужна другая технология: метод <code>asImmutable()</code>
интерфейса <code>Array</code>. См. JavaDoc, в частности, комментарий к пакету &mdash; package summary.)
Если вы все же попытаетесь, пользуясь буфером данных в режиме <code>READ</code>,
модифицировать исходный массив,
может быть, это получится, может быть, ваша попытка будут проигнорирована,
а может быть, изменится лишь часть массива &mdash; это не оговорено документацией.
Все, что можно сказать: реализация <code>DataBuffer</code> постарается,
по возможности, сэкономить время, избегая ненужных вам операций записи данных в массив.</p>
<p>Вторая вещь, о которой иногда полезно задуматься &mdash; размер буфера (<i>capacity</i>).
Иначе говоря, число последовательных элементов AlgART-массива, которые
будут "за один раз" читаться из массива в буфер и сохраняться
в обычной памяти (массиве) языка Java.
По умолчанию, выбирается некоторый "разумный" размер, обеспечивающий
почти оптимальную скорость обмена с AlgART-массивом: вероятнее всего
(но отнюдь не обязательно) несколько тысяч элементов.
Вы можете задать этот объем "вручную": у метода <code>buffer</code>
есть соответствующие перегруженные версии.
Так, при дальнейшей оптимизации нашего метода было бы невредно явно задать размер буфера,
чтобы гарантировать, что буфер не будет длиннее 2<sup>15</sup>-1=32767 элементов.
Это позволило бы просуммировать в одном цикле, заведомо без переполнения,
все элементы типа <code>byte</code> или <code>short</code>,
используя переменную-сумматор типа <code>int</code>.
Впрочем, на данном этапе мы не будем настолько углубляться в оптимизацию.</p>
<p>Идем дальше. Обратите внимание на организацию цикла:</p>
<pre>
        for (buf.map(0); buf.hasData(); buf.mapNext()) {
            . . .
        }
</pre>
<p>Напоминает итераторы по коллекциям <code>java.util</code>, не правда ли?</p>
<p>Однако есть и отличия. Прежде всего, буфер данных ориентирован на произвольный,
а не последовательный доступ, поэтому его можно (и нужно) явно "позиционировать"
на некоторый участок AlgART-массива. Так как мы собираемся обрабатывать массив
в естественном порядке, слева направо, то цикл начинается с позиционирования
буфера на начало массива: <code>buf.map(0)</code>.
После этого вызова буфер будет содержать некоторое количество
(зависящее от объема буфера) последовательных элементов AlgART-массива,
начиная с 0-го элемента, т.е. с начала массива.
Подчеркиваю: в отличие итераторов коллекций Java,
перед началом использования буфера необходим хотя бы один вызов метода <code>map</code>.
Чаще всего это <code>map(0)</code>.</p>
<p>При переходе к следующей итерации цикла вызывается метод <code>mapNext()</code>.
На самом деле мы могли бы вызвать явно метод <code>map</code>, вычислив следующую позицию
в массиве: в JavaDoc приведен соответствующий пример цикла.
Но вариант с <code>mapNext()</code> проще: позиция начала буфера
автоматически смещается вперед на число элементов, загруженных в буфер предыдущим
вызовом <code>map</code> или <code>mapNext</code>.</p>
<p>При последнем вызове <code>mapNext</code> "сдвинет" буфер на позицию,
равную длине AlgART-массива. Это корректная ситуация, но буфер в этом случае
считается <i>пустым</i>. Соответственно, метод <code>buf.hasData()</code>
вернет <code>false</code>, и цикл естественным образом завершится.</p>
<p>Рассмотрим теперь тело цикла. Вначале идет уже знакомое нам обращение к контекстам прерываний
и прогресса. (Удобнее вызвать контекст прогресса в начале, а не в конце цикла,
так как количество уже обработанных данных оказывается равным текущей начальной
позиции буфера, возвращаемой методом <code>buf.position()</code>.)</p>
<p>Далее начинается ветвление по типам элементов. Все ветки начинаются с вызова
метода <code>buf.data()</code>.
Этот метод возвращает ссылку на некоторый Java-массив,
который содержит элементы AlgART-массива, присутствующие в данный момент в буфере.
Тип массива определяется типом элементов: для байтового AlgART-массива <code>ByteArray</code>
это будет массив <code>byte[]</code>, для <code>ShortArray</code> &mdash; массив <code>short[]</code>,
и т.д. С различными типами Java-массива нужно работать по-разному:
это главная причина, по которой необходимы 8 веток.</p>
<p>Заметим, что затребованный фрагмент AlgART-массива вовсе не обязательно
окажется <i>в&nbsp;начале</i> Java-массива <code>buf.data()</code>,
т.е. с первого его элемента.
Чтобы узнать, где в Java-массиве находится первый затребованный элемент AlgART-массива,
используется метод <code>buf.fromIndex()</code>.
Количество элементов в буфере данных возвращается методом <code>buf.count()</code>.
Также есть метод <code>buf.toIndex()</code>, возвращающий сумму <code>buf.fromIndex()+buf.count()</code>.
Обычно число элементов <code>buf.count()</code> соответствует объему буфера,
определенному при создании буфера данных методом <code>buffer</code>.
Но <code>buf.count()</code> может быть и меньше. Например, при обработке
последнего блока AlgART-массива, когда число оставшихся необработанных элементов
AlgART-массиве меньше размера буфера, <code>buf.count()</code>
вернет число оставшихся элементов &mdash; или даже 0, когда массив обработан полностью.</p>
<p><i>С массивом, полученным методом <code>data()</code>, необходимо обращаться аккуратно!</i>
А именно, не следует модифицировать его элементы, если вы не ставите целью модификацию
исходного AlgART-массива. Как уже говорилось, даже в режиме <code>READ</code>
это может привести к изменениям в исходном массиве.
Существует важный частный случай AlgART-массивов: так называемые <i>простые</i> массивы,
являющиеся "оболочкой" вокруг самых обыкновенных, стандартных массивов Java.
Такие AlgART-массивы часто применяются, например, для оптимизации.
В случае простого AlgART-массива метод <code>data()</code> может вернуть ссылку на сам
исходный Java-массив, лежащий в основе AlgART-массива!
В этом случае никаких копирований между AlgART-массивом и буфером данных вообще не производится.
Это чрезвычайно полезно с точки зрения производительности, но требует
аккуратности при использовании буфера данных.
(Конечно, такое возможно лишь при определенных условиях: не надо думать,
что здесь имеется "дыра" в безопасности архитектуры AlgART-массивов.
Например, если AlgART-массив объявлен <i>неизменяемым</i> при помощи метода <code>asImmutable</code>,
то <code>DataBuffer</code> не позволит нарушить неизменяемость: в этом случае
<code>DataBuffer</code> будет копировать данные в отдельный Java-массив.)</p>
<p>Первая из 8 веток цикла посвящена случаю битового массива: <code>BitArray</code>.
Это самый сложный случай, поскольку биты в AlgART-массивах, так же как и в буферах
данных, <i>упакованы</i> в 64-битовые целые числа типа <code>long</code>.
Соответственно, метод <code>buf.data()</code> возвращает массив типа <code>long[]</code>.
Обрабатывать такой упакованный массив "вручную" было бы крайне неудобно.
Так, простейшее чтение бита с индексом <code>index</code> выражается следующим громоздким оператором:</p>
<pre>
    (data[(int)(index &gt;&gt;&gt; 6)] &amp; (1L &lt;&lt; (index &amp; 63))) != 0
</pre>
<p>К счастью, в составе пакета <code>net.algart.arrays</code> предусмотрен специальный
класс <code>PackedBitArrays</code>, содержащий сервисные функции для большинства
задач, возникающих при обработке битов, упакованных в массивы <code>long[]</code>.
В нашем примере мы используем готовую высокоэффективную функцию <code>cardinality</code>,
решающую в точности нашу задачу: подсчет количества единичных битов
(или, что то же самое, суммы) в произвольном фрагменте упакованного битового массива.</p>
<p>Все прочие ветки алгоритма похожи друг на друга и практически очевидны. Но, вероятно,
вы заметили, что вместо методов <code>fromIndex()</code> и <code>toIndex()</code>
используются методы с более краткими названиями <code>from()</code> и <code>to()</code>.
Причина этого отличия тривиальна: разрядность индексов.</p>
<p>Методы <code>fromIndex()</code>, <code>toIndex()</code> и <code>count()</code>
возвращают результат типа <code>long</code>.
Ведь обычный Java-массив <code>long[]</code> <i>может</i>
содержать более 2<sup>31</sup>-1 битов. Например, даже 32-разрядные версии Java
в состоянии создать массив <code>long[]</code> длиной в гигабайт, а это уже 2<sup>33</sup> битов.
И хотя маловероятно, что вам потребуется <code>DataBuffer</code> такого объема
(впрочем, кто знает, какими "порциями" мы будем обрабатывать сверхбольшие массивы
через несколько лет), корректный код для случая битов должен
опираться на 64-разрядные методы <code>fromIndex()</code>, <code>toIndex()</code>
и <code>count()</code>.</p>
<p>В противоположность битовому случаю, для всех остальных типов элементов
мы имеем дело с обычным, неупакованным Java-массивом <code>buf.data()</code>
соответствующего типа <code>byte[]</code>, <code>short[]</code> и т.д.
В нем по определению не может быть более 2<sup>31</sup>-1 элементов,
более того, для его индексации пригоден только тип <code>int</code>, но не <code>long</code>.
Чтобы не заставлять программиста всякий раз приводить результаты методов
<code>fromIndex()</code>, <code>toIndex()</code> и <code>count()</code>
к типу <code>int</code>, интерфейс <code>DataBuffer</code>
предусматривает 32-битовые версии этих методов <code>from()</code>, <code>to()</code>
и <code>cnt()</code>, выполняющие указанное приведение внутри себя.
Подчеркнем: методами <code>from()</code>, <code>to()</code>
и <code>cnt()</code> <i>не следует</i> пользоваться для обработки битовых массивов,
так как это может привести к переполнению индексов. Впрочем,
при переполнении эти методы предупредят о проблеме, сгенерировав исключение.</p>
<p>В заключение, обратите внимание на операторы "&amp; 0xFF" и "&amp; 0xFFFF"
при обработке типов <code>byte</code> и <code>short</code>.
Эти операторы нужны, чтобы, подобно предыдущим версиям нашего метода,
обработать 8- и 16-битовые элементы как беззнаковые.
Метод <code>getDouble</code> выполнял такую коррекцию внутри себя,
теперь же мы должны выполнить преобразование явно.</p>
<p>Мы закончили рассмотрение первого примера обработки AlgART-массива,
построенного на применении <code>DataBuffer</code>.
Относительная сложность такого решения окупается с лихвой:
на моем компьютере новый метод работает примерно в 10 раз быстрее,
чем <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_3>предыдущий вариант.</a></p>
<h4 style="margin-bottom: 0px"><a name=meanOf_5></a>6. Вычисление средней яркости: библиотечная функция все-таки лучше</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_4>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_1>Следующий раздел</a></div>
<p>Последний разобранный нами вариант подсчета среднего достаточно эффективен.
Можно было бы выполнить ряд очевидных оптимизаций, например,
заменить, где возможно, вещественное сложение целочисленным.
Но это уже не так интересно.</p>
<p>На самом деле, если мы хотим найти оптимальное решение некоторой задачи,
в 90% случаев нужно последовать классическому рецепту:
поискать готовое решение в библиотеках.
Почти наверняка оно окажется не хуже вашего.
А если даже оно не оптимально, вероятнее всего, алгоритм будет оптимизирован
в одной из следующих версий библиотки.</p>
<p>Как и следовало ожидать, такая простая задача, как суммирование элементов массива,
уже предусмотрена в библиотеках AlgART.
Это метод <code>sumOf</code> библиотечного класса <code>Arrays</code>.
С его использованием решение нашей задачи записывается совсем лаконично:</p>
<pre>
    public static double meanOf_5(Context context, @Name("image")Image2D image) {
        ArrayContext arrayContext = new DefaultArrayContext(context);
        Matrix&lt;? extends PArray&gt; m = image.i();
        PArray a = m.array();
        double sum = Arrays.sumOf(arrayContext, a);
        return sum / a.length();
    }
</pre>
<p>По сравнению с предыдущими примерами, здесь добавилось только одно понятие.
Это <i>контекст массивов</i>: интерфейс <code>ArrayContext</code>.</p>
<p>На самом деле <code>ArrayContext</code> реализует ту же самую концепцию,
что и контексты типа <code>Context</code>, рассмотренные нами раньше.
Но <code>ArrayContext</code>, расположенный, в отличие от <code>Context</code>,
в пакете <code>net.algart.arrays</code>, несколько проще.
<code>ArrayContext</code> &mdash; это как бы "пакет <code>net.algart.contexts</code> в миниатюоре".
В отличие от нетривиальной системы интерфейсов и классов,
здесь мы имеем дело всего с одним интерфейсом &mdash;
реализующим, однако, практически все задачи,
необходимые при работе с массивами на уровне пакета <code>net.algart.arrays</code>.
В модулях, ориентированных исключительно на обработку AlgART-массивов и матриц,
часто достаточно работать с <code>ArrayContext</code>.
Более мощный пакет <code>net.algart.contexts</code> обычно привлекается,
когда, кроме AlgART-массивов, необходимы другие сущности, такие, как
необходимые нам изображения <code>Image2D</code>
(про которые <code>ArrayContext</code>, конечно, ничего не "знает").</p>
<p>Разумеется, общий контекст <code>Context</code> допускает автоматическое
преобразование к <code>ArrayContext</code>. В нашем примере преобразование выполняется
в первой строчке:</p>
<pre>
        ArrayContext arrayContext = new DefaultArrayContext(context);
</pre>
<p>Именно такой контекст, <code>ArrayContext</code>, следует передавать
вычислительным функциям пакета <code>net.algart.arrays</code>,
в частности, функции <code>Arrays.sumOf</code>.
<p>Насколько наш новый метод лучше предыдущего, выполняющего суммирование "вручную"?</p>
<p>Конечно, библиотечная функция <code>Arrays.sumOf</code> содержит мелкие оптимизации
вроде целочисленного суммирования, которыми мы пренебрегли в учебном методе
<code>meanOf_4</code>.
Но главное преимущество <code>sumOf</code> &mdash; <i>распараллеливание вычислений</i>.</p>
<p>Вообще, распараллеливание &mdash; одно из важных достоинств большинства
расчетных методов, предусмотренных в библиотеках AlgART.
Современые компьютеры часто оснащены несколькими процессорами либо многоядерными процессорами,
позволяющими параллельно выполнить несколько задач,
например, просуммировать несколько фрагментов одного большого AlgART-массива.
Для этого достаточно создать несколько потоков и поручить каждому выполнение своей
части задачи. Таким образом на многопроцессорном или многоядерном компьютере
можно добиться многократного ускорения вычислений.</p>
<p>При помощи пакета <code>java.util.concurrent</code> распараллеливание
программируется довольно просто. Более того,
для распареллеливания обработки массивов в большинстве случаев
можно использовать библиотечный класс <code>Arrays.ParallelExecutor</code>,
который "берет на себя" большую часть рутинной работы по организации
совместной работы потоков и взаимодействию с контекстом <code>ArrayContext</code>.
Профессиональный метод <code>Arrays.sumOf</code>, действительно,
опирается на этот класс.
Деталями распараллеливания &mdash; например, количеством параллельных потоков
&mdash; тоже управляет соответствующий контекст
(либо часть <code>ArrayContext</code>, либо независимый интерфейс
<code>net.algart.contexts.ArrayThreadPoolContext</code>).
В JavaDoc вы можете найти детали этого управления.
Если вы решите задействовать параллельность в своих собственных вычислительных методах,
рекомендую посмотреть, как реализован в библиотеке метод <code>sumOf</code>
(или один из похожих методов, скажем, <code>rangeOf</code>)
и изучить документацию к <code>Arrays.ParallelExecutor</code>.
Даже если <code>ParallelExecutor</code> окажется для ваших целей недостаточен,
в любом случае рекомендую использовать <code>ArrayThreadPoolContext</code>:
тогда приложения смогут управлять вашим распараллеливанием таким же образом,
как и распараллеливанием в библиотеках AlgART.</p>
<h4 style="margin-bottom: 0px"><a name=constant_1></a>7. Генерация константного изображения простейшим способом: цикл по массиву</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_5>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_2>Следующий раздел</a></div>
<p>Мы научились получать на входе алгоритма изображения, представленные AlgART-матрицами,
и анализировать несколькими способами значения яркостей пикселов (т.е. элементы матрицы).
Рассмотрим теперь обратную задачу:
создание нового изображения и заполнение его какими-то значениями,
для начала &mdash; некоторой числовой константой.</p>
<p>Начнем с простейшего, хотя и неэффективного способа: поэлементного присваивания элементов.
Мы уже <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_1>говорили</a>, что для таких задач поокординатный цикл по матрице (по y и по x)
никакого смысла не имеет, разве что вам хочется слегка замедлить алгоритм.
Начнем с цикла по линейному массиву: аналога <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_2>разобранного выше</a>
простейшего способа вычисления суммы элементов в очень похожем цикле.</p>
<pre>
    public static Image2D constant_1(Context context,
        @Name("dimX")long dimX, @Name("dimY")long dimY,
        @Name("value")float value)
    {
        ArrayMemoryContext amc = context.as(ArrayMemoryContext.class);
        MemoryModel mm = amc.getMemoryModel();
        Matrix&lt;UpdatableFloatArray&gt; m = mm.newFloatMatrix(dimX, dimY);
        UpdatableFloatArray a = m.array();
        long length = a.length();
        for (long k = 0; k &lt; length; k++) {
            a.setFloat(k, value);
        }
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newGrayscaleImage2D(m);
        return result;
    }

</pre>
<p>В отличие от предыдущих примеров, мы собираемся решить новую для нас задачу:
создать "с нуля" AlgART-матрицу (т.е. отвести память),
элементы которой мы будем заполнять константным значением.
Размеры матрицы и желаемое значение &mdash; это аргументы метода <code>dimX</code>,
<code>dimY</code>, <code>value</code>.</p>
<p>AlgART-матрица, также как и AlgART-массив &mdash; это интерфейс.
Для создания экземпляров матриц и массивов, в соответствии с хорошими традициями шаблона <i>Factory</i>,
служит класс под названием <code>MemoryModel</code>... впрочем, нет, не класс, а опять интерфейс!
Почему интерфейс и почему <code>MemoryModel</code>?</p>
<p><code>MemoryModel</code>, или <i>модель памяти</i> &mdash; фундаментальное понятие библиотек AlgART.
Архитектура AlgART-массивов изначально спроектирована так, чтобы физический способ хранения данных
был легко и произвольно расширяем.
Этот способ хранения называется <i>моделью памяти</i>.
Основная задача интерфейса <code>MemoryModel</code> &mdash; служить фабрикой,
создающей экземпляры массивов и матриц любого желаемого типа и размера.
В зависимости от того, какая реализация <code>MemoryModel</code> применяется
(т.е. какая выбрана конкретная модель памяти),
будут создаваться различные реализации массивов и матриц:
практически неотличимые друг от друга с точки зрения использования,
но совершенно разные по "внутреннему устройству".</p>
<p>Например, существует <i>простая</i> модель памяти: класс <code>SimpleMemoryModel</code>,
реализующий интерфейс <code>MemoryModel</code>.
В этом случае AlgART-массив &mdash; всего лишь "оболочка" вокруг обычного Java-массива,
хранящегося в Java-куче. Это самый эффективный вариант с точки зрения быстродействия,
но такие массивы ограничены размерами памяти JVM и предельной длиной 2<sup>31</sup>-1 элементов
(несколько больше для битовых массивов, за счет упаковки битов в <code>long</code>-значения).</p>
<p>Но есть и альтернативная, <i>большая</i> модель памяти <code>LargeMemoryModel</code>.
Здесь AlgART-массив реально представляет собой дисковый файл, а операции доступа к его элементам
приводят к отображению фрагментов файла в память: мы рассказывали об этом
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_4>выше</a>, когда разбирали механизм работы метода <code>getDouble</code>.
Этот вариант несколько медленнее, но не накладывает никаких ограничений на размер массивов,
за исключением естественного предела &mdash; свободного места на диске &mdash;
и чисто теоретического лимита на число элементов 2<sup>63</sup>-1
(т.е. более 9 миллионов терабайт).</p>
<p>Другой интересный пример модели памяти (впрочем, не имеющий прямого отношения к обработке изображений)
&mdash; <i>комбинированная</i> модель памяти <code>CombinedMemoryModel</code>.
Она предназначена для хранения массивов объектов, а не примитивных типов,
и позволяет хранить AlgART-массив однотипных структур в одном или нескольких других AlgART-массивах,
уже состоящих из элементов примитивных типов.
Например, AlgART-массив объектов типа "точка" (2 числа x и y, допустим, типа <code>float</code>),
внешне "выглядящий" как обычный массив объектов и похожий на классический <code>ArrayList</code>,
при помощи такой модели можно сохранить в AlgART-массиве <code>float</code>-значений,
в котором поочередно будут записываться x- и y-координаты каждой точки.
Такой способ позволит как сэкономить память &mdash; на точку будет израсходовано ровно 2*4=8 байтов,
в отличие от <code>ArrayList</code> или массива объектов Java, где добавятся изрядные накладные
расходы на поддержание отдельного экзепляра объекта &mdash; так и преодолеть лимит 2 Гб
и задействовать для хранения точек свободное дисковое пространство.</p>
<p>Разумеется, профессиональное приложение должно каким-то образом выбрать желаемую модель памяти,
которой будет рекомендовано пользоваться библиотечным алгоритмам для создания своих массивов и матриц.
В сложном приложении, возможно, модель памяти будет отличаться от стандартных, предусмотренных
в пакете <code>net.algart.arrays</code>, хотя бы своими настройками
(вроде каталога временных файлов, в котором следует создавать большие массивы).</p>
<p>Для передачи этой информации в алгоритм, как обычно, используется контекст.
Речь идет о частном <i>контексте памяти</i>: класс <code>ArrayMemoryContext</code>.
Его задача &mdash; вернуть модель памяти <code>MemoryModel</code>, которую должен
использовать алгоритм для создания любого AlgART-массива или матрицы
(кроме, быть может, совсем маленьких массивов, для которых <code>SimpleMemoryModel</code>
является оптимальным выбором).
Это и происходит в начале нашего метода:</p>
<pre>
        ArrayMemoryContext amc = context.as(ArrayMemoryContext.class);
        MemoryModel mm = amc.getMemoryModel();
</pre>
<p>Если в качестве параметра <code>context</code> в данный метод
передан <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#DefaultContext>"контекст-заглушка"</a> <code>DefaultContext.getInstance()</code>,
то метод <code>getMemoryModel()</code> вернет некоторую "умолчательную" глобальную модель памяти,
настраиваемую через системное свойство "<code>net.algart.arrays.globalMemoryModel</code>":
см. метод <code>Arrays.globalMemoryModel()</code>. В свою очередь, если такое свойство
отсутствует, применяется простейшая модель памяти, т.е. <code>SimpleMemoryModel</code>.</p>
<p>Располагая экземпляром <code>MemoryModel</code>, нет проблем создать матрицу желаемого
типа и размера. В этом примере мы, не мудрствуя лукаво, создаем вещественную матрицу
типа <code>float</code>:</p>
<pre>
        Matrix&lt;UpdatableFloatArray&gt; m = mm.newFloatMatrix(dimX, dimY);
</pre>
<p>Тип AlgART-массива в данном случае &mdash; <code>UpdatableFloatArray</code>,
т.е. допускающий модифицацию элементов (но не изменение длины) массив вещественных
чисел <code>float</code>.</p>
<p>Следующий цикл вполне тривиален:</p>
<pre>
        long length = a.length(); // можно было бы написать dimX*dimY, но так нагляднее
        for (long k = 0; k &lt; length; k++) {
            a.setFloat(k, value);
        }
</pre>
<p>Метод <code>setFloat</code> &mdash; "брат-близнец" подробно разбиравшегося выше метода
<code>getDouble</code>, объявленный в конкретном интерфейсе <code>UpdatableFloatArray</code>.
С тем же успехом можно было бы использовать <code>setDouble</code>:
чуть более общий метод, объявленный в интерфейсе <code>UpdatablePArray</code>.
В дальнейших разделах мы заменим <code>setFloat</code> более эффективными решениями.</p>
<p>Последние два оператора знакомы нам по <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#toGrayscale>первому разобранному нами примеру</a>,
когда мы возвращали полутоновой эквивалент RGB-картинки:</p>
<pre>
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newGrayscaleImage2D(m);
</pre>
<p>Как и там, мы используем частный контекст <code>ImageContext</code>,
чтобы на основании AlgART-матрицы создать изображение типа <code>Image2D</code>.
В качестве результата возвращается полутоновое изображение, яркость всех пикселов которого
равна переданной константе <code>value</code>.</p>
<p>Что значит "яркость равна переданной константе"? На самом деле, вопрос интерпретации вещественного
числа в качестве яркости, на данный момент &mdash; вне нашей компетенции.
Это решает программа, которая вызвала наш метод и собирается что-то делать с полученным <code>Image2D</code>:
визуализировать, экспортировать в BMP-файл, делать что-то еще.
(Может быть, это вообще не яркость, а уровень высот в будущей топографической карте,
которую предполагается показать в виде трехмерной поверхности.)</p>
<p>В качестве "разумного умолчания" я рекомендую принять следующее соглашение:
для вещественных чисел значение 0.0 соответствует нулевой яркости (черные пикселы),
значение 1.0 &mdash; максимальной яркости (белые пикселы),
значения между 0.0 и 1.0 &mdash; промежуточным яркостям.
Значения вне диапазона 0.0...1.0 "некорректны" и могут показываться, например,
как черные (отрицательные) и белые (большие чем 1.0).
Если бы мы создавали изображение с другим типом элементов (что мы и будем делать в следующих разделах),
то рекомендуемые соглашения такие:</p>
<ul><li>тип <code>byte</code>: яркость увеличивается от 0 (черный цвет) до 2<sup>8</sup>-1=255 (белый);</li><li>тип <code>short</code>: яркость увеличивается от 0 (черный цвет) до 2<sup>16</sup>-1=65535 (белый);
напоминаем, что в библиотеках AlgART типы <code>byte</code> и <code>short</code> считаются беззнаковыми;</li><li>тип <code>char</code>: так же, как <code>short</code> (хотя кому нужен тип <code>char</code> для
обработки изображений, остается загадкой);</li><li>тип <code>int</code>: яркость увеличивается от 0 (черный цвет) до 2<sup>31</sup>-1 (белый),
отрицательные значения в качестве яркости являются некорректными;</li><li>тип <code>long</code>: яркость увеличивается от 0 (черный цвет) до 2<sup>63</sup>-1 (белый),
отрицательные значения в качестве яркости являются некорректными;</li><li>тип <code>boolean</code> (битовые массивы): 0 (false) означает черный цвет, 1 (true) &mdash; белый.</li></ul>
<p>Подчеркиваю: это лишь рекомендация для визуализации и экспорта в других форматы изображений.
Таким соглашениям следует, например, система <a href=http://algart.net/ww/simagis.com/>SIMAGIS</a>,
хотя там есть возможность, при желании, настроить другие диапазоны для представления яркостей.
Для программирования алгоритмов данные соглашения обычно не имеют значения.</p>
<h4 style="margin-bottom: 0px"><a name=constant_2></a>8. Генерация константного изображения: произвольная разрядность результата</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_1>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_3>Следующий раздел</a></div>
<p>В предыдущем примере мы создаем вещественную матрицу с элементами фиксированного
типа, а именно <code>float</code>.
На самом деле такое решение редко является приемлемым.
Почему именно <code>float</code>? Потому что так удобнее разработчику &mdash; раз аргумент
<code>value</code> такого типа?
А если мы хотим получить байтовое (8-битовое) изображение?
В конце концов, необходимость экономить память и место на диске никто не отменял,
а 8-битовая матрица в 4 раза компактнее.</p>
<p>В "настоящих", серьезных алгоритмах, создающих новое изображение, таких
как фильтр удаления шума, тип элементов результата (разрядность)
обычно определяется входными данными. Скажем, алгоритм удаления аддитивного шума может
создать результирующее изображение с той же разрядностью, что и исходное, или
получить желаемый примитивный тип непосредственно в качестве аргумента метода.</p>
<p>Исправимся. Изменим предыдущий метод, чтобы он вернул константное изображение
произвольной разрядности, которую мы укажем в параметре.
Заодно вспомним о пользователе и добавим контексты прерываний и прогресса,
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_3>подробно рассмотренные нами ранее</a>.</p>
<pre>
    public static Image2D constant_2(Context context,
        @Name("dimX")long dimX, @Name("dimY")long dimY,
        @Name("elementType")String elementType, @Name("value")double value)
    {
        ArrayMemoryContext amc = context.as(ArrayMemoryContext.class);
        MemoryModel mm = amc.getMemoryModel();
        ProgressUpdater pu = context.as(ProgressUpdater.class);
        InterruptionContext ic = context.as(InterruptionContext.class);
        Class&lt;?&gt; eType = typeOf(elementType);
        Matrix&lt;? extends UpdatablePArray&gt; m =
            mm.newMatrix(UpdatablePArray.class, eType, dimX, dimY);
        UpdatablePArray a = m.array();
        long length = a.length();
        for (long k = 0; k &lt; length; k++) {
            a.setDouble(k, value);
            if ((k &amp; 0xFFFF) == 0) { // equivalent to k%65536==0
                ic.checkInterruption();
                pu.updateProgress((double)k / (double)length, false);
            }
        }
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newGrayscaleImage2D(m);
        return result;
    }
</pre>
<p>Теперь желаемый тип элементов результата &mdash; один из 8 примитивных типов Java &mdash;
описывается строчным параметром <code>elementType</code>, а значение-заполнитель
<code>value</code> &mdash; уже не <code>float</code>, а <code>double</code>,
которым можно описать практически любое значение любого примитивного типа...
Стоп! Почему, собственно, <code>elementType</code> <i>строчный</i>?
Ведь ясно, что нужен параметр типа <code>Class</code>!</p>
<p>На самом деле тут нет никаких "глубокомысленных" причин. Просто так удобнее.
Если вы все-таки когда-нибудь вызовете этот метод (на что я надеюсь) &mdash;
или написав собственный тест-утилиту, или применив мощную оболочку
<a href=http://algart.net/ww/simagis.com/>SIMAGIS</a> &mdash; вам придется как-то задавать этот параметр.
А если даже не вызовете, то во всяком случае этот метод вызывал <i>я</i>,
пока писал этот текст, а об удобстве автора тоже надо подумать.
Удобнее, если значение параметра можно ввести
при исполнении программы, а не "зашивать" в код теста.
Самый простой способ задать примитивный тип (не самый лучший, но зато вполне очевидный) &mdash;
набрать его имя, т.е. строчку "boolean", "byte" и т.д.
В учебном классе <code>SimplestTutorialDemo</code> есть простенькая сервисная private-функция
<code>typeOf</code>, преобразующая подобную строку в объект типа <code>Class</code>,
описывающий один из примитивных типов. Эта функция вызывается в нашем методе, чтобы превратить
<code>elementType</code> в переменную <code>eType</code> типа <code>Class</code>
(вернее, <code>Class&lt;?&gt;</code>, в соответствии с традициями современной Java).
Текст <code>typeOf</code> невелик, скучен и потому здесь не приводится. При желании, я полагаю,
вы можете запросто написать десяток подобных функций.</p>
<p>Начало нового метода почти повторяет предыдущий вариант, только добавляется
извлечение уже знакомых нам контекстов прогресса и прерываний.
Затем, как и ранее, мы создаем матрицу при помощи модели памяти <code>mm</code>,
но на этот раз указываем желаемый класс примитивного типа <code>eType</code>.
Это делается почти так же просто, как и создание матрицы конкретного типа:</p>
<pre>
        Matrix&lt;? extends UpdatablePArray&gt; m =
            mm.newMatrix(UpdatablePArray.class, eType, dimX, dimY);
</pre>
<p>Так, так... А зачем тут параметр <code>UpdatablePArray.class</code>?
Согласно здравому смыслу, а также описанному <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Matrix>в самом начале</a> понятию матрицы
и традициям нормальных языков программирования, чтобы создать матрицу,
вполне достаточно указать ее размеры и тип элементов!
То, что она окажется <code>Matrix&lt;?&nbsp;extends&nbsp;UpdatablePArray&gt;</code>, <i>уже вытекает</i>
из значения аргумента <code>eType</code>, который, как предполагается
(если функция <code>eType</code> написана без ошибок), всегда описывает примитивный тип!</p>
<p>Тут мне остается лишь принести извинения за язык Java. Его технология generics,
по крайней мере в версиях Java 5 и Java 6, автору кажется, скажем так, недостаточно развитой.
Может быть (и многие надеются на это), в следующих версиях ее расширят,
но пока, во избежание трудноуловимых ошибок,
порой приходится снабжать методы "костылями": параметрами типа <code>Class</code>,
с точки зрения логики совершенно избыточными.</p>
<p>Что же все-таки <i>делает</i> этот параметр?</p>
<p>Взгляните на декларацию вызываемого метода <code>newMatrix</code>:</p>
<pre>
    public&nbsp;&lt;T&nbsp;extends&nbsp;UpdatableArray&gt;&nbsp;Matrix&lt;T&gt; newMatrix(
        Class&lt;T&gt;&nbsp;arraySupertype, Class&lt;?&gt;&nbsp;elementType, long&nbsp;...dim);
</pre>
<p>Давайте попытаемся убрать первый параметр, чтобы сделать метод более "логичным":</p>
<pre>
    public &lt;T extends UpdatableArray&gt; Matrix&lt;T&gt; newMatrix(
        Class&lt;?&gt; elementType, long ...dim);
</pre>
<p>(По секрету: должен сознаться, к стыду своему, что в процессе создания библиотек в одной из ранних версий
<i>так оно и было</i>. И на старуху бывает проруха...)</p>
<p>На первый взгляд все нормально: мы можем присвоить результат любой матрице типа <code>Matrix&lt;T&gt;</code>,
где <code>T</code> &mdash; произвольный updatable-массив, т.е. допускающий изменения элементов.
(Кстати: конечно, <i>updatable</i>.
Кому нужна свежесозданная матрица, если ее элементам не удастся ничего присвоить.)
Конкретный тип массива <code>T</code>, скажем, <code>UpdatableByteArray</code>, будет определяться типом
элементов <code>elementType</code>, например:</p>
<pre>
        Matrix&lt;UpdatableByteArray&gt; m = mm.newMatrix(byte.class, dimX, dimY);
</pre>
<p>Будет ли?... А вот и нет. В языке Java, при всей его замечательности в прочих отношениях,
информация о generic-типах <i>стирается</i> в момент компиляции.
Во время исполнения программы такой оператор присваивания выполняется в точности так, как если
бы мы написали просто:</p>
<pre>
        Matrix m = mm.newMatrix(byte.class, dimX, dimY);
</pre>
<p>Что отсюда следует? Следует возможность написать следующую страшную вещь,
которая, что ужаснее всего, без ошибок отработает во время выполнения:</p>
<pre>
        Matrix&lt;UpdatableByteArray&gt; m = mm.newMatrix(short.class, dimX, dimY);
</pre>
<p>Сам по себе вызов <code>mm.newMatrix(short.class, dimX, dimY)</code> абсолютно корректен:
реализация метода <code>newMatrix</code>, какой бы хитроумной она ни была, не в состоянии
усмотреть в таких параметрах чего-либо "крамольного". Ну просят его создать матрицу с элементами
<code>short</code>, что ж, он и создаст. Откуда же методу <code>newMatrix</code> знать,
что глупый программист собирается присвоить созданную матрицу переменной типа
<code>Matrix&lt;UpdatableByteArray&gt;</code>, а не <code>Matrix&lt;UpdatableShortArray&gt;</code>!</p>
<p>Что будет дальше? Оператор присваивания <i>спокойно отработает</i> &mdash;
ведь после "стирания" в нем не осталось никаких намеков на <code>UpdatableByteArray</code>!</p>
<p>Сравните: если бы речь шла об обычных, не "генерализованных" классах и интерфейсах,
то никакого стирания бы не было, а компилятор потребовал бы от нас вставить оператор приведения типа.
При исполнении этого оператора, в случае несоответсвия типов,
произошло бы исключение времени выполнения <code>ClassCastException</code>.
Например:</p>
<pre>
        UpdatableByteArray a = (UpdatableByteArray)mm.newUnresizableArray(
            short.class, arrayLen);
        // - Генерируется ClassCastException при приведении типа,
        // так как метод возвращает тип UpdatableShortArray,
        // несовместимый с UpdatableByteArray.
        // Если же убрать приведение типов "(UpdatableByteArray)",
        // будет синтаксическая ошибка, так как newUnresizableArray
        // возвращает UpdatableArray, а не UpdatableByteArray.
</pre>
<p>Какие были бы последствия описаного метода <code>newMatrix</code>?
Самые печальные. При указании ошибочного типа элементов матрицы
ошибка останется незамеченной и "выплывет" где-то позже.
Возможно, при первой попытке "поработать" с созданной матрицей,
когда мы, скажем, попытаемся присвоить массив <code>m.array()</code> переменной
типа <code>UpdatableByteArray</code>.
Компилятор в этом случае не потребует явно приводить тип (как было бы при отсутствии generics),
поскольку "считает", что матрица <code>Matrix&lt;UpdatableByteArray&gt;</code> в принципе
не может содержать никакого другого массива, кроме <code>UpdatableByteArray</code>.
Приведение типа произойдет неявно, и программа выдаст <code>ClassCastException</code>
на "совершенно ровном" месте. Да и то, если повезет: скажем, код, ориентированный
на матрицы общего вида <code>Matrix&lt;?&nbsp;extends&nbsp;UpdatablePArray&gt;</code>
выполнится без исключений,
но, быть может, абсолютно неверно, если программист, видя тип конкретной переменной
<code>Matrix&lt;UpdatableByteArray&gt;</code>, существенно использовал 8-битовость элементов.</p>
<p>Правильное решение &mdash;
явно передать методу аргумент типа <code>Class&lt;T&gt;</code>, где <code>T</code> &mdash;
нужный нам generic-тип. Так и сделано в библиотеке AlgART. Для удобства читателя,
повторим декларацию из интерфейса <code>Matrix</code>:</p>
<pre>
    public&nbsp;&lt;T&nbsp;extends&nbsp;UpdatableArray&gt;&nbsp;Matrix&lt;T&gt; newMatrix(
        Class&lt;T&gt;&nbsp;arraySupertype, Class&lt;?&gt;&nbsp;elementType, long&nbsp;...dim);
</pre>
<p>(Кстати сказать, аналогичный прием используется
и в других методах, возвращающих результат с generics-параметром,
например, в методе <code>Matrix.cast</code>.)</p>
<p>Что изменилось, когда мы добавили параметр <code>Class&lt;T&gt;&nbsp;arraySupertype</code>?</p>
<p>С одной стороны, теперь метод <i>знает</i>, какой именно тип массива <code>T</code>
должен быть у создаваемой матрицы. Если тип элемента ему не соответствует,
то метод самостоятельно сгенерирует исключение <code>ClassCastException</code>:
ошибка далее не распространится.</p>
<p>С другой стороны, компилятор теперь получил возможность проконтролировать тип результата.
Ведь переданный параметр <code>Class</code> сам обладает параметром <code>T</code>, причем
тем же самым, который указан в качестве параметра матрицы.
Если мы попытаемся "обмануть" метод <code>newMatrix</code>, указав соответствующие друг другу,
но неверные <code>arraySupertype</code> и <code>elementType</code>,
то мы просто не сможем присвоить результат переменной-матрице с неподходящим generics-типом.
Скажем, следующий код попросту не скомпилируется:</p>
<pre>
        Matrix&lt;UpdatableByteArray&gt; m =
            mm.newMatrix(UpdatableShortArray.class, short.class, dimX, dimY);
        // ошибка: несовместимые параметры T у результата метода и переменной m
</pre>
<p>В нашем алгоритме мы "заказываем" тип массива <code>UpdatablePArray.class</code>:</p>
<pre>
        Matrix&lt;? extends UpdatablePArray&gt; m =
            mm.newMatrix(UpdatablePArray.class, eType, dimX, dimY);
</pre>
<p>Это значит, что метод <code>newMatrix</code> непременно вернет матрицу,
generics-параметр которой соответствует массиву с элементами примитивного типа, т.е.
является <code>UpdatablePArray</code> или его наследником.
Такую матрицу, естественно, мы имеем право присвоить переменной типа
<code>Matrix&lt;UpdatablePArray&gt;</code> и, конечно же,
переменной более общего типа <code>Matrix&lt;?&nbsp;extends&nbsp;UpdatablePArray&gt;</code>.
Мы выбираем второй, более общий вариант: см. вступление про <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#generics>матрицы и generics</a>.
<p>Дальнейшая часть метода достаточно очевидна.
Производится цикл по массиву и каждому его элементу присваивается значение <code>value</code>.
На этот раз используется общий метод <code>setDouble</code> интерфейса <code>UpdatablePArray</code>,
применимый к массивам любого примитивного типа.</p>
<p>Подобно методу <code>getDouble</code>, метод <code>setDouble</code> позволяет
писать общие, хотя и не самые эффективные алгоритмы, обрабатывающие массивы элементов
любого примитивного типа. Подобно <code>getDouble</code>, этот метод выполняет автоматическое
преобразование типов. И подобно <code>getDouble</code>, этот метод нарушает традиции
языка Java, воспринимая значения типа <code>byte</code> и <code>short</code> как беззнаковые...</p>
<p>Стоп. А правда ли нарушает? Загляните в JavaDoc-комментарий к <code>setDouble</code>.
Как ни странно, в отличие от <code>getDouble</code>, в этом комментарии нет никаких
оговорок насчет типов <code>byte</code> и <code>short</code>. Простым английским языком сказано:
"Sets the element #<code>index</code> by convertion from <code>double</code>,
as <code>(xxx)value</code> for numeric element type <code>xxx</code>
(<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>,
<code>float</code>, <code>double</code> or <code>char</code>),
or as <code>value!=0.0</code> for <code>boolean</code> element type."</p>
<p>В чем дело? Неужели ошибка? Может быть, <code>getDouble</code> и <code>setDouble</code>
не соответствуют друг другу &mdash; записав значение методом <code>setDouble</code>,
при чтении методом <code>getDouble</code> мы рискуем получить нечто совершенно другое?</p>
<p>Конечно, никакой ошибки здесь нет &mdash; иначе, надо полагать, я бы не стал об этом писать.
Однако разобраться в этом весьма важно, дабы не попасть "впросак" потом,
когда вам понадобится реализовать аналогичную конверсию самостоятельно &mdash;
скажем, при заполнении AlgART-массива через <code>DataBuffer</code>.</p>
<p>Чтобы понять, почему в <code>setDouble</code> "все чисто", надо внимательно проанализировать, что
<i>на самом деле</i> делает кажущийся столь простым оператор приведения типа
<code>(xxx)value</code>, заявленный в комментарии к <code>setDouble</code>.</p>
<p>Пусть <code>value</code> &mdash; переменная типа <code>double</code>,
содержащая значение 200, и мы пытаемся выполнить <code>setDouble</code> с таким аргументом
для случая <i>байтового</i> массива <code>UpdatableByteArray</code>.
Мнения библиотек AlgART и языка Java насчет интерпретации такой величины в качестве <i>байта</i>
расходятся. Для нас это нормальный беззнаковый байт, равный 200.
Для языка Java, такое значение не может храниться в переменной типа <code>byte</code>:
эти переменные изменяются от -128 до +127.</p>
<p>Что произойдет, если все же выполнить приведение типа <code>(byte)value</code> &mdash;
т.е. сделать в точности то, что, согласно документации, делает метод <code>setDouble</code>?
Если вы напишете коротенький тест, вы убедитесь, что <code>(byte)200.0</code> равно <code>-56</code>!</p>
<p>Почему? Потому, что язык Java <i>вначале</i> приводит вещественный тип к
"универсальному" целочисленному типу <code>int</code>, а только потом конвертирует
тип <code>int</code> в более узкие типы <code>byte</code>, <code>short</code> или <code>char</code>.
Именно такое поведение зафиксировано в спецификации языка.
И если приведение <code>double</code> к <code>int</code> сопровождается усечением
слишком больших значений до диапазона <code>Integer.MIN_VALUE..Integer.MAX_VALUE</code>,
то конверсия <code>int</code> в <code>byte</code> (как и всякая конверсия более
широкого <i>целого</i> типа к более узкому) означает всего-навсего отбрасывание старших битов.
В результате 200.0 превращается вначале в положительное <code>int</code>-значение 200
(в двоичной системе это 11001000),
а уже это число далее превращается в байт, состоящий из тех же самых 8 битов 11001000.
С точки зрения Java, полученный байт равен -56, а с нашей, "беззнаковой" точки зрения
он как раз содержит 200! Иначе говоря, все в порядке: последующий вызов <code>getDouble</code>,
действуя в соответствии с "беззнаковыми" соглашениями, для такого байта вернет правильное
значение 200.0. Т.е. произойдет в точности то, что требуется.</p>
<p>Будьте внимательны! В качестве "универсальной разменной монеты" для целых чисел
язык Java применяет именно <code>int</code>, а не <code>long</code>.
Поэтому, если мы попытаемся повторить те же действия с чрезвычайно большим
(больше <code>Integer.MAX_VALUE</code>) целым значением,
представленным типом <code>double</code>, и переменной (типом элемента) <code>int</code>,
поведение будет <i>другим</i>! Впрочем, по-прежнему согласующимся с документацией
на методы <code>getDouble</code> и <code>setDouble</code>.
А именно, если попытаться привести очень большое число <code>double</code>,
скажем, 10<sup>12</sup>, к типу <code>int</code> (оператором <code>(int)value</code>)
Java <i>не будет</i> предварительно конвертировать его в более "широкий" тип <code>long</code>
с последующим отбрасыванием "лишних" битов. Вместо этого, оператор <code>(int)value</code>
выполнит "усечение" до ближайшего допустимого int-значения, т.е. вернет <code>Integer.MAX_VALUE</code>.</p>
<p>На этом мы заканчиваем рассмотрение данного примера и переходим к разбору более
эффективных решений, не использующих метод <code>setDouble</code>.</p>
<h4 style="margin-bottom: 0px"><a name=constant_3></a>9. Генерация константного изображения: да здравствует лень</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_2>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_4>Следующий раздел</a></div>
<p>Сейчас мы могли бы пойти <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_4_dataBuffer>тем же путем,
что и при вычислении средней яркости</a>:
заменить поэлементный цикл вызовов <code>setDouble</code> использованием
буферов данных (<code>DataBuffer</code>), возможно, добавить распараллеливание.
Однако это довольно скучно. Кроме того, решения, которые мы изложим далее,
во многих случаях оказываются более удобными и эффективными.</p>
<p>Поэтому мы оставим перевод предыдущего примера на технику <code>DataBuffer</code>
читателю в качестве упражнения. В некоторых алгоритмах
такой способ заполнения массива, безусловно, является правильным решением, и невредно
его освоить. На случай, если читатель окажется настолько храбрым
(и при этом недостаточно ленивым &mdash; вопреки заголовку параграфа),
что действительно возьмется за это упражнение, дам несколько подсказок.</p>
<p>Цикл заполнения массива <code>a=m.array()</code> (для свежесозданной матрицы <code>m</code>)
при помощи <code>DataBuffer</code> должен быть аналогичен циклу чтения матрицы
через <code>DataBuffer</code>, <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_4_impl>разобранному нами ваше</a>
в алгоритме вычисления средней яркости. С той очевидной разницей,
что теперь массив <code>data()</code> будет не читаться, а заполняться требуемой константой.
Нетривиальных отличий всего два.</p>
<p>Во-первых, разумеется, режим чтения <code>DataBuffer.AccessMode.READ</code>
(параметр метода <code>a.buffer</code>) теперь не годится. Нужно указать режим
<code>DataBuffer.AccessMode.READ_WRITE</code>. Можно и ничего не указывать,
вызвав метод <code>a.buffer()</code> без аргументов: по умолчанию для updatable-массива метод
выберет правильный режим. Но явное указание режима улучшит читабельность и поможет
раньше обнаружить возможную ошибку.</p>
<p>Во-вторых, в конце цикла, после заполнения очередного массива <code>data()</code>,
<i>вы должны вызвать метод <code>buf.force()</code></i>.</p>
<p>Будьте внимательны! Если вы забудете вызвать <code>force()</code>, и даже если вы используете
неверный режим доступа <code>READ</code>, в некоторых случаях ваш метод,
<i>тем не менее, будет работать правильно</i>!
Например, если модель памяти <code>mm</code>, использованная для создания матрицы
&mdash; это <code>SimpleMemoryModel</code>.
Напоминаю, что в этом случае AlgART-массив является "оболочкой" вокруг обычного Java-массива.
Соответственно, результат метода <code>buf.data()</code> будет ссылкой
на этот Java-массив, и модификации элементов <code>data()</code>
немедленно отразятся на содержимом матрицы.
В то же время, в других моделях памяти, вероятнее всего, вызов метода <code>force()</code>
будет абсолютно необходим &mdash; для того, чтобы переслать измененные данные
из временного буфера в фактическое хранилище элементов.
Иначе говоря, применение буферов данных для модификации элементов <i>требует определенной
аккуратности</i>: нужно использовать правильный режим доступа и
обязательно своевременно вызывать <code>force()</code>.
Такова цена за универсальность и эффективность технологии буферов.</p>
<p>Осталось добавить, что в классе <code>PackedBitArrays</code> вы найдете метод,
нужный для заполнения константой упакованного битового массива.
А также, что на этот раз
поддержка беззнаковости для типов <code>byte</code>
и <code>short</code> не потребует специальных усилий
(в отличие от цикла вычисления суммы, где пришлось использовать операторы
<code>&amp;0xFF</code> и <code>&amp;0xFFFF</code>):
вспомните рассуждения о методе <code>setDouble</code> в конце предыдущего параграфа.
Удачи в решении упражнения!</p>
<p>Перейдем к обещанному альтернативному решению задачи. Вот оно:</p>
<pre>
    public static Image2D constant_3(Context context,
        @Name("dimX")long dimX, @Name("dimY")long dimY,
        @Name("elementType")String elementType, @Name("value")double value)
    {
        Class&lt;?&gt; eType = typeOf(elementType);
        if (dimX &lt; 0)
            throw new IllegalArgumentException("Negative dimX");
        if (dimY &lt; 0)
            throw new IllegalArgumentException("Negative dimY");
        long length = Arrays.longMul(dimX, dimY);
        if (length == Long.MIN_VALUE)
            throw new TooLargeArrayException();
        PArray a;
        if (eType == boolean.class) {
            a = Arrays.nBitCopies(length, value != 0.0);
        } else if (eType == char.class) {
            a = Arrays.nCharCopies(length, (char)value);
        } else if (eType == byte.class) {
            a = Arrays.nByteCopies(length, (byte)value);
        } else if (eType == short.class) {
            a = Arrays.nShortCopies(length, (short)value);
        } else if (eType == int.class) {
            a = Arrays.nIntCopies(length, (int)value);
        } else if (eType == long.class) {
            a = Arrays.nLongCopies(length, (long)value);
        } else if (eType == float.class) {
            a = Arrays.nFloatCopies(length, (float)value);
        } else if (eType == double.class) {
            a = Arrays.nDoubleCopies(length, (double)value);
        } else {
            throw new AssertionError("Must not occur");
        }
        Matrix&lt;? extends PArray&gt; m = Matrices.matrix(a, dimX, dimY);
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newGrayscaleImage2D(m);
        return result;
    }
</pre>
<p>По сравнению с предыдущим решением, сразу обращает на себя внимание странная вещь:
куда-то пропали контексты прерываний и прогресса.
Что это &mdash; небрежность автора, которому больше не хочется думать о пользователе?</p>
<p>На самом деле, эти контексты стали <i>не нужны</i>.
По очень простой причине: данный метод выполняется практически мгновеннно!
Вернее, не весь метод, а его основная часть, от начала до вызова
<code>newGrayscaleImage2D</code> &mdash; метода, находящегося "вне нашей компетенции"
и поставляемого внешним приложением через контекст <code>ImageContext</code>.
На моем компьютере основная часть метода, создающая AlgART-матрицу <code>m</code>,
отрабатывает примерно за 50 микросекунд,
причем <i>независимо от размеров создаваемой матрицы</i>.
Очевидно, контексты прерываний и прогресса при такой скорости просто не нужны.
(Собственно, их и вставить было бы некуда: в этом решении нет ни циклов,
ни методов, принимающих контексты в качестве аргумента.)</p>
<p>В чем секрет такого "супербыстродействия"? Если вы имели дело с методом
<code>nCopies</code> из класса <code>java.util.Collections</code>, вы, наверно, уже догадались.
Итак &mdash; <i>добро пожаловать в мир лени!</i></p>
<p>На более "официальном" языке применяемый механизм называется
<i>ленивые</i>, или <i>отложенные вычисления</i>.
Это значит, что методы <code>n<i>Xxx</i>Copies</code>, являющиеся "сердцем" новой реализации,
сами по себе не выполняют заказанную задачу &mdash; заполнение константой
некоторой области памяти. Вместо этого они возвращают реализацию интерфейса
<code>PArray</code>, в которой методы доступа всегда возвращают
элементы, равные заказанной константе. Создание экземпляра такой реализации
почти не требует ни времени, ни памяти. Подобные реализации AlgART-массивов
мы будем называть <i>ленивыми массивами</i>.</p>
<p>Как мы увидим далее, ленивые массивы весьма активно используются при работе с библиотеками AlgART.
Очень многие простые задачи можно выразить "лениво" &mdash; созданием
подходящей реализации интерфейса <code>PArray</code> и его частных наследников
<code>ByteArray</code>, <code>ShortArray</code> и т.д.
Существуют специальные классы-"заготовки" <code>AbstractByteArray</code>,
<code>AbstractShortArray</code> и т.д., упрощающие написание таких реализаций.
С помощью этих классов, например, можно было бы очень легко создать не массив-"константу",
а массив, элементы которого вычисляются на основе индекса по некоторой формуле.
Как правило, такой подход позволяет сэкономить как время, так и память.</p>
<p>Приятной новостью оказывается то, что не надо писать сложных и занудных циклов.
Не надо также думать о контекстах прерываний и прогресса.
Об этом придется позаботиться клиентскому коду, когда он захочет
что-то проделать с полученным массивом &mdash; например, нарисовать изображение
или посчитать по нему среднюю яркость.
На самом деле, как мы увидим далее,
самая типичная операция, применяемая к ленивым массивам &mdash; это банальное
копирование их в "настоящие" массивы, создаваемые методами модели памяти <code>MemoryModel</code>:
<code>newMatrix</code>, <code>newArray</code> или <code>newUnresizableArray</code>.
А поскольку для этой задачи предусмотрена готовая функция,
"понимающая" контексты и умеющая распараллеливаться на многопроцессорных системах, то труд программиста
по написанию максимально эффективного кода упрощается весьма заметно.
Автор очень порадовался, когда впервые заметил эту особенность созданных им библиотек.
Но мы забегаем вперед.</p>
<p>Если читатель помнит <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_1>многословные рассуждения</a>
о мощной и со всех сторон замечательной концепции <i>моделей памяти</i>,
у него может возникнуть резонный вопрос &mdash; к какой модели памяти
принадлежат массивы, созданные методами <code>n<i>Xxx</i>Copies</code>?
Ответ прост: ни к какой. <code>Array</code> и его наследники &mdash;
это интерфейсы, и никто не мешает их реализовать, не задумываясь ни о каких
моделях памяти. В данном случае так оно и есть. Более того, это касается
большинства разновидностей ленивых массивов.</p>
<p>Это оправдано. Модель памяти &mdash; достаточно сложная абстракция,
касающаяся прежде всего именно <i>хранения</i> данных. А как раз хранить данные
ленивому массиву не надо: он их вычисляет в момент обращения. Кроме того,
реализация модели памяти обязана предоставить методы-фабрики для массивов
всех уровней изменяемости: <code>Array</code> (доступ на чтение),
<code>UpdatableArray</code> (чтение и запись элементов)
и <code>MutableArray</code> (чтение, запись и изменение длины).
Ленивый же массив, как правило, является неизменяемым и не имеет изменяемых аналогов,
реализующих <code>UpdatableArray</code> и тем более <code>MutableArray</code>.</p>
<p>На что еще стоит обратить внимание в нашем примере?
Наверно, на относительно сложные манипуляции с параметрами <code>dimX</code>
и <code>dimY</code> в самом начале метода.
В предыдущих примерах мы просто передавали эти параметры методу <code>newMatrix</code>,
который выполнял все необходимые проверки на корректность.
Но в библиотеках (по крайней мере в текущей версии) нет средств
создать константную <i>матрицу</i>, есть только методы создания линейного массива
<code>Arrays.n<i>Xxx</i>Copies</code>.
Матрица создается уже после полного формирования массива при помощью сервисного метода
<code>Matrices.matrix</code>, конвертирующего массив в матрицу.</p>
<p>Чтобы создать массив, нужно вначале вычислить его длину <code>dimX*dimY</code>.
А чтобы вычислить ее без ошибок, нужно тщательно проверить аргументы.
Помните о переполнении! Вы же не хотите, чтобы, скажем, для параметров
<code>dimX=2<sup>32</sup></code> и <code>dimY=2<sup>32</sup></code>
наш код создал массив длины <code>0</code> (такая длина получится
при попытке тривиально перемножить эти <code>long</code>-значения).
Поэтому мы заранее проверяем параметры на неотрицательность,
а для перемножения используем специальную функцию <code>Arrays.longMul</code>,
позволяющую обнаружить факт переполнения.
(Да-да, не на положительность, а именно на <i>неотрицательность</i>! Нулевой размер матрицы
по любой координате в библиотеках AlgART считается корректным.
Имейте это в виду при написании алгоритмов обработки: они должны быть
готовы "справиться" с нулевыми размерами.)</p>
<p>На самом деле, конкретно в этом методе мы могли бы обойтись без проверок <code>dimX</code>
и <code>dimY</code> и даже написать "крамольный" оператор
<code>length=dimX*dimY</code>.
Функция <code>n<i>Xxx</i>Copies</code>, даже получив "бессмысленную" длину, не сделает
ничего страшного: в худшем случае вернет массив с неправильной длиной,
не затратив при этом никаких ресурсов.
А следующий за этим вызов <code>Matrices.matrix</code> проверит аргументы на корректность.
Однако, хороший тон требует всегда выполнять все проверки вовремя.
Эта привычка поможет вам в других ситуациях &mdash; когда, например,
по заданным размерностям будет создаваться реальный, не ленивый массив, занимающий память,
или когда вам понадобится цикл по такому массиву.
Чем раньше вы обнаружите заведомо "дикие" значения аргументов,
тем раньше программа выведет сообщение об ошибке, вместо того чтобы тратить время и память
на обработку полученного массива.
Скажем, если аргументы <code>dimX</code> и <code>dimY</code>
содержат "двоичный мусор" (случайный набор битов, прочитанный по ошибке из какого-нибудь файла),
то их произведение, вычисленное оператором <code>dimX*dimY</code>,
с вероятностью 1/2 окажется неотрицательным, т.е. корректной величиной в качестве
возможной длины массива. Причем, очевидно, астрономически большой.
Если же заранее проверить аргументы, как это сделано в нашем примере,
то сработает либо проверка на отрицательность, либо
&mdash; с почти стопроцентной вероятностью &mdash; проверка на переполнение:
случайные <code>long</code> значения при перемножении почти наверняка не "уложатся" в 63 бита.</p>
<h4 style="margin-bottom: 0px"><a name=constant_4></a>10. Генерация константного изображения: ленимся грамотно</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_3>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_5>Следующий раздел</a></div>
<p>У предыдущего примера есть очевидный недостаток: мы вынуждены были написать
8 веток для всех примитивных типов. Конечно, это неудобно.
Когда мы решали задачу вычисления яркости, от написания 8 веток нас
в конце концов "спасла" библиотечная функция <code>Arrays.sumOf</code>,
которая "понимала" любой примитивный тип элементов.
Нет ли и здесь библиотечной функции, которая поможет нам избавиться
от громоздкого ветвления по типам?</p>
<p>Да, есть. И это несколько неожиданная функция, позволяющая, на самом деле,
решить куда более обширный класс задач, чем генерация константного изображения.
Представляю вам "великую и ужасную" функцию <i><code>asFuncMatrix</code></i>:</p>
<pre>
    public static Image2D constant_4(Context context,
        @Name("dimX")long dimX, @Name("dimY")long dimY,
        @Name("elementType")String elementType, @Name("value")double value)
    {
        ArrayMemoryContext amc = context.as(ArrayMemoryContext.class);
        MemoryModel mm = amc.getMemoryModel();
        Class&lt;?&gt; eType = typeOf(elementType);
        Class&lt;? extends PArray&gt; aType = Arrays.type(PArray.class, eType);
        Func f = ConstantFunc.getInstance(value);
        Matrix&lt;? extends PArray&gt; m = Matrices.asFuncMatrix(mm, f, aType, dimX, dimY);
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newGrayscaleImage2D(m);
        return result;
    }
</pre>
<p>Ядро нового решения состоит всего из двух строчек:</p>
<pre>
        Func f = ConstantFunc.getInstance(value);
        Matrix&lt;? extends PArray&gt; m = Matrices.asFuncMatrix(mm, f, aType, dimX, dimY);
</pre>
<p>Прежде всего: что такое <code>Func</code>? Это чрезвычайно общий интерфейс из нового для нас пакета
<code>net.algart.math.functions</code>.
Интерфейс <code>Func</code> представляет собой абстрактную математическую
функцию <i>f</i>, получающую на вход произвольный набор вещественных чисел-аргументов
и возвращающая вещественное число-результат.
Основной метод этого интерфейса объявлен так:</p>
<pre>
    public double get(double ...x);
</pre>
<p>Здесь <code>x</code> &mdash; аргументы математической функции <i>f</i>, и метод <code>get</code> должен
вернуть результат применения функции к этим аргументам, т.е.
<i>f</i>(<i>x</i><sub>0</sub>,&nbsp;<i>x</i><sub>1</sub>,&nbsp;...,&nbsp;<i>x</i><sub><i>n</i>-1</sub>)
(где <i>n</i> &mdash; длина массива аргументов <code>x</code>).</p>
<p>В пакете <code>net.algart.math.functions</code> предусмотрен ряд реализаций интерфейса
<code>Func</code>, соответствующий наиболее употребительным математическим функциям.
Например, <code>Func.MAX</code>: метод <code>get</code> обрабатывает произвольное число аргументов
и возврашает максимальное из переданных чисел. Или <code>Func.ABS_DIFF</code>: у этой функции
должно быть не менее двух аргументов, и метод <code>get</code> возвращает модуль разности первых двух
|<i>x</i><sub>0</sub>-<i>x</i><sub>1</sub>|.
(По соглашению, метод <code>get</code> игнорирует лишние аргументы,
если таковые переданы, но имеет право потребовать наличия хотя бы некоторого количества
аргументов, как в случае <code>Func.ABS_DIFF</code> и многих других функций.)</p>
<p>Второй "кирпичик" нового решения &mdash; метод <code>asFuncMatrix</code>.
Этот метод позволяет поэлементно применить заданную функцию <code>Func</code>
к нескольким AlgART-матрицам с одинаковым набором размерностей.
Например, для двух 2-мерных матриц A и B размером 1000x1000 метод <code>asFuncMatrix</code> позволяет
вернуть матрицу-максимум M того же размера 1000x1000, каждый элемент которой является максимумом из
двух соответствующих элементов A и B. Или, если нужно, модулем разности этих двух элементов.
Или разностью, или суммой, или произведением (такие стандартные функции уже предусмотрены).
Или вообще чем угодно, если вы сами реализуете интерфей <code>Func</code>.</p>
<p>Метод <code>asFuncMatrix</code>, подобно <code>Arrays.n<i>Xxx</i>Copies</code>,
возвращает <i>ленивый</i> результат. (На это, кстати, указывает префикс "<code>as</code>":
возвращается <i>представление</i> входных массивов, а не новый массив.)
Реализация AlgART-массива, лежащего в основе полученной матрицы,
запоминает ссылки на исходные массивы (лежащие в основе входных матриц),
и при каждой попытке чтения своих элементов вычисляет затребованную функцию для
соответствующих элементов исходных массивов.</p>
<p>Эта концепция весьма общая и мощная. Реализуя разные варианты интерфейса <code>Func</code>
(что, как правило, весьма тривиально), мы получаем возможность с помощью всего одного
стандартного метода <code>asFuncMatrix</code> выполнять самые разнообразные поэлементные
операции над разными матрицами. Вплоть до весьма неочевидных!
Так, в библиотечном классе <code>Func.SELECT</code> метод <code>get</code>
возвращает один из своих аргументов, номер которого определяется первым аргументом.
Такая функция, будучи применена
к целочисленной или бинарной матрице и произвольному набору других матриц,
позволяет скомбинировать несколько изображений, выбирая каждый пиксел согласно
номеру (или биту 0/1) из первой матрицы.</p>
<p>Но как же применяется данная технология в нашем случае?
Ведь у нас нет <i>ни одной</i> входной матрицы.
Тем не менее, нам надо создать матрицу-результат.</p>
<p>Дело в том, что допускается вырожденный случай функции <code>Func</code>:
функция с <i>нулевым</i> числом аргументов.
Именно такова применяемая нами функция <code>ConstantFunc</code>:
в ней метод <code>get</code> игнорирует все аргументы и всегда возвращает
число, заданное в параметре метода генерации <code>getInstance</code>.</p>
<p>У метода <code>Matrices.asFuncMatrix</code>, в действительности,
есть целый ряд перегруженных вариантов, отличающихся набором аргументов.
Мы используем вариант, рассчитанный на функцию без аргументов.
В этом случае никакие входные матрицы передавать не нужно, но надо
в последних параметрах указать требуемые размерности создаваемой матрицы.
Если бы мы хотели вычислить поэлементный максимум или сумму двух матриц,
мы передали бы в <code>asFuncMatrix</code> эти две матрицы (тоже последними параметрами).
В этом случае метод получил бы требуемые размеры из переданных матриц,
заодно протестировав их на совпадение.</p>
<p>Кстати, заметим, что все методы <code>Matrices.asFuncMatrix</code> &mdash;
всего лишь "надстройки" над аналогичными методами <code>Arrays.asFuncArray</code>,
обрабатывающими линейные AlgART-массивы.
Наш пример можно было бы переписать с использованием этих методов.
Правда, тогда нам пришлось бы конструировать матрицу из массива самостоятельно,
так же, как мы это делали в предыдущем примере.</p>
<p>Но как же метод <code>asFuncMatrix</code> решает проблему разрядности элементов?
Ведь интерфейс <code>Func</code> "работает" исключительно с типом <code>double</code>!</p>
<p>Требуемая разрядность результата задается аргументом <code>aType</code>.
Это не класс примитивного типа вроде <code>byte.class</code>,
а некоторый класс или интерфейс, реализующий (расширяющий) базовый интерфейс <code>PArray</code>.
Например, чтобы получить в результате байтовую матрицу, мы должны указать
<code>ByteArray.class</code> или какой-нибудь класс, реализующий этот интерфейс.
Точные соглашения относительно этого параметра, а также способ его получения,
мы обсудим чуть позже. А пока сосредоточимся на правилах конверсии типов,
осущeствляемой методом <code>asFuncMatrix</code>.</p>
<p>Общий алгоритм вычисления элементов результирующей матрицы, реализуемый методом
<code>asFuncMatrix</code>, следующий.
Прежде всего, для всех входных матриц (если они имеются: в нашем примере их нет)
извлекатюся числовые значения соответствующих элементов.
Значения элементов конвертируются в тип <code>double</code>
по тем же соглашениям, что и в методе <code>PArray.getDouble</code>:
см. наш <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_1>самый первый пример чтения элементов матрицы</a>.
Затем к этим элементам применяется заданная функция <code>Func</code>:
вызывается ее метод <code>get</code>.
Получается некий результат типа <code>double</code>.
Далее этот результат "разумным" образом преобразуется в заказанный примитивный тип,
определяемый параметром <code>aType</code>.</p>
<p>Что значит "разумным"? Подробности, конечно, абсолютно точно сформулированы в JavaDoc,
но читать эту спецификацию довольно утомительно.
Кратко можно сказать, что при конверсии к целым типам производится
<i>усечение</i> до допустимого диапазона с последующим <i>округлением</i>.
(Округление производится простейшим способом, т.е. "в сторону нуля"
&mdash; так же, как в операторе <code>(int)v</code> для вещественного <code>v</code>.)
При этом, согласно общему соглашению библиотек AlgART,
типы <code>byte</code> и <code>short</code> считаются беззнаковыми,
с диапазонами изменения <code>0..255</code> и <code>0..65535</code>.
В отличие от операторов приведения типов Java, старшие биты никогда не отбрасываются:
вместо этого при необходимости производится усечение до допустимого диапазона.
Например, в нашем случае, если мы "закажем" в качестве результата байтовую матрицу,
то константа <code>value=157.8</code> округлится до 157 (не до 158!),
отрицательные <code>value</code> дадут 0 (черное изображение в обычной интерпретации),
а все <code>value&gt;255</code> превратятся в максимальную яркость 255 (белое изображение).</p>
<p>Этим поведением, впрочем, можно управлять, указав методу <code>asFuncMatrix</code> необязательный
второй boolean-параметр <code>truncateOverflows</code>, равный <code>false</code>.
(Только что описанное поведение соответствует значению <code>true</code>.)
Если этот параметр равен <code>false</code>, поведение, в некотором смысле, меняется на противоположное:
усечение до допустимого диапазона по возможности не производится,
а вместо этого "лишние" старшие биты просто отбрасываются.
Подробнее см. JavaDoc. Впрочем, такой режим является экзотикой:
чаще всего наиболее разумным выбором является описанный выше вариант.</p>
<p>Если результат должен иметь тип <code>boolean</code> (битовая матрица), используется простейшее
соглашение, такое же, как в методах <code>getDouble</code> и <code>setDouble</code>.
Вещественное число, точно равное <code>0.0</code> (в смысле оператора <code>==</code>),
преобразуется в 0 (<code>false</code>), все прочие числа &mdash; в 1 (<code>true</code>).</p>
<p>Надо полагать, читатель уже испугался.
Ведь все эти сложные преобразования, наверно, расходуют уйму времени!
Неужели, чтобы вычислить, например, поэлементный модуль разности двух <i>байтовых</i> матриц,
метод <code>asFuncMatrix</code> предусматривает преобразование каждого байта в <code>double</code>,
применение к двум <code>double</code> метода <code>Func.ABS_DIFF.get</code>
и округление результата, с проверкой на попадание в диапазон 0..255?
А наш случай &mdash; неужели требуемая вещественная константа будет проходить
через все эти "ужасы" при получении каждого элемента или последовательности элементов результата?</p>
<p>Конечно, нет. Я не зря с самого начала назвал метод <code>asFuncMatrix</code> "великим и ужасным".
Этот метод "знает" о большинстве стандартных функций, реализованных в пакете
<code>net.algart.math.functions</code>, и предусматривает для них специальные реализации
своего ленивого результата.
Так, если мы попытаемся передать в метод <code>asFuncMatrix</code> функцию <code>Func.ABS_DIFF.get</code>
и две байтовые матрицы, и при этом "закажем" на выходе тоже байтовую матрицу
&mdash; что, конечно, вполне естественно,
&mdash; то метод "догадается" создать предельно эффективную реализацию ByteArray
(в качестве "основы" для возвращаемой матрицы).
В этой реализации методы доступа к элементам будут вычислять модуль разности
непосредственно для байтовых элементов. Более того, блочные методы доступа,
применяемые, скажем, при работе через <code>DataBuffer</code>,
будут считывать блоки байтов в массивы типа <code>byte[]</code> и
эффективным циклом выполнять поэлементную обработку таких массивов.
В случае же, скажем, битовых матриц,
когда нужно вычислять модуль разности двух упакованных битовых массивов,
представленных в виде <code>long[]</code>,
метод <code>asFuncMatrix</code> будет применять к упакованным <code>long</code>-значениям
оператор исключающего "или" (<code>a^b</code>).</p>
<p>Также имеется множество других оптимизаций.
Скажем, если даже функция <code>Func</code> не принадлежит к числу "стандартных"
(предусмотренных в пакете <code>net.algart.math.functions</code> и "известных" методу <code>asFuncMatrix</code>),
но это &mdash; функция одного аргумента, и вам нужно применить ее к битовой, байтовой (8-битовой)
или 16-битовой матрице, то метод <code>asFuncMatrix</code> построит таблицу результатов
<code>f(x)</code> для всех 2, 256 или 65536 возможных вариантов аргумента,
чтобы впоследствии получать требуемые результаты максимально быстро.
Метод <code>asFuncMatrix</code> также "знает" о модели памяти <code>SimpleMemoryModel</code>,
в которой некоторые операции можно выполнить без лишних копирований,
умеет специально опознавать и оптимизировать случай, когда его результат впоследствии копируется
на место одной из входных матриц (операции "на месте"), и многое, многое другое.
Причем набор оптимизаций постепенно расширяется, благо это не затрагивает API библиотек.
Если окажется, что для вашей задачи решение, предлагаемое методом <code>asFuncMatrix</code>,
недостаточно эффективно, сообщите об этом автору. Возможно, в следующей версии
нужная вам функция будет добавлена в пакет <code>net.algart.math.functions</code>,
а метод <code>asFuncMatrix</code> будет дополнительно оптимизирован для этого случая.</p>
<p>В текущей версии библиотек, метод <code>asFuncMatrix</code> "знает" и вычисляет
по возможности оптимально следующие функции:
<code>Func.IDENTITY</code>, <code>Func.MIN</code>, <code>Func.MAX</code>,
<code>Func.ABS_DIFF</code>, <code>Func.POSITIVE_DIFF</code>,
<code>LinearFunc</code> и &mdash; конечно же &mdash; нужную нам <code>ConstantFunc</code>.</p>
<p>На самом деле, в нашем случае результат метода <code>asFuncMatrix</code>
будет <i>точно такой же</i>, как в нашем предыдущем решении!
Ибо для случая функции <code>ConstantFunc</code> метод <code>asFuncMatrix</code>, не мудрствуя лукаво,
попросту вызывает один из методов <code>Arrays.n<i>Xxx</i>Copies</code>
в соответствии с затребованным типом результата и описанными выше правилами конверсии типов.
(Так что идентичность предыдущему решению все-таки неполная.
Раньше наша константа конвертировалась в требуемый тип по более простым правилам,
не обеспечивающим корректного отсечения для 8- и 16-битовых матриц.)
В сущности, в данном случае <code>asFuncMatrix</code> просто слегка сэкономил нам размер кода.
В более полезных алгоритмах <code>asFuncMatrix</code> становится воистину незаменимым.
Ведь он позволяет компактно описать любые поэлементные операции
с серией массивов или матриц любой разрядности. Причем
для всех популярных функций и разрядностей будут использованы
мощные и нетривиальные оптимизации, совершенствующиеся от версии к версии.</p>
<p>Мне осталось, как я обещал выше, прокомментировать параметр <code>aType</code>.
И правда, почему передается класс <i>массива</i>, а не примитивный тип элемента?
Ведь так было бы проще.</p>
<p>Вспомните проблему, с которой мы столкнулись при разборе метода <code>newMatrix</code>
во <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_2>втором примере генерации константного изображения</a>.
Обратите внимание на декларацию метода <code>asFuncMatrix</code>:</p>
<pre>
    public static &lt;T extends PArray&gt; Matrix&lt;T&gt; asFuncMatrix(
        MemoryModel resultMemoryModel,
        Func f, Class&lt;? extends T&gt; requiredType, long ...resultDim)
</pre>
<p>Такая декларация позволяет безопасно написать, скажем, следующее:</p>
<pre>
        Matrix&lt;ByteArray&gt; m = Matrices.asFuncMatrix(mm,
            f, ByteArray.class, dimX, dimY);
</pre>
<p>Если бы мы передавали примитивный тип, то компилятор не смог бы проверить его соответствие
generics-типу, необходимому в контексте вызова метода &mdash; в данном случае,
типу переменной <code>m</code>. Это значит, что нам всегда пришлось бы возвращать
<code>Matrix&lt;?&nbsp;extends&nbsp;PArray&gt;</code>, даже когда мы точно знаем разрядность
результата. Конечно, это менее удобно.</p>
<p>Обратите внимание: в качестве аргумента <code>requiredType</code>
разрешается передать либо один из 8 конкретных интерфейсов <code>ByteArray</code>,
<code>ShortArray</code> и т.д., либо некий класс, реализующий требуемый интерфейс.
(Однако, этому классу <i>не разрешается</i> реализовывать <code>UpdatableArray</code>:
ведь полученный ленивый массив или матрица неизменяемы.)
Такая гибкость полезна при обработке одной или нескольких входных матриц (или массивов):
в этом случае тип элементов результата нередко выбирается совпадающим с типом элементов
входных матриц. В этом случае в качестве <code>requiredType</code>
можно передать тип реализации исходного массива &mdash;
при условии, что он неизменяем &mdash; либо, если это не так,
тип его "неизменяемого партнера", получаемого методом <code>Array.asImmutable()</code>.
В случае матриц, требуемый тип можно также получить вызовом метода
<code>Matrix.type()</code> для экземпляра одной из входных матриц.</p>
<p>Наш метод <code>constant_4</code> получает на входе примитивный тип элементов
(вернее, его строчное описание).
Соответственно, его необходимо преобразовать в соответствующий тип AlgART-массива.
Это делает сервисная функция <code>type</code>:</p>
<pre>
        Class&lt;? extends PArray&gt; aType = Arrays.type(PArray.class, eType);
</pre>
<p>И опять, как в случае с <code>newMatrix</code>, мы "помогаем" механизму
generics, указывая в методе дополнительный аргумент <code>PArray.class</code>,
который должен быть предком возвращаемого класса.
Если бы не этот параметр, мы смогли бы получить в результате, в лучшем случае,
<code>Class&lt;?&nbsp;extends&nbsp;Array&gt;</code> (данный метод
работает с любыми типами элементов, не только примитивными). А это не то,
что требуется в нашем коде.</p>
<p>Аргумент <code>PArray.class</code> выполняет еще одну полезную функцию &mdash;
он позволяет выбрать, какой тип изменяемости массива нам нужен.
Для каждого примитивного типа <code><i>xxx</i></code> есть 3 базовых
интерфейса, описывающих AlgART-массив: <code><i>XxxArray</i></code>,
<code><i>UpdatableXxxArray</i></code>, <code><i>MutableXxxArray</i></code>.
Так как мы указали <code>PArray.class</code>, но не <code>UpdatablePArray.class</code>
и не <code>MutablePArray.class</code>, то данный вызов вернет один из интерфейсов
первого типа, обеспечивающих только чтение данных.
Как уже говорилось, именно такой вариант и нужен методу <code>asFuncMatrix</code>.
<p>Что еще мы не разобрали? Может быть, наконец-то, все? Почти.</p>
<p>Как это уже было не раз, я рекомендую обратить пристальное внимание на контексты.
И правда &mdash; зачем нам снова понадобились контексты, а именно
контекст памяти <code>ArrayMemoryContext</code>?
Ведь в прошлом решении мы успешно без него обошлись.
Зачем же сейчас понадобилась модель памяти <code>mm</code> &mdash; передаваемая,
как вы видите, методу <code>asFuncMatrix</code> в качестве первого (между прочим, обязательного!)
аргумента?</p>
<p>Должен сознаться, что в предыдущем решении, простоты ради, я немного смошенничал.
На самом деле <i>и там</i> следовало бы использовать контекст памяти.
У методов <code>Arrays.n<i>Xxx</i>Copies</code> есть перегруженные версии
с первым параметром типа <code>MemoryModel</code>.
И правильнее было бы задействовать именно их, получая необходимую модель
памяти из контекста <code>ArrayMemoryContext</code>.</p>
<p>Казалось бы, зачем? Ведь модель памяти нужна для <i>фактического</i> создания массивов и матриц,
т.е. размещения их элементов в той или иной памяти.
А мы создаем ленивую матрицу, которая, как уже говорилось, не относится ни к одной
модели памяти и не хранит свои элементы.</p>
<p>Причина заключается в некоторых методах базового интерфейса <code>Array</code>.
А именно, в нем предусмотрены методы, создающие новый AlgART-массив:
<code>newCompatibleArray</code>, <code>newCompatibleEmptyArray</code>,
<code>newCompatibleUnresizableArray</code>,
<code>updatableClone</code>, <code>mutableClone</code>.
В традиционных массивах, созданных в рамках какой-то модели памяти,
эти методы выполняют вполне очевидную функцию:
позволяют создать <i>аналогичный</i> массив, т.е. принадлежащий той же модели.
В простых решениях, не применяющих контексты повсеместно, это бывает удобно.
Скажем, если процедура обрабатывает некий AlgART-массив и ей требуется рабочая память
"того же типа", при этом процедуре не передаются никакие параметры, кроме самого массива,
то для этой рабочей памяти можно использовать <code>newCompatibleUnresizableArray</code>:
будет создан массив в той модели памяти, которую считает подходящим вызывающий код.</p>
<p>Но что делают эти методы в ленивых массивах? Например, в массивах,
созданных при помощи <code>Arrays.n<i>Xxx</i>Copies</code> или <code>asFuncMatrix</code>?</p>
<p>Вот здесь и используется модель <code>mm</code>, переданная нами в <code>asFuncMatrix</code>
в качестве первого параметра. Именно она отвечает за создание нового AlgART-массива
во всех метода возвращаемой реализации интерфейса <code>Array</code>, где это необходимо.</p>
<p>Вообще говоря, в данном случае разрешается указать <code>null</code>.
Для методов <code>Arrays.n<i>Xxx</i>Copies</code> можно применять более краткую их форму,
без аргумента <code>MemoryModel</code> (что мы и сделали в предыдущем решении) &mdash;
это то же самое, что указание <code>null</code>.
Тогда будет выбрана умолчательная модель &mdash; как нетрудно догадаться,
простейшая: <code>SimpleMemoryModel</code>.
И очень может быть, что такое решение вполне подойдет.
Ведь далеко не факт, что кому-то вообще понадобится вызывать упомянутые методы
интерфейса <code>Array</code>: нужны они весьма нечасто и лишь тем программистам,
который не хотят или не умеют применять контексты для создания любых AlgART-массивов.
Не факт также, что в вашем приложении <i>вообще нужны</i> какие-то модели памяти, отличные от
<code>SimpleMemoryModel</code> &mdash; не всем ведь надо обрабатывать гигабайтные изображения.
Именно в силу существования таких приложений, где, возможно, требуется лишь
1% всех возможностей библиотеки AlgART, сохранены краткие варианты
<code>Arrays.n<i>Xxx</i>Copies</code> и предусмотрены "простенькие"
средства вроде <code>Array.updatableClone()</code>.</p>
<p>Однако в заголовке данного параграфа мы пообещали "лениться грамотно".
Что ж, по-настоящему грамотный метод обязан учитывать все случаи своего применения.
Возможно, основная модель памяти данного приложения, предоставляемая контекстом
&mdash; <code>LargeMemoryModel</code>, так как программа рассчитана на очень большие объекты.
Возможно, клиент затребовал создание константного изображения размером в 10 гигабайт.
Возможно, метод <code>newGrayscaleImage2D</code> сохранил ссылку на эту матрицу
(вполне возможно для простой реализации контекста <code>ImageContext</code>).
Возможно, клиент получил эту ссылку обратно (одним из методов <code>Image2D</code>)
и вызвал метод <code>array().updatableClone()</code>, желая, например,
открыть визуальный редактор для этого изображения.
В этой ситуации разумно ожидать, что <code>updatableClone()</code> успешно
вернет сверхбольшой массив, разместив его во временном дисковом файле.
Если бы мы не позаботились явно указать модель памяти (скажем, указали бы <code>null</code>),
произошел бы позорный сбой при попытке отвести в памяти Java массив длиннее 2<sup>31</sup>-1 элементов.</p>
<p>Единственная ситуация, когда мы имеем <i>полное</i> право не указывать модель памяти
при создании ленивого массива или матрицы &mdash; если созданный таким образом объект
является временным и не будет передан наружу, и если мы уверены, что наш код не обращается
к методам <code>newCompatibleArray</code>, <code>newCompatibleEmptyArray</code>,
<code>newCompatibleUnresizableArray</code>,
<code>updatableClone</code>, <code>mutableClone</code> интерфейса <code>Array</code>.
И даже тогда, как правило, имеет смысл (когда это несложно) указывать <code>MemoryModel</code>:
хуже точно не будет, а код получится более понятным и "устойчивым" к возможным
будущим изменениям.</p>
<h4 style="margin-bottom: 0px"><a name=constant_5></a>11. Генерация константного изображения: сколько можно лениться?</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_4>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_6>Следующий раздел</a></div>
<p>Нет, лень, безусловно, дело благородное и полезное. Работа не волк, в лес она не убежит,
стало быть, делать ее надо настолько поздно, насколько возможно. Но реальность, к сожалению,
такова, что иногда лень, когда ей увлекаешься, приводит к печальным результатам: работа вовсе не делается
в срок. Или же делается гораздо неэффективнее, чем могла бы.</p>
<p>К ленивым массивам и матрицам сие наблюдение относится в полной мере. Правда, не к константным
матрицам, которые мы сейчас разбираем: здесь требуемая работа столь ничтожна, что ее
практически всегда совершенно смело можно (и нужно) отложить на потом.
Но заполнение константой &mdash; это чисто учебная задача, выбранная в силу
своей тривиальности. В реальности, вероятнее всего, вам придется сталкиваться
с более сложными ленивами массивами, где реальное вычисление все же требует заметных временных
затрат.</p>
<p>Поэтому мы уже сейчас, на нашей учебной задаче, покажем, как следует правильно бороться с ленью.
В реальных задачах эта техника, называемая <i>актуализацией копированием</i>,
применяется повсеместно.</p>
<p>Прежде всего проиллюстрируем проблему на следующем чрезвычайно простом методе
(построенном, как и наш последний пример, на основе метода <code>asFuncMatrix</code>):</p>
<pre>
    public static Matrix&lt;FloatArray&gt; asLinear(MemoryModel mm,
        double a1, double a2, double a3,
        Matrix&lt;FloatArray&gt; m1, Matrix&lt;FloatArray&gt; m2, Matrix&lt;FloatArray&gt; m3)
    {
        Func f = LinearFunc.getInstance(0.0, a1, a2, a3);
        return Matrices.asFuncMatrix(mm, f, FloatArray.class, m1, m2, m3);
    }

</pre>
<p>На вид все просто и изящно. Есть 3 вещественные матрицы <code>m1</code>, <code>m2</code>, <code>m3</code>
и 3 вещественных коэффициента <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, <i>a</i><sub>3</sub>.
Создаем линейную функцию
<i>f</i>(<i>x</i><sub>1</sub>,&nbsp;<i>x</i><sub>2</sub>&nbsp;<i>x</i><sub>3</sub>)&nbsp;=
<i>b</i>+<i>a</i><sub>1</sub><i>x</i><sub>1</sub>+<i>a</i><sub>2</sub><i>x</i><sub
>2</sub>+<i>a</i><sub>3</sub><i>x</i><sub>3</sub>,
где <i>b</i>=0.0 и <i>a</i><sub><i>i</i></sub> передаются в качестве
параметров методу генерации <code>LinearFunc.getInstance</code> (см. JavaDoc).
Применяем эту функцию к матрицам <code>m1</code>, <code>m2</code>, <code>m3</code>
и получаем новую ленивую матрицу, обращение к элементам которой
автоматически приводит к чтению соответствующих элементов <code>m1</code>, <code>m2</code>, <code>m3</code>
и вычислению их линейной комбинации с заданными весами.</p>
<p>Казалось бы, все замечательно. "Великий и ужасный" метод <code>asFuncMatrix</code> "знает"
про линейную функцию и, наверное, подберет самый быстрый алгоритм. И правда, попытка прочитать,
скажем, 10000 последовательных элементов полученной матрицы через метод
<code>Array.getData</code> или через технику <code>DataBuffer</code>
приведет к выполнению наиболее разумного кода: цикл поэлементного суммирования (с заданными весами)
трех Java-массивов типа <code>float</code>.
На современных процессорах, при использовании хорошей JVM сумма трех вещественных
произведений вычисляется достаточно быстро.
Пусть это будет <i>L</i> тактов.
(В идеальной реализации, активно использующей SIMD-инструкции современных процессоров,
можно добиться очень малых <i>L</i>. Вероятно, со временем так и будет, но
в текущей версии библиотек и JVM на моем компьютере пока получается <i>L</i> порядка сотни.)</p>
<p>Предположим теперь, что клиентский код активно занимается вычислением поэлементных линейных
комбинаций между матрицами. Эта ситуация действительно вероятна,
скажем, при простых цветовых преобразованиях. Конверсия между цветовыми моделями
RGB, YUV и некоторыми другими выражается именно через такие линейные функции
и может базироваться на приведенном методе.</p>
<p>Допустим, мы применяем метод <code>asLinear</code> к некоторому набору из <i>K</i> матриц,
созданных в самой обычной модели памяти, скажем, <code>SimpleMemoryModel</code>.
Получаются ленивые матрицы: назовем их матрицами 1-го уровня.
Пусть их тоже будет <i>K</i>.
Допустим, далее мы применяем метод <code>asLinear</code> к этим <i>K</i> матрицам 1-го уровня.
Получаются снова ленивые матрицы: назовем их матрицами 2-го уровня.
Пусть их тоже будет <i>K</i>.
И так далее. В случае упомянутых цветовых преобразований, вероятно, мы
имели бы дело с <i>K</i>=3 матрицами, которые многократно преобразовывались бы
в новые тройки матриц по каждому запросу пользователя "сменить цветовую модель".</p>
<p>Давайте подсчитаем: сколько тактов понадобится, чтобы получить
каждый элемент матрицы <i>N</i>-го уровня?</p>
<p>Каждый такой элемент получается за <i>L</i> тактов из 3 элементов других матриц.
Каждый из них для своего вычисления требует тоже <i>L</i> тактов, опять из 3 элементов других матриц.
И так <i>N</i> раз. Итого получается</p>
<blockquote>
<i>t</i>&nbsp;=&nbsp;<i>L</i>+3<i>L</i>+9<i>L</i>+...+3<sup><i>N</i>-1</sup><i>L</i>&nbsp;=
(3<sup><i>N</i></sup>-1)<i>L</i>/2.</blockquote>
<p>Экспонента. Иначе говоря, начиная с некоторого уровня <i>N</i> доступ к ленивой матрице
станет невозможно медленным. Скажем, при <i>N</i>=20 уже получится
<i>t</i>&nbsp;=&nbsp;1743&nbsp;392&nbsp;200<i>L</i>,
т.е. много секунд (если не минут) на каждый элемент матрицы.
При <i>N</i>=40 речь пойдет о годах на каждый элемент. И так далее.
Вот вам пример злоупотребления ленью: работа, не сделанная вовремя,
делается чрезвычайно неэффективно или не делается вовсе.
В то же время, очевидно, можно полностью вычислить <i>N</i> наборов из <i>K</i> матриц
за разумное время, т.е. <i>O</i>(<i>N</i>).</p>
<p>Причина экспоненты, конечно, в том, что наша ленивая матрица зависит от <i>нескольких</i> входных матриц.
Если бы была зависимость только от одного аргумента,
то вместо тройки в сумме была бы единица, и получилось бы
<i>t</i>&nbsp;=&nbsp;<i>NL</i>.
В этом случае, в принципе, уже нет снижения эффективности.
Однако при больших <i>N</i> и <i>L</i> получается эффект "работы, не сделанной в срок".
Да, все вызовы метода <code>asLinear</code> отработали "мгновено".
Но за это приходится расплачиваться: после 100 таких вызовов ленивая матрица читается примерно
в 100<i>L</i> раз медленнее, чем обычная, не ленивая матрица, созданная в одной
из традиционных моделей памяти. (Блочное чтение обычной матрицы, как правило,
работает со скоростью порядка 1 такта на элемент.)
Если такую матрицу, скажем, понадобится нарисовать (в качестве изображения),
пользователь будет неприятно удивлен чрезвычайно низкой скоростью.
Очевидно, эффект будет усугубляться по мере роста <i>N</i>,
т.е. числа применений метода к его же результатам.</p>
<p>Описанные проблемы не возникают лишь в нашем вырожденном случае, когда число аргументов равно 0,
а функция предельно проста и <i>L</i> чрезвычайно мало (порядка 1 такта).</p>
<p>Что же делать? Не применять красивую технологию <code>asFuncMatrix</code> нигде,
кроме генерации константного массива, и вернуться к громоздким алгоритмам
заполнения результата, основанным на <code>DataBuffer</code>?</p>
<p>Конечно, нет. Все, что надо &mdash; время от время <i>актуализировать</i> полученную
ленивую матрицу (или массив). Т.е. попросту <i>копировать</i> ее в обычную матрицу (массив),
созданную в традиционной модели памяти. Это практически не усложняет алгоритм и сохраняет
все преимущества оптимизаций, реализованных в "великом и ужасном" методе <code>asFuncMatrix</code>.</p>
<p>Покажем, как это выглядит на примере нашей задачи:</p>
<pre>
    public static Image2D constant_5(Context context,
        @Name("dimX")long dimX, @Name("dimY")long dimY,
        @Name("elementType")String elementType, @Name("value")double value)
    {
        ArrayContext arrayContext = new DefaultArrayContext(context);
        MemoryModel mm = arrayContext.getMemoryModel();
        Class&lt;?&gt; eType = typeOf(elementType);
        Class&lt;? extends PArray&gt; aType = Arrays.type(PArray.class, eType);
        Func f = ConstantFunc.getInstance(value);
        Matrix&lt;? extends PArray&gt; lazy = Matrices.asFuncMatrix(mm, f, aType, dimX, dimY);
        Matrix&lt;? extends UpdatablePArray&gt; m = mm.newMatrix(UpdatablePArray.class,
            lazy.elementType(), lazy.dimensions());
        Matrices.copy(arrayContext, m, lazy);
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newGrayscaleImage2D(m);
        return result;
    }
</pre>
<p>Теперь основой решения служат не два оператора, как в предыдущем методе, а четыре:</p>
<pre>
        Func f = ConstantFunc.getInstance(value);
        Matrix&lt;? extends PArray&gt; lazy = Matrices.asFuncMatrix(mm, f, aType, dimX, dimY);
        Matrix&lt;? extends UpdatablePArray&gt; m = mm.newMatrix(UpdatablePArray.class,
            lazy.elementType(), lazy.dimensions());
        Matrices.copy(arrayContext, m, lazy);
</pre>
<p>Теперь после вызова <code>asFuncMatrix</code> явно создается новая матрица тех же размеров и типа,
что и ленивая матрица <code>lazy</code>;
при этом, естественно, используется полученная из контекста модель памяти <code>mm</code>.
Метод создания матрицы <code>newMatrix</code> для нас не нов &mdash; мы уже разбирали
его выше, во <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_2>втором варианте решения нашей задачи</a>.</p>
<p>А вот следующий за этим метод <code>Matrices.copy</code> &mdash;
настоящая изюминка ленивых технологий.
Можно сказать, "сердце" большинства алгоритмов, основанных на ленивых технологиях AlgART.</p>
<p>В принципе, это метод не делает ничего необычного. Он просто копирует свой третий аргумент-матрицу
во второй аргумент-матрицу. То же самое можно было бы сделать, написав
<code>m.array().copy(lazy.array())</code> &mdash;
конечно же, интерфейс <code>UpdatableArray</code> предусматривает столь очевидную
операцию, как копирование данных из другого массива.</p>
<p>Но фокус в том, что сейчас, на самом деле,
<i>вся работа алгоритма выполняется именно методом <code>Matrices.copy</code></i>!</p>
<p>Ведь что такое копирование? Это последовательное чтение блоков данных из
входного AlgART-массива (как правило, в промежуточный Java-массив) и последующая запись
этих блоков в выходной AlgART-массив. А чтение данных из ленивого массива
подразумевает их <i>фактическое вычисление</i>, т.е. исполнение затребованной
функции <code>f</code> для всех элементов.</p>
<p>Как правило, метод <code>Matrices.copy</code> применяется именно для такой цели &mdash;
<i>актуализации</i> ленивой матрицы, т.е. создания обычной, быстродоступной копии,
размещенной в реальной памяти.
А это означает выполнение некоторого алгоритма из весьма широкого класса.
Поэтому методу <code>Matrices.copy</code> совершенно необходим <i>контекст</i>,
позволяющий, как минимум, прерываться, показывать проценты исполнения и распараллеливать вычисления.
Таким контекстом, как и в случае <a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#meanOf_5>разобранной нами ранее</a>
функции <code>Arrays.sumOf</code>,
служит "array-ориентированный" интерфейс <code>ArrayContext</code>,
передаваемый первым параметром.
Именно ради контекста мы применяем метод <code>Matrices.copy</code>,
а не "низкоуровневый" <code>UpdatableArray.copy</code>.</p>
<p>Действительно, метод <code>Matrices.copy</code> достаточно "умен".
Он поддерживает все перечисленные возможности: прерываться, показывать проценты выполнения
и распараллеливать вычисления. Распараллеливание достигается путем разбиения
копируемого массива (лежащего в основе матрицы) на несколько блоков:
эти блоки копируются в параллельных потоках.</p>
<p>Конечно, у метода <code>Matrices.copy</code>, как и у
<code>Matrices.asFuncMatrix</code>, есть "брат-близнец" <code>Arrays.copy</code>,
работающий с линейными AlgART-массивами.</p>
<p>Получается удивительная вещь. Если алгоритм <i>можно</i> выразить в виде
создания ленивого массива или матрицы, то все решение сводится
к реализации необходимой функции <code>Func</code>
и вызову пары методов <code>asFuncMatrix</code> и <code>copy</code>.
При этом автоматически достигается прерываемость, показ процентов и прочие "прелести",
заложенные в метод <code>copy</code> &mdash; скажем, его умение выдавать
в лог скорость своей работы.</p>
<p>Много ли алгоритмов сводятся к построению ленивого массива или матрицы?
Если пользоваться только методом <code>asFuncMatrix</code>, то не очень.
Лишь всевозможные "поэлементные" алгоритмы, когда каждый элемент
результирующего массива или матрицы является функцией от соответствующих
элементов массивов-аргументов или матриц-аргументов.
Но <code>asFuncMatrix</code> &mdash; это лишь частный случай воплощения общей идеи:
построения ленивого массива (выполняющего отложенные вычисления) путем реализации
8 базовых интерфейсов <code>ByteArray</code>, <code>ShortArray</code> и пр.,
описывающих AlgART-массив примитивного типа в варианте "только чтение".
Есть и другие методы, подобные <code>asFuncMatrix</code>.
Так, методы <code>Arrays.asShifted</code> и <code>Matrices.asShifted</code>
возвращают ленивое представление исходного массива (матрицы),
циклически сдвинутое на сколько-то позиций.
Например, сдвигая массив на 1 элемент вправо или влево,
можно получить представление массива, в котором на позиции <i>k</i>
будут находиться элементы номер <i>k</i>-1 или <i>k</i>+1 исходного массива.
Совмещая такое представление с <code>asFuncMatrix</code>, можно, скажем,
"сгладить" изображение путем усреднения нескольких соседних элементов матрицы.
Существует также метод <code>asConcatenation</code>,
возвращающий (ленивым образом) результат "сцепления" нескольких массивов.
(Обратная задача &mdash; выделение подмассива &mdash;
реализована уже в стандартных методах исходного интерфейса <code>Array</code>,
и опять же ленивым образом.)
Подобных методов, возвращающих ленивый массив для решения вычислительной задачи,
можно создать очень много.</p>
<p>В результате получается, что весьма широкий класс алгоритмов
можно выразить через создание ленивого массива (или матрицы) с последующей актуализацией
методом <code>copy</code> &mdash; или разбить на подзадачи, выражаемые таким образом.
Скажем, сюда относятся разнообразные методы фильтрации изображений,
как линейные, так и нелинейные, различные геометрические преобразования изображений
или трехмерных матриц,
алгебраические операции над обычными двумерными матрицами и одномерными векторами, и т.д.
Поэтому методы <code>Matrices.copy</code> и <code>Arrays.copy</code> действительно
часто оказываются "сердцем" алгоритмических приложений.
Если приложение, обрабатывающее AlgART-матрицы или массивы, о чем-то "задумалось",
это с большой вероятностью может означать, что в данный момент исполняется
<code>Matrices.copy</code> или <code>Arrays.copy</code>,
"прогоняя" через себя некоторый алгоритм, реализованный в ленивой технологии.</p>
<p>Итак, <code>Arrays.copy</code> / <code>Matrices.copy</code> &mdash;
методы, предназначенные для актуализации ленивых вычислений &mdash;
являются основным способом преодоления (вернее сказать, использования)
заложенной в библиотеки лени.
Создавая ленивые массивы или матрицы, следует своевременно их актуализировать.
Но что считать "своевременным"? Допустимы ли вообще методы,
которые, подобно предыдущему нашему примеру <code>constant_4</code>,
возвращают ленивый результат?
Или конечный результат всегда следует актуализировать, как мы сделали это сейчас?</p>
<p>Есть одна ситуация, когда ответ очевиден. А именно, генерация
константы, когда в качестве функции применяется
<code>ConstantFunc</code>. В данном случае никакого смысла актуализация не имеет,
так как скорость доступа к элементам построенной ленивой матрицы будет
не ниже, а, может быть, даже и выше, чем в случае обычной матрицы.
Пример, разбираемый нами сейчас, нарушает эту рекомендацию &mdash;
исключительно в учебных целях, чтобы показать, как следует действовать
в более сложных случаях.</p>
<p>Кроме того, надо заметить, что константный массив, а также более изощренные
ленивые массивы, которые можно построить путем наследования абстрактных классов
<code>AbstractByteArray</code>, <code>AbstractShortArray</code> и пр. &mdash;
единственная разновидность массивов, вообще не ограниченных в размере
никакими физическими пределами вроде объема диска.
Если вам действительно нужны подобные сверхбольшие массивы
(скажем, длиной <code>Long.MAX_VALUE</code>=2<sup>63</sup>-1 элементов),
то никакая актуализация попросту невозможна.</p>
<p>Для прочих случаев я не знаю универсального рецепта.
Лично я считаю, что public-методы, возвращающие ленивый массив или матрицу, в принципе допустимы &mdash;
если в спецификации четко сформулировано, что происходит при обращениях к их элементам
и насколько эта операция дорогостоящая.
Но если есть вероятность, что к полученному массиву или матрице
будет нужен интенсивный доступ &mdash; например, что массив будет передан расчетному алгоритму,
требущему многократных "проходов" по нему &mdash;
то лучше заранее предоставить метод-"партнер", выполняющие те же действия,
но с завершающей актуализацией.
Так, наш текущий метод <code>constant_5</code> (если бы он возвращал
<code>Matrix</code>, а не <code>Image2D</code>) был бы подобным "партнером"
для <code>constant_4</code>.
На практике, конечно, код такого "партнера" обычно куда проще:
он просто вызывает "ленивый" метод и применяет к его результату
<code>Matrices.copy</code> или <code>Arrays.copy</code>.
Кроме того, метод, возвращающий ленивый результат (кроме константы),
лучше начинать с префикса <code>as</code> &mdash;
это ясно дает понять, что выполнение метода еще не заканчивает вычисления,
а лишь возврашает некое ленивое представление входных матриц или массивов.</p>
<h4 style="margin-bottom: 0px"><a name=constant_6></a>12. Генерация константного изображения: да будет цвет!</h4>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#constant_5>Предыдущий раздел</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a></div>
<p>В этом параграфе мы придадим законченность нашему методу, "научив" его возвращать
цветное изображение, все точки которого имеют заданный цвет.
И это будет наш последний пример, решающий тривиальную задачу.</p>
<p>Вот "цветная" версия предыдушего метода:</p>
<pre>
    public static Image2D constant_6(Context context,
        @Name("dimX")long dimX, @Name("dimY")long dimY,
        @Name("elementType")String elementType,
        @Name("red")double r, @Name("green")double g, @Name("blue")double b)
    {
        ArrayContext arrayContext = new DefaultArrayContext(context);
        MemoryModel mm = arrayContext.getMemoryModel();
        Class&lt;?&gt; eType = typeOf(elementType);
        long[] dim = new long[] {dimX, dimY};
        Class&lt;? extends PArray&gt; aType = Arrays.type(PArray.class, eType);
        Matrix&lt;? extends PArray&gt; lazyr = Matrices.asFuncMatrix(mm,
            ConstantFunc.getInstance(r), aType, dim);
        Matrix&lt;? extends PArray&gt; lazyg = Matrices.asFuncMatrix(mm,
            ConstantFunc.getInstance(g), aType, dim);
        Matrix&lt;? extends PArray&gt; lazyb = Matrices.asFuncMatrix(mm,
            ConstantFunc.getInstance(b), aType, dim);
        Matrix&lt;? extends UpdatablePArray&gt; mr =
            mm.newMatrix(UpdatablePArray.class, eType, dim);
        Matrices.copy(arrayContext.part(0.0, 1.0 / 3.0), mr, lazyr);
        Matrix&lt;? extends UpdatablePArray&gt; mg =
            mm.newMatrix(UpdatablePArray.class, eType, dim);
        Matrices.copy(arrayContext.part(1.0 / 3.0, 2.0 / 3.0), mg, lazyg);
        Matrix&lt;? extends UpdatablePArray&gt; mb =
            mm.newMatrix(UpdatablePArray.class, eType, dim);
        Matrices.copy(arrayContext.part(2.0 / 3.0, 1.0), mb, lazyb);
        ImageContext imageContext = context.as(ImageContext.class);
        Image2D result = imageContext.newRGBImage2D(mr, mg, mb);
        return result;
    }
</pre>
<p>В основном, все отличия вполне очевидны. Вместо одной константы <code>value</code>
метод получает три константы <code>r</code>, <code>g</code> и <code>b</code>,
описывающие красную, зеленую и синюю компоненты желаемого цвета.
Соответственно, вместо одной матрицы мы строим три ленивых матрицы
<code>lazyr</code>, <code>lazyg</code>, <code>lazyb</code>,
актуализируем их, копируя в обычные матрицы <code>mr</code>, <code>mg</code>, <code>mb</code>,
после чего строим на основе <code>mr</code>, <code>mg</code>, <code>mb</code> изображение
при помощи метода <code>newRGBImage2D</code> контекста <code>ImageContext</code>.
Как и в предыдущем примере, константные ленивые матрицы лучше было бы вообще не актуализировать,
а передать непосредственно методу <code>newRGBImage2D</code>.
Но в учебных целях мы все же выполняем актуализацию.
Почти в любых более сложных задачах это было бы полезно.</p>
<p>В чем же заключаются наши "учебные цели", раз все так просто? Не лучше ли было бы
убрать актуализацию и получить "вполне безупречный" метод?</p>
<p>Учебные цели касаются именно актуализации. Заметьте: это первый наш метод,
в котором надо выполнить <i>несколько</i> библиотечных методов, работающих с контекстами.
Здесь мы три раза вызываем метод актуализации <code>Matrices.copy</code>.
И мы видим нечто новое: использование метода контекста <code>part</code>.</p>
<p>Что это такое и зачем это нужно?</p>
<p>Представьте себе, что получится, если мы напишем более просто:</p>
<pre>
        Matrix&lt;? extends UpdatablePArray&gt; mr =
            mm.newMatrix(UpdatablePArray.class, eType, dim);
        Matrices.copy(arrayContext, mr, lazyr);
        Matrix&lt;? extends UpdatablePArray&gt; mg =
            mm.newMatrix(UpdatablePArray.class, eType, dim);
        Matrices.copy(arrayContext, mg, lazyg);
        Matrix&lt;? extends UpdatablePArray&gt; mb =
            mm.newMatrix(UpdatablePArray.class, eType, dim);
        Matrices.copy(arrayContext, mb, lazyb);
</pre>
<p>Разумеется, все будет работать. Контекст, переданный методу <code>copy</code>,
как и раньше, позволит обеспечить распараллеливание, прерываемость и даже,
если вызвающее приложение позаботится об этом, вывод процентов исполнения...
Да, но <i>какие</i> будут показаны проценты?</p>
<p>Конечно же, неверные! Каждый из трех методов <code>copy</code> передаст контексту
<code>ArrayContext</code> (и далее, через него, контексту прогресса
<code>ProgressUpdater</code>, поддерживаемому приложением)
информацию о процентах <i>своего</i> исполнения.
Которые в каждом из трех методов будут увеличиваться от 0% до 100%.
Если пользователь программы нажмет кнопку, запускающую наш алгоритм,
он, вероятнее всего, увидит, как индикатор выполнения
три раза "пробежит" от начальной позиции до конечной.
Вряд ли это можно считать правильным поведением.</p>
<p>Проблема, как легко видеть, имеет общий характер.
Почти всякая реальная задача, исполняемая по нажатию одной кнопки пользователем,
состоит из каких-то подзадач. Те &mdash; из своих подзадач, и так далее.
Лишь на самом нижнем уровне мы приходим к циклам обработки <code>DataBuffer</code>
или библиотечным вызовам вроде <code>sumOf</code> или <code>copy</code>,
где мы имеем возможность указать контексту процент готовности цикла или метода <code>copy</code>.
Какой-нибудь сложный фильтр, удаляющий шум из изображения, может
в конечном счете выражаться через сотни вызовов <code>Matrices.copy</code>,
каждый из которых решает лишь очень маленькую подзадачу полного алгоритма.</p>
<p>Очевидно, нужно что-то вроде иерархии контекстов прогресса,
чтобы изменение процентов готовности от 0% до 100% в "дочернем" контексте
означало лишь некоторое приращение процента готовности в его "родителе".
Именно это и обеспечивает метод <code>part</code> интерфейса <code>ArrayContext</code>.</p>
<p>Методу <code>part</code> передаются два параметра типа <code>double</code>: <code>fromPart</code>
и <code>toPart</code>. Результатом метода является новый, "дочерный" контекст <code>ArrayContext</code>.
Все методы этого контекста тривиальным образом вызывают соответствующие методы исходного контекста,
за одним-единственным исключением. А именно: когда вызывается метод <code>updateProgress</code>
(аналог такого же метода <code>ProgressUpdater</code>), этот метод корректирует переданную
ему информацию о процентах исполнения, так, чтобы диапазон изменения процентов
<code>0.0..1.0</code> преобразовался в диапазон <code>fromPart..toPart</code>.
(Метод <code>updateProgress</code> описывает процент готовности вещественным числом от 0 до 1,
а не от 0 до 100.)</p>
<p>В нашем примере в результате такой трансформации получается, что первый метод <code>copy</code>
сообщает исходному контексту информацию о процентах исполнения, меняющихся
не от 0% до 100%, а от 0% до ~33.3% (<code>toPart=1.0/3.0</code>).
Второй метод <code>copy</code> сообщает о процентах исполнения, меняющихся
от ~33.3% (<code>fromPart=1.0/3.0</code>) до ~66.6% (<code>toPart=2.0/3.0</code>),
и, наконец, третий метод <code>copy</code> &mdash;
о процентах от ~66.6% (<code>fromPart=2.0/3.0</code>) до 100% (<code>toPart=1.0</code>).</p>
<p>Аналогичное преобразование можно произвести и с контекстом, описываемым более общим
интерфейсом <code>Context</code>. Для этого служит специальный класс <code>SubtaskContext</code>.
Прямым аналогом вызова <code>arrayContext.part(fromPart,toPart)</code> в этом случае
является вызов конструктора <code>new&nbsp;SubtaskContext(context,fromPart,toPart)</code>.</p>
<p>Заметим, что при вычислениях аргументов метода <code>part</code> следует соблюдать
известную аккуратность. Этот метод генерирует исключение <code>IllegalArgumentException</code>,
если его параметры не удовлетворяют точным неравенствам
<code><i>x</i>&gt;=0.0</code> и <code><i>x</i>&lt;=1.0</code>.
А вещественные вычисления обычно выполняются неточно,
и при расчете "крайних" значений <code>0.0</code> и <code>1.0</code> легко допустить ошибку.
Скажем, было бы неправильно завести в методе константу <code>p=1.0/3.0</code>
и вызывать метод <code>part</code> как-нибудь так:</p>
<pre>
        part(k * p, (k + 1) * p)
</pre>
<p>где <code>k</code> &mdash; целое число от 0 до 2. Число <code>p=<sup>1</sup>/<sub>3</sub></code>
представляется в компьютере неточно, и нет никаких гарантий, что величина
<code>(k+1)*p</code> при <code>k=2</code> не окажется
чуть-чуть больше <code>1.0</code>.
Если это произойдет, метод <code>part</code> выдаст <code>IllegalArgumentException</code>.
(По секрету: на самом деле гарантии есть, но лучше вам об этом не знать.
При других способах расчета <code>toPart</code> может не повезти.
Автору однажды не повезло &mdash; одна из причин, по которым я остановился на этой детали.)</p>
<p>Чтобы избежать этих неприятностей, лучше всего проверять случаи,
когда параметр <code>fromPart</code> может оказаться равен <code>0.0</code> или
когда <code>toPart</code> может оказаться равен <code>1.0</code>,
и в этих случаях передавать точные <code>double</code>-константы <code>0.0</code> и <code>1.0</code>.</p>
<p>На этом мы заканчиваем разбор тривиальных задач обработки AlgART-матриц и массивов.
Накопленных знаний уже достаточно, чтобы грамотно решать сравнительно сложные
и практически полезные задачи.</p>
<div align=right>
<a href=http://algart.net/ww/0/java/AlgART/docs/tutorials/SimpleImageIntroduction_ru.html#Content>К оглавлению</a>
<br>&nbsp;</div></div>
<div id=ad_bottom_counters align=right>
<script src=http://algart.net/ww/~clientscriptgz/tools.spylog.ru/counter_cv.js id=spylog_code type=text/javascript counter=877799 part="" track_links=ext page_level=0>
</script>
<noscript>
<a href=http://algart.net/ww/u8777.99.spylog.com/cnt?cid=877799&f=3&p=0 target=_blank>
<img src=http://u8777.99.spylog.com/cnt?cid=877799&p=0 alt=SpyLOG border=0 width=88 height=31></a>
</noscript></div>
<div id=ad_bottom_google align=center>
<script type=text/javascript><!--
google_ad_client = "pub-6340524491670971";
/* ad algart.net, created 5/24/08 */
google_ad_slot = "4726790607";
google_ad_width = 728;
google_ad_height = 90;
if (window.___ww) ___ww_flush();
//--></script>
<script type=text/javascript
src=http://algart.net/ww/~clientscriptgz/pagead2.googlesyndication.com/pagead/show_ads.js>
</script></div>
<script language="JavaScript"><!--
var _wTI="1,0,0,0,0,0,0,0,0,189283";
if (window.___ww_finishpage!=null) ___ww_finishpage();
//--></script>
</body>
<!-- 189283,+3480(2%)corr=192763[b],gzip: 10init+9cache+1DIRECT+0compile+388process[ms]+writecache --><script>_wGI=60826</script></html>