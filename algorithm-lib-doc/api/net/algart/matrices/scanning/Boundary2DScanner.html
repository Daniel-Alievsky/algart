<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Boundary2DScanner
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Boundary2DScanner";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DProjectionMeasurer.html" title="class in net.algart.matrices.scanning"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/scanning/Boundary2DScanner.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Boundary2DScanner.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.matrices.scanning</FONT>
<BR>
Class Boundary2DScanner</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.matrices.scanning.Boundary2DScanner</STRONG>
</PRE>
<DL>
<DT><STRONG>Direct Known Subclasses:</STRONG></DT> <DD><A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning">Boundary2DWrapper</A></DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>Boundary2DScanner</STRONG>
extends java.lang.Object</PRE>

<P>
<p>2-dimensional object boundaries scanner: the class allowing to trace boundaries of objects,
 "drawn" at some 2-dimensional bit matrix.</p>

 <p>More precisely, let's consider some 2-dimensional AlgART bit matrix
 <tt><A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays"><CODE>Matrix</CODE></A>&lt;?&nbsp;extends&nbsp;<A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>&gt;</tt>.
 Below we shall designate this matrix as <b>M</b>.</p>

 <p>Let's define a <i>pixel</i> with integer coordinates (<i>x</i>,&nbsp;<i>y</i>)
 as a set of points of the plane with such coordinates (<i>x'</i>,&nbsp;<i>y'</i>) that
 <nobr><i>x</i>&minus;0.5&le;<i>x'</i>&le;<i>x</i>+0.5,</nobr>
 <nobr><i>y</i>&minus;0.5&le;<i>y'</i>&le;<i>y</i>+0.5.</nobr>
 In other words, pixel is the square with the center (<i>x</i>,&nbsp;<i>y</i>) and the side 1.0.</p>

 <p>Every unit element of the matrix <b>M</b> with <A HREF="../../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>coordinates</CODE></A>
 (<i>x</i>,&nbsp;<i>y</i>) corresponds to a pixel (<i>x</i>,&nbsp;<i>y</i>) at the plane.
 Let's designate <b>IM</b> the figure (point set) consisting of all points of all pixels
 (squares with the side 1.0), corresponding to unit (1) elements of our matrix <b>M</b>.
 We can consider <b>IM</b> as an image (figure), "drawn" at the matrix <b>M</b>.
 Every unit element in <b>M</b> represents a little square 1x1 (a pixel) in the image (figure) <b>IM</b>,
 and the center of the pixel has integer coordinates in ranges
 <nobr>0..<b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A>&minus;1,</nobr>
 <nobr>0..<b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimY()"><CODE>dimY()</CODE></A>&minus;1.</nobr></p>

 <p>Then, let's consider a <i>connected object</i> at the matrix <b>M</b>, defined in the same terms
 as in <A HREF="../../../../net/algart/matrices/scanning/ConnectedObjectScanner.html" title="class in net.algart.matrices.scanning"><CODE>ConnectedObjectScanner</CODE></A> class, and corresponding <i>connected figure</i>
 in the image <b>IM</b>. As well as in that class, a connected object can have <i>straight-and-diagonal</i>
 connectivity (8-connected object) or <i>straight</i> connectivity (4-connected object).
 The first case corresponds to a usual connected area in the image <b>IM</b>,
 the second case &mdash; to a connected area in the figure, coming out from <b>IM</b> by removing
 all points with half-integer coordinates.</p>

 <p>We define the <i>boundary</i> of some connected object as the geometrical boundary of the corresponding
 connected figure in the image <b>IM</b>. More precisely, the <i>boundary</i> of the connected object
 is a connected component of the full set of the boundary points
 (not pixels, but infinitesimal <i>points</i> of the plane) of the corresponding connected figure.
 So, the connected object can have several boundaries, if there are some "holes" in it.
 Any boundary is a chain of horizontal or vertical <i>segments</i> with the length 1.0,
 that separate pixels from each others. The ends of each segment have half-integer coordinates,
 and the 2nd end of the last segment coincides with the 1st end of the first segment.</p>

 <p>We define the <i>main boundary</i> of the connected object as its boundary
 containing whole this object inside it.</p>

 <p><a name="completion"></a>We define the <i>completion</i> of the connected object as the sets of all points
 lying at or inside its main boundary. In other words, the completion is the object, where all internal
 "holes" are filled. If the connected object has no "holes", its completion is identical to it.</p>

 <p>Each segment with length 1.0 in any object boundary is a boundary of some pixel, belonging to the image <b>IM</b>.
 These pixels can lie 1) inside the boundary, and then it is true for all segments of the boundary,
 or 2) outside the boundary, and then it is true for all segments of the boundary.</p>

 <p>In the first case we shall call the boundary as <i>external</i>,
 and in the second case we shall call it as <i>internal</i>.
 A connected object always have only one external boundary, namely, its main boundary.
 But a connected object can have several internal boundaries: these are boundaries of all its "holes".</p>

 <p>This class represents a <i>boundary scanner</i>: an iterator allowing to trace all segments
 of one boundary &mdash; in the clockwise order for external boundaries, in the anticlockwise order
 for internal boundaries (if the <i>x</i> axis is directed <i>rightwards</i> and
 the <i>y</i> axis is directed <i>downwards</i>). The basic method of this iterator is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A>.
 In addition, this class allows to sequentially visit all boundaries or all main boundaries
 of all connected objects; it is performed by the method <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>.</p>

 <p>The boundary scanner always has the current <i>position</i>. The position consists of:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>-coordinate of the current pixel;</li>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>-coordinate of the current pixel;</li>
 <li>the current pixel <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A>: index of one of 4 sides of the square 1x1,
 represented by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning"><CODE>Boundary2DScanner.Side</CODE></A> enumeration class.</li>
 </ul>

 <p>There is the only exception, when the scanner has no any position &mdash;
 directly after creating new instance. The first call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary</CODE></A>
 or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A> method sets some position.</p>

 <p>In other words, the current position specifies some segment with length 1.0. This segment
 can be an element of some object boundary, but also can be a random pixel side in the image.</p>

 <p>There are two basic methods of this class, changing the current position. The first method is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>: it moves the current position to the nearest next object boundary,
 according to some rules depending on a concrete kind of scanner. After calling this method you may be sure
 that the current position specifies a segment of some object boundary.
 The second method is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A>: it supposes that the current position specifies a segment of a boundary
 and, if it's true, moves the current position to the next segment of this boundary.
 So, you can find the next object boundary by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method
 and then scan it by sequential calls of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method.
 Instead of manual loop of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> calls, you can use <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A> method.</p>

 <p><a name="positions_order"></a>We suppose that all possible positions are <i>sorted</i>
 in the following "natural" order: the position
 <i>x</i><sub>1</sub>,&nbsp;<i>y</i><sub>1</sub>,&nbsp;<i>side</i><sub>1</sub> is "less" than the position
 <i>x</i><sub>2</sub>,&nbsp;<i>y</i><sub>2</sub>,&nbsp;<i>side</i><sub>2</sub>,</p>

 <ul>
 <li>if <i>y</i><sub>1</sub>&lt;<i>y</i><sub>2</sub>,</li>
 <li>or if <i>y</i><sub>1</sub>=<i>y</i><sub>2</sub> and  <i>x</i><sub>1</sub>&lt;<i>x</i><sub>2</sub>,</li>
 <li>or if <i>y</i><sub>1</sub>=<i>y</i><sub>2</sub>,  <i>x</i><sub>1</sub>=<i>x</i><sub>2</sub>
 and <nobr><i>side</i><sub>1</sub>.<CODE>ordinal()</CODE>&lt;<i>side</i><sub>2</sub>.<CODE>ordinal()</CODE></nobr>
 (i.e., for the same coordinates,
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_MINUS"><CODE>X_MINUS</CODE></A>&lt;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#Y_MINUS"><CODE>Y_MINUS</CODE></A>&lt;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>X_PLUS</CODE></A>&lt;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#Y_PLUS"><CODE>Y_PLUS</CODE></A>).</li>
 </ul>

 <p>We also suppose that the "undefined" position, when the scanner is newly created and
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A> methods
 were not called yet, is "less" than all other positions.
 This order is used by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method.</p>

 <p>There are the following ways to create an instance of this class:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner(Matrix, ConnectivityType)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner(Matrix, Matrix, Matrix, ConnectivityType)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner(Matrix, Matrix, ConnectivityType)</CODE></A>,</li>
 <li>extending <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A> class,</li>
 <li>using some ready wrappers like <A HREF="../../../../net/algart/matrices/scanning/Boundary2DSimpleMeasurer.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DSimpleMeasurer</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DProjectionMeasurer.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DProjectionMeasurer</CODE></A>.</li>
 </ul>

 <p>The difference between instances, created by first 3 methods, is in the behavior of
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> and <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A>: see comments to these instantiation methods.
 The <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A> class and its inheritors just call some parent boundary scanner and,
 maybe, do some additional work (for example, measure the objects).</p>

 <p>The instance of this class always works with some concrete matrix and some concrete connectivity type,
 specified while creating the instance, and
 you cannot switch an instance of this class to another bit matrix. But this class is lightweight:
 there is no problem to create new instances for different matrices.</p>

 <p>You <b>must not</b> use this instance after any modifications in the scanned matrix,
 performed by an external code.
 If you modify the matrix, you must create new instance of this class after this.</p>

 <p>Below is a typical example of using this class:</p>

 <pre>
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DScanner</CODE></A> scanner = <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>Boundary2DScanner.getAllBoundariesScanner</CODE></A>(m, um1, um2, connectivityType);
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DSimpleMeasurer.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DSimpleMeasurer</CODE></A> measurer = <A HREF="../../../../net/algart/matrices/scanning/Boundary2DSimpleMeasurer.html#getInstance(net.algart.matrices.scanning.Boundary2DScanner, net.algart.matrices.scanning.ContourLineType, java.util.EnumSet)"><CODE>Boundary2DSimpleMeasurer.getInstance</CODE></A>(scanner,
 &#32;   EnumSet.of(<A HREF="../../../../net/algart/matrices/scanning/Boundary2DSimpleMeasurer.ObjectParameter.html#AREA"><CODE>Boundary2DSimpleMeasurer.ObjectParameter.AREA</CODE></A>));
 while (measurer.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>) {
 &#32;   measurer.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#checkInterruption(net.algart.arrays.ArrayContext)"><CODE>checkInterruption</CODE></A>(ac);
 &#32;   measurer.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#updateProgress(net.algart.arrays.ArrayContext)"><CODE>updateProgress</CODE></A>(ac);
 &#32;   measurer.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary</CODE></A>(ac);
 &#32;   long area = measurer.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DSimpleMeasurer.html#area()"><CODE>area()</CODE></A>;
 &#32;   // some operations with the found area
 }
 </pre>

 <p>Note: this class works <b>much faster</b> (in several times)
 if the scanned matrix is created by <A HREF="../../../../net/algart/arrays/SimpleMemoryModel.html" title="class in net.algart.arrays"><CODE>SimpleMemoryModel</CODE></A>,
 especially if its horizontal dimension <A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A> is divisible by 64
 (<tt><A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A>%64==0</tt>).
 So, if the matrix is not created by <A HREF="../../../../net/algart/arrays/SimpleMemoryModel.html" title="class in net.algart.arrays"><CODE>SimpleMemoryModel</CODE></A> and is not too large,
 we recommend to create its clone by <A HREF="../../../../net/algart/arrays/SimpleMemoryModel.html" title="class in net.algart.arrays"><CODE>SimpleMemoryModel</CODE></A>,
 expanded by <i>x</i> to the nearest integer divisible by 64, and use this class for the clone.</p>

 <p>Note: this class can process only 2-dimensional matrices.
 An attempt to create an instance of this class for a matrix with other number of dimensions
 leads to <tt>IllegalArgumentException</tt>.</p>

 <p>This class does not use multithreading optimization, unlike
 <A HREF="../../../../net/algart/arrays/Arrays.html#copy(net.algart.arrays.ArrayContext, net.algart.arrays.UpdatableArray, net.algart.arrays.Array)"><CODE>Arrays.copy(ArrayContext, UpdatableArray, Array)</CODE></A> and similar methods.
 In other words, all methods of this class are executed in the current thread.</p>

 <p>This class is not thread-safe, but <b>is thread-compatible</b>
 and can be synchronized manually, if multithread access is necessary.
 <b>Warning</b>! Even if you use in several different threads different instances of this class,
 created via one of the following methods:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner(Matrix matrix, Matrix buffer1, Matrix buffer2, ConnectivityType)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner(Matrix matrix, Matrix buffer, ConnectivityType)</CODE></A>,</li>
 </ul>

 then you either must pass different buffer matrices in different threads,
 or manually synchronize all called methods.
 In other case, the content of buffer matrices will be unspecified and behavior of the scanning algorithm
 will be undefined.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Nested Class Summary table, listing nested classes, and an explanation">
<CAPTION CLASS="TableCaption">
Nested Class Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Class and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning">Boundary2DScanner.Side</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The pixel side.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Step.html" title="class in net.algart.matrices.scanning">Boundary2DScanner.Step</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The step of scanning the boundary: moving from one boundary segment to the next boundary segment.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#boundaryFinished()">boundaryFinished</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if the current position (<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A>)
 is identical to the position, set by last call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#checkInterruption(net.algart.arrays.ArrayContext)">checkInterruption</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls <tt>context.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt> or
 does nothing if <tt>context==null</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#connectivityType()">connectivityType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the connectivity kind, used by this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#coordinatesChanged()">coordinatesChanged</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the last call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method has changed <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>
 coordinate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#currentIndexInArray()">currentIndexInArray</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of the current pixel in the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>underlying array</CODE></A> of the currently
 scanned matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#get()">get</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the current element of the currently scanned matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)">getAllBoundariesScanner</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;matrix,
                        <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>&gt;&nbsp;buffer1,
                        <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>&gt;&nbsp;buffer2,
                        <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A>&nbsp;connectivityType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an instance of this class, allowing to sequentially trace all segments of <i>all</i> boundaries
 at the matrix (internal and external).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)">getMainBoundariesScanner</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;matrix,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>&gt;&nbsp;buffer,
                         <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A>&nbsp;connectivityType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an instance of this class, allowing to trace all segments of <i>main</i> boundaries
 at the matrix and to build <a href="Boundary2DScanner.html#completion">completions</a> of all objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)">getSingleBoundaryScanner</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;matrix,
                         <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A>&nbsp;connectivityType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an instance of the simplest kind of this class,
 allowing to trace all segments of a <i>single</i> boundary (internal or external).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)">goTo</A></STRONG>(long&nbsp;x,
     long&nbsp;y,
     <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning">Boundary2DScanner.Side</A>&nbsp;side)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current position in the matrix to the specified coordinates and pixel side.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goToSamePosition(net.algart.matrices.scanning.Boundary2DScanner)">goToSamePosition</A></STRONG>(<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A>&nbsp;scanner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current position in the matrix to the same as in the specified scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isAllBoundariesScanner()">isAllBoundariesScanner</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this scanner is an all boundaries scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()">isInitialized</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this instance was positioned to some coordinates in the matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInternalBoundary()">isInternalBoundary</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if
 <nobr><tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A> == <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>Side.X_PLUS</CODE></A></tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isMainBoundariesScanner()">isMainBoundariesScanner</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this scanner is a main boundaries scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isMovedAlongBoundary()">isMovedAlongBoundary</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this scanner is already positioned
 (<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>isInitialized()</CODE></A> returns <tt>true</tt>) and, in addition, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A> methods were called at least once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isSingleBoundaryScanner()">isSingleBoundaryScanner</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this scanner is a single boundary scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Step.html" title="class in net.algart.matrices.scanning">Boundary2DScanner.Step</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#lastStep()">lastStep</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information about the movement of the current position, performed by the last call of
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()">matrix</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the reference to the currently scanned matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nestingLevel()">nestingLevel</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current <i>nesting level</i> of object boundaries:
 the number of boundaries (external or internal), inside which the current pixel side
 &mdash; the segment with the length 1.0, described by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A>
 &mdash; is located.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()">next</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move the current position to the next segment of the currently scanned object boundary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()">nextBoundary</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the next vertical segment, belonging to some object boundary,
 after the current position, and sets the current position to the found one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)">scanBoundary</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans the current boundary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning">Boundary2DScanner.Side</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()">side</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current pixel side (or throws <tt>IllegalStateException</tt> if this scanner
 was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#stepCount()">stepCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total number of calls of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method since the last call <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#toString()">toString</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a brief string description of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#updateProgress(net.algart.arrays.ArrayContext)">updateProgress</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls <tt>context.<A HREF="../../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress(event)</CODE></A></tt>
 with an event, created by the following operator:
 <nobr><tt>new ArrayContext.Event(boolean.class, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>)</tt></nobr>,
 or does nothing if <tt>context==null</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()">x</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current <i>x</i>-coordinate (or throws <tt>IllegalStateException</tt> if the scanner
 was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()">y</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current <i>y</i>-coordinate (or throws <tt>IllegalStateException</tt> if this scanner
 was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><!-- --></A><H3>
getSingleBoundaryScanner</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A> <STRONG>getSingleBoundaryScanner</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;matrix,
                                                         <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A>&nbsp;connectivityType)</PRE>
<DL>
<DD>Creates an instance of the simplest kind of this class,
 allowing to trace all segments of a <i>single</i> boundary (internal or external).

 <p>In the created instance:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method finds (after the current position)
 the nearest vertical segment, belonging to some object boundary,
 sets the current position to the found one and does nothing else.
 <br>&nbsp;</li>

 <li><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method switches to the next segment in the current object boundary and does nothing else.
 </li>
 </ul>

 <p>This instance does not save anywhere the fact of tracing the boundary.
 So, it is not convenient for scanning all boundaries of some kind in the matrix:
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method will find the same boundary many times, at least 2 times
 for every horizontal line intersecting the boundary.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>matrix</CODE> - the matrix that will be scanned by the created instance.</DD><DD><CODE>connectivityType</CODE> - the connectivity kind used by the created instance.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> or <tt>connectivityType</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>matrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not 2.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><!-- --></A><H3>
getAllBoundariesScanner</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A> <STRONG>getAllBoundariesScanner</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;matrix,
                                                        <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>&gt;&nbsp;buffer1,
                                                        <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>&gt;&nbsp;buffer2,
                                                        <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A>&nbsp;connectivityType)</PRE>
<DL>
<DD>Creates an instance of this class, allowing to sequentially trace all segments of <i>all</i> boundaries
 at the matrix (internal and external).

 <p>The scanner, created by this method, works with two additional matrices <tt>buffer1</tt>
 and <tt>buffer2</tt>, that are used for marking already visited boundary segments.
 These matrices can have any fixed-point element type (but usually it is <tt>boolean</tt>)
 and must have the same dimensions as the main matrix.
 These matrices should be zero-initialized before using the created instance (in other case,
 some boundaries are possible to be skipped).
 One of these matrices is always <i>current</i>.
 In the <i>state&nbsp;1</i>, the current buffer matrix is <tt>buffer1</tt>;
 in the <i>state&nbsp;2</i>, the current buffer matrix is <tt>buffer2</tt>.
 The <i>state&nbsp;1</i> is default: it is chosen after creating the scanner.

 <p>While scanning boundaries, inside the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method, this scanner writes "brackets" in the current
 buffer matrix. It means that:

 <ul>
 <li>when the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A> is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_MINUS"><CODE>X_MINUS</CODE></A>, the element with coordinates <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>,<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>
 in the current buffer matrix is set to 1 ("opening bracket"),</li>
 <li>when the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A> is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>X_PLUS</CODE></A>, the element with coordinates <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>+1,<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>
 in the current buffer matrix is set to 1 ("closing bracket"), or nothing occurs if
 <tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>+1&gt;=matrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>,</li>
 <li>nothing occurs if the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A> is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#Y_MINUS"><CODE>Y_MINUS</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#Y_PLUS"><CODE>Y_PLUS</CODE></A>.</li>
 </ul>

 <p>This behavior is the same as in main boundaries scanner created by
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner</CODE></A> method.

 <p>The <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method in this scanner finds (after the current position)
 the nearest vertical segment, belonging to some object boundary,
 which was not visited yet by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method,
 and sets the current position to the found one.
 "Not visited" means that no "brackets" are set for that position neither in <tt>buffer1</tt>
 nor in <tt>buffer2</tt> matrix.
 <small>(There is the only exception from this simple rule:
 this method never stops at the right side of a last pixel in the horizontal line.
 If the last element in the horizontal line is 1, the corresponding boundary &mdash;
 its right side &mdash; is always skipped, and
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method searches for the next unit element in next lines.
 The only case when it can be important is calling <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> after
 direct positioning by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method.)</small>

 <p>If the new found position corresponds to a left pixel side
 (<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A> is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_MINUS"><CODE>Side.X_MINUS</CODE></A>),
 this method changes the current state to <i>state&nbsp;1</i>.
 It means an external boundary, if the scanning the matrix was started outside any boundaries,
 in particular, if <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A> method was never called.

 <p>If the new found position corresponds to a right pixel side
 (<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A> is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>Side.X_PLUS</CODE></A>),
 this method changes the current state to <i>state&nbsp;2</i>
 It means an internal boundary, if the scanning the matrix was started outside any boundaries,
 in particular, if <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A> method was never called.

 <p>While searching the next non-visited boundary, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method counts "brackets"
 in 1st and 2nd buffer matrices and corrects the current <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nestingLevel()"><CODE>nesting level</CODE></A>.

 <p>It is possible to specify the same matrix as both <tt>buffer1</tt> and <tt>buffer2</tt> arguments.
 In this case, all will work normally excepting the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nestingLevel()"><CODE>nesting level</CODE></A>,
 which will be calculated incorrectly.

 <p>This instance is convenient for scanning all boundaries in the matrix.
 To do this, it's possible to use the following loop:

 <pre>
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DScanner</CODE></A> scanner = <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner</CODE></A>(m, um1, um2, connectivityType);
 while (scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>) {
 &#32;   scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary</CODE></A>(ac); // or some more useful actions
 }
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>matrix</CODE> - the matrix that will be scanned by the created instance.</DD><DD><CODE>buffer1</CODE> - the 1st buffer matrix for writing "brackets" (usually indicates external boundaries).</DD><DD><CODE>buffer2</CODE> - the 2nd buffer matrix for writing "brackets" (usually indicates internal boundaries).
                         To save memory, you may pass here the same matrix as <tt>buffer1</tt>
                         and <tt>buffer2</tt> arguments, but in this case the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nestingLevel()"><CODE>nestingLevel()</CODE></A> method
                         will work incorrectly.</DD><DD><CODE>connectivityType</CODE> - the connectivity kind used by the created instance.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> or <tt>connectivityType</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>matrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not 2.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><!-- --></A><H3>
getMainBoundariesScanner</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A> <STRONG>getMainBoundariesScanner</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;matrix,
                                                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>&gt;&nbsp;buffer,
                                                         <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A>&nbsp;connectivityType)</PRE>
<DL>
<DD>Creates an instance of this class, allowing to trace all segments of <i>main</i> boundaries
 at the matrix and to build <a href="Boundary2DScanner.html#completion">completions</a> of all objects.

 <p>The scanner, created by this method, works with the additional matrix <tt>buffer</tt>,
 where <a href="Boundary2DScanner.html#completion">completions</a>
 of all objects are stored as a result of the scanning.
 This matrix can have any fixed-point element type (but usually it is <tt>boolean</tt>)
 and must have the same dimensions as the main matrix.
 This matrix should be zero-initialized before using the created instance (in other case,
 some boundaries are possible to be skipped).

 <p>While scanning boundaries, inside the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method, this scanner writes "brackets" in the
 buffer matrix. It means that:

 <ul>
 <li>when the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A> is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_MINUS"><CODE>X_MINUS</CODE></A>, the element with coordinates <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>,<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>
 in the buffer matrix is set to 1 ("opening bracket"),</li>
 <li>when the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A> is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>X_PLUS</CODE></A>, the element with coordinates <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>+1,<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>
 in the buffer matrix is set to 1 ("closing bracket"), or nothing occurs if
 <tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>+1&gt;=matrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>,</li>
 <li>nothing occurs if the <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A> is
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#Y_MINUS"><CODE>Y_MINUS</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#Y_PLUS"><CODE>Y_PLUS</CODE></A>.</li>
 </ul>

 <p>This behavior is the same as in all boundaries scanner created by
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner</CODE></A> method.

 <p>The <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method in this scanner is more complicated.
 If the element of the buffer matrix at the current position is zero,
 it just finds the nearest vertical segment,
 belonging to some object boundary,
 after the current position (alike in the simplest scanner returned by
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner</CODE></A> method).
 In other case we suppose that we are at the "open bracket" (the beginning of a series of unit elements),
 and <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method does the following:

 <ol>
 <li>finds the <i>next</i> unit element <tt>#p</tt> in the <i>buffer</i> matrix in the same horizontal line
 ("close bracket", written while previous scanning the boundary of the current object);</li>
 <li>fills all elements in the buffer matrix from the current position (inclusive) until
 the found <tt>#p</tt> position at this line (exclusive) by 1;</li>
 <li>clears the element <tt>#p</tt> in the buffer matrix to 0;</li>
 <li>and finds the nearest vertical segment in the main matrix, belonging to some object boundary,
 after all elements filled at step&nbsp;2.
 </ol>

 <p>If the next unit element was not found in the current line at step&nbsp;1,
 all buffer elements until the end of the horizontal line are filled by 1 &mdash;
 the <tt>p</tt> index is supposed to be <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A>
 &mdash; and the step 3 is skipped.

 <p>In fact, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> method skips all interior of previously scanned boundaries and fills
 this interior by 1 in the buffer matrix. As a result, the buffer matrix will contain
 <a href="Boundary2DScanner.html#completion">completions</a>
 of all objects after finishing scanning the matrix.

 <p>This instance is convenient for scanning main boundaries in the matrix and, as a side effect,
 for calculating completions of all objects.
 To do this, it's possible to use the following loop:

 <pre>
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DScanner</CODE></A> scanner = <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner</CODE></A>(m, um, connectivityType);
 while (scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>) {
 &#32;   scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary</CODE></A>(ac); // or some more useful actions
 }
 // now um contains the completions of all objects drawn in m
 // (if um was initially zero-filled)
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>matrix</CODE> - the matrix that will be scanned by the created instance.</DD><DD><CODE>buffer</CODE> - the buffer matrix for writing "brackets" and filling holes.</DD><DD><CODE>connectivityType</CODE> - the connectivity kind used by the created instance.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> or <tt>connectivityType</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>matrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not 2.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSingleBoundaryScanner()"><!-- --></A><H3>
isSingleBoundaryScanner</H3>
<PRE>
public abstract boolean <STRONG>isSingleBoundaryScanner</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this scanner is a single boundary scanner. More precisely,
 it is <tt>true</tt> if and only if:
 <ul>
     <li>this instance was created by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner(net.algart.arrays.Matrix<? extends net.algart.arrays.BitArray>, net.algart.matrices.scanning.ConnectivityType)</CODE></A> method</li>
     <li>or it is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A> and this method of its <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html#parent()"><CODE>parent scanner</CODE></A> returns <tt>true</tt>.</li>
 </ul>
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this scanner is a a single boundary scanner.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isAllBoundariesScanner()"><!-- --></A><H3>
isAllBoundariesScanner</H3>
<PRE>
public abstract boolean <STRONG>isAllBoundariesScanner</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this scanner is an all boundaries scanner. More precisely,
 it is <tt>true</tt> if and only if:
 <ul>
     <li>this instance was created by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner(net.algart.arrays.Matrix<? extends net.algart.arrays.BitArray>, net.algart.arrays.Matrix<? extends net.algart.arrays.UpdatablePFixedArray>, net.algart.arrays.Matrix<? extends net.algart.arrays.UpdatablePFixedArray>, net.algart.matrices.scanning.ConnectivityType)</CODE></A> method</li>
     <li>or it is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A> and this method of its <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html#parent()"><CODE>parent scanner</CODE></A> returns <tt>true</tt>.</li>
 </ul>
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this scanner is a an all boundaries scanner.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isMainBoundariesScanner()"><!-- --></A><H3>
isMainBoundariesScanner</H3>
<PRE>
public abstract boolean <STRONG>isMainBoundariesScanner</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this scanner is a main boundaries scanner. More precisely,
 it is <tt>true</tt> if and only if:
 <ul>
     <li>this instance was created by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner(net.algart.arrays.Matrix<? extends net.algart.arrays.BitArray>, net.algart.arrays.Matrix<? extends net.algart.arrays.UpdatablePFixedArray>, net.algart.matrices.scanning.ConnectivityType)</CODE></A> method</li>
     <li>or it is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A> and this method of its <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html#parent()"><CODE>parent scanner</CODE></A> returns <tt>true</tt>.</li>
 </ul>
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this scanner is a a main boundaries scanner.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="matrix()"><!-- --></A><H3>
matrix</H3>
<PRE>
public final <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt; <STRONG>matrix</STRONG>()</PRE>
<DL>
<DD>Returns the reference to the currently scanned matrix.
 If this instance was created by
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner</CODE></A>,
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner</CODE></A>,
 the first argument of those methods is returned.
 If this instance is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A>, the result of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A> method
 of the parent scanner is returned.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the reference to the currently scanned matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="connectivityType()"><!-- --></A><H3>
connectivityType</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html" title="enum in net.algart.matrices.scanning">ConnectivityType</A> <STRONG>connectivityType</STRONG>()</PRE>
<DL>
<DD>Returns the connectivity kind, used by this object.
 It is specified while creating this instance.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the connectivity kind, used by this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isInitialized()"><!-- --></A><H3>
isInitialized</H3>
<PRE>
public abstract boolean <STRONG>isInitialized</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this instance was positioned to some coordinates in the matrix.
 More precisely, returns <tt>false</tt> if this instance was newly created and none from
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goToSamePosition(net.algart.matrices.scanning.Boundary2DScanner)"><CODE>goToSamePosition</CODE></A>
 methods were called yet, or <tt>true</tt> in all other cases.
 If this instance is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A>, the result of this method for the parent scanner is returned.
 If this object is not positioned, most of methods, processing pixels in the current position,
 throw <tt>IllegalStateException</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if and only if this instance was already positioned by
                       <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary</CODE></A> or
                       <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A> method.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isMovedAlongBoundary()"><!-- --></A><H3>
isMovedAlongBoundary</H3>
<PRE>
public abstract boolean <STRONG>isMovedAlongBoundary</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this scanner is already positioned
 (<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>isInitialized()</CODE></A> returns <tt>true</tt>) and, in addition, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A> methods were called at least once.

 <p>This information can be useful before calling <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#lastStep()"><CODE>lastStep()</CODE></A> method
 (for example, for debugging goals): that method throws <tt>IllegalStateException</tt>
 if and only if this method returns <tt>false</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if and only <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A> methods
         were successfully called after creating this instance.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="x()"><!-- --></A><H3>
x</H3>
<PRE>
public abstract long <STRONG>x</STRONG>()</PRE>
<DL>
<DD>Returns the current <i>x</i>-coordinate (or throws <tt>IllegalStateException</tt> if the scanner
 was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current <i>x</i>-coordinate.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="y()"><!-- --></A><H3>
y</H3>
<PRE>
public abstract long <STRONG>y</STRONG>()</PRE>
<DL>
<DD>Returns the current <i>y</i>-coordinate (or throws <tt>IllegalStateException</tt> if this scanner
 was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current <i>y</i>-coordinate.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="side()"><!-- --></A><H3>
side</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning">Boundary2DScanner.Side</A> <STRONG>side</STRONG>()</PRE>
<DL>
<DD>Returns the current pixel side (or throws <tt>IllegalStateException</tt> if this scanner
 was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current pixel side.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="nestingLevel()"><!-- --></A><H3>
nestingLevel</H3>
<PRE>
public abstract long <STRONG>nestingLevel</STRONG>()</PRE>
<DL>
<DD>Returns the current <i>nesting level</i> of object boundaries:
 the number of boundaries (external or internal), inside which the current pixel side
 &mdash; the segment with the length 1.0, described by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A>
 &mdash; is located.
 (Here we suppose, that if the current pixel side lies <i>at</i> some boundary,
 then it lies <i>inside</i> this boundary.)

 <p>Just after creating an instance of this class the nesting level is 0.
 After the first call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> it becomes 1.
 After finding the first internal boundary (if it exists) by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A>
 the nesting level becomes 2.
 After each intersection of a boundary while searching for the next boundary
 the nesting level is increased by 1 or decreased by 1.
 So, odd values of the nesting level correspond to external boundaries
 and even values correspond to internal boundaries, excepting the case of a newly created instance
 (the only case when it is 0).

 <p>Please <i>note:</i> the nesting level is supported only
 <ol>
 <li>if this scanner was created via
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner(Matrix, Matrix, Matrix, ConnectivityType)</CODE></A> method;</li>
 <li>if the <tt>buffer1</tt> and <tt>buffer2</tt> argument of that method are different,
 independently allocated matrices;</li>
 <li>and if <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method was never called;</li>
 <li>note: if this instance is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DWrapper.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DWrapper</CODE></A>, the result of this method for the parent scanner
 is returned.</li>
 </ol>

 <p>If this scanner was created via
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner(Matrix, ConnectivityType)</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner(Matrix, Matrix, ConnectivityType)</CODE></A>,
 the returned nesting level is always 0.
 In all other cases, the result of this method is not specified.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current <i>nesting level</i> of object boundaries.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="currentIndexInArray()"><!-- --></A><H3>
currentIndexInArray</H3>
<PRE>
public abstract long <STRONG>currentIndexInArray</STRONG>()</PRE>
<DL>
<DD>Returns the index of the current pixel in the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>underlying array</CODE></A> of the currently
 scanned matrix. This method is almost equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A> * <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A> + <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A></tt></nobr>,
 with the only difference that it works even if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>:
 in the last case it returns 0.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the index of the current pixel in the underlying array of the scanned matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><!-- --></A><H3>
goTo</H3>
<PRE>
public abstract void <STRONG>goTo</STRONG>(long&nbsp;x,
                          long&nbsp;y,
                          <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning">Boundary2DScanner.Side</A>&nbsp;side)</PRE>
<DL>
<DD>Sets the current position in the matrix to the specified coordinates and pixel side.

 <p>Usually this method is not necessary for scanners, created by
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner</CODE></A> and
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner</CODE></A> methods:
 it is enough to use <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> and <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> (or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A>)
 methods to visit all object boundaries at the matrix.
 But this method may be helpful if you need to scan a single boundary (for example,
 that was found by another scanner).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - new current <i>x</i>-coordinate.</DD><DD><CODE>y</CODE> - new current <i>y</i>-coordinate.</DD><DD><CODE>side</CODE> - new current pixel side.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>side</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>x&lt;0</tt>, <tt>y&lt;0</tt>,
                                   <tt>x&gt;=<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>
                                   or <tt>y&gt;=<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimY()"><CODE>dimY()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="goToSamePosition(net.algart.matrices.scanning.Boundary2DScanner)"><!-- --></A><H3>
goToSamePosition</H3>
<PRE>
public final void <STRONG>goToSamePosition</STRONG>(<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html" title="class in net.algart.matrices.scanning">Boundary2DScanner</A>&nbsp;scanner)</PRE>
<DL>
<DD>Sets the current position in the matrix to the same as in the specified scanner.
 Equivalent to the following call:
 <tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A>(scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>, scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>, scanner.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>scanner</CODE> - some other scanner.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>scanner</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the specified <tt>scanner</tt> was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - in the same situations as <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo</CODE></A> method
                                   (impossible if the currently scanned matrices of this and passed scanners
                                   have identical dimensions).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="get()"><!-- --></A><H3>
get</H3>
<PRE>
public abstract boolean <STRONG>get</STRONG>()</PRE>
<DL>
<DD>Returns the value of the current element of the currently scanned matrix.
 This method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/BitArray.html#getBit(long)"><CODE>getBit</CODE></A>(<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>)</tt></nobr>,
 but works little faster.
 This method works even if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>;
 in this case, it returns the value of (0,0) matrix element
 (i.e. <nobr><tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/BitArray.html#getBit(long)"><CODE>getBit(0)</CODE></A></tt></nobr>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the value of the current element of the currently scanned matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="nextBoundary()"><!-- --></A><H3>
nextBoundary</H3>
<PRE>
public abstract boolean <STRONG>nextBoundary</STRONG>()</PRE>
<DL>
<DD>Finds the next vertical segment, belonging to some object boundary,
 after the current position, and sets the current position to the found one.

 <p>More precisely, it finds some "next" position <i>after</i> the current position,
 in the <a href="Boundary2DScanner.html#positions_order">natural order</a>,
 where the side is <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_MINUS"><CODE>X_MINUS</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>X_PLUS</CODE></A>
 and one from two matrix elements on the left and on the right from the specified segment (pixel side) is 1,
 but another from these two elements is 0 or lies outside the matrix.
 If this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>, this method finds the first
 such position.

 <p>The precise sense of the "next" term above depends on the kind of the boundary scanner.
 <ul>
 <li>If this scanner is created by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner(Matrix, ConnectivityType)</CODE></A>
 method, it is just the nearest possible position
 (in the <a href="Boundary2DScanner.html#positions_order">natural order</a>).</li>
 <li>If this scanner is created by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner(Matrix, Matrix, Matrix, ConnectivityType)</CODE></A>
 method, it is the nearest boundary segment that was not visited yet by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method.</li>
 <li>If this scanner is created by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner(Matrix, Matrix, ConnectivityType)</CODE></A>
 method, it is the nearest boundary segment that was not visited yet by <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method
 and that does not lie inside some already scanned boundary.</li>
 </ul>

 <p>In addition to searching for the next position, this method may do something else:
 see comments to methods <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner</CODE></A>,
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner</CODE></A>,
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner</CODE></A>.

 <p>This method returns <tt>true</tt> if it can find the necessary "next" position, or <tt>false</tt>
 if there is no required position, i.e. if the matrix scanning is finished. In the second case,
 the current position is not changed.

 <p>Note that if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>, it becomes positioned
 if this method returns <tt>true</tt>, but stays not positioned if it returns <tt>false</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this method has successfully found new boundary.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="next()"><!-- --></A><H3>
next</H3>
<PRE>
public abstract void <STRONG>next</STRONG>()</PRE>
<DL>
<DD>Move the current position to the next segment of the currently scanned object boundary.
 External boundaries are scanned in clockwise order, internal boundaries in anticlockwise order
 (if we suppose that the <i>x</i> axis is directed rightwards and the <i>y</i> axis is directed downwards).

 <p>If the current position does not correspond to an object boundary, the position will be changed
 to some unknown position near the current one (precise behavior is not specified).

 <p>In addition to switching to the next position, this method can do something else:
 see comments to methods
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getSingleBoundaryScanner(net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getSingleBoundaryScanner</CODE></A>,
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner</CODE></A>,
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getMainBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getMainBoundariesScanner</CODE></A>,
 and comments to classes <A HREF="../../../../net/algart/matrices/scanning/Boundary2DSimpleMeasurer.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DSimpleMeasurer</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DProjectionMeasurer.html" title="class in net.algart.matrices.scanning"><CODE>Boundary2DProjectionMeasurer</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="lastStep()"><!-- --></A><H3>
lastStep</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Step.html" title="class in net.algart.matrices.scanning">Boundary2DScanner.Step</A> <STRONG>lastStep</STRONG>()</PRE>
<DL>
<DD>Returns information about the movement of the current position, performed by the last call of
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method.

 <p>If that method was never called (in particular, as a part of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A>),
 this method throws <tt>IllegalStateException</tt>. You can check this situation with help of
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isMovedAlongBoundary()"><CODE>isMovedAlongBoundary()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the step of scanning boundary, performed by the call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> (or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A>) method was never
                               called for this instance.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isMovedAlongBoundary()"><CODE>isMovedAlongBoundary()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordinatesChanged()"><!-- --></A><H3>
coordinatesChanged</H3>
<PRE>
public abstract boolean <STRONG>coordinatesChanged</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the last call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method has changed <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>
 coordinate. Returns <tt>false</tt> if the last call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method has changed only the
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>current pixel side</CODE></A>.

 <p>Equivalent to
 <tt>!<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#lastStep()"><CODE>lastStep()</CODE></A>.<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Step.html#isSamePixel()"><CODE>isSamePixel()</CODE></A></tt>,
 but works little faster.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether the last call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method has changed current pixel coordinates.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> (or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A>) method was never
                               called for this instance.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="boundaryFinished()"><!-- --></A><H3>
boundaryFinished</H3>
<PRE>
public abstract boolean <STRONG>boundaryFinished</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if the current position (<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#x()"><CODE>x()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#y()"><CODE>y()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A>)
 is identical to the position, set by last call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method.
 Usually it means that the current boundary has been successfully scanned.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the current boundary scanning is finished.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepCount()"><!-- --></A><H3>
stepCount</H3>
<PRE>
public abstract long <STRONG>stepCount</STRONG>()</PRE>
<DL>
<DD>Returns the total number of calls of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method since the last call <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> or
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the internal counter, incremented in <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#next()"><CODE>next()</CODE></A> method and reset to zero while object creation
         and while every call of <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> or <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)"><CODE>goTo(long, long, net.algart.matrices.scanning.Boundary2DScanner.Side)</CODE></A> method.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isInternalBoundary()"><!-- --></A><H3>
isInternalBoundary</H3>
<PRE>
public final boolean <STRONG>isInternalBoundary</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if
 <nobr><tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A> == <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>Side.X_PLUS</CODE></A></tt></nobr>.
 Usually it means that the current position corresponds to an internal boundary:
 see comments to <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#getAllBoundariesScanner(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.matrices.scanning.ConnectivityType)"><CODE>getAllBoundariesScanner(Matrix, Matrix, Matrix, ConnectivityType)</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><nobr><tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#side()"><CODE>side()</CODE></A> == <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html#X_PLUS"><CODE>Side.X_PLUS</CODE></A></tt></nobr>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="scanBoundary(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
scanBoundary</H3>
<PRE>
public final long <STRONG>scanBoundary</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Scans the current boundary. This method performs the following simple loop:

 <pre>
 do {
 &#32;   next();
 } while (!boundaryFinished());
 </pre>

 <p>and returns <tt><A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#stepCount()"><CODE>stepCount()</CODE></A></tt> (the number of performed iterations,
 i.e. the length of the scanned boundary).
 In addition, this method calls <tt>context.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt>
 method from time to time (if <tt>context!=null</tt>) to allow interruption of scanning very long boundaries.
 No other methods of the <tt>context</tt> are called.

 <p>Note: the number of boundary segments, returned of this method, can theoretically be
 incorrect if the length of the boundary is greater than <tt>Long.MAX_VALUE</tt>.
 It is a very exotic case, that can be practically realized only on a virtual matrix, containing
 almost 2<sup>63</sup> bits, with special structure. In this case, this method will work during
 more than 10<sup>10</sup> seconds (&gt; 300 years) on a very quick computer that can perform one
 iteration per 1&nbsp;ns.</p>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the length of scanned boundary (the number of visited pixel sides,
                not the number of visited pixels!)</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="updateProgress(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
updateProgress</H3>
<PRE>
public final void <STRONG>updateProgress</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Calls <tt>context.<A HREF="../../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress(event)</CODE></A></tt>
 with an event, created by the following operator:
 <nobr><tt>new ArrayContext.Event(boolean.class, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>, <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#matrix()"><CODE>matrix()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>)</tt></nobr>,
 or does nothing if <tt>context==null</tt>.

 <p>The method can be useful while sequentially scanning the matrix via a usual loop of
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> and <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A> calls.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="checkInterruption(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
checkInterruption</H3>
<PRE>
public final void <STRONG>checkInterruption</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Calls <tt>context.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt> or
 does nothing if <tt>context==null</tt>.

 <p>The method can be useful while sequentially scanning the matrix via a usual loop of
 <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#nextBoundary()"><CODE>nextBoundary()</CODE></A> and <A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.html#scanBoundary(net.algart.arrays.ArrayContext)"><CODE>scanBoundary(ArrayContext)</CODE></A> calls.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <STRONG>toString</STRONG>()</PRE>
<DL>
<DD>Returns a brief string description of this object.

 <p>The result of this method may depend on implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a brief string description of this object.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DProjectionMeasurer.html" title="class in net.algart.matrices.scanning"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/scanning/Boundary2DScanner.Side.html" title="enum in net.algart.matrices.scanning"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/scanning/Boundary2DScanner.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Boundary2DScanner.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
