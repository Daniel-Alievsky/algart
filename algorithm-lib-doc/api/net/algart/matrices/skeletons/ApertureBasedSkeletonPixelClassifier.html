<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ApertureBasedSkeletonPixelClassifier
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ApertureBasedSkeletonPixelClassifier";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="ApertureBasedSkeletonPixelClassifier.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier">NESTED</A>&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.matrices.skeletons</FONT>
<BR>
Class ApertureBasedSkeletonPixelClassifier</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">net.algart.matrices.skeletons.SkeletonPixelClassifier</A>
      <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.matrices.skeletons.ApertureBasedSkeletonPixelClassifier</STRONG>
</PRE>
<DL>
<DT><STRONG>Direct Known Subclasses:</STRONG></DT> <DD><A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons">BasicSkeletonPixelClassifier2D</A></DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>ApertureBasedSkeletonPixelClassifier</STRONG>
extends <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></PRE>

<P>
<p>A skeletal implementation of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonPixelClassifier</CODE></A> abstract class,
 minimizing the effort required to implement its abstract methods.</p>

 <p>Namely, the main <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method is implemented in this class
 via the following 2 abstract methods:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachingBranch(int)"><CODE>pixelTypeOrAttachingBranch(int)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachedNode(int)"><CODE>pixelTypeOrAttachedNode(int)</CODE></A>.</li>
 </ul>

 <p>The methods <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#neighbourOffset(long[], int)"><CODE>neighbourOffset(long[], int)</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#reverseNeighbourIndex(int)"><CODE>reverseNeighbourIndex(int)</CODE></A>
 are implemented on the base of the array of offsets of all neighbours of a random element.
 This array should be passed to the <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#ApertureBasedSkeletonPixelClassifier(int, long[][])"><CODE>constructor</CODE></A>.
 The constructor analyses the passed array, checks that it really contains
 offsets of all neighbours, copies this array into an internal field, which is used
 by <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#neighbourOffset(long[], int)"><CODE>neighbourOffset(long[], int)</CODE></A>, and also automatically finds,
 for every neighbour, the reverse neighbour index, which will be returned by <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#reverseNeighbourIndex(int)"><CODE>reverseNeighbourIndex(int)</CODE></A>.

 <p>The method <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><CODE>markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])</CODE></A> is implemented here
 in some reasonable way for 2-dimensional case, as specified in comments to this method.
 For other number of dimensions, this method does nothing.
 It is a good solution for the degenerated case <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>=1;
 for 3-dimensional case, this method probably should be overridden.</p>

 <p>So, it is enough to implement <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachingBranch(int)"><CODE>pixelTypeOrAttachingBranch(int)</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachedNode(int)"><CODE>pixelTypeOrAttachedNode(int)</CODE></A>
 methods and, maybe, override <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><CODE>markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])</CODE></A> method
 to create a full implementation of the skeleton pixel classifier on the base of this class.</p>

 <p>This class can be used in 1-, 2- and 3-dimensional cases only.
 One of the reasons of this restriction is that the argument of <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachingBranch(int)"><CODE>pixelTypeOrAttachingBranch(int)</CODE></A>
 and <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachedNode(int)"><CODE>pixelTypeOrAttachedNode(int)</CODE></A> (<tt>int</tt> type) can represent the values of, maximally, 32
 neighbours. It is enough for 3-dimensional case, where the number of neighbours is 3<sup>3</sup>&minus;1=26&lt;32,
 but not enough already for 4-dimensional case, where the number of neighbours is 3<sup>4</sup>&minus;1=80
 (and even 64-bit <tt>long</tt> type would have been insufficient).</p>

 <p>This class is <b>immutable</b> and <b>thread-safe</b>:
 there are no ways to modify settings of the created instance.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Nested Class Summary table, listing nested classes, and an explanation">
<CAPTION CLASS="TableCaption">
Nested Class Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Class and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Nested classes/interfaces inherited from class net.algart.matrices.skeletons.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from class net.algart.matrices.skeletons.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount">dimCount</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours">numberOfNeighbours</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MAX">TYPE_BRANCH_MAX</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MIN">TYPE_BRANCH_MIN</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END">TYPE_FREE_BRANCH_END</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL">TYPE_ILLEGAL</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED">TYPE_ISOLATED</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MAX">TYPE_NODE_OR_BRANCH_END_MAX</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MIN">TYPE_NODE_OR_BRANCH_END_MIN</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH">TYPE_USUAL_BRANCH</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE">TYPE_USUAL_NODE</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO">TYPE_ZERO</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Constructor Summary table, listing constructors, and an explanation">
<CAPTION CLASS="TableCaption">
Constructor Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Constructor and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#ApertureBasedSkeletonPixelClassifier(int, long[][])">ApertureBasedSkeletonPixelClassifier</A></STRONG>(int&nbsp;dimCount,
                                     long[][]&nbsp;neighbourOffsets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new instance of this class, allowing to process skeletons with the given number of dimensions,
 with the order of neighbours, specified in the second argument.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asNeighbourhoodBitMaps(net.algart.arrays.Matrix)">asNeighbourhoodBitMaps</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed skeleton matrix, where each element is an integer,
 containing, in its low bits, the bit values of the corresponding element
 <tt><b><i>C</i></b></tt> of the source skeleton and of all its neighbours (in terms of the
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)">asPixelTypes</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
             <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A>&nbsp;attachmentInformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed skeleton matrix, where each element is an integer,
 specifying the type of the corresponding pixel of the skeleton.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])">markNeighbouringNodesNotConnectedViaDegeneratedBranches</A></STRONG>(int[]&nbsp;pixelTypesOfAllNeighbours)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds and marks, by assigning <tt>Integer.MIN_VALUE</tt> to corresponding elements of the passed Java array,
 all neighbours of some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, which are also <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>
 and are considered to be <i>not</i> connected with this node via a degenerated 0-pixel branch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#neighbourOffset(long[], int)">neighbourOffset</A></STRONG>(long[]&nbsp;coordinateIncrements,
                int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method,
 which stores the results in the passed Java array instead of creating new Java array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachedNode(int)">pixelTypeOrAttachedNode</A></STRONG>(int&nbsp;apertureBits)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates and returns the value of an element <tt><b><i>C'</i></b></tt>
 in the resulting matrix, produced by
 <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method with
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A> value of <tt>attachmentInformation</tt> argument,
 on the base of bit values of all neighbours (in terms of the
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>)
 of the corresponding unit element <tt><b><i>C</i></b></tt> in the source skeleton bit matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachingBranch(int)">pixelTypeOrAttachingBranch</A></STRONG>(int&nbsp;apertureBits)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates and returns the value of an element <tt><b><i>C'</i></b></tt>
 in the resulting matrix, produced by
 <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method with
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A> value of <tt>attachmentInformation</tt> argument,
 on the base of bit values of all neighbours (in terms of the
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>)
 of the corresponding unit element <tt><b><i>C</i></b></tt> in the source skeleton bit matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#reverseNeighbourIndex(int)">reverseNeighbourIndex</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an index of such neighbour <i>B</i> of some element <i>A</i> of a skeleton matrix,
 so that the element <i>A</i> is the neighbour with the specified index <tt>neighbourIndex</tt>
 of its neighbour <i>B</i>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class net.algart.matrices.skeletons.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()">dimCount</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)">isAttachableBranchEndPixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isBranchPixelType(int)">isBranchPixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)">isFreeBranchEndPixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isIllegalPixelType(int)">isIllegalPixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodeOrFreeBranchEndPixelType(int)">isNodeOrFreeBranchEndPixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)">isNodePixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isUsualBranchPixelType(int)">isUsualBranchPixelType</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)">neighbourOffset</A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()">numberOfNeighbours</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Constructor Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="ApertureBasedSkeletonPixelClassifier(int, long[][])"><!-- --></A><H3>
ApertureBasedSkeletonPixelClassifier</H3>
<PRE>
protected <STRONG>ApertureBasedSkeletonPixelClassifier</STRONG>(int&nbsp;dimCount,
                                               long[][]&nbsp;neighbourOffsets)</PRE>
<DL>
<DD>Creates new instance of this class, allowing to process skeletons with the given number of dimensions,
 with the order of neighbours, specified in the second argument.
 The number of dimensions must be 1, 2 or 3.

 <p>The argument <tt>neighbourOffsets</tt> must contain offsets of all neighbours,
 in terms of the <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>, of any matrix element, in some order.
 More precisely, this array must contain
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>=3<sup>dimCount</sup>-1</tt></nobr> elements
 (2, 8 or 26 for 1-, 2-, 3-dimensional cases) in <nobr>3/3x3/3x3x3-aperture</nobr>, and each its element
 <tt>neighbourOffsets[k]</tt> must be equal to the result of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(k)</CODE></A> call.

 <p>The passed <tt>neighbourOffsets</tt> array is deeply cloned by the constructor: no references to it
 or its elements are maintained by the created object.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dimCount</CODE> - the number of dimensions, which will be returned by
                         <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A> method.</DD><DD><CODE>neighbourOffsets</CODE> - offsets of all neighbours of any matrix element,
                         in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>neighbourOffsets</tt> or one of its elements is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>dimCount</tt> is not in <tt>1..3</tt> range,
                                  or if <tt>neighbourOffsets.length!=3<sup>dimCount</sup>-1</tt>,
                                  or if <tt>neighbourOffsets[k].length!=dimCount</tt> for some <tt>k</tt>,
                                  or if <tt>neighbourOffsets</tt> does not contain, in some order,
                                  the offsets of all <tt>3<sup>dimCount</sup>-1</tt> neighbours
                                  (in particular, if some elements <tt>neighbourOffsets[k][j]</tt> are
                                  not in <tt>-1..+1</tt> range or if offsets of some neighbours are equal).</DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="neighbourOffset(long[], int)"><!-- --></A><H3>
neighbourOffset</H3>
<PRE>
public void <STRONG>neighbourOffset</STRONG>(long[]&nbsp;coordinateIncrements,
                            int&nbsp;neighbourIndex)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(long[], int)">SkeletonPixelClassifier</A></CODE></STRONG></DD>
<DD>More efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method,
 which stores the results in the passed Java array instead of creating new Java array.
 This method is equivalent to calling that method and copying its result into
 <tt>coordinateIncrements</tt> argument, but does not allocate any arrays.
 It is a better solution if we need to calculate neighbour offsets in a long loop,
 because allows to avoid allocating a lot of short arrays.

 <p>The length of the passed array must be equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>the number of dimensions</CODE></A>
 of processed matrices.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(long[], int)">neighbourOffset</A></CODE> in class <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinateIncrements</CODE> - Java array for storing the differences of all coordinates of
                             the neighbour #<tt>neighbourIndex</tt> of some (central) element
                             and the coordinates of this central element.</DD><DD><CODE>neighbourIndex</CODE> - an index if the neighbour of some central element of the matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>SkeletonScanner.neighbourOffsetInArray(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="reverseNeighbourIndex(int)"><!-- --></A><H3>
reverseNeighbourIndex</H3>
<PRE>
public int <STRONG>reverseNeighbourIndex</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#reverseNeighbourIndex(int)">SkeletonPixelClassifier</A></CODE></STRONG></DD>
<DD>Returns an index of such neighbour <i>B</i> of some element <i>A</i> of a skeleton matrix,
 so that the element <i>A</i> is the neighbour with the specified index <tt>neighbourIndex</tt>
 of its neighbour <i>B</i>.
 Both neighbour indexes are considered in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 It means, that if <tt>k1</tt> is the argument of this method and <tt>k2</tt> is the result of this method,
 <nobr><tt>offset1=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset</CODE></A>(k1)</tt></nobr> and
 <nobr><tt>offset2=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset</CODE></A>(k2)</tt></nobr>,
 then
 <blockquote>
 <tt>offset2[<i>i</i>] = -offset1[<i>i</i>]</tt> for all <i>i</i>.
 </blockquote>

 <p>For example, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> class (which enumerates 8 neighbours along
 the perimeter of 3x3 square) this method returns <tt>(neighbourIndex+4)%8</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#reverseNeighbourIndex(int)">reverseNeighbourIndex</A></CODE> in class <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - an index of some neighbour <i>B</i> of some central element <i>A</i>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>an index of the central element <i>A</i> as a neighbour of the element <i>B</i>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><!-- --></A><H3>
asPixelTypes</H3>
<PRE>
public <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt; <STRONG>asPixelTypes</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
                                                    <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A>&nbsp;attachmentInformation)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)">SkeletonPixelClassifier</A></CODE></STRONG></DD>
<DD>Returns an immutable view of the passed skeleton matrix, where each element is an integer,
 specifying the type of the corresponding pixel of the skeleton. The number of dimensions of
 the passed matrix must be equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>.

 <p>More precisely, let's consider that <tt>skeleton</tt> matrix is the result of some skeletonization
 algorithm (chosen while creating an instance of this class). The resulting matrix will
 contain the following values:

 <ol>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>SkeletonPixelClassifier.TYPE_ZERO</CODE></A>, if the corresponding element of the skeleton is zero (no pixel);</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>SkeletonPixelClassifier.TYPE_ILLEGAL</CODE></A>, if here is an impossible configuration for a correct result of the given
 skeletonization algorithm (probable case, if the passed matrix is really not a skeleton);</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>SkeletonPixelClassifier.TYPE_USUAL_NODE</CODE></A>, if the corresponding element of the skeleton is a node, where 3 or more
 branches meet;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>SkeletonPixelClassifier.TYPE_ISOLATED</CODE></A>, if the corresponding element of the skeleton is an isolated unit pixel,
 having no unit neighbour elements;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>SkeletonPixelClassifier.TYPE_FREE_BRANCH_END</CODE></A>, if the corresponding element of the skeleton is an end of some branch,
 having 1 unit neighbour elements;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>SkeletonPixelClassifier.TYPE_USUAL_BRANCH</CODE></A>, if the corresponding element of the skeleton has 2
 unit neighbour elements;</li>
 <li>some non-negative value in <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt> range,
 if the corresponding element of the skeleton has &ge;3 unit neighbour elements, but this class recommends
 to consider this pixel not a node, but an additional <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>"attached" element</CODE></A> of some branch. In this case, this value means the following:
     <ol type=A>
     <li>if <tt>attachmentInformation</tt> argument is
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A>,
     this value specifies the direction (neighbour index) towards the neighbouring node,
     which is one of the ends of this branch;
     there is a guarantee that this neighbour is either really <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or, maybe,
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>SkeletonPixelClassifier.TYPE_ILLEGAL</CODE></A>;</li>
     <li>if <tt>attachmentInformation</tt> argument is
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A>,
     this value specifies the direction (neighbour index) towards the branch,
     to which this pixel should be attached as its ending element;
     there is no guarantee that this neighbour is really a branch element, but it cannot be
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>zero</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated</CODE></A>, and if it is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>,
     it is supposed that we have a short branch to it, consisting of 1 pixel.</li>
     </ol>
 See also the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>,
 section "Pixel types", group 5.<br>
 The direction is specified in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 In <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A>, it can be 0,1,2,3,4,5,6,7, corresponding to the following diagram:
 <pre>
 0 1 2
 7 <b><i>C</i></b> 3
 6 5 4</pre>
 <p>(the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).
 Namely, if the current element has coordinates <nobr>(<i>x</i>,<i>y</i>)</nobr>,
 then "0" value means attaching of the node with coordinates
 <nobr>(<i>x</i>&minus;1,<i>y</i>&minus;1)</nobr> (the case A)
 or attaching of the node to the branch containing the pixel
 <nobr>(<i>x</i>&minus;1,<i>y</i>&minus;1)</nobr> (the case B),
 "1" value means attaching of the node / to the branch <nobr>(<i>x</i>,<i>y</i>&minus;1)</nobr>,
 "2" value means attaching of the node / to the branch <nobr>(<i>x</i>+1,<i>y</i>&minus;1)</nobr>,
 "3" value means attaching of the node / to the branch  <nobr>(<i>x</i>+1,<i>y</i>)</nobr>,
 "4" value means attaching of the node / to the branch  <nobr>(<i>x</i>+1,<i>y</i>+1)</nobr>,
 "5" value means attaching of the node / to the branch  <nobr>(<i>x</i>,<i>y</i>+1)</nobr>,
 "6" value means attaching of the node / to the branch  <nobr>(<i>x</i>&minus;1,<i>y</i>+1)</nobr>,
 "7" value means attaching of the node / to the branch  <nobr>(<i>x</i>&minus;1,<i>y</i>)</nobr>.
 </li>
 </ol>

 <p>Note, that the situation, when some neighbouring elements are out of ranges of the matrix coordinates,
 is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>.

 <p>Note, that all values, specified by constants of this class
 (all cases 1-6 above, excepting the last case 7), are different negative integers.
 Then, note that <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>SkeletonPixelClassifier.TYPE_USUAL_NODE</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>SkeletonPixelClassifier.TYPE_ISOLATED</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>SkeletonPixelClassifier.TYPE_FREE_BRANCH_END</CODE></A>
 are adjacent integers <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MIN">-3</A>..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MAX">-1</A>.
 Then, note that two constants, corresponding to branches and their ends &mdash;
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>SkeletonPixelClassifier.TYPE_FREE_BRANCH_END</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>SkeletonPixelClassifier.TYPE_USUAL_BRANCH</CODE></A> &mdash;
 are also adjacent integers <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MIN">-4</A>..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MAX">-3</A>.
 Then, note that two constants, corresponding to nodes and isolated pixels &mdash;
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>SkeletonPixelClassifier.TYPE_USUAL_NODE</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>SkeletonPixelClassifier.TYPE_ISOLATED</CODE></A> &mdash;
 are also adjacent integers <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED">-2</A>..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE">-1</A>.
 This can be useful for extracting special kinds of skeleton pixels into bit matrices.</p>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)">asPixelTypes</A></CODE> in class <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>skeleton</CODE> - the skeleton matrix that should be processed.</DD><DD><CODE>attachmentInformation</CODE> - what should this method return for attachable pixels.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the matrix of integer codes with the same sizes, describing the types
                              of all skeleton pixels.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><!-- --></A><H3>
markNeighbouringNodesNotConnectedViaDegeneratedBranches</H3>
<PRE>
public void <STRONG>markNeighbouringNodesNotConnectedViaDegeneratedBranches</STRONG>(int[]&nbsp;pixelTypesOfAllNeighbours)</PRE>
<DL>
<DD><STRONG>Description copied from class: <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])">SkeletonPixelClassifier</A></CODE></STRONG></DD>
<DD>Finds and marks, by assigning <tt>Integer.MIN_VALUE</tt> to corresponding elements of the passed Java array,
 all neighbours of some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, which are also <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>
 and are considered to be <i>not</i> connected with this node via a degenerated 0-pixel branch.
 Neighbouring nodes, which are considered to be connected with the central node
 via 0-pixel branch, stay unchanged.

 <p>More precisely, this method analyses the Java array <tt>pixelTypesOfAllNeighbours</tt>,
 which contains the pixel types of all neighbours of some "central" pixel, which is supposed to be
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, in the order, defined by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 This method finds among them all values, equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>SkeletonPixelClassifier.TYPE_USUAL_NODE</CODE></A>, and, if this class considers
 that they should not be connected with the central node via degenerated branches, such values are
 replaced with <tt>Integer.MIN_VALUE</tt> (which means "removing" these neighbours from candidates to
 connection with the central node). So, if some elements of the passed array are
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>SkeletonPixelClassifier.TYPE_USUAL_NODE</CODE></A> after calling this method as before,
 it means that such neighbouring nodes should be considered as connected
 with the central node via degenerated branches.

 <p>This method is used in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>SkeletonScanner.adjacentBranches()</CODE></A> to correctly find all degenerated
 branches, originating in the current node.

 <p>The passed array must contain at least <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> elements.
 If it contains more elements, this method processes only first
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> elements and ignores others.

 <p>In <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>ApertureBasedSkeletonPixelClassifier</CODE></A> for 2-dimensional case and,
 in particular, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A>,
 the neighbouring node <i>Q</i> of the central node <i>P</i>
 is not marked for removing (not replaced with <tt>Integer.MIN_VALUE</tt>),
 if the segment <i>PQ</i> is not diagonal (4-connected neighbour) or if it is diagonal,
 but the two adjacent pixels, which are 4-connected neighbours
 of both <i>P</i> and <i>Q</i>, are not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>:
 <pre>
     . . * . . .      . . . * . .
     . . * . . .      . . . * . .
     * * . * * *      . . . Q * *
     . . P Q . .  or  * * P . . .
     . . * . * .      . . * . . .
     . . * . . *      . . * . . .
 </pre>
 In other situations, a diagonal degenerated branch between <i>P</i> and <i>Q</i> would be extra, because
 they are connected via two horizontal and vertical degenerated 0-pixel branches.
 (In <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>ApertureBasedSkeletonPixelClassifier</CODE></A> class for the number of dimensions, other than 2,
 the implementation of this method does nothing.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])">markNeighbouringNodesNotConnectedViaDegeneratedBranches</A></CODE> in class <CODE><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelTypesOfAllNeighbours</CODE> - an array of the pixel types of all neighbours of some given element,
                                  supposed to be a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>; this method will replace
                                  some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>SkeletonPixelClassifier.TYPE_USUAL_NODE</CODE></A> values in this array with
                                  <tt>Integer.MIN_VALUE</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="asNeighbourhoodBitMaps(net.algart.arrays.Matrix)"><!-- --></A><H3>
asNeighbourhoodBitMaps</H3>
<PRE>
public final <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt; <STRONG>asNeighbourhoodBitMaps</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Returns an immutable view of the passed skeleton matrix, where each element is an integer,
 containing, in its low bits, the bit values of the corresponding element
 <tt><b><i>C</i></b></tt> of the source skeleton and of all its neighbours (in terms of the
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>).

 <p>More precisely, each integer element <i>w</i> of the resulting matrix will contain:
 <ul>
 <li>in the bit #0 (in other words, <nobr><i>w</i><tt>&amp;1</tt></nobr>):
 the value of the corresponding element
 <tt><b><i>C</i></b></tt> of the source skeleton bit matrix;</li>
 <li>in the bit #<i>k</i>+1, 0&le;<i>k</i>&lt;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>
 (in other words, <nobr>(<i>w</i><tt>&gt;&gt;&gt;(</tt><i>k</i><tt>+1))&amp;1</tt></nobr>):
 the value of the neighbour #<i>k</i> of the central element <tt><b><i>C</i></b></tt>,
 in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method;</li>
 <li>all other bits of the elements if the resulting matrix will be zero.</li>
 </ul>

 <p>In particular, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> implementation,
 the lower 9 bits in the elements of the returned matrix correspond to elements of 3x3 aperture
 of the source skeleton according the following diagram:
 <pre>
 1 2 3
 8 <b>0</b> 4
 7 6 5</pre>
 <p>(the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).</p>

 <p>The implementation of <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method in this class is based on
 this method and <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachingBranch(int)"><CODE>pixelTypeOrAttachingBranch(int)</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachedNode(int)"><CODE>pixelTypeOrAttachedNode(int)</CODE></A> methods:
 the results <i>w</i>, returned by this method for unit central elements <tt><b><i>C</i></b></tt>
 of the source skeleton, are shifted to the right and passed as
 <nobr><tt>apertureBits</tt>=<i>w</i><tt>&gt;&gt;&gt;1</tt></nobr> argument to
 <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachingBranch(int)"><CODE>pixelTypeOrAttachingBranch(int)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#pixelTypeOrAttachedNode(int)"><CODE>pixelTypeOrAttachedNode(int)</CODE></A> to form the elements
 of the resulting matrix.

 <p>Note, that the situation, when the neighbouring elements are out of ranges of the matrix coordinates,
 is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>skeleton</CODE> - the skeleton matrix that should be processed.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the matrix of integer values with the same sizes, containing the bit maps
                    of the neighbourhoods of all skeleton pixels.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>skeleton</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.dimCount()!=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>SkeletonPixelClassifier.dimCount()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pixelTypeOrAttachingBranch(int)"><!-- --></A><H3>
pixelTypeOrAttachingBranch</H3>
<PRE>
protected abstract int <STRONG>pixelTypeOrAttachingBranch</STRONG>(int&nbsp;apertureBits)</PRE>
<DL>
<DD>Calculates and returns the value of an element <tt><b><i>C'</i></b></tt>
 in the resulting matrix, produced by
 <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method with
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A> value of <tt>attachmentInformation</tt> argument,
 on the base of bit values of all neighbours (in terms of the
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>)
 of the corresponding unit element <tt><b><i>C</i></b></tt> in the source skeleton bit matrix.

 <p>More precisely, the bit values of the neighbours of this skeleton element <tt><b><i>C</i></b></tt>
 are passed via the low
 <i>m</i>=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> bits of <tt>apertureBits</tt> argument.
 The bit #<i>k</i> of this argument, 0&le;<i>k</i>&lt;<i>m</i> (its value is
 <nobr>(<tt>apertureBits&gt;&gt;&gt;</tt><i>k</i><tt>)&amp;1</tt></nobr>), is equal to the value
 of the neighbour #<i>k</i> in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 In particular, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> implementation,
 the order of neighbours is described by the following diagram:
 <pre>
 0 1 2
 7 <b><i>C</i></b> 3
 6 5 4</pre>
 <p>So, 8 low bits of <tt>apertureBits</tt> contain the values of the corresponding neighbouring elements
 in anticlockwise order (the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).

 <p>It is supposed that the central element (<tt><b><i>C</i></b></tt>) of the skeleton is unit
 (for zero elements ot the skeleton matrix, <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method of
 this class returns <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>SkeletonPixelClassifier.TYPE_ZERO</CODE></A> without calling this method).

 <p>Note, that the situation, when the neighbouring elements are out of ranges of the matrix coordinates,
 is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>apertureBits</CODE> - the values of all 8 neighbours of the current unit element of the source skeleton
                     bit matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of this pixel of the skeleton.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pixelTypeOrAttachedNode(int)"><!-- --></A><H3>
pixelTypeOrAttachedNode</H3>
<PRE>
protected abstract int <STRONG>pixelTypeOrAttachedNode</STRONG>(int&nbsp;apertureBits)</PRE>
<DL>
<DD>Calculates and returns the value of an element <tt><b><i>C'</i></b></tt>
 in the resulting matrix, produced by
 <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method with
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A> value of <tt>attachmentInformation</tt> argument,
 on the base of bit values of all neighbours (in terms of the
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>straight-and-diagonal connectivity kind</CODE></A>)
 of the corresponding unit element <tt><b><i>C</i></b></tt> in the source skeleton bit matrix.

 <p>More precisely, the bit values of the neighbours of this skeleton element <tt><b><i>C</i></b></tt>
 are passed via the low
 <i>m</i>=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> bits of <tt>apertureBits</tt> argument.
 The bit #<i>k</i> of this argument, 0&le;<i>k</i>&lt;<i>m</i> (its value is
 <nobr>(<tt>apertureBits&gt;&gt;&gt;</tt><i>k</i><tt>)&amp;1</tt></nobr>), is equal to the value
 of the neighbour #<i>k</i> in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 In particular, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> implementation,
 the order of neighbours is described by the following diagram:
 <pre>
 0 1 2
 7 <b><i>C</i></b> 3
 6 5 4</pre>
 <p>So, 8 low bits of <tt>apertureBits</tt> contain the values of the corresponding neighbouring elements
 in anticlockwise order (the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).

 <p>It is supposed that the central element (<tt><b><i>C</i></b></tt>) of the skeleton is unit
 (for zero elements ot the skeleton matrix, <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method of
 this class returns <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>SkeletonPixelClassifier.TYPE_ZERO</CODE></A> without calling this method).

 <p>Note, that the situation, when the neighbouring elements are out of ranges of the matrix coordinates,
 is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>apertureBits</CODE> - the values of all 8 neighbours of the current unit element of the source skeleton
                     bit matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of this pixel of the skeleton.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="ApertureBasedSkeletonPixelClassifier.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier">NESTED</A>&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_net.algart.matrices.skeletons.SkeletonPixelClassifier">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
