<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
PackedBitBuffers
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="PackedBitBuffers";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/PackedBitBuffers.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="PackedBitBuffers.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.arrays</FONT>
<BR>
Class PackedBitBuffers</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.arrays.PackedBitBuffers</STRONG>
</PRE>
<HR>
<PRE>public class <STRONG>PackedBitBuffers</STRONG>
extends java.lang.Object</PRE>

<P>
<p>Operations with bit arrays packed into <tt>java.nio.LongBuffer</tt>.</p>

 <p>The maximal length of bit arrays supported by this class is <tt>2<sup>37</sup>-64</tt>.
 All indexes and lengths passed to methods of this class should not exceed this value.
 In other case, the results are unspecified. ("Unspecified" means that any elements
 of the passed buffers can be read or changed, or that <tt>IndexOutOfBoundsException</tt> can be thrown.)</p>

 <p>In all methods of this class, it's supposed that the bit <tt>#k</tt>
 in a packed <tt>LongBuffer b</tt> is the bit
 <tt>#(k%64)</tt> in the long element <tt>b.get(k/64)</tt>. In other words, the bit <tt>#k</tt>
 (<tt>false</tt> or <tt>true</tt> value) can be extracted by the following operator:</p

 <pre>
 (b.get(k >>> 6) & (1L << (k & 63))) != 0L
 </pre>

 <p>and can be set or cleared by the following operators:</p>

 <pre>
 if (newValue) // we need to set bit #k to 1
 &#32;   b.put(k >>> 6, b.get(k >>> 6) | 1L << (k & 63));
 else          // we need to clear bit #k to 0
 &#32;   b.put(k >>> 6, b.get(k >>> 6) & ~(1L << (k & 63)));
 </pre>

 <p>If any method of this class modifies some portion of an element of a packed <tt>LongBuffer</tt>,
 i.e. modifies less than all 64 its bits, then all accesses to this <tt>long</tt> element are performed
 <b>inside a single synchronized block</b>, using the following instruction:</p>

 <pre>
 synchronized (<A HREF="../../../net/algart/arrays/PackedBitBuffers.html#getLock(java.nio.LongBuffer)"><CODE>getLock</CODE></A>(buffer)) {
 &#32;   // accessing to some element #k via buffer.get(k) and buffer.put(k, ...)
 }
 </pre>

 <p>(See an example in comments to <A HREF="../../../net/algart/arrays/PackedBitBuffers.html#setBit(java.nio.LongBuffer, long, boolean)"><CODE>setBit(java.nio.LongBuffer, long, boolean)</CODE></A> method.)
 If all 64 bits of the element are written, or if the bits are read only, then no synchronization is performed.
 Such behavior allows to simultaneously work with non-overlapping fragments of a packed bit array
 from several threads (different fragments for different threads), as if it would be a usual Java array.
 Synchronization by <tt><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#getLock(java.nio.LongBuffer)"><CODE>getLock</CODE></A>(buffer)</tt> (instead of <tt>buffer</tt> instance) allows
 to use in different threads different instances of <tt>LongBuffer</tt>, created by <tt>LongBuffer.wrap</tt>
 method for the sampe Java <tt>long[]</tt> array.</p>

 <p>This class cannot be instantiated.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.4</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#andBits(long[], long, java.nio.LongBuffer, long, long)">andBits</A></STRONG>(long[]&nbsp;dest,
        long&nbsp;destPos,
        java.nio.LongBuffer&nbsp;src,
        long&nbsp;srcPos,
        long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#andNotBits(long[], long, java.nio.LongBuffer, long, long)">andNotBits</A></STRONG>(long[]&nbsp;dest,
           long&nbsp;destPos,
           java.nio.LongBuffer&nbsp;src,
           long&nbsp;srcPos,
           long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#cardinality(java.nio.LongBuffer, long, long)">cardinality</A></STRONG>(java.nio.LongBuffer&nbsp;src,
            long&nbsp;fromIndex,
            long&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of high bits (1) in the given fragment of the given packed bit buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#copyBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long)">copyBits</A></STRONG>(java.nio.LongBuffer&nbsp;dest,
         long&nbsp;destPos,
         java.nio.LongBuffer&nbsp;src,
         long&nbsp;srcPos,
         long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits, packed into <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>,
 to packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#copyBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long, boolean)">copyBits</A></STRONG>(java.nio.LongBuffer&nbsp;dest,
         long&nbsp;destPos,
         java.nio.LongBuffer&nbsp;src,
         long&nbsp;srcPos,
         long&nbsp;count,
         boolean&nbsp;reverseOrder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits, packed into <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>,
 to packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>,
 in normal or reverse order depending on <tt>reverseOrder</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#fillBits(java.nio.LongBuffer, long, long, boolean)">fillBits</A></STRONG>(java.nio.LongBuffer&nbsp;dest,
         long&nbsp;destPos,
         long&nbsp;count,
         boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <tt>count</tt> bits in the packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>,
 by the specified value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#getBit(java.nio.LongBuffer, long)">getBit</A></STRONG>(java.nio.LongBuffer&nbsp;src,
       long&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bit <tt>#index</tt> in the packed <tt>dest</tt> bit buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#getLock(java.nio.LongBuffer)">getLock</A></STRONG>(java.nio.LongBuffer&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>buffer.hasArray()?buffer.array():buffer</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#indexOfBit(java.nio.LongBuffer, long, long, boolean)">indexOfBit</A></STRONG>(java.nio.LongBuffer&nbsp;src,
           long&nbsp;lowIndex,
           long&nbsp;highIndex,
           boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit buffer is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#lastIndexOfBit(java.nio.LongBuffer, long, long, boolean)">lastIndexOfBit</A></STRONG>(java.nio.LongBuffer&nbsp;src,
               long&nbsp;lowIndex,
               long&nbsp;highIndex,
               boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit buffer is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#notBits(long[], long, java.nio.LongBuffer, long, long)">notBits</A></STRONG>(long[]&nbsp;dest,
        long&nbsp;destPos,
        java.nio.LongBuffer&nbsp;src,
        long&nbsp;srcPos,
        long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical NOT of corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#orBits(long[], long, java.nio.LongBuffer, long, long)">orBits</A></STRONG>(long[]&nbsp;dest,
       long&nbsp;destPos,
       java.nio.LongBuffer&nbsp;src,
       long&nbsp;srcPos,
       long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#orNotBits(long[], long, java.nio.LongBuffer, long, long)">orNotBits</A></STRONG>(long[]&nbsp;dest,
          long&nbsp;destPos,
          java.nio.LongBuffer&nbsp;src,
          long&nbsp;srcPos,
          long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#packBits(java.nio.LongBuffer, long, boolean[], int, int)">packBits</A></STRONG>(java.nio.LongBuffer&nbsp;dest,
         long&nbsp;destPos,
         boolean[]&nbsp;src,
         int&nbsp;srcPos,
         int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#setBit(java.nio.LongBuffer, long, boolean)">setBit</A></STRONG>(java.nio.LongBuffer&nbsp;dest,
       long&nbsp;index,
       boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the bit <tt>#index</tt> in the packed <tt>dest</tt> bit buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#swapBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long)">swapBits</A></STRONG>(java.nio.LongBuffer&nbsp;first,
         long&nbsp;firstPos,
         java.nio.LongBuffer&nbsp;second,
         long&nbsp;secondPos,
         long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swaps <tt>count</tt> bits, packed into <tt>first</tt> buffer,
 starting from the bit <tt>#firstPos</tt>,
 with <tt>count</tt> bits, packed into <tt>second</tt> buffer,
 starting from the bit <tt>#secondPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#unpackBits(boolean[], int, java.nio.LongBuffer, long, int)">unpackBits</A></STRONG>(boolean[]&nbsp;dest,
           int&nbsp;destPos,
           java.nio.LongBuffer&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits, packed into <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#xorBits(long[], long, java.nio.LongBuffer, long, long)">xorBits</A></STRONG>(long[]&nbsp;dest,
        long&nbsp;destPos,
        java.nio.LongBuffer&nbsp;src,
        long&nbsp;srcPos,
        long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical XOR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="getLock(java.nio.LongBuffer)"><!-- --></A><H3>
getLock</H3>
<PRE>
public static java.lang.Object <STRONG>getLock</STRONG>(java.nio.LongBuffer&nbsp;buffer)</PRE>
<DL>
<DD>Returns <tt>buffer.hasArray()?buffer.array():buffer</tt>.
 This object is used by all methods of this class for synchronization, when any portion (not all 64 bits)
 of some <tt>long</tt> element is modified.
 Synchronization by <tt>buffer.array()</tt> (instead of <tt>buffer</tt> instance) allows
 to use in different threads different instances of <tt>LongBuffer</tt>, created by <tt>LongBuffer.wrap</tt>
 method for the sampe Java <tt>long[]</tt> array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>buffer</CODE> - the buffer.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>this buffer if it is not backed by a Java array, the underlying Java array if it is backed by it.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getBit(java.nio.LongBuffer, long)"><!-- --></A><H3>
getBit</H3>
<PRE>
public static boolean <STRONG>getBit</STRONG>(java.nio.LongBuffer&nbsp;src,
                             long&nbsp;index)</PRE>
<DL>
<DD>Returns the bit <tt>#index</tt> in the packed <tt>dest</tt> bit buffer.
 Equivalent to the following expression:<pre>
 (src.get((int)(index >>> 6)) & (1L << (index & 63))) != 0L;
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source buffer (bits are packed into <tt>long</tt> values).</DD><DD><CODE>index</CODE> - index of the returned bit.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the bit at the specified index.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if this method cause access of data outside buffer limits.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>src</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="setBit(java.nio.LongBuffer, long, boolean)"><!-- --></A><H3>
setBit</H3>
<PRE>
public static void <STRONG>setBit</STRONG>(java.nio.LongBuffer&nbsp;dest,
                          long&nbsp;index,
                          boolean&nbsp;value)</PRE>
<DL>
<DD>Sets the bit <tt>#index</tt> in the packed <tt>dest</tt> bit buffer.
 Equivalent to the following operators:<pre>
 synchronized (<A HREF="../../../net/algart/arrays/PackedBitBuffers.html#getLock(java.nio.LongBuffer)"><CODE>PackedBitBuffers.getLock</CODE></A>(dest)) {
 &#32;   if (value)
 &#32;       dest.put((int)(index >>> 6), dest.get((int)(index >>> 6)) | 1L << (index & 63));
 &#32;   else
 &#32;       dest.put((int)(index >>> 6), dest.get((int)(index >>> 6)) & ~(1L << (index & 63)));
 }
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination buffer (bits are packed into <tt>long</tt> values).</DD><DD><CODE>index</CODE> - index of the written bit.</DD><DD><CODE>value</CODE> - new bit value.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if this method cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="copyBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
copyBits</H3>
<PRE>
public static void <STRONG>copyBits</STRONG>(java.nio.LongBuffer&nbsp;dest,
                            long&nbsp;destPos,
                            java.nio.LongBuffer&nbsp;src,
                            long&nbsp;srcPos,
                            long&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits, packed into <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>,
 to packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>.

 <p>This method works correctly even if <tt>src == dest</tt>
 and the copied areas overlap,
 i.e. if <tt>Math.abs(destPos - srcPos) &lt; count</tt>.
 More precisely, in this case the copying is performed as if the
 bits at positions <tt>srcPos..srcPos+count-1</tt> in <tt>src</tt>
 were first unpacked to a temporary <tt>boolean[]</tt> array with <tt>count</tt> elements
 and then the contents of the temporary array were packed into positions
 <tt>destPos..destPos+count-1</tt> of <tt>dest</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination buffer.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be copied (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside buffer limits.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="copyBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long, boolean)"><!-- --></A><H3>
copyBits</H3>
<PRE>
public static void <STRONG>copyBits</STRONG>(java.nio.LongBuffer&nbsp;dest,
                            long&nbsp;destPos,
                            java.nio.LongBuffer&nbsp;src,
                            long&nbsp;srcPos,
                            long&nbsp;count,
                            boolean&nbsp;reverseOrder)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits, packed into <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>,
 to packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>,
 in normal or reverse order depending on <tt>reverseOrder</tt> argument.

 <p>If <tt>reverseOrder</tt> flag is <tt>false</tt>, this method copies bits in normal order:
 bit <tt>#srcPos</tt> of <tt>src</tt> to bit <tt>#destPos</tt> of <tt>dest</tt>, then
 bit <tt>#srcPos+1</tt> of <tt>src</tt> to bit <tt>#destPos+1</tt> of <tt>dest</tt>, then
 bit <tt>#srcPos+2</tt> of <tt>src</tt> to bit <tt>#destPos+2</tt> of <tt>dest</tt>, ..., then
 bit <tt>#srcPos+count-1</tt> of <tt>src</tt> to bit <tt>#destPos+count-1</tt> of <tt>dest</tt>.
 If <tt>reverseOrder</tt> flag is <tt>true</tt>, this method copies bits in reverse order:
 bit <tt>#srcPos+count-1</tt> of <tt>src</tt> to bit <tt>#destPos+count-1</tt> of <tt>dest</tt>, then
 bit <tt>#srcPos+count-2</tt> of <tt>src</tt> to bit <tt>#destPos+count-2</tt> of <tt>dest</tt>, ..., then
 bit <tt>#srcPos</tt> of <tt>src</tt> to bit <tt>#destPos</tt> of <tt>dest</tt>.
 Usually, copying in reverse order is slower, but it is necessary if <tt>src</tt>
 and <tt>dest</tt> are the same buffer or views or the same data (for example,
 buffers mapped to the same file), the copied areas overlap and
 destination position is greater than source position.
 If <tt>src==dest</tt>, you may use <A HREF="../../../net/algart/arrays/PackedBitBuffers.html#copyBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long)"><CODE>copyBits(LongBuffer, long, LongBuffer, long, long)</CODE></A>
 method that chooses the suitable order automatically.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination buffer.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be copied (must be &gt;=0).</DD><DD><CODE>reverseOrder</CODE> - if <tt>true</tt>, the bits will be copied in the reverse order.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside buffer limits.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#copyBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long)"><CODE>copyBits(LongBuffer, long, LongBuffer, long, long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="swapBits(java.nio.LongBuffer, long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
swapBits</H3>
<PRE>
public static void <STRONG>swapBits</STRONG>(java.nio.LongBuffer&nbsp;first,
                            long&nbsp;firstPos,
                            java.nio.LongBuffer&nbsp;second,
                            long&nbsp;secondPos,
                            long&nbsp;count)</PRE>
<DL>
<DD>Swaps <tt>count</tt> bits, packed into <tt>first</tt> buffer,
 starting from the bit <tt>#firstPos</tt>,
 with <tt>count</tt> bits, packed into <tt>second</tt> buffer,
 starting from the bit <tt>#secondPos</tt>.

 <p>Some bits may be swapped incorrectly if the swapped areas overlap,
 i.e. if <tt>first==second</tt> and <tt>Math.abs(firstIndex - secondIndex) &lt; count</tt>,
 or if <tt>first</tt> and <tt>second</tt> are views of the same data
 (for example, buffers mapped to the same file) and the corresponding areas of this data
 overlap.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>first</CODE> - the first <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>firstPos</CODE> - starting index of bit to exchange in the first <tt>LongBuffer</tt>.</DD><DD><CODE>second</CODE> - the second <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>secondPos</CODE> - starting index of bit to exchange in the second <tt>LongBuffer</tt>.</DD><DD><CODE>count</CODE> - the number of bits to be exchanged (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside buffer limits.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBits(java.nio.LongBuffer, long, boolean[], int, int)"><!-- --></A><H3>
packBits</H3>
<PRE>
public static void <STRONG>packBits</STRONG>(java.nio.LongBuffer&nbsp;dest,
                            long&nbsp;destPos,
                            boolean[]&nbsp;src,
                            int&nbsp;srcPos,
                            int&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination buffer.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds or buffer limit.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(boolean[], int, java.nio.LongBuffer, long, int)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(boolean[]&nbsp;dest,
                              int&nbsp;destPos,
                              java.nio.LongBuffer&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits, packed into <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> array, starting from the element <tt>#destPos</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be unpacked (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds or buffer limit.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="fillBits(java.nio.LongBuffer, long, long, boolean)"><!-- --></A><H3>
fillBits</H3>
<PRE>
public static void <STRONG>fillBits</STRONG>(java.nio.LongBuffer&nbsp;dest,
                            long&nbsp;destPos,
                            long&nbsp;count,
                            boolean&nbsp;value)</PRE>
<DL>
<DD>Fills <tt>count</tt> bits in the packed <tt>dest</tt> buffer, starting from the bit <tt>#destPos</tt>,
 by the specified value. <i>Be careful:</i> the second <tt>int</tt> argument in this method
 is the number of filled element, but not the end filled index
 as in <tt>java.util.Arrays.fill</tt> methods.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination buffer.</DD><DD><CODE>count</CODE> - the number of bits to be filled (must be &gt;=0).</DD><DD><CODE>value</CODE> - new value of all filled bits (<tt>false</tt> means the bit 0, <tt>true</tt> means the bit 1).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if filling would cause access of data outside buffer limit.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="notBits(long[], long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
notBits</H3>
<PRE>
public static void <STRONG>notBits</STRONG>(long[]&nbsp;dest,
                           long&nbsp;destPos,
                           java.nio.LongBuffer&nbsp;src,
                           long&nbsp;srcPos,
                           long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical NOT of corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.
 The packed <tt>long[]</tt> Java array stores bits as described in <A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><CODE>PackedBitArrays</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="andBits(long[], long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
andBits</H3>
<PRE>
public static void <STRONG>andBits</STRONG>(long[]&nbsp;dest,
                           long&nbsp;destPos,
                           java.nio.LongBuffer&nbsp;src,
                           long&nbsp;srcPos,
                           long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.
 The packed <tt>long[]</tt> Java array stores bits as described in <A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><CODE>PackedBitArrays</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="orBits(long[], long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
orBits</H3>
<PRE>
public static void <STRONG>orBits</STRONG>(long[]&nbsp;dest,
                          long&nbsp;destPos,
                          java.nio.LongBuffer&nbsp;src,
                          long&nbsp;srcPos,
                          long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.
 The packed <tt>long[]</tt> Java array stores bits as described in <A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><CODE>PackedBitArrays</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="xorBits(long[], long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
xorBits</H3>
<PRE>
public static void <STRONG>xorBits</STRONG>(long[]&nbsp;dest,
                           long&nbsp;destPos,
                           java.nio.LongBuffer&nbsp;src,
                           long&nbsp;srcPos,
                           long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical XOR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.
 The packed <tt>long[]</tt> Java array stores bits as described in <A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><CODE>PackedBitArrays</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="andNotBits(long[], long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
andNotBits</H3>
<PRE>
public static void <STRONG>andNotBits</STRONG>(long[]&nbsp;dest,
                              long&nbsp;destPos,
                              java.nio.LongBuffer&nbsp;src,
                              long&nbsp;srcPos,
                              long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.
 The packed <tt>long[]</tt> Java array stores bits as described in <A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><CODE>PackedBitArrays</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="orNotBits(long[], long, java.nio.LongBuffer, long, long)"><!-- --></A><H3>
orNotBits</H3>
<PRE>
public static void <STRONG>orNotBits</STRONG>(long[]&nbsp;dest,
                             long&nbsp;destPos,
                             java.nio.LongBuffer&nbsp;src,
                             long&nbsp;srcPos,
                             long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> buffer, starting from the bit <tt>#srcPos</tt>.
 The packed <tt>long[]</tt> Java array stores bits as described in <A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><CODE>PackedBitArrays</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source <tt>LongBuffer</tt> (bits are packed into <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source buffer.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="indexOfBit(java.nio.LongBuffer, long, long, boolean)"><!-- --></A><H3>
indexOfBit</H3>
<PRE>
public static long <STRONG>indexOfBit</STRONG>(java.nio.LongBuffer&nbsp;src,
                              long&nbsp;lowIndex,
                              long&nbsp;highIndex,
                              boolean&nbsp;value)</PRE>
<DL>
<DD>Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit buffer is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.

 <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the searched packed bit buffer.</DD><DD><CODE>lowIndex</CODE> - the low index for search (inclusive).</DD><DD><CODE>highIndex</CODE> - the high index for search (exclusive).</DD><DD><CODE>value</CODE> - the value of bit to be found.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the index of the first occurrence of this bit in range <tt>lowIndex..highIndex-1</tt>,
                  or <tt>-1</tt> if this bit does not occur
                  or if <tt>lowIndex&gt;=highIndex</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>buffer</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>lowIndex</tt> is negative or
                                   if <tt>highIndex</tt> is greater than <tt>src.limit()*64</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/PackedBitBuffers.html#lastIndexOfBit(java.nio.LongBuffer, long, long, boolean)"><CODE>lastIndexOfBit(LongBuffer, long, long, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOfBit(java.nio.LongBuffer, long, long, boolean)"><!-- --></A><H3>
lastIndexOfBit</H3>
<PRE>
public static long <STRONG>lastIndexOfBit</STRONG>(java.nio.LongBuffer&nbsp;src,
                                  long&nbsp;lowIndex,
                                  long&nbsp;highIndex,
                                  boolean&nbsp;value)</PRE>
<DL>
<DD>Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit buffer is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.

 <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.

 <p>Note that <tt>lowIndex</tt> and <tt>highIndex</tt> arguments have the same sense as in
 <A HREF="../../../net/algart/arrays/PackedBitBuffers.html#indexOfBit(java.nio.LongBuffer, long, long, boolean)"><CODE>indexOfBit(LongBuffer, long, long, boolean)</CODE></A> method:
 they describes the search index range <tt>lowIndex&lt;=k&lt;highIndex</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the searched packed bit buffer.</DD><DD><CODE>lowIndex</CODE> - the low index in the array for search (inclusive);
                  pass <tt>0</tt> to search all remaining elements.</DD><DD><CODE>highIndex</CODE> - the high index in the array for search (exclusive).</DD><DD><CODE>value</CODE> - the value of bit to be found.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the index of the last occurrence of this bit in range <tt>lowIndex..highIndex-1</tt>,
                  or <tt>-1</tt> if this bit does not occur
                  or if <tt>lowIndex&gt;=highIndex</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>src</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>lowIndex</tt> is negative or
                                   if <tt>highIndex</tt> is greater than <tt>src.length*64</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="cardinality(java.nio.LongBuffer, long, long)"><!-- --></A><H3>
cardinality</H3>
<PRE>
public static long <STRONG>cardinality</STRONG>(java.nio.LongBuffer&nbsp;src,
                               long&nbsp;fromIndex,
                               long&nbsp;toIndex)</PRE>
<DL>
<DD>Returns the number of high bits (1) in the given fragment of the given packed bit buffer.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source packed bit buffer.</DD><DD><CODE>fromIndex</CODE> - the initial checked bit index in <tt>src</tt>, inclusive.</DD><DD><CODE>toIndex</CODE> - the end checked bit index in <tt>src</tt>, exclusive.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of high bits (1) in the given fragment of the given packed bit buffer.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <tt>src</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>fromIndex</tt> or <tt>toIndex</tt> are negative,
          if <tt>toIndex</tt> is greater than <tt>src.limit() * 64</tt>,
          or if <tt>fromIndex</tt> is greater than <tt>startIndex</tt></DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/PackedBitArrays.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/PackedBitBuffers.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="PackedBitBuffers.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
