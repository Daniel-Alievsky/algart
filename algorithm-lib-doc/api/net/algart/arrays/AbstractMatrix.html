<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractMatrix
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractMatrix";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/AbstractLongArray.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/AbstractMemoryModel.html" title="class in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/AbstractMatrix.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractMatrix.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.arrays</FONT>
<BR>
Class AbstractMatrix&lt;T extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.arrays.AbstractMatrix&lt;T&gt;</STRONG>
</PRE>
<DL>
<DT><STRONG>All Implemented Interfaces:</STRONG></DT> <DD>java.lang.Cloneable, <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;T&gt;</DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>AbstractMatrix&lt;T extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</STRONG>
extends java.lang.Object
implements <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;T&gt;</PRE>

<P>
<p>A skeletal implementation of the <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays"><CODE>Matrix</CODE></A> interface to minimize
 the effort required to implement this interface.</p>

 <p>All non-abstract methods are completely implemented here and may be not overridden in subclasses.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Nested Class Summary table, listing nested classes, and an explanation">
<CAPTION CLASS="TableCaption">
Nested Class Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Interface and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_net.algart.arrays.Matrix"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Nested classes/interfaces inherited from interface net.algart.arrays.<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.arrays.Matrix"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from interface net.algart.arrays.<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#MAX_DIM_COUNT_FOR_SOME_ALGORITHMS">MAX_DIM_COUNT_FOR_SOME_ALGORITHMS</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Constructor Summary table, listing constructors, and an explanation">
<CAPTION CLASS="TableCaption">
Constructor Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Constructor and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#AbstractMatrix()">AbstractMatrix</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#array()">array</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the built-in AlgART array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#cast(java.lang.Class)">cast</A></STRONG>(java.lang.Class&lt;U&gt;&nbsp;arrayClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this matrix, cast to the specified generic array type,
 or throws <tt>ClassCastException</tt> if the built-in AlgART array
 cannot be cast to the required type (because the array type is not its subclass).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#coordinates(long, long[])">coordinates</A></STRONG>(long&nbsp;index,
            long[]&nbsp;result)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coordinates in the matrix, corresponding to the given linear index in the built-in AlgART array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#cyclicIndex(long...)">cyclicIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dim(int)">dim</A></STRONG>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the dimension <tt>#n</tt> of this matrix
 or <tt>1</tt> if <tt>n&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of dimensions of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimensions()">dimensions</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing all dimensions of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimEquals(long...)">dimEquals</A></STRONG>(long...&nbsp;dimensions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether the passed dimensions are equal to the dimension array of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimEquals(net.algart.arrays.Matrix)">dimEquals</A></STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether the other matrix has the same dimension array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimX()">dimX</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(0)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimY()">dimY</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(1)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#dimZ()">dimZ</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(2)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#elementType()">elementType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of matrix elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#equals(java.lang.Object)">equals</A></STRONG>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether some other matrix is equal to this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#flushResources(net.algart.arrays.ArrayContext)">flushResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(context)</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#freeResources()">freeResources</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(null)</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#freeResources(net.algart.arrays.ArrayContext)">freeResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(context)</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#hashCode()">hashCode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash code of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#index(long...)">index</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the linear index in the built-in AlgART array of the matrix element
 with specified coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#index(long, long)">index</A></STRONG>(long&nbsp;x,
      long&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 2-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#index(long, long, long)">index</A></STRONG>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 3-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#inside(long...)">inside</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if all specified coordinates <tt><i>i<sub>k</sub></i></tt>
 are inside the ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>,
 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#inside(long, long)">inside</A></STRONG>(long&nbsp;x,
       long&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 2-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#inside(long, long, long)">inside</A></STRONG>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 3-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#isCopyOnNextWrite()">isCopyOnNextWrite</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#isDirectAccessible()">isDirectAccessible</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if the built-in AlgART array implements <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>
 interface and <tt>((<A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>)<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>).<A HREF="../../../net/algart/arrays/DirectAccessible.html#hasJavaArray()"><CODE>hasJavaArray()</CODE></A></tt> method returns <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#isImmutable()">isImmutable</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#isStructuredLike(net.algart.arrays.Matrix)">isStructuredLike</A></STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the elements of this matrix is ordered "alike" the elements
 of the specified matrix <tt>m</tt>, in terms of <A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>Matrix.structureLike(Matrix)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#isSubMatrix()">isSubMatrix</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of
 some <tt>parent</tt> matrix, created by one of calls <tt>parent.subMatrix(...)</tt>,
 <tt>parent.subMatr(...)</tt> or equivalent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#isTiled()">isTiled</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not ready yet!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#matrix(U)">matrix</A></STRONG>(U&nbsp;anotherArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the new matrix backed by the specified AlgART array with the same dimensions as this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#mirrorCyclicIndex(long...)">mirrorCyclicIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions
 or with complement of these remainders on the dimensions,
 as if the matrix would be reflected in each its bound as in a mirror.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#pseudoCyclicIndex(long...)">pseudoCyclicIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges,
 but replaces the resulting index with the positive remainder
 from division of it by the length of the built-in array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#size()">size</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total number of matrix elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#structureLike(net.algart.arrays.Matrix)">structureLike</A></STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view ot this matrix, where the elements are reordered in some order "like"
 in the specified matrix <tt>m</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatr(long[], long[])">subMatr</A></STRONG>(long[]&nbsp;position,
        long[]&nbsp;dimensions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></STRONG>(long[]&nbsp;position,
        long[]&nbsp;dimensions,
        <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatr(long, long, long, long)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;dimX,
        long&nbsp;dimY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatr(long, long, long, long, long, long)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;z,
        long&nbsp;dimX,
        long&nbsp;dimY,
        long&nbsp;dimZ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatr(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;z,
        long&nbsp;dimX,
        long&nbsp;dimY,
        long&nbsp;dimZ,
        <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatr(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;dimX,
        long&nbsp;dimY,
        <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(net.algart.math.IRectangularArea)">subMatrix</A></STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(net.algart.math.IRectangularArea, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(long[], long[])">subMatrix</A></STRONG>(long[]&nbsp;from,
          long[]&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view of the rectangular fragment of this matrix between <tt>from</tt>,
 inclusive, and <tt>to</tt>, exclusive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(long[]&nbsp;from,
          long[]&nbsp;to,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended analog of <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> method, allowing to get a rectangular fragment
 which is not fully inside this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(long, long, long, long)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;toX,
          long&nbsp;toY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(long, long, long, long, long, long)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;fromZ,
          long&nbsp;toX,
          long&nbsp;toY,
          long&nbsp;toZ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;fromZ,
          long&nbsp;toX,
          long&nbsp;toY,
          long&nbsp;toZ,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrix(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;toX,
          long&nbsp;toY,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrixContinuationMode()">subMatrixContinuationMode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>submatrix</CODE></A>
 of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><CODE>continuation mode</CODE></A>, used by this submatrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrixFrom()">subMatrixFrom</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the starting position of this submatrix
 in the parent one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrixParent()">subMatrixParent</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns a reference to the <tt>parent</tt> matrix instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#subMatrixTo()">subMatrixTo</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the ending position (exclusive) of this submatrix
 in the parent one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#tile()">tile</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a tiled view ot this matrix with some default dimensions of the tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#tile(long...)">tile</A></STRONG>(long...&nbsp;tileDim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view ot this matrix, where the elements are reordered by <i>tiles</i>: a grid of rectangular
 regions (<i>tiles</i>), the sizes of which are specified by <tt>tileDim</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#tileDimensions()">tileDimensions</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not ready yet!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#tileParent()">tileParent</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not ready yet!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#toString()">toString</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a brief string description of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#type()">type</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
java.lang.Class&lt;? extends U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#type(java.lang.Class)">type</A></STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#uncheckedIndex(long...)">uncheckedIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#updatableType()">updatableType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
java.lang.Class&lt;? extends U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/AbstractMatrix.html#updatableType(java.lang.Class)">updatableType</A></STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Constructor Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractMatrix()"><!-- --></A><H3>
AbstractMatrix</H3>
<PRE>
public <STRONG>AbstractMatrix</STRONG>()</PRE>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="array()"><!-- --></A><H3>
array</H3>
<PRE>
public abstract <A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> <STRONG>array</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#array()">Matrix</A></CODE></STRONG></DD>
<DD>Returns a reference to the built-in AlgART array.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#array()">array</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the built-in AlgART array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="elementType()"><!-- --></A><H3>
elementType</H3>
<PRE>
public java.lang.Class&lt;?&gt; <STRONG>elementType</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#elementType()">Matrix</A></CODE></STRONG></DD>
<DD>Returns the type of matrix elements.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#elementType()">elementType</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of the matrix elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public long <STRONG>size</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#size()">Matrix</A></CODE></STRONG></DD>
<DD>Returns the total number of matrix elements.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#size()">size</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the total number of matrix elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="type()"><!-- --></A><H3>
type</H3>
<PRE>
public java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <STRONG>type</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#type()">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#type()">type</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical type of AlgART array of the same kind as the built-in one.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="updatableType()"><!-- --></A><H3>
updatableType</H3>
<PRE>
public java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>&gt; <STRONG>updatableType</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#updatableType()">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#updatableType()">updatableType</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical updatable type of AlgART array of the same kind as the built-in one.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="type(java.lang.Class)"><!-- --></A><H3>
type</H3>
<PRE>
public &lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; java.lang.Class&lt;? extends U&gt; <STRONG>type</STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#type(java.lang.Class)">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.
 (If the passed argument is a class of <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> or some its
 subinterfaces or subclasses, <tt>IllegalArgumentException</tt> is thrown instead:
 updatable array classes cannot be specified in this method.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#type(java.lang.Class)">type</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arraySupertype</CODE> - the required supertype of the built-in AlgART array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical type of AlgART array of the same kind as the built-in one.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="updatableType(java.lang.Class)"><!-- --></A><H3>
updatableType</H3>
<PRE>
public &lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; java.lang.Class&lt;? extends U&gt; <STRONG>updatableType</STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#updatableType(java.lang.Class)">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#updatableType(java.lang.Class)">updatableType</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arraySupertype</CODE> - the required supertype of the built-in AlgART array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical updatable type of AlgART array of the same kind as the built-in one.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimensions()"><!-- --></A><H3>
dimensions</H3>
<PRE>
public abstract long[] <STRONG>dimensions</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimensions()">Matrix</A></CODE></STRONG></DD>
<DD>Returns an array containing all dimensions of this matrix.
 Returned array is equal to the <tt>dim</tt> argument passed to methods that create new matrix instances.

 <p>The returned array is a clone of the internal dimension array, stored in this object.
 The returned array is never empty (its length cannot be zero).
 The elements of the returned array are never negative.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimensions()">dimensions</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an array containing all dimensions of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
public abstract int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()">Matrix</A></CODE></STRONG></DD>
<DD>Returns the number of dimensions of this matrix.
 This value is always positive (&gt;=1).
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>Matrix.dimensions()</CODE></A>.length</tt>, but works faster.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()">dimCount</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of dimensions of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dim(int)"><!-- --></A><H3>
dim</H3>
<PRE>
public abstract long <STRONG>dim</STRONG>(int&nbsp;n)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)">Matrix</A></CODE></STRONG></DD>
<DD>Returns the dimension <tt>#n</tt> of this matrix
 or <tt>1</tt> if <tt>n&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A></tt>.
 Equivalent to <tt>n&lt;<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>?<A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>Matrix.dimensions()</CODE></A>[n]:1</tt>, but works faster.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)">dim</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>n</CODE> - the index of dimension.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the dimension <tt>#n</tt> of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimX()"><!-- --></A><H3>
dimX</H3>
<PRE>
public long <STRONG>dimX</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimX()">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(0)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimX()">dimX</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the first matrix dimension.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimY()"><!-- --></A><H3>
dimY</H3>
<PRE>
public long <STRONG>dimY</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimY()">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(1)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimY()">dimY</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the second matrix dimension.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimZ()"><!-- --></A><H3>
dimZ</H3>
<PRE>
public long <STRONG>dimZ</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimZ()">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(2)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimZ()">dimZ</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the third matrix dimension.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimEquals(net.algart.arrays.Matrix)"><!-- --></A><H3>
dimEquals</H3>
<PRE>
public boolean <STRONG>dimEquals</STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(net.algart.arrays.Matrix)">Matrix</A></CODE></STRONG></DD>
<DD>Indicates whether the other matrix has the same dimension array.
 In other words, returns <tt>true</tt> if and only if
 both matrices have the same dimension count (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>)
 and the corresponding dimensions (<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>) are equal.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(net.algart.arrays.Matrix)">dimEquals</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>m</CODE> - the matrix to be compared for equal dimensions with this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified matrix has the same dimension array.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(long...)"><CODE>Matrix.dimEquals(long...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimEquals(long...)"><!-- --></A><H3>
dimEquals</H3>
<PRE>
public boolean <STRONG>dimEquals</STRONG>(long...&nbsp;dimensions)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(long...)">Matrix</A></CODE></STRONG></DD>
<DD>Indicates whether the passed dimensions are equal to the dimension array of this matrix.
 In other words, returns <tt>true</tt> if and only if
 <tt>dimension.length==<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A></tt>
 and the corresponding dimensions <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>==dimension[k]</tt> for all <tt>k</tt>.

 <p>Note: this method does not check, whether all passed dimensions are correct (in particular, non-negative).
 If some elements of the passed array are incorrect, this method just returns <tt>false</tt>.
 But it the passed array is <tt>null</tt>, this method throws <tt>NullPointerException</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(long...)">dimEquals</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dimensions</CODE> - the dimension array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified dimensions are equal to the dimensions of this matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(net.algart.arrays.Matrix)"><CODE>Matrix.dimEquals(Matrix)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="index(long...)"><!-- --></A><H3>
index</H3>
<PRE>
public long <STRONG>index</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#index(long...)">Matrix</A></CODE></STRONG></DD>
<DD>Returns the linear index in the built-in AlgART array of the matrix element
 with specified coordinates.

 <p>More precisely,
 <tt>index(<i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i>)</tt>
 returns the following value:

 <blockquote>
 <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.
 All passed indexes <tt><i>i<sub>k</sub></i></tt> must be in ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>.

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 But the extra elements of <tt>coordinates</tt> array must be zero,
 because <tt><i>d<sub>k</sub></i>=1</tt> for <tt><i>k</i>&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A></tt>.

 <p>Good algorithms processing the matrix should use this method rarely:
 usually there are more optimal ways to calculate necessary linear index.
 For example, if you just need to calculate something for all matrix elements,
 the best way is the following:

 <pre>
 Array a = m.array();
 for (long disp = 0, n = a.length(); disp < n; disp++)
 &#32;   // process the element #k of the array
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#index(long...)">index</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the linear index of the matrix element with specified coordinates.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#uncheckedIndex(long...)"><CODE>Matrix.uncheckedIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)"><CODE>Matrix.cyclicIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)"><CODE>Matrix.pseudoCyclicIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#mirrorCyclicIndex(long...)"><CODE>Matrix.mirrorCyclicIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])"><CODE>Matrix.coordinates(long, long[])</CODE></A>, 
<A HREF="../../../net/algart/math/IPoint.html#toOneDimensional(long[], boolean)"><CODE>IPoint.toOneDimensional(long[], boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="index(long, long)"><!-- --></A><H3>
index</H3>
<PRE>
public long <STRONG>index</STRONG>(long&nbsp;x,
                  long&nbsp;y)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#index(long, long)">Matrix</A></CODE></STRONG></DD>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 2-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#index(long, long)">index</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>y * <A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>Matrix.dimX()</CODE></A> + x</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="index(long, long, long)"><!-- --></A><H3>
index</H3>
<PRE>
public long <STRONG>index</STRONG>(long&nbsp;x,
                  long&nbsp;y,
                  long&nbsp;z)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#index(long, long, long)">Matrix</A></CODE></STRONG></DD>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 3-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#index(long, long, long)">index</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD><DD><CODE>z</CODE> - the third coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>z * <A HREF="../../../net/algart/arrays/Matrix.html#dimY()"><CODE>Matrix.dimY()</CODE></A> * <A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>Matrix.dimX()</CODE></A> + y * <A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>Matrix.dimX()</CODE></A> + x</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordinates(long, long[])"><!-- --></A><H3>
coordinates</H3>
<PRE>
public long[] <STRONG>coordinates</STRONG>(long&nbsp;index,
                          long[]&nbsp;result)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])">Matrix</A></CODE></STRONG></DD>
<DD>Returns the coordinates in the matrix, corresponding to the given linear index in the built-in AlgART array.
 This method is reverse to <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A>: for any index,
 <nobr><tt><A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>(<A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])"><CODE>coordinates</CODE></A>(index, null)) == index</tt></nobr>.

 <p>The <tt>result</tt> argument may be <tt>null</tt> or some array, containing at least <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>
 elements. If the first case, this method allocates new Java array <tt>long[<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>]</tt>
 for storing coordinates and returns it.
 In the second case, this method stores the found coordinates in <tt>result</tt> array and returns it.
 The returned coordinates are always in ranges
 <pre>
 0 &le; result[<i>k</i>] &lt; <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])">coordinates</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>index</CODE> - the linear index in the built-in AlgART array.</DD><DD><CODE>result</CODE> - the array where you want to store results; may be <tt>null</tt>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the <tt>result</tt> argument, if it is not <tt>null</tt>,
               else newly created Java array contains all calculated coordinates.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="uncheckedIndex(long...)"><!-- --></A><H3>
uncheckedIndex</H3>
<PRE>
public long <STRONG>uncheckedIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#uncheckedIndex(long...)">Matrix</A></CODE></STRONG></DD>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges.

 <p>More precisely,
 <tt>uncheckedIndex(<i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i>)</tt>
 always returns the following value:

 <blockquote>
 <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.

 <p>All calculations are performed with <tt>long</tt> type without any overflow checks.
 All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 Please remember that <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)=1</tt>
 for <tt><i>k</i>&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>
 (extra elements of <tt>coordinates</tt> array).</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#uncheckedIndex(long...)">uncheckedIndex</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the linear index of the matrix element with specified coordinates, without range checks.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="cyclicIndex(long...)"><!-- --></A><H3>
cyclicIndex</H3>
<PRE>
public long <STRONG>cyclicIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)">Matrix</A></CODE></STRONG></DD>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions.

 <p>More precisely, let <tt><i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i></tt>
 are the arguments of the method. Let
 <nobr><tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr> and
 <blockquote>
 <i>i'<sub>k</sub></i> = <i>d<sub>k</sub></i> == 0 ? 0 :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> &gt;= 0 ?
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> + <i>d<sub>k</sub></i>
 </blockquote>

 This method returns the following value:

 <blockquote>
 <i>i'<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i'<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i'<sub>1</sub>d<sub>0</sub></i> + <i>i'<sub>0</sub></i>,
 </blockquote>

 In other words, the resulting index is "cyclical".

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 (You can note that extra elements of <tt>coordinates</tt> array are ignored in fact:
 the reminders <i>i<sub>k</sub></i>%<i>d<sub>k</sub></i>=<i>i<sub>k</sub></i>%1 will be zero for them.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)">cyclicIndex</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the cyclical linear index of the matrix element with specified coordinates,
                    without range checks.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#CYCLIC"><CODE>Matrix.ContinuationMode.CYCLIC</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="pseudoCyclicIndex(long...)"><!-- --></A><H3>
pseudoCyclicIndex</H3>
<PRE>
public long <STRONG>pseudoCyclicIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)">Matrix</A></CODE></STRONG></DD>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges,
 but replaces the resulting index with the positive remainder
 from division of it by the length of the built-in array.

 <p>More precisely, let <tt><i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i></tt>
 are the arguments of the method, and <tt><i>index</i></tt> is the following value
 (as in <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method):

 <blockquote>
 <tt><i>index</i></tt> = <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.
 Here we <i>do no require</i> that the passed indexes <tt><i>i<sub>k</sub></i></tt>
 are in ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>.
 Then, let <tt><i>len</i>=<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>=d<sub>n-1</sub>...d<sub>1</sub>d<sub>0</sub></i></tt>.
 The result of this method is the following:

 <blockquote>
 <tt><i>len</i> == 0 ? 0 : <i>index</i> % <i>len</i> &gt;= 0 ?
 <i>index</i> % <i>len</i> : <i>index</i> % <i>len</i> + <i>len</i></tt>
 </blockquote>

 (It is in the <tt>0..<i>len</i>-1</tt> range always, excepting the generated case <tt><i>len</i>==0</tt>.)
 In other words, the resulting index is "pseudo-cyclical", as the resulting shift
 in <A HREF="../../../net/algart/arrays/Matrices.html#asShifted(net.algart.arrays.Matrix, long...)"><CODE>Matrices.asShifted(Matrix, long...)</CODE></A> method.

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 (You can note that extra elements of <tt>coordinates</tt> array are ignored in fact:
 they add <tt>k*<i>len</i></tt> summand, where <tt>k</tt> is an integer.)

 <p>Note that all calculations are performed absolutely precisely, even in a case when
 the direct calculation according the formulas above leads to overflow (because some
 of values in these formulas are out of <tt>Long.MIN_VALUE..Long.MAX_VALUE</tt> range).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)">pseudoCyclicIndex</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the pseudo-cyclical linear index of the matrix element with specified coordinates,
                    without range checks.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/math/IPoint.html#toOneDimensional(long[], boolean)"><CODE>IPoint.toOneDimensional(long[], boolean)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#PSEUDO_CYCLIC"><CODE>Matrix.ContinuationMode.PSEUDO_CYCLIC</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="mirrorCyclicIndex(long...)"><!-- --></A><H3>
mirrorCyclicIndex</H3>
<PRE>
public long <STRONG>mirrorCyclicIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#mirrorCyclicIndex(long...)">Matrix</A></CODE></STRONG></DD>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>Matrix.index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions
 or with complement of these remainders on the dimensions,
 as if the matrix would be reflected in each its bound as in a mirror.

 <p>More precisely, let <tt><i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i></tt>
 are the arguments of the method. Let
 <nobr><tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr>,
 <blockquote>
 <i>i'<sub>k</sub></i> = <i>d<sub>k</sub></i> == 0 ? 0 :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> &gt;= 0 ?
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> + <i>d<sub>k</sub></i>
 </blockquote>
 (as in <A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)"><CODE>Matrix.cyclicIndex(long...)</CODE></A> and
 <blockquote>
 <i>i''<sub>k</sub></i> = <i>d<sub>k</sub></i> == 0 ? 0 :
 &lfloor;<i>i<sub>k</sub></i> / <i>d<sub>k</sub></i>&rfloor; % 2 == 0 ?
 <i>i'<sub>k</sub></i> :
 <i>d<sub>k</sub></i> &minus; 1 &minus; <i>i'<sub>k</sub></i>
 </blockquote>
 (here &lfloor;<i>x</i>&rfloor; means the integer part of <i>x</i>, i.e. <tt>Math.floor(<i>x</i>)</tt>).

 <p>This method returns the following value:

 <blockquote>
 <i>i''<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i''<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i''<sub>1</sub>d<sub>0</sub></i> + <i>i''<sub>0</sub></i>,
 </blockquote>

 <p>In other words, the resulting index is "mirroring-cyclical".

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 (You can note that extra elements of <tt>coordinates</tt> array are ignored in fact:
 the reminders <i>i<sub>k</sub></i>%<i>d<sub>k</sub></i>=<i>i<sub>k</sub></i>%1 will be zero for them.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#mirrorCyclicIndex(long...)">mirrorCyclicIndex</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the mirror-cyclical linear index of the matrix element with specified coordinates,
                    without range checks.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#MIRROR_CYCLIC"><CODE>Matrix.ContinuationMode.MIRROR_CYCLIC</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="inside(long...)"><!-- --></A><H3>
inside</H3>
<PRE>
public boolean <STRONG>inside</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if all specified coordinates <tt><i>i<sub>k</sub></i></tt>
 are inside the ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>,
 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.

 <p>This method allows simply check that the arguments of
 the <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method are correct and will not lead to
 <tt>IndexOutOfBoundsException</tt>:
 <pre>
 if (matrix.inside(i1, i2, ...)) {
 &#32;   long index = matrix.index(i1, i2, ...);
 &#32;   // processing an element at this index
 } else {
 &#32;   // special branch for positions outside the matrix
 }
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)">inside</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if all specified coordinates are inside the matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="inside(long, long)"><!-- --></A><H3>
inside</H3>
<PRE>
public boolean <STRONG>inside</STRONG>(long&nbsp;x,
                      long&nbsp;y)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#inside(long, long)">Matrix</A></CODE></STRONG></DD>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 2-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#inside(long, long)">inside</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>tt>true</tt> if all specified coordinates are inside the matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="inside(long, long, long)"><!-- --></A><H3>
inside</H3>
<PRE>
public boolean <STRONG>inside</STRONG>(long&nbsp;x,
                      long&nbsp;y,
                      long&nbsp;z)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#inside(long, long, long)">Matrix</A></CODE></STRONG></DD>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 3-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#inside(long, long, long)">inside</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD><DD><CODE>z</CODE> - the third coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>tt>true</tt> if all specified coordinates are inside the matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="matrix(net.algart.arrays.Array)"><!-- --></A><A NAME="matrix(U)"><!-- --></A><H3>
matrix</H3>
<PRE>
public abstract &lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt; <STRONG>matrix</STRONG>(U&nbsp;anotherArray)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#matrix(U)">Matrix</A></CODE></STRONG></DD>
<DD>Returns the new matrix backed by the specified AlgART array with the same dimensions as this one.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrices.html#matrix(T, long...)"><CODE>Matrices.matrix</CODE></A>(anotherArray, <A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>Matrix.dimensions()</CODE></A>)</tt>.

 <p>The array <tt>anotherArray</tt> must be <A HREF="../../../net/algart/arrays/Array.html#isUnresizable()"><CODE>unresizable</CODE></A>,
 and its length must be equal to the length of the array built-in this matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#matrix(U)">matrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>anotherArray</CODE> - some another AlgART array with the same length as <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new matrix instance.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="cast(java.lang.Class)"><!-- --></A><H3>
cast</H3>
<PRE>
public &lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt; <STRONG>cast</STRONG>(java.lang.Class&lt;U&gt;&nbsp;arrayClass)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#cast(java.lang.Class)">Matrix</A></CODE></STRONG></DD>
<DD>Returns this matrix, cast to the specified generic array type,
 or throws <tt>ClassCastException</tt> if the built-in AlgART array
 cannot be cast to the required type (because the array type is not its subclass).
 Works alike <tt><A HREF="../../../net/algart/arrays/Matrix.html#matrix(U)"><CODE>matrix</CODE></A>((U)array)</tt>, but returns
 the reference to this instance and is compiled without "unchecked cast" warning.

 <p>This method is useful when you need to cast the type of AlgART array,
 built in this matrix, to to its sub- or superinterface.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#cast(java.lang.Class)">cast</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arrayClass</CODE> - the type of built-in array in the new matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new matrix with the same dimensions, based on the same array cast to the required type.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long[], long[])"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long[]&nbsp;from,
                           long[]&nbsp;to)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])">Matrix</A></CODE></STRONG></DD>
<DD>Returns a view of the rectangular fragment of this matrix between <tt>from</tt>,
 inclusive, and <tt>to</tt>, exclusive.

 <p>More precisely, the returned matrix consists of all elements of this one with coordinates
 <i>i<sub>0</sub></i>, <i>i<sub>1</sub></i>, ..., <i>i<sub>n&minus;1</sub></i>,
 <i>n</i><tt>=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A></tt>,
 matching the following conditions:<pre>
     from[0] &lt;= <i>i<sub>0</sub></i> &lt; to[0],
     from[1] &lt;= <i>i<sub>1</sub></i> &lt; to[1],
     . . .
     from[<i>n</i>-1] &lt;= <i>i<sub>n-1</sub></i> &lt; to[<i>n</i>-1]
 </pre>

 So, every dimension <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A> in the returned matrix will be equal to <tt>to[k]-from[k]</tt>.
 The following condition must be fulfilled for all <tt>k</tt>:
 <tt>0&lt;=from[k]&lt;=to[k]&lt;=thisMatrix.<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A></tt>.
 The <A HREF="../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A> of the returned matrix is identical to the element type
 of this matrix.

 <p>This method is equivalent to the call
 <nobr><tt><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(from,to,<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A>)</tt></nobr>.

 <p>The built-in AlgART array of the returned matrix is backed by the built-in array of this matrix,
 so &mdash; if this matrix is not <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A>
 &mdash; any changes of the elements of the returned matrix are reflected in this matrix, and vice-versa.
 The returned matrix is <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A> if, and only if,
 the built-in array of this matrix does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>.
 The <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>Array.asTrustedImmutable()</CODE></A> method
 in the built-in array of the returned matrix is equivalent to <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>Array.asImmutable()</CODE></A>,
 and <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>Array.asCopyOnNextWrite()</CODE></A> method just returns the full copy of the array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>from</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>to</CODE> - high endpoints (exclusive) of all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea)"><CODE>Matrix.subMatrix(IRectangularArea)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatr(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>Matrix.subMatr(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>Matrix.isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(net.algart.math.IRectangularArea)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>area</CODE> - rectangular area within this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                           long&nbsp;fromY,
                           long&nbsp;toX,
                           long&nbsp;toY)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY})</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long, long, long)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                           long&nbsp;fromY,
                           long&nbsp;fromZ,
                           long&nbsp;toX,
                           long&nbsp;toY,
                           long&nbsp;toZ)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, long, long)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ})</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, long, long)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>fromZ</CODE> - low endpoints (inclusive) of the third coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD><DD><CODE>toZ</CODE> - high endpoints (exclusive) of the third coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long[]&nbsp;from,
                           long[]&nbsp;to,
                           <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>An extended analog of <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> method, allowing to get a rectangular fragment
 which is not fully inside this matrix.

 <p>More precisely, unlike <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A>, here
 the only requirement for the <tt>from</tt> and <tt>to</tt> coordinate boundaries is <tt>from[k]&lt;=to[k]</tt>,
 but <tt>from[k]</tt> may be negative and <tt>to[k]</tt> may be greater than <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>.
 (And there is also a trivial obvious requirement
 <nobr><tt>to[k]-from[k]&le;Long.MAX_VALUE</tt></nobr>, i.e. that the dimensions of the result must
 be representable by <tt>long</tt> type.)

 <p>The elements of the returned matrix, that do not correspond to any elements of this one,
 i.e. "lie outside" of the source matrix, are considered to be equal to some values, according to
 some <i>continuation model</i>, described by <tt>continuationMode</tt> argument.
 Such "outside" elements can correspond (according some rules) to actual elements of the source elements &mdash;
 then attempts to read them return the values of the corresponding source elements
 and attempts to write into them modify the corresponding source elements
 (it is so for <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#CYCLIC"><CODE>Matrix.ContinuationMode.CYCLIC</CODE></A>, <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#PSEUDO_CYCLIC"><CODE>Matrix.ContinuationMode.PSEUDO_CYCLIC</CODE></A>,
 <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#MIRROR_CYCLIC"><CODE>Matrix.ContinuationMode.MIRROR_CYCLIC</CODE></A> modes),
 &mdash; or can be calculated "virtually" (according some rules) &mdash;
 then attempts to read them return the calculated values
 and attempts to modify them are ignored
 (it is so for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation</CODE></A> mode).
 See <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><CODE>Matrix.ContinuationMode</CODE></A> class for more details.

 <p>Important note: there are two cases, when requirements to the <tt>from</tt> and <tt>to</tt>
 coordinate boundaries are more strong, than described above.
 <ol>
     <li>If <tt>continuationMode==<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A></tt>, this method is strictly
     equivalent to more simple <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> method,
     so all requirements are the same as for that method.</li>
     <li>If <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#CYCLIC"><CODE>Matrix.ContinuationMode.CYCLIC</CODE></A>,
     <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#PSEUDO_CYCLIC"><CODE>Matrix.ContinuationMode.PSEUDO_CYCLIC</CODE></A> or <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#MIRROR_CYCLIC"><CODE>Matrix.ContinuationMode.MIRROR_CYCLIC</CODE></A>
     (but it is not a constant continuation mode) and some dimension <tt>#k</tt>
     of this matrix is zero &mdash; <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(k)==0</tt> &mdash;
     then both corresponding coordinate boundaries <tt>from[k]</tt> and <tt>to[k]</tt>
     must be zero (as in <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> method).</li>
 </ol>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>from</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>to</CODE> - high endpoints (exclusive) of all coordinates.</DD><DD><CODE>continuationMode</CODE> - the mode of continuation outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatr(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>Matrix.subMatr(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>Matrix.isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(net.algart.math.IRectangularArea, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area,
                           <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea, net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>area</CODE> - rectangular area within this matrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                           long&nbsp;fromY,
                           long&nbsp;toX,
                           long&nbsp;toY,
                           <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY}, continuationMode)</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                           long&nbsp;fromY,
                           long&nbsp;fromZ,
                           long&nbsp;toX,
                           long&nbsp;toY,
                           long&nbsp;toZ,
                           <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ}, continuationMode)</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>fromZ</CODE> - low endpoints (inclusive) of the third coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD><DD><CODE>toZ</CODE> - high endpoints (exclusive) of the third coordinate.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long[], long[])"><!-- --></A><H3>
subMatr</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatr</STRONG>(long[]&nbsp;position,
                         long[]&nbsp;dimensions)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])">subMatr</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>position</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>dimensions</CODE> - dimensions of the returned submatrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatr(long[], long[], ContinuationMode)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long)"><!-- --></A><H3>
subMatr</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;dimX,
                         long&nbsp;dimY)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY})</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long)">subMatr</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long, long, long)"><!-- --></A><H3>
subMatr</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;dimX,
                         long&nbsp;dimY,
                         long&nbsp;dimZ)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, long, long)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ})</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, long, long)">subMatr</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>z</CODE> - low endpoint (inclusive) of the third coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD><DD><CODE>dimZ</CODE> - the third dimension of the returned submatrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatr</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatr</STRONG>(long[]&nbsp;position,
                         long[]&nbsp;dimensions,
                         <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>position</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>dimensions</CODE> - dimensions of the returned submatrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>Matrix.subMatr(long[], long[])</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatr</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;dimX,
                         long&nbsp;dimY,
                         <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY}, continuationMode)</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatr</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                         long&nbsp;y,
                         long&nbsp;z,
                         long&nbsp;dimX,
                         long&nbsp;dimY,
                         long&nbsp;dimZ,
                         <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ}, continuationMode)</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>z</CODE> - low endpoint (inclusive) of the third coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD><DD><CODE>dimZ</CODE> - the third dimension of the returned submatrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSubMatrix()"><!-- --></A><H3>
isSubMatrix</H3>
<PRE>
public boolean <STRONG>isSubMatrix</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if and only if this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of
 some <tt>parent</tt> matrix, created by one of calls <tt>parent.subMatrix(...)</tt>,
 <tt>parent.subMatr(...)</tt> or equivalent.
 The <A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()"><CODE>Matrix.subMatrixParent()</CODE></A> method throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>
 if and only if this method returns <tt>false</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()">isSubMatrix</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this object is created by <tt>subMatrix(...)</tt>, <tt>subMatr(...)</tt> or equivalent call.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>Matrix.subMatr(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatr(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()"><CODE>Matrix.subMatrixParent()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixParent()"><!-- --></A><H3>
subMatrixParent</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>subMatrixParent</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()">Matrix</A></CODE></STRONG></DD>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns a reference to the <tt>parent</tt> matrix instance.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()">subMatrixParent</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the parent matrix, if this instance is a submatrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>Matrix.isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixFrom()"><!-- --></A><H3>
subMatrixFrom</H3>
<PRE>
public long[] <STRONG>subMatrixFrom</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixFrom()">Matrix</A></CODE></STRONG></DD>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the starting position of this submatrix
 in the parent one. The result will be equal to "<tt>from</tt>" argument of
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> and <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], ContinuationMode)</CODE></A> methods.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixFrom()">subMatrixFrom</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>low endpoints (inclusive) of all coordinates of this submatrix in its parent matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>Matrix.isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixTo()"><!-- --></A><H3>
subMatrixTo</H3>
<PRE>
public long[] <STRONG>subMatrixTo</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixTo()">Matrix</A></CODE></STRONG></DD>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the ending position (exclusive) of this submatrix
 in the parent one. The result will be equal to "<tt>to</tt>" argument of
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> and <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], ContinuationMode)</CODE></A> methods.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixTo()">subMatrixTo</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>low endpoints (inclusive) of all coordinates of this submatrix in its parent matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>Matrix.isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixContinuationMode()"><!-- --></A><H3>
subMatrixContinuationMode</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A> <STRONG>subMatrixContinuationMode</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixContinuationMode()">Matrix</A></CODE></STRONG></DD>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>submatrix</CODE></A>
 of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><CODE>continuation mode</CODE></A>, used by this submatrix.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.

 <p>If the submatrix was created by
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)</CODE></A> or equivalent method,
 the <tt>continuationMode</tt> argument, passed to that method, is returned.
 If the submatrix was created by
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>Matrix.subMatrix(long[], long[])</CODE></A> or equivalent method,
 <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A> constant is returned.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixContinuationMode()">subMatrixContinuationMode</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>low endpoints (inclusive) of all coordinates of this submatrix in its parent matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>Matrix.isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="structureLike(net.algart.arrays.Matrix)"><!-- --></A><H3>
structureLike</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>structureLike</STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)">Matrix</A></CODE></STRONG></DD>
<DD>Returns a view ot this matrix, where the elements are reordered in some order "like"
 in the specified matrix <tt>m</tt>.
 In other words, the elements of the <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in array</CODE></A> of the returned matrix are
 the same as the elements of the <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in array</CODE></A> of this one
 (any changes of the elements of the returned matrix are reflected in this matrix, and vice-versa),
 but the order of the elements can differ. The precise algorithm of reordering is not specified
 and depends of the matrix <tt>m</tt>: this method tries to help algorithms, processing the same
 or similar areas in both matrices, to provide maximal performance.

 <p>This method returns non-trivial results only if the matrix <tt>m</tt> is already a view of some other
 matrix with some form of reordering elements, for example, if <tt>m</tt> is a <A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>tiled</CODE></A> matrix.
 In other case, this method just returns this instance.

 <p>In the current version of this package (if this instance was created by means of methods of this package),
 this method is equivalent to the following:

 <pre>
 m.<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>Matrix.isTiled()</CODE></A> ?
 &#32;   thisInstance.<A HREF="../../../net/algart/arrays/Matrix.html#tile()"><CODE>tile</CODE></A>(m.<A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()"><CODE>Matrix.tileDimensions()</CODE></A>) :
 &#32;   thisInstance;
 </pre>

 <p>In future versions, it is possible that this method will recognize other forms of reordering matrix elements
 and return non-trivial results for such <tt>m</tt> matrices.

 <p>Because the precise order of elements of the returning matrix is not specified, we recommend to use
 this method generally for newly created matrices, for example:

 <pre>
 memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newMatrix(java.lang.Class, net.algart.arrays.Matrix)"><CODE>newMatrix</CODE></A>(<A HREF="../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays"><CODE>UpdatablePArray</CODE></A>.class, m).<A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>structureLike</CODE></A>(m);
 </pre>
 or, more briefly,
 <pre>
 memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newStructuredMatrix(java.lang.Class, net.algart.arrays.Matrix)"><CODE>newStructuredMatrix</CODE></A>(<A HREF="../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays"><CODE>UpdatablePArray</CODE></A>.class, m);
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)">structureLike</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>m</CODE> - some matrix, probably a view of another matrix with reordered elements
          (for example, <A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tiled</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of this matrix with elements reordered in similar order, or a reference to this instance
          if <tt>m</tt> matrix is not reodered or this method does not "know" about the way of that reordering.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isStructuredLike(net.algart.arrays.Matrix)"><CODE>Matrix.isStructuredLike(Matrix)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isStructuredLike(net.algart.arrays.Matrix)"><!-- --></A><H3>
isStructuredLike</H3>
<PRE>
public boolean <STRONG>isStructuredLike</STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#isStructuredLike(net.algart.arrays.Matrix)">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if the elements of this matrix is ordered "alike" the elements
 of the specified matrix <tt>m</tt>, in terms of <A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>Matrix.structureLike(Matrix)</CODE></A> method.
 "Ordered alike" does not mean that the dimensions of both matrices are equal, or that
 the details of the structure are the same; it means only that both matrices use similar
 reordering algorithms.

 <p>More precisely, <A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>Matrix.structureLike(Matrix)</CODE></A> method returns this instance if and only if
 this method returns <tt>true</tt>.

 <p>In the current version of this package (if this instance was created by means of methods of this package),
 this method is equivalent to: <tt>thisInstance.<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>Matrix.isTiled()</CODE></A>==m.<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>Matrix.isTiled()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#isStructuredLike(net.algart.arrays.Matrix)">isStructuredLike</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>m</CODE> - some matrix, probably a view of another matrix with reordered elements
          (for example, <A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tiled</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this matrix is reordered alike <tt>m</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="tile(long...)"><!-- --></A><H3>
tile</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>tile</STRONG>(long...&nbsp;tileDim)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)">Matrix</A></CODE></STRONG></DD>
<DD>Returns a view ot this matrix, where the elements are reordered by <i>tiles</i>: a grid of rectangular
 regions (<i>tiles</i>), the sizes of which are specified by <tt>tileDim</tt> argument.
 It means that the elements of the built-in AlgART array of the returned matrix are the elements
 of the built-in array of this one, but "shuffled" so that all elements of every tile in the returned matrix
 are located in a continuous block of the built-in array of this matrix.
 The returned matrix is named <i>tiled matrix</i>. The <A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>dimensions</CODE></A>
 of the returned matrix are the same as the dimensions of this one.
 The <A HREF="../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A> of the returned matrix is identical to the element type
 of this matrix.

 <p>More precisely, let this matrix be <b>M</b> and the tiled matrix, returned by this method, be <b>T</b>.
 Let <i>i<sub>0</sub></i>, <i>i<sub>1</sub></i>, ..., <i>i<sub>n&minus;1</sub></i>
 (<i>n</i><tt>=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A></tt>) be coordinates of some element it the tiled matrix <b>T</b>,
 that is located in <b>T</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt>
 at the index <i>i</i>=<b>T</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A></tt>(<i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n&minus;1</sub></i>).
 This element is located in the original array <b>M</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt> at another index
 <i>j</i>, which is calculated by the following algorithm.

 <ol>
 <li>Let <i>d<sub>k</sub></i> = <b>M</b>.<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>),
 <i>k</i>=0,1,...,<i>n</i>&minus;1: dimensions of this and returned matrix.</li>

 <li>Let <i>i'<sub>k</sub></i> = <i>i<sub>k</sub></i>%<tt>tileDim[<i>k</i>]</tt>,
 <i>k</i>=0,1,...,<i>n</i>&minus;1: <i>i'<sub>k</sub></i> are the coordinates of this element inside
 the tile, containing it in <b>T</b> matrix.</li>

 <li>Let <i>s<sub>k</sub></i> = <i>i<sub>k</sub></i>&minus;<i>i'<sub>k</sub></i>,
 <i>k</i>=0,1,...,<i>n</i>&minus;1: <i>s<sub>k</sub></i> are the coordinates of the starting element
 of the tile, containing this element in <b>T</b> matrix.</li>

 <li>Let <i>t<sub>k</sub></i> = <tt>min</tt>(<tt>tileDim[</tt><i>k</i><tt>]</tt>,
 <i>d<sub>k</sub></i>&minus;<i>s<sub>k</sub></i>),
 <i>k</i>=0,1,...,<i>n</i>&minus;1: <i>t<sub>k</sub></i> are the dimensions
 of the tile, containing this element in <b>T</b> matrix. (Note that boundary tiles can be less
 than <tt>tileDim</tt>, if dimensions of matrix are not divisible by corresponding dimensions of tiles.)</li>

 <li>Let <tt>previousVolume</tt> =
 <i>d</i><sub>0</sub><i>d</i><sub>1</sub>...<i>d</i><sub><i>n</i>&minus;3</sub><i
 class="dummy">d</i><sub><i>n</i>&minus;2</sub><i>s</i><sub><i>n</i>&minus;1</sub>
 + <i>d</i><sub>0</sub><i>d</i><sub>1</sub>...<i>d</i><sub><i>n</i>&minus;3</sub><i
 class="dummy">c</i><sub><i>n</i>&minus;2</sub><i>t</i><sub><i>n</i>&minus;1</sub>
 + ... + <i>s</i><sub>0</sub><i>t</i><sub>1</sub>...<i
 class="dummy">t</i><sub><i>n</i>&minus;2</sub><i>t</i><sub><i>n</i>&minus;1</sub>.
 This complex formula returns the summary sizes of all tiles, that are fully located
 in the source <b>T</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt> before the given element.
 In 2-dimensional case, the formula is more simple:
 <tt>previousVolume</tt> = <i>d</i><sub><i>x</i></sub><i>s</i><sub><i>y</i></sub>
 + <i>s</i><sub><i>x</i></sub><i>t</i><sub><i>y</i></sub>.
 </li>

 <li>Let <tt>indexInTile</tt> =
 <i>i'</i><sub>0</sub> + <i>i'</i><sub>1</sub><i>t</i><sub>0</sub> + ...
 + <i>i'</i><sub><i>n</i>&minus;1</sub><i>t</i><sub><i>n</i>&minus;2</sub>...<i>t</i><sub>0</sub>:
 it is the index of the element with coordinates
 <nobr><i>i'<sub>0</sub></i>,<i>i'<sub>1</sub></i>,...,<i>i'<sub>n&minus;1</sub></i></nobr>
 in the built-in array of a little matrix, dimensions of which are equal to the tile dimensions.
 </li>

 <li>The required index of the given element in the original array <b>M</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt>
 is <nobr><i>j</i> = <tt>previousVolume</tt> + <tt>indexInTile</tt></nobr>.</li>
 </ol>

 <p>Tiled matrices are necessary to provide good performance of many algorithms, if this matrix is very large
 (much greater than amount of RAM) and is located on disk or other external devices.
 For example, extracting a rectangular area 1000x1000 from a byte matrix 1000000x1000000 (1&nbsp;terabyte)
 will probably work much faster if it is tiled, than if it is a usual matrix, where every line
 occupies 1 MB of continuous disk space.

 <p>In the degenerated case of 1-dimensional matrix (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>=1)
 the tiled matrix is absolutely useless, though still works correctly.

 <p>Recommended tile dimensions are from several hundreds to several thousands, but it depends
 on the number of dimensions. If tile dimensions are degrees of two (2<sup><i>k</i></sup>),
 the tiled matrix will probably work faster.

 <p>The built-in AlgART array of the returned matrix is backed by the built-in array of this matrix,
 so &mdash; if this matrix is not <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A>
 &mdash; any changes of the elements of the returned matrix are reflected in this matrix, and vice-versa.
 The returned matrix is <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A> if, and only if,
 the built-in array of this matrix does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>.
 The <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>Array.asTrustedImmutable()</CODE></A> method
 in the built-in array of the returned matrix is equivalent to <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>Array.asImmutable()</CODE></A>,
 and <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>Array.asCopyOnNextWrite()</CODE></A> method just returns the full copy of the array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)">tile</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>tileDim</CODE> - dimensions of the tiles in the returned matrix (excepting the boundary tiles,
                which can be less).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a tiled view of this matrix.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#tile()"><CODE>Matrix.tile()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>Matrix.isTiled()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()"><CODE>Matrix.tileDimensions()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="tile()"><!-- --></A><H3>
tile</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>tile</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#tile()">Matrix</A></CODE></STRONG></DD>
<DD>Returns a tiled view ot this matrix with some default dimensions of the tiles.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tile</CODE></A>(tileDim)</tt>, where all elements of <tt>tileDim</tt>
 are equal to the default integer value, retrieved from the system property
 "<tt>net.algart.arrays.matrixTile2D</tt>",
 "<tt>net.algart.arrays.matrixTile3D</tt>"
 "<tt>net.algart.arrays.matrixTile4D</tt>"
 "<tt>net.algart.arrays.matrixTile5D</tt>" or
 "<tt>net.algart.arrays.matrixTileND</tt>",
 if the <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>number of dimensions</CODE></A> of this matrix is correspondingly 2, 3, 4, 5 or greater.
 If there is no such property, or if it contains not a number,
 or if some exception occurred while calling <tt>Long.getLong</tt>,
 this method uses the following tile dimensions:
 4096x4096 in 2-dimensional case,
 256x256x256 in 3-dimensional case,
 64x64x64x64 in 4-dimensional case,
 32x32x32x32x32 in 5-dimensional case,
 16x16x... if the number of dimensions is greater than 5.
 If the corresponding property exists and contains a valid integer number,
 but it is too small, in particular, zero or negative, then it is replaced with some minimal positive value.
 The values of all these system property is loaded and checked only once
 while initializing <A HREF="../../../net/algart/arrays/Arrays.html" title="class in net.algart.arrays"><CODE>Arrays</CODE></A> class.
 If the number of dimensions is 1 (degenerated case), this method always uses 65536 as the tile size.
 (<i>Warning</i>! These defaults can be changed in future versions!)
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#tile()">tile</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a tiled view of this matrix with default tile dimensions.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>Matrix.tile(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>Matrix.isTiled()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()"><CODE>Matrix.tileDimensions()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="tileParent()"><!-- --></A><H3>
tileParent</H3>
<PRE>
public <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A>&gt; <STRONG>tileParent</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#tileParent()">Matrix</A></CODE></STRONG></DD>
<DD>Not ready yet!
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#tileParent()">tileParent</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>original non-tiled matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="tileDimensions()"><!-- --></A><H3>
tileDimensions</H3>
<PRE>
public long[] <STRONG>tileDimensions</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()">Matrix</A></CODE></STRONG></DD>
<DD>Not ready yet!
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()">tileDimensions</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>dimensions of the tile in this matrix, if it is tiled.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isTiled()"><!-- --></A><H3>
isTiled</H3>
<PRE>
public boolean <STRONG>isTiled</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#isTiled()">Matrix</A></CODE></STRONG></DD>
<DD>Not ready yet!
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#isTiled()">isTiled</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if and only if this matrix is tiled.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isImmutable()"><!-- --></A><H3>
isImmutable</H3>
<PRE>
public boolean <STRONG>isImmutable</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A></tt>.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()">isImmutable</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this instance is immutable.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isCopyOnNextWrite()"><!-- --></A><H3>
isCopyOnNextWrite</H3>
<PRE>
public boolean <STRONG>isCopyOnNextWrite</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#isCopyOnNextWrite()">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A></tt>.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#isCopyOnNextWrite()">isCopyOnNextWrite</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this instance is copy-on-next-write.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isDirectAccessible()"><!-- --></A><H3>
isDirectAccessible</H3>
<PRE>
public boolean <STRONG>isDirectAccessible</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#isDirectAccessible()">Matrix</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if and only if the built-in AlgART array implements <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>
 interface and <tt>((<A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>)<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>).<A HREF="../../../net/algart/arrays/DirectAccessible.html#hasJavaArray()"><CODE>hasJavaArray()</CODE></A></tt> method returns <tt>true</tt>.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#isDirectAccessible()">isDirectAccessible</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this matrix can be viewed as a Java array or a part of Java array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="flushResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
flushResources</H3>
<PRE>
public void <STRONG>flushResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#flushResources(net.algart.arrays.ArrayContext)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(context)</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#flushResources(net.algart.arrays.ArrayContext)">flushResources</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="freeResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
freeResources</H3>
<PRE>
public void <STRONG>freeResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#freeResources(net.algart.arrays.ArrayContext)">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(context)</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#freeResources(net.algart.arrays.ArrayContext)">freeResources</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="freeResources()"><!-- --></A><H3>
freeResources</H3>
<PRE>
public void <STRONG>freeResources</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#freeResources()">Matrix</A></CODE></STRONG></DD>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(null)</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#freeResources()">freeResources</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <STRONG>toString</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#toString()">Matrix</A></CODE></STRONG></DD>
<DD>Returns a brief string description of this object.

 <p>The result of this method may depend on implementation and usually contains
 a short description of the built-in AlgART array and all matrix dimensions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#toString()">toString</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a brief string description of this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <STRONG>hashCode</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#hashCode()">Matrix</A></CODE></STRONG></DD>
<DD>Returns the hash code of this matrix. The result depends on all elements of the built-in array
 (as <A HREF="../../../net/algart/arrays/Array.html#hashCode()"><CODE>Array.hashCode()</CODE></A> and all matrix dimensions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#hashCode()">hashCode</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the hash code of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <STRONG>equals</STRONG>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../net/algart/arrays/Matrix.html#equals(java.lang.Object)">Matrix</A></CODE></STRONG></DD>
<DD>Indicates whether some other matrix is equal to this one.
 Returns <tt>true</tt> if and only if:<ol>
 <li>the specified object is a matrix (i.e. implements <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays"><CODE>Matrix</CODE></A>),</li>
 <li>both matrices have the same dimension count (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>Matrix.dimCount()</CODE></A>)
 and the same corresponding dimensions;</li>
 <li>the built-in AlgART arrays (<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>Matrix.array()</CODE></A>) are equal (see <A HREF="../../../net/algart/arrays/Array.html#equals(java.lang.Object)"><CODE>Array.equals(Object)</CODE></A>).</li>
 </ol>
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../net/algart/arrays/Matrix.html#equals(java.lang.Object)">equals</A></CODE> in interface <CODE><A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="type parameter in AbstractMatrix">T</A> extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></DD>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>obj</CODE> - the object to be compared for equality with this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified object is a matrix equal to this one.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/AbstractLongArray.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/AbstractMemoryModel.html" title="class in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/AbstractMatrix.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractMatrix.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
