<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Matrix
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Matrix";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/Matrices.Simplex.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/Matrix.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Matrix.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.arrays</FONT>
<BR>
Interface Matrix&lt;T extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</H2>
<DL>
<DT><STRONG>All Superinterfaces:</STRONG></DT> <DD>java.lang.Cloneable</DD>
</DL>
<DL>
<DT><STRONG>All Known Implementing Classes:</STRONG></DT> <DD><A HREF="../../../net/algart/arrays/AbstractMatrix.html" title="class in net.algart.arrays">AbstractMatrix</A></DD>
</DL>
<HR>
<PRE>public interface <STRONG>Matrix&lt;T extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</STRONG>
extends java.lang.Cloneable</PRE>

<P>
<p>AlgART matrix: multidimensional array.</p>

 <p>Unlike <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays"><CODE>AlgART array</CODE></A>, AlgART matrix is a very simple thing.
 The matrix is just <i>a pair</i>:</p>

 <ol>
 <li>a reference to any AlgART array, so-called <i>built-in array</i> of the matrix,
 that actually stores all matrix elements;</li>

 <li>the <i>set of dimensions</i>: a little usual array of integers &mdash; <tt>long[] dim</tt>,
 describing the sizes of the multidimensional matrix in every dimension.</li>
 </ol>

 <p>The product of all dimensions must be equal to the array length. Moreover,
 the array must be <A HREF="../../../net/algart/arrays/UpdatableArray.html#asUnresizable()"><CODE>unresizable</CODE></A>: so, the array length
 cannot be changed after creating the matrix.</p>

 <p>It is supposed that all matrix elements are stored in the built-in AlgART array.
 The storing scheme is traditional. For 2D matrix, the matrix element <tt>(x,y)</tt>
 is stored at the position <tt>y*dim[0]+x</tt> of the array (<tt>dim[0]</tt> is the first
 matrix dimension: the "width"). For 3D matrix, the matrix element <tt>(x,y,z)</tt>
 is stored at the position <tt>z*dim[1]*dim[0]+y*dim[0]+x</tt> (<tt>dim[0]</tt> is the
 x-dimension, dim[1] is the y-dimension). In the common case, the element of <tt>n</tt>-dimensional matrix
 with coordinates <i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i> is stored
 in the built-in array at the position</p>

 <blockquote>
 <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 <p>where <i>d<sub>k</sub></i><tt>=dim[<i>k</i>]</tt> (<tt><i>k</i>=0,1,...,<i>n</i>-1</tt>)
 is the dimension <tt>#<i>k</i></tt>.</p>

 <p>There are 3 basic ways to create a new matrix.</p>

 <ol>
 <li>You may create a new zero-filled matrix with new allocated array by
 <A HREF="../../../net/algart/arrays/MemoryModel.html#newMatrix(java.lang.Class, java.lang.Class, long...)"><CODE>MemoryModel.newMatrix(Class, Class, long...)</CODE></A>
 method or one of more concrete methods <A HREF="../../../net/algart/arrays/MemoryModel.html#newByteMatrix(long...)"><CODE>MemoryModel.newByteMatrix(long...)</CODE></A>,
 <A HREF="../../../net/algart/arrays/MemoryModel.html#newShortMatrix(long...)"><CODE>MemoryModel.newShortMatrix(long...)</CODE></A>, etc.</li>

 <li>You may create a matrix view of an existing array with the specified dimension set
 by <A HREF="../../../net/algart/arrays/Matrices.html#matrix(T, long...)"><CODE>Matrices.matrix(Array, long...)</CODE></A> method.</li>

 <li>You may replace built-in array of the matrix with a new one (with the same length)
 by <A HREF="../../../net/algart/arrays/Matrix.html#matrix(U)"><CODE>matrix(Array)</CODE></A> method of the matrix instance;
 the new matrix instance will be created.
 It is the basic way to change some properties of the built-in array,
 for example, to convert it to <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable</CODE></A>
 or <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A> form.</li>
 </ol>

 <p>We do not provide special tools for accessing matrix elements by several indexes,
 as "getByte(x,y)" or similar methods. But there is the <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>
 method, that transforms a set of multidimensional indexes
 <i>i<sub>0</sub></i>, <i>i<sub>2</sub></i>, ..., <i>i<sub>n-1</sub></i>
 into the position in the corresponded array, as described above.
 Also you can get a reference to the built-in array by the <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A> method.
 The typical example of access to matrix elements is the following:</p>

 <pre>
 Matrix&lt;UpdatableFloatArray&gt; m = ...;
 m.array().setFloat(m.index(x, y, z), myValue);
 </pre>

 <p>There are two important notes concerning usage of matrices.</p>

 <p>First, the matrix indexes in all methods (<A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>,
 <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(n)</CODE></A>, <tt>dim</tt> argument in <A HREF="../../../net/algart/arrays/MemoryModel.html#newMatrix(java.lang.Class, java.lang.Class, long...)"><CODE>MemoryModel.newMatrix</CODE></A>, etc.) are ordered from the <i>lowest</i> index to the <i>highest</i>.
 Please compare: for numeric matrix <tt>m</tt>, <nobr><tt>m.array().getDouble(m.index(15,10))</tt></nobr>
 returns the element <tt>#15</tt> of the row <tt>#10</tt>. However, for usual <nobr>2-dimensional</nobr> Java array,
 declared as "<nobr><tt>double[][] a</tt></nobr>", the same element is accessed as
 <nobr><tt>a[10][15]</tt></nobr>!</p>

 <p>Second, the number of indexes in the <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method
 may <i>differ</i> from the number of dimensions (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>).
 In any case, the returned position in calculated by the formula listed above
 (<nobr><i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i></nobr>),
 where <i>i<sub>0</sub></i>, <i>i<sub>2</sub></i>, ..., <i>i<sub>n-1</sub></i>
 are the coordinates passed to the method, and <i>d<sub>k</sub></i> is the dimension <tt>#<i>k</i></tt>
 or 1 if <tt><i>k</i>&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</p>
 In other words, it is supposed that all dimensions "after" the actual number of dimensions
 are always equal to 1. For example, the one-dimensional matrix with <tt>L</tt> elements
 can be interpreted as <nobr>2-dimensional</nobr> <tt>Lx1</tt> matrix, or 3-dimensional <tt>Lx1x1</tt> one, etc.</p>

 <p>The matrix object is <b>immutable</b>, that means that there are no ways to change
 any dimension or the reference to the built-in AlgART array.
 But the matrix elements can be modified, if the AlgART array is not
 <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable</CODE></A>.
 So, the matrix object is <b>thread-safe</b> or <b>thread-compatible</b>
 in the same situations as the built-in AlgART array: see comments to <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays"><CODE>Array</CODE></A> interface.</p>

 <p>The generic argument <tt>T</tt> specifies the type of the built-in AlgART array.
 Any array type can be declared here, but the contract of this interface
 requires that the array must be <A HREF="../../../net/algart/arrays/UpdatableArray.html#asUnresizable()"><CODE>unresizable</CODE></A>.
 So, there are no ways to create a matrix with <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A> (or its subinterface)
 as the type argument, alike <tt>Matrix&lt;MutableByteArray&gt;</tt>:
 all creation methods throw <tt>IllegalArgumentException</tt> in this case.

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays"><CODE>Array</CODE></A>, 
<A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>, 
<A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A></DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Nested Class Summary table, listing nested classes, and an explanation">
<CAPTION CLASS="TableCaption">
Nested Class Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Interface and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continuation mode for submatrices, created by
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[], long[], ContinuationMode continuationMode)</CODE></A>,
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr(long[], long[], ContinuationMode continuationMode)</CODE></A> and similar methods.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#MAX_DIM_COUNT_FOR_SOME_ALGORITHMS">MAX_DIM_COUNT_FOR_SOME_ALGORITHMS</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximal number of dimensions for some complex algorithms or service classes: 9.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#array()">array</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the built-in AlgART array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#cast(java.lang.Class)">cast</A></STRONG>(java.lang.Class&lt;U&gt;&nbsp;arrayClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this matrix, cast to the specified generic array type,
 or throws <tt>ClassCastException</tt> if the built-in AlgART array
 cannot be cast to the required type (because the array type is not its subclass).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])">coordinates</A></STRONG>(long&nbsp;index,
            long[]&nbsp;result)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coordinates in the matrix, corresponding to the given linear index in the built-in AlgART array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)">cyclicIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)">dim</A></STRONG>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the dimension <tt>#n</tt> of this matrix
 or <tt>1</tt> if <tt>n&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of dimensions of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimensions()">dimensions</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing all dimensions of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(long...)">dimEquals</A></STRONG>(long...&nbsp;dimensions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether the passed dimensions are equal to the dimension array of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(net.algart.arrays.Matrix)">dimEquals</A></STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether the other matrix has the same dimension array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimX()">dimX</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(0)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimY()">dimY</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(1)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#dimZ()">dimZ</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(2)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#elementType()">elementType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of matrix elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#equals(java.lang.Object)">equals</A></STRONG>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether some other matrix is equal to this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#flushResources(net.algart.arrays.ArrayContext)">flushResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(context)</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#freeResources()">freeResources</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(null)</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#freeResources(net.algart.arrays.ArrayContext)">freeResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(context)</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#hashCode()">hashCode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash code of this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#index(long...)">index</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the linear index in the built-in AlgART array of the matrix element
 with specified coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#index(long, long)">index</A></STRONG>(long&nbsp;x,
      long&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 2-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#index(long, long, long)">index</A></STRONG>(long&nbsp;x,
      long&nbsp;y,
      long&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 3-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)">inside</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if all specified coordinates <tt><i>i<sub>k</sub></i></tt>
 are inside the ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>,
 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#inside(long, long)">inside</A></STRONG>(long&nbsp;x,
       long&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 2-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#inside(long, long, long)">inside</A></STRONG>(long&nbsp;x,
       long&nbsp;y,
       long&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 3-dimensional matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#isCopyOnNextWrite()">isCopyOnNextWrite</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#isDirectAccessible()">isDirectAccessible</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if the built-in AlgART array implements <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>
 interface and <tt>((<A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>)<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>).<A HREF="../../../net/algart/arrays/DirectAccessible.html#hasJavaArray()"><CODE>hasJavaArray()</CODE></A></tt> method returns <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()">isImmutable</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#isStructuredLike(net.algart.arrays.Matrix)">isStructuredLike</A></STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the elements of this matrix is ordered "alike" the elements
 of the specified matrix <tt>m</tt>, in terms of <A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>structureLike(Matrix)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()">isSubMatrix</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of
 some <tt>parent</tt> matrix, created by one of calls <tt>parent.subMatrix(...)</tt>,
 <tt>parent.subMatr(...)</tt> or equivalent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#isTiled()">isTiled</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not ready yet!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#matrix(U)">matrix</A></STRONG>(U&nbsp;anotherArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the new matrix backed by the specified AlgART array with the same dimensions as this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#mirrorCyclicIndex(long...)">mirrorCyclicIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions
 or with complement of these remainders on the dimensions,
 as if the matrix would be reflected in each its bound as in a mirror.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)">pseudoCyclicIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges,
 but replaces the resulting index with the positive remainder
 from division of it by the length of the built-in array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#size()">size</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total number of matrix elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)">structureLike</A></STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view ot this matrix, where the elements are reordered in some order "like"
 in the specified matrix <tt>m</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])">subMatr</A></STRONG>(long[]&nbsp;position,
        long[]&nbsp;dimensions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></STRONG>(long[]&nbsp;position,
        long[]&nbsp;dimensions,
        <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;dimX,
        long&nbsp;dimY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, long, long)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;z,
        long&nbsp;dimX,
        long&nbsp;dimY,
        long&nbsp;dimZ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;z,
        long&nbsp;dimX,
        long&nbsp;dimY,
        long&nbsp;dimZ,
        <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatr</A></STRONG>(long&nbsp;x,
        long&nbsp;y,
        long&nbsp;dimX,
        long&nbsp;dimY,
        <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea)">subMatrix</A></STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])">subMatrix</A></STRONG>(long[]&nbsp;from,
          long[]&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view of the rectangular fragment of this matrix between <tt>from</tt>,
 inclusive, and <tt>to</tt>, exclusive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(long[]&nbsp;from,
          long[]&nbsp;to,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An extended analog of <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> method, allowing to get a rectangular fragment
 which is not fully inside this matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;toX,
          long&nbsp;toY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, long, long)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;fromZ,
          long&nbsp;toX,
          long&nbsp;toY,
          long&nbsp;toZ)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ})</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;fromZ,
          long&nbsp;toX,
          long&nbsp;toY,
          long&nbsp;toZ,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)">subMatrix</A></STRONG>(long&nbsp;fromX,
          long&nbsp;fromY,
          long&nbsp;toX,
          long&nbsp;toY,
          <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY}, continuationMode)</nobr></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixContinuationMode()">subMatrixContinuationMode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>submatrix</CODE></A>
 of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><CODE>continuation mode</CODE></A>, used by this submatrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixFrom()">subMatrixFrom</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the starting position of this submatrix
 in the parent one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()">subMatrixParent</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns a reference to the <tt>parent</tt> matrix instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#subMatrixTo()">subMatrixTo</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the ending position (exclusive) of this submatrix
 in the parent one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#tile()">tile</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a tiled view ot this matrix with some default dimensions of the tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)">tile</A></STRONG>(long...&nbsp;tileDim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view ot this matrix, where the elements are reordered by <i>tiles</i>: a grid of rectangular
 regions (<i>tiles</i>), the sizes of which are specified by <tt>tileDim</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()">tileDimensions</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not ready yet!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#tileParent()">tileParent</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not ready yet!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#toString()">toString</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a brief string description of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#type()">type</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
java.lang.Class&lt;? extends U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#type(java.lang.Class)">type</A></STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#uncheckedIndex(long...)">uncheckedIndex</A></STRONG>(long...&nbsp;coordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#updatableType()">updatableType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; 
<BR>
java.lang.Class&lt;? extends U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Matrix.html#updatableType(java.lang.Class)">updatableType</A></STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Field Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="MAX_DIM_COUNT_FOR_SOME_ALGORITHMS"><!-- --></A><H3>
MAX_DIM_COUNT_FOR_SOME_ALGORITHMS</H3>
<PRE>
static final int <STRONG>MAX_DIM_COUNT_FOR_SOME_ALGORITHMS</STRONG></PRE>
<DL>
<DD>Maximal number of dimensions for some complex algorithms or service classes: 9.
 Most modules process matrices with any number of dimensions, but there are some cases
 when an algorithm can work only with 2-dimensional, 3-dimensional or <i>n</i>-dimensional matrices with
 <i>n</i><tt>&lt;=<A HREF="../../../net/algart/arrays/Matrix.html#MAX_DIM_COUNT_FOR_SOME_ALGORITHMS"><CODE>MAX_DIM_COUNT_FOR_SOME_ALGORITHMS</CODE></A></tt>.
 In this package and all known subpackages of <tt>net.algart</tt> package,
 the following classes require that the number of dimensions must not be greater
 than <A HREF="../../../net/algart/arrays/Matrix.html#MAX_DIM_COUNT_FOR_SOME_ALGORITHMS"><CODE>MAX_DIM_COUNT_FOR_SOME_ALGORITHMS</CODE></A>:
 <ul>
 <li><tt>net.algart.matrices.scanning.ConnectedObjectScanner</tt>;</li>
 <li><A HREF="../../../net/algart/arrays/MatrixInfo.html" title="class in net.algart.arrays"><CODE>MatrixInfo</CODE></A>.</li>
 </ul>

 <p>Note: the value of this constant (9) is the maximal <i>n</i> so that
 3<sup><i>n</i></sup>&lt;32768=2<sup>15</sup> (3<sup>9</sup>=19683).
 It can be useful while storing indexes of elements of little 3x3x3x... submatrix (aperture):
 signed <tt>short</tt> type is enough in this case.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../constant-values.html#net.algart.arrays.Matrix.MAX_DIM_COUNT_FOR_SOME_ALGORITHMS">Constant Field Values</A></DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="array()"><!-- --></A><H3>
array</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A> <STRONG>array</STRONG>()</PRE>
<DL>
<DD>Returns a reference to the built-in AlgART array.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the built-in AlgART array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="elementType()"><!-- --></A><H3>
elementType</H3>
<PRE>
java.lang.Class&lt;?&gt; <STRONG>elementType</STRONG>()</PRE>
<DL>
<DD>Returns the type of matrix elements.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of the matrix elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
long <STRONG>size</STRONG>()</PRE>
<DL>
<DD>Returns the total number of matrix elements.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the total number of matrix elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="type()"><!-- --></A><H3>
type</H3>
<PRE>
java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <STRONG>type</STRONG>()</PRE>
<DL>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical type of AlgART array of the same kind as the built-in one.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed argument is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="updatableType()"><!-- --></A><H3>
updatableType</H3>
<PRE>
java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>&gt; <STRONG>updatableType</STRONG>()</PRE>
<DL>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical updatable type of AlgART array of the same kind as the built-in one.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed argument is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="type(java.lang.Class)"><!-- --></A><H3>
type</H3>
<PRE>
&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; java.lang.Class&lt;? extends U&gt; <STRONG>type</STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</PRE>
<DL>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.
 (If the passed argument is a class of <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> or some its
 subinterfaces or subclasses, <tt>IllegalArgumentException</tt> is thrown instead:
 updatable array classes cannot be specified in this method.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arraySupertype</CODE> - the required supertype of the built-in AlgART array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical type of AlgART array of the same kind as the built-in one.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed argument is a class of <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> or some its
                                  subinterfaces or subclasses (updatable classes cannot be supertypes of
                                  for <A HREF="../../../net/algart/arrays/Array.html#type()"><CODE>Array.type()</CODE></A>).</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>arraySupertype</tt> does not allow storing
                                  the immutable version of the built-in AlgART array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="updatableType(java.lang.Class)"><!-- --></A><H3>
updatableType</H3>
<PRE>
&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; java.lang.Class&lt;? extends U&gt; <STRONG>updatableType</STRONG>(java.lang.Class&lt;U&gt;&nbsp;arraySupertype)</PRE>
<DL>
<DD>Returns <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#updatableType()"><CODE>updatableType()</CODE></A></tt>,
 if it is subtype of (or same type as) the passed <tt>arraySupertype</tt>,
 or throws <tt>ClassCastException</tt> in other case.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arraySupertype</CODE> - the required supertype of the built-in AlgART array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the canonical updatable type of AlgART array of the same kind as the built-in one.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>arraySupertype</tt> does not allow storing
                              the built-in AlgART array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimensions()"><!-- --></A><H3>
dimensions</H3>
<PRE>
long[] <STRONG>dimensions</STRONG>()</PRE>
<DL>
<DD>Returns an array containing all dimensions of this matrix.
 Returned array is equal to the <tt>dim</tt> argument passed to methods that create new matrix instances.

 <p>The returned array is a clone of the internal dimension array, stored in this object.
 The returned array is never empty (its length cannot be zero).
 The elements of the returned array are never negative.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an array containing all dimensions of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD>Returns the number of dimensions of this matrix.
 This value is always positive (&gt;=1).
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>dimensions()</CODE></A>.length</tt>, but works faster.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of dimensions of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dim(int)"><!-- --></A><H3>
dim</H3>
<PRE>
long <STRONG>dim</STRONG>(int&nbsp;n)</PRE>
<DL>
<DD>Returns the dimension <tt>#n</tt> of this matrix
 or <tt>1</tt> if <tt>n&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.
 Equivalent to <tt>n&lt;<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>?<A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>dimensions()</CODE></A>[n]:1</tt>, but works faster.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>n</CODE> - the index of dimension.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the dimension <tt>#n</tt> of this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>n&lt;0</tt> (but <i>not</i> if <tt>n</tt> is too large).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimX()"><!-- --></A><H3>
dimX</H3>
<PRE>
long <STRONG>dimX</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(0)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the first matrix dimension.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimY()"><!-- --></A><H3>
dimY</H3>
<PRE>
long <STRONG>dimY</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(1)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the second matrix dimension.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimZ()"><!-- --></A><H3>
dimZ</H3>
<PRE>
long <STRONG>dimZ</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(2)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the third matrix dimension.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimEquals(net.algart.arrays.Matrix)"><!-- --></A><H3>
dimEquals</H3>
<PRE>
boolean <STRONG>dimEquals</STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</PRE>
<DL>
<DD>Indicates whether the other matrix has the same dimension array.
 In other words, returns <tt>true</tt> if and only if
 both matrices have the same dimension count (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>)
 and the corresponding dimensions (<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>) are equal.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>m</CODE> - the matrix to be compared for equal dimensions with this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified matrix has the same dimension array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed argument is <tt>null</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(long...)"><CODE>dimEquals(long...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimEquals(long...)"><!-- --></A><H3>
dimEquals</H3>
<PRE>
boolean <STRONG>dimEquals</STRONG>(long...&nbsp;dimensions)</PRE>
<DL>
<DD>Indicates whether the passed dimensions are equal to the dimension array of this matrix.
 In other words, returns <tt>true</tt> if and only if
 <tt>dimension.length==<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>
 and the corresponding dimensions <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>==dimension[k]</tt> for all <tt>k</tt>.

 <p>Note: this method does not check, whether all passed dimensions are correct (in particular, non-negative).
 If some elements of the passed array are incorrect, this method just returns <tt>false</tt>.
 But it the passed array is <tt>null</tt>, this method throws <tt>NullPointerException</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dimensions</CODE> - the dimension array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified dimensions are equal to the dimensions of this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed argument is <tt>null</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#dimEquals(net.algart.arrays.Matrix)"><CODE>dimEquals(Matrix)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="index(long...)"><!-- --></A><H3>
index</H3>
<PRE>
long <STRONG>index</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD>Returns the linear index in the built-in AlgART array of the matrix element
 with specified coordinates.

 <p>More precisely,
 <tt>index(<i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i>)</tt>
 returns the following value:

 <blockquote>
 <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.
 All passed indexes <tt><i>i<sub>k</sub></i></tt> must be in ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>.

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 But the extra elements of <tt>coordinates</tt> array must be zero,
 because <tt><i>d<sub>k</sub></i>=1</tt> for <tt><i>k</i>&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.

 <p>Good algorithms processing the matrix should use this method rarely:
 usually there are more optimal ways to calculate necessary linear index.
 For example, if you just need to calculate something for all matrix elements,
 the best way is the following:

 <pre>
 Array a = m.array();
 for (long disp = 0, n = a.length(); disp < n; disp++)
 &#32;   // process the element #k of the array
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the linear index of the matrix element with specified coordinates.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed array is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is empty (no coordinates are passed).</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if some coordinate <tt><i>i<sub>k</sub></i></tt> is out of range
                                   <tt>0..<i>d<sub>k</sub></i>-1</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#uncheckedIndex(long...)"><CODE>uncheckedIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)"><CODE>cyclicIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)"><CODE>pseudoCyclicIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#mirrorCyclicIndex(long...)"><CODE>mirrorCyclicIndex(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])"><CODE>coordinates(long, long[])</CODE></A>, 
<A HREF="../../../net/algart/math/IPoint.html#toOneDimensional(long[], boolean)"><CODE>IPoint.toOneDimensional(long[], boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="index(long, long)"><!-- --></A><H3>
index</H3>
<PRE>
long <STRONG>index</STRONG>(long&nbsp;x,
           long&nbsp;y)</PRE>
<DL>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 2-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>y * <A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A> + x</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>x&lt;0</tt>, <tt>x&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>,
                                   <tt>y&lt;0</tt> or <tt>y&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="index(long, long, long)"><!-- --></A><H3>
index</H3>
<PRE>
long <STRONG>index</STRONG>(long&nbsp;x,
           long&nbsp;y,
           long&nbsp;z)</PRE>
<DL>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method for the case
 of 3-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD><DD><CODE>z</CODE> - the third coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>z * <A HREF="../../../net/algart/arrays/Matrix.html#dimY()"><CODE>dimY()</CODE></A> * <A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A> + y * <A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A> + x</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>x&lt;0</tt>, <tt>x&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>,
                                   <tt>y&lt;0</tt>, <tt>y&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimX()"><CODE>dimX()</CODE></A></tt>,
                                   <tt>z&lt;0</tt> or <tt>z&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimZ()"><CODE>dimZ()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordinates(long, long[])"><!-- --></A><H3>
coordinates</H3>
<PRE>
long[] <STRONG>coordinates</STRONG>(long&nbsp;index,
                   long[]&nbsp;result)</PRE>
<DL>
<DD>Returns the coordinates in the matrix, corresponding to the given linear index in the built-in AlgART array.
 This method is reverse to <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A>: for any index,
 <nobr><tt><A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>(<A HREF="../../../net/algart/arrays/Matrix.html#coordinates(long, long[])"><CODE>coordinates</CODE></A>(index, null)) == index</tt></nobr>.

 <p>The <tt>result</tt> argument may be <tt>null</tt> or some array, containing at least <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>
 elements. If the first case, this method allocates new Java array <tt>long[<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>]</tt>
 for storing coordinates and returns it.
 In the second case, this method stores the found coordinates in <tt>result</tt> array and returns it.
 The returned coordinates are always in ranges
 <pre>
 0 &le; result[<i>k</i>] &lt; <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>index</CODE> - the linear index in the built-in AlgART array.</DD><DD><CODE>result</CODE> - the array where you want to store results; may be <tt>null</tt>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the <tt>result</tt> argument, if it is not <tt>null</tt>,
               else newly created Java array contains all calculated coordinates.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>result!=null</tt>, but <tt>result.length&lt;<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>index&lt;0</tt> or <tt>index&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(0)*<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(1)*...=<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="uncheckedIndex(long...)"><!-- --></A><H3>
uncheckedIndex</H3>
<PRE>
long <STRONG>uncheckedIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges.

 <p>More precisely,
 <tt>uncheckedIndex(<i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i>)</tt>
 always returns the following value:

 <blockquote>
 <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.

 <p>All calculations are performed with <tt>long</tt> type without any overflow checks.
 All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 Please remember that <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)=1</tt>
 for <tt><i>k</i>&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>
 (extra elements of <tt>coordinates</tt> array).</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the linear index of the matrix element with specified coordinates, without range checks.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed array is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is empty (no coordinates are passed).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="cyclicIndex(long...)"><!-- --></A><H3>
cyclicIndex</H3>
<PRE>
long <STRONG>cyclicIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions.

 <p>More precisely, let <tt><i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i></tt>
 are the arguments of the method. Let
 <nobr><tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr> and
 <blockquote>
 <i>i'<sub>k</sub></i> = <i>d<sub>k</sub></i> == 0 ? 0 :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> &gt;= 0 ?
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> + <i>d<sub>k</sub></i>
 </blockquote>

 This method returns the following value:

 <blockquote>
 <i>i'<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i'<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i'<sub>1</sub>d<sub>0</sub></i> + <i>i'<sub>0</sub></i>,
 </blockquote>

 In other words, the resulting index is "cyclical".

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 (You can note that extra elements of <tt>coordinates</tt> array are ignored in fact:
 the reminders <i>i<sub>k</sub></i>%<i>d<sub>k</sub></i>=<i>i<sub>k</sub></i>%1 will be zero for them.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the cyclical linear index of the matrix element with specified coordinates,
                    without range checks.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed array is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is empty (no coordinates are passed).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#CYCLIC"><CODE>Matrix.ContinuationMode.CYCLIC</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="pseudoCyclicIndex(long...)"><!-- --></A><H3>
pseudoCyclicIndex</H3>
<PRE>
long <STRONG>pseudoCyclicIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that does not check,
 whether the passed coordinates are in the required ranges,
 but replaces the resulting index with the positive remainder
 from division of it by the length of the built-in array.

 <p>More precisely, let <tt><i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i></tt>
 are the arguments of the method, and <tt><i>index</i></tt> is the following value
 (as in <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method):

 <blockquote>
 <tt><i>index</i></tt> = <i>i<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i<sub>1</sub>d<sub>0</sub></i> + <i>i<sub>0</sub></i>,
 </blockquote>

 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.
 Here we <i>do no require</i> that the passed indexes <tt><i>i<sub>k</sub></i></tt>
 are in ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>.
 Then, let <tt><i>len</i>=<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>=d<sub>n-1</sub>...d<sub>1</sub>d<sub>0</sub></i></tt>.
 The result of this method is the following:

 <blockquote>
 <tt><i>len</i> == 0 ? 0 : <i>index</i> % <i>len</i> &gt;= 0 ?
 <i>index</i> % <i>len</i> : <i>index</i> % <i>len</i> + <i>len</i></tt>
 </blockquote>

 (It is in the <tt>0..<i>len</i>-1</tt> range always, excepting the generated case <tt><i>len</i>==0</tt>.)
 In other words, the resulting index is "pseudo-cyclical", as the resulting shift
 in <A HREF="../../../net/algart/arrays/Matrices.html#asShifted(net.algart.arrays.Matrix, long...)"><CODE>Matrices.asShifted(Matrix, long...)</CODE></A> method.

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 (You can note that extra elements of <tt>coordinates</tt> array are ignored in fact:
 they add <tt>k*<i>len</i></tt> summand, where <tt>k</tt> is an integer.)

 <p>Note that all calculations are performed absolutely precisely, even in a case when
 the direct calculation according the formulas above leads to overflow (because some
 of values in these formulas are out of <tt>Long.MIN_VALUE..Long.MAX_VALUE</tt> range).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the pseudo-cyclical linear index of the matrix element with specified coordinates,
                    without range checks.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed array is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is empty (no coordinates are passed).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/math/IPoint.html#toOneDimensional(long[], boolean)"><CODE>IPoint.toOneDimensional(long[], boolean)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#PSEUDO_CYCLIC"><CODE>Matrix.ContinuationMode.PSEUDO_CYCLIC</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="mirrorCyclicIndex(long...)"><!-- --></A><H3>
mirrorCyclicIndex</H3>
<PRE>
long <STRONG>mirrorCyclicIndex</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD>An analog of <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index(long...)</CODE></A> method, that, before all calculations,
 replaces the passed coordinates with the positive remainders
 from division of them by the corresponding matrix dimensions
 or with complement of these remainders on the dimensions,
 as if the matrix would be reflected in each its bound as in a mirror.

 <p>More precisely, let <tt><i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n-1</sub></i></tt>
 are the arguments of the method. Let
 <nobr><tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr>,
 <blockquote>
 <i>i'<sub>k</sub></i> = <i>d<sub>k</sub></i> == 0 ? 0 :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> &gt;= 0 ?
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> :
 <i>i<sub>k</sub></i> % <i>d<sub>k</sub></i> + <i>d<sub>k</sub></i>
 </blockquote>
 (as in <A HREF="../../../net/algart/arrays/Matrix.html#cyclicIndex(long...)"><CODE>cyclicIndex(long...)</CODE></A> and
 <blockquote>
 <i>i''<sub>k</sub></i> = <i>d<sub>k</sub></i> == 0 ? 0 :
 &lfloor;<i>i<sub>k</sub></i> / <i>d<sub>k</sub></i>&rfloor; % 2 == 0 ?
 <i>i'<sub>k</sub></i> :
 <i>d<sub>k</sub></i> &minus; 1 &minus; <i>i'<sub>k</sub></i>
 </blockquote>
 (here &lfloor;<i>x</i>&rfloor; means the integer part of <i>x</i>, i.e. <tt>Math.floor(<i>x</i>)</tt>).

 <p>This method returns the following value:

 <blockquote>
 <i>i''<sub>n-1</sub>d<sub>n-2</sub>...d<sub>1</sub>d<sub>0</sub></i> + ... +
 <i>i''<sub>2</sub>d<sub>1</sub>d<sub>0</sub></i> +
 <i>i''<sub>1</sub>d<sub>0</sub></i> + <i>i''<sub>0</sub></i>,
 </blockquote>

 <p>In other words, the resulting index is "mirroring-cyclical".

 <p>All elements of <tt>coordinates</tt> array are always used, regardless of the number of matrix dimensions.
 (You can note that extra elements of <tt>coordinates</tt> array are ignored in fact:
 the reminders <i>i<sub>k</sub></i>%<i>d<sub>k</sub></i>=<i>i<sub>k</sub></i>%1 will be zero for them.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the mirror-cyclical linear index of the matrix element with specified coordinates,
                    without range checks.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed array is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is empty (no coordinates are passed).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#MIRROR_CYCLIC"><CODE>Matrix.ContinuationMode.MIRROR_CYCLIC</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="inside(long...)"><!-- --></A><H3>
inside</H3>
<PRE>
boolean <STRONG>inside</STRONG>(long...&nbsp;coordinates)</PRE>
<DL>
<DD>Returns <tt>true</tt> if all specified coordinates <tt><i>i<sub>k</sub></i></tt>
 are inside the ranges <tt>0..<i>d<sub>k</sub></i>-1</tt>,
 where <tt><i>d<sub>k</sub></i>=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt>.

 <p>This method allows simply check that the arguments of
 the <A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A> method are correct and will not lead to
 <tt>IndexOutOfBoundsException</tt>:
 <pre>
 if (matrix.inside(i1, i2, ...)) {
 &#32;   long index = matrix.index(i1, i2, ...);
 &#32;   // processing an element at this index
 } else {
 &#32;   // special branch for positions outside the matrix
 }
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinates</CODE> - all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if all specified coordinates are inside the matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the passed array is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is empty (no coordinates are passed).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="inside(long, long)"><!-- --></A><H3>
inside</H3>
<PRE>
boolean <STRONG>inside</STRONG>(long&nbsp;x,
               long&nbsp;y)</PRE>
<DL>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 2-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>tt>true</tt> if all specified coordinates are inside the matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="inside(long, long, long)"><!-- --></A><H3>
inside</H3>
<PRE>
boolean <STRONG>inside</STRONG>(long&nbsp;x,
               long&nbsp;y,
               long&nbsp;z)</PRE>
<DL>
<DD>The simplified version of the full <A HREF="../../../net/algart/arrays/Matrix.html#inside(long...)"><CODE>inside</CODE></A> method for the case
 of 3-dimensional matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - the first coordinate.</DD><DD><CODE>y</CODE> - the second coordinate.</DD><DD><CODE>z</CODE> - the third coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>tt>true</tt> if all specified coordinates are inside the matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="matrix(net.algart.arrays.Array)"><!-- --></A><A NAME="matrix(U)"><!-- --></A><H3>
matrix</H3>
<PRE>
&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt; <STRONG>matrix</STRONG>(U&nbsp;anotherArray)</PRE>
<DL>
<DD>Returns the new matrix backed by the specified AlgART array with the same dimensions as this one.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrices.html#matrix(T, long...)"><CODE>Matrices.matrix</CODE></A>(anotherArray, <A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>dimensions()</CODE></A>)</tt>.

 <p>The array <tt>anotherArray</tt> must be <A HREF="../../../net/algart/arrays/Array.html#isUnresizable()"><CODE>unresizable</CODE></A>,
 and its length must be equal to the length of the array built-in this matrix.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>anotherArray</CODE> - some another AlgART array with the same length as <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new matrix instance.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>anotherArray</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the passed array is resizable
                                  (for example, implements <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A>).</DD>
<DD><CODE><A HREF="../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the product of all dimensions is not equal to the passed array length.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="cast(java.lang.Class)"><!-- --></A><H3>
cast</H3>
<PRE>
&lt;U extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;U&gt; <STRONG>cast</STRONG>(java.lang.Class&lt;U&gt;&nbsp;arrayClass)</PRE>
<DL>
<DD>Returns this matrix, cast to the specified generic array type,
 or throws <tt>ClassCastException</tt> if the built-in AlgART array
 cannot be cast to the required type (because the array type is not its subclass).
 Works alike <tt><A HREF="../../../net/algart/arrays/Matrix.html#matrix(U)"><CODE>matrix</CODE></A>((U)array)</tt>, but returns
 the reference to this instance and is compiled without "unchecked cast" warning.

 <p>This method is useful when you need to cast the type of AlgART array,
 built in this matrix, to to its sub- or superinterface.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arrayClass</CODE> - the type of built-in array in the new matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new matrix with the same dimensions, based on the same array cast to the required type.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if the built-in AlgART array cannot be cast to the required type.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long[], long[])"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long[]&nbsp;from,
                    long[]&nbsp;to)</PRE>
<DL>
<DD>Returns a view of the rectangular fragment of this matrix between <tt>from</tt>,
 inclusive, and <tt>to</tt>, exclusive.

 <p>More precisely, the returned matrix consists of all elements of this one with coordinates
 <i>i<sub>0</sub></i>, <i>i<sub>1</sub></i>, ..., <i>i<sub>n&minus;1</sub></i>,
 <i>n</i><tt>=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>,
 matching the following conditions:<pre>
     from[0] &lt;= <i>i<sub>0</sub></i> &lt; to[0],
     from[1] &lt;= <i>i<sub>1</sub></i> &lt; to[1],
     . . .
     from[<i>n</i>-1] &lt;= <i>i<sub>n-1</sub></i> &lt; to[<i>n</i>-1]
 </pre>

 So, every dimension <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A> in the returned matrix will be equal to <tt>to[k]-from[k]</tt>.
 The following condition must be fulfilled for all <tt>k</tt>:
 <tt>0&lt;=from[k]&lt;=to[k]&lt;=thisMatrix.<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A></tt>.
 The <A HREF="../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A> of the returned matrix is identical to the element type
 of this matrix.

 <p>This method is equivalent to the call
 <nobr><tt><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(from,to,<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A>)</tt></nobr>.

 <p>The built-in AlgART array of the returned matrix is backed by the built-in array of this matrix,
 so &mdash; if this matrix is not <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A>
 &mdash; any changes of the elements of the returned matrix are reflected in this matrix, and vice-versa.
 The returned matrix is <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A> if, and only if,
 the built-in array of this matrix does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>.
 The <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>Array.asTrustedImmutable()</CODE></A> method
 in the built-in array of the returned matrix is equivalent to <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>Array.asImmutable()</CODE></A>,
 and <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>Array.asCopyOnNextWrite()</CODE></A> method just returns the full copy of the array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>from</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>to</CODE> - high endpoints (exclusive) of all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>from</tt> or <tt>to</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>from.length</tt> or <tt>to.length</tt>
                                   is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if, for some <tt>k</tt>,
                                   <tt>from[k]&lt;0 || to[k]&gt;<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A> ||
                                   from[k]&gt;to[k]</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(net.algart.math.IRectangularArea)"><CODE>subMatrix(IRectangularArea)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(net.algart.math.IRectangularArea)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>area</CODE> - rectangular area within this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>
                                   is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if, for some <tt>k</tt>,
                                   <tt>min[k]&lt;0 || max[k]&gt;=<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A></tt>, where
                                   <tt>min=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min()"><CODE>min()</CODE></A>.<A HREF="../../../net/algart/math/IPoint.html#coordinates()"><CODE>coordinates()</CODE></A></tt> and,
                                   <tt>max=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max()"><CODE>max()</CODE></A>.<A HREF="../../../net/algart/math/IPoint.html#coordinates()"><CODE>coordinates()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                    long&nbsp;fromY,
                    long&nbsp;toX,
                    long&nbsp;toY)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY})</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - in the same situations as in <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long, long, long)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                    long&nbsp;fromY,
                    long&nbsp;fromZ,
                    long&nbsp;toX,
                    long&nbsp;toY,
                    long&nbsp;toZ)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ})</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>fromZ</CODE> - low endpoints (inclusive) of the third coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD><DD><CODE>toZ</CODE> - high endpoints (exclusive) of the third coordinate.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=3</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - in the same situations as in <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long[]&nbsp;from,
                    long[]&nbsp;to,
                    <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>An extended analog of <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> method, allowing to get a rectangular fragment
 which is not fully inside this matrix.

 <p>More precisely, unlike <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A>, here
 the only requirement for the <tt>from</tt> and <tt>to</tt> coordinate boundaries is <tt>from[k]&lt;=to[k]</tt>,
 but <tt>from[k]</tt> may be negative and <tt>to[k]</tt> may be greater than <A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>.
 (And there is also a trivial obvious requirement
 <nobr><tt>to[k]-from[k]&le;Long.MAX_VALUE</tt></nobr>, i.e. that the dimensions of the result must
 be representable by <tt>long</tt> type.)

 <p>The elements of the returned matrix, that do not correspond to any elements of this one,
 i.e. "lie outside" of the source matrix, are considered to be equal to some values, according to
 some <i>continuation model</i>, described by <tt>continuationMode</tt> argument.
 Such "outside" elements can correspond (according some rules) to actual elements of the source elements &mdash;
 then attempts to read them return the values of the corresponding source elements
 and attempts to write into them modify the corresponding source elements
 (it is so for <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#CYCLIC"><CODE>Matrix.ContinuationMode.CYCLIC</CODE></A>, <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#PSEUDO_CYCLIC"><CODE>Matrix.ContinuationMode.PSEUDO_CYCLIC</CODE></A>,
 <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#MIRROR_CYCLIC"><CODE>Matrix.ContinuationMode.MIRROR_CYCLIC</CODE></A> modes),
 &mdash; or can be calculated "virtually" (according some rules) &mdash;
 then attempts to read them return the calculated values
 and attempts to modify them are ignored
 (it is so for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation</CODE></A> mode).
 See <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><CODE>Matrix.ContinuationMode</CODE></A> class for more details.

 <p>Important note: there are two cases, when requirements to the <tt>from</tt> and <tt>to</tt>
 coordinate boundaries are more strong, than described above.
 <ol>
     <li>If <tt>continuationMode==<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A></tt>, this method is strictly
     equivalent to more simple <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> method,
     so all requirements are the same as for that method.</li>
     <li>If <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#CYCLIC"><CODE>Matrix.ContinuationMode.CYCLIC</CODE></A>,
     <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#PSEUDO_CYCLIC"><CODE>Matrix.ContinuationMode.PSEUDO_CYCLIC</CODE></A> or <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#MIRROR_CYCLIC"><CODE>Matrix.ContinuationMode.MIRROR_CYCLIC</CODE></A>
     (but it is not a constant continuation mode) and some dimension <tt>#k</tt>
     of this matrix is zero &mdash; <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(k)==0</tt> &mdash;
     then both corresponding coordinate boundaries <tt>from[k]</tt> and <tt>to[k]</tt>
     must be zero (as in <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> method).</li>
 </ol>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>from</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>to</CODE> - high endpoints (exclusive) of all coordinates.</DD><DD><CODE>continuationMode</CODE> - the mode of continuation outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>from</tt>, <tt>to</tt> or <tt>continuationMode</tt>
                                   argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>from.length</tt> or <tt>to.length</tt>
                                   is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - for <tt>continuationMode==<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A></tt> &mdash;
                                   see <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> method;
                                   for other cases &mdash; if, for some <tt>k</tt>,
                                   <tt>from[k]&gt;to[k]</tt> or
                                   <nobr><tt>to[k]-from[k]&gt;Long.MAX_VALUE</tt></nobr>,
                                   or if (for some <tt>k</tt>) <tt><A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A>==0</tt> and
                                   <nobr><tt>from[k]!=0 || to[k]!=0</tt></nobr>,
                                   or if the product of all differences <tt>to[k]-from[k]</tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(net.algart.math.IRectangularArea, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(<A HREF="../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A>&nbsp;area,
                    <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from.length=to.length=area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>,
 <tt>from[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#min(int)"><CODE>min</CODE></A>(k)</tt>,
 <tt>to[k]=area.<A HREF="../../../net/algart/math/IRectangularArea.html#max(int)"><CODE>max</CODE></A>(k)+1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>area</CODE> - rectangular area within this matrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>area.<A HREF="../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A></tt>
                                   is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the product of all <tt>area.<A HREF="../../../net/algart/math/IRectangularArea.html#sizes()"><CODE>IRectangularArea.sizes()</CODE></A></tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <tt>Long.MAX_VALUE</tt>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                    long&nbsp;fromY,
                    long&nbsp;toX,
                    long&nbsp;toY,
                    <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY}, new long[]{toX,toY}, continuationMode)</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>continuationMode</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>fromX&gt;toX</tt> or <tt>toX-fromX&gt;Long.MAX_VALUE</tt>,
                                   or if <tt>fromY&gt;toY</tt> or <tt>toY-fromY&gt;Long.MAX_VALUE</tt>,
                                   or if the product <tt>(toX-fromX)*(toY-fromY)</tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrix(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatrix</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrix</STRONG>(long&nbsp;fromX,
                    long&nbsp;fromY,
                    long&nbsp;fromZ,
                    long&nbsp;toX,
                    long&nbsp;toY,
                    long&nbsp;toZ,
                    <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix</CODE></A>(new long[]{fromX,fromY,fromZ}, new long[]{toX,toY,toZ}, continuationMode)</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromX</CODE> - low endpoints (inclusive) of the first coordinate.</DD><DD><CODE>fromY</CODE> - low endpoints (inclusive) of the second coordinate.</DD><DD><CODE>fromZ</CODE> - low endpoints (inclusive) of the third coordinate.</DD><DD><CODE>toX</CODE> - high endpoints (exclusive) of the first coordinate.</DD><DD><CODE>toY</CODE> - high endpoints (exclusive) of the second coordinate.</DD><DD><CODE>toZ</CODE> - high endpoints (exclusive) of the third coordinate.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>continuationMode</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=3</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>fromX&gt;toX</tt> or <tt>toX-fromX&gt;Long.MAX_VALUE</tt>,
                                   or if <tt>fromY&gt;toY</tt> or <tt>toY-fromY&gt;Long.MAX_VALUE</tt>,
                                   or if <tt>fromZ&gt;toZ</tt> or <tt>toZ-fromZ&gt;Long.MAX_VALUE</tt>,
                                   or if the product <tt>(toX-fromX)*(toY-fromY)*(toZ-fromZ)</tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long[], long[])"><!-- --></A><H3>
subMatr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatr</STRONG>(long[]&nbsp;position,
                  long[]&nbsp;dimensions)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[] from, long[] to)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>position</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>dimensions</CODE> - dimensions of the returned submatrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>position</tt> or <tt>dimensions</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>position.length</tt> or <tt>dimensions.length</tt>
                                   is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if, for some <tt>k</tt>,
                                   <tt>position[k]&lt;0 || dimensions[k]&lt;0 ||
                                   position[k]+dimensions[k]&gt;<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim(k)</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr(long[], long[], ContinuationMode)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long)"><!-- --></A><H3>
subMatr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                  long&nbsp;y,
                  long&nbsp;dimX,
                  long&nbsp;dimY)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY})</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - in the same situations as in <A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr(long[], long[])</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long, long, long)"><!-- --></A><H3>
subMatr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                  long&nbsp;y,
                  long&nbsp;z,
                  long&nbsp;dimX,
                  long&nbsp;dimY,
                  long&nbsp;dimZ)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ})</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>z</CODE> - low endpoint (inclusive) of the third coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD><DD><CODE>dimZ</CODE> - the third dimension of the returned submatrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - in the same situations as in <A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr(long[], long[])</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatr</STRONG>(long[]&nbsp;position,
                  long[]&nbsp;dimensions,
                  <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[] from, long[] to, ContinuationMode continuationMode)</CODE></A> method, where
 <tt>from[k]=position[k]</tt> and <tt>to[k]=position[k]+dimensions[k]</tt> for all <tt>k</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>position</CODE> - low endpoints (inclusive) of all coordinates.</DD><DD><CODE>dimensions</CODE> - dimensions of the returned submatrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>position</tt>, <tt>dimensions</tt> or <tt>continuationMode</tt>
                                   argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>position.length</tt> or <tt>dimensions.length</tt>
                                   is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>/</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if, for some <tt>k</tt>, <tt>dimensions[k]&lt;0</tt>
                                   or <tt>position[k]+dimensions[k]&gt;Long.MAX_VALUE</tt>,
                                   or if the product of all <tt>dimensions[k]</tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr(long[], long[])</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                  long&nbsp;y,
                  long&nbsp;dimX,
                  long&nbsp;dimY,
                  <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y}, new long[]{dimX,dimY}, continuationMode)</nobr></tt>.
 Note that this matrix must be 2-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>continuationMode</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>dimX&lt;0</tt>, <tt>dimY&lt;0</tt>, <tt>x+dimX&gt;Long.MAX_VALUE</tt>
                                   or <tt>y+dimY&gt;Long.MAX_VALUE</tt>,
                                   or if the product <tt>dimX*dimY</tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatr(long, long, long, long, long, long, net.algart.arrays.Matrix.ContinuationMode)"><!-- --></A><H3>
subMatr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatr</STRONG>(long&nbsp;x,
                  long&nbsp;y,
                  long&nbsp;z,
                  long&nbsp;dimX,
                  long&nbsp;dimY,
                  long&nbsp;dimZ,
                  <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A>&nbsp;continuationMode)</PRE>
<DL>
<DD>Equivalent to <tt><nobr><A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr</CODE></A>(new long[]{x,y,z}, new long[]{dimX,dimY,dimZ}, continuationMode)</nobr></tt>.
 Note that this matrix must be 3-dimensional (in other case <tt>IllegalArgumentException</tt> will be thrown).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>x</CODE> - low endpoint (inclusive) of the first coordinate.</DD><DD><CODE>y</CODE> - low endpoint (inclusive) of the second coordinate.</DD><DD><CODE>z</CODE> - low endpoint (inclusive) of the third coordinate.</DD><DD><CODE>dimX</CODE> - th first dimension of the returned submatrix.</DD><DD><CODE>dimY</CODE> - the second dimension of the returned submatrix.</DD><DD><CODE>dimZ</CODE> - the third dimension of the returned submatrix.</DD><DD><CODE>continuationMode</CODE> - the value returned while reading elements, lying outside this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified rectangular fragment within this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>continuationMode</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt><A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=3</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>dimX&lt;0</tt>, <tt>dimY&lt;0</tt>, <tt>dimZ&lt;0</tt>,
                                   <tt>x+dimX&gt;Long.MAX_VALUE</tt>, <tt>y+dimY&gt;Long.MAX_VALUE</tt>
                                   or <tt>z+dimZ&gt;Long.MAX_VALUE</tt>,
                                   or if the product <tt>dimX*dimY*dimZ</tt>
                                   (i.e. desired total size of the new matrix)
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>continuationMode</tt> is <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>a constant mode</CODE></A>,
                                   the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#continuationConstant()"><CODE>continuation constant</CODE></A> is not <tt>null</tt> and the class of this
                                   constant is illegal, i.e.
                                   cannot be casted to the necessary type according the rules, specified
                                   for the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#getConstantMode(java.lang.Object)"><CODE>constant continuation mode</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSubMatrix()"><!-- --></A><H3>
isSubMatrix</H3>
<PRE>
boolean <STRONG>isSubMatrix</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of
 some <tt>parent</tt> matrix, created by one of calls <tt>parent.subMatrix(...)</tt>,
 <tt>parent.subMatr(...)</tt> or equivalent.
 The <A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()"><CODE>subMatrixParent()</CODE></A> method throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>
 if and only if this method returns <tt>false</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this object is created by <tt>subMatrix(...)</tt>, <tt>subMatr(...)</tt> or equivalent call.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[])"><CODE>subMatr(long[], long[])</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatr(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatr(long[], long[], ContinuationMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#subMatrixParent()"><CODE>subMatrixParent()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixParent()"><!-- --></A><H3>
subMatrixParent</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>subMatrixParent</STRONG>()</PRE>
<DL>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns a reference to the <tt>parent</tt> matrix instance.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the parent matrix, if this instance is a submatrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays">NotSubMatrixException</A></CODE> - if this object is not created by <tt>subMatrix(...)</tt>,
                               <tt>subMatr(...)</tt> or equivalent call.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixFrom()"><!-- --></A><H3>
subMatrixFrom</H3>
<PRE>
long[] <STRONG>subMatrixFrom</STRONG>()</PRE>
<DL>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the starting position of this submatrix
 in the parent one. The result will be equal to "<tt>from</tt>" argument of
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> and <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[], long[], ContinuationMode)</CODE></A> methods.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>low endpoints (inclusive) of all coordinates of this submatrix in its parent matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays">NotSubMatrixException</A></CODE> - if this object is not created by <tt>subMatrix(...)</tt>,
                               <tt>subMatr(...)</tt> or equivalent call.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixTo()"><!-- --></A><H3>
subMatrixTo</H3>
<PRE>
long[] <STRONG>subMatrixTo</STRONG>()</PRE>
<DL>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>submatrix</CODE></A> of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 creates and returns a new Java array containing the ending position (exclusive) of this submatrix
 in the parent one. The result will be equal to "<tt>to</tt>" argument of
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> and <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[], long[], ContinuationMode)</CODE></A> methods.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>low endpoints (inclusive) of all coordinates of this submatrix in its parent matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays">NotSubMatrixException</A></CODE> - if this object is not created by <tt>subMatrix(...)</tt>,
                               <tt>subMatr(...)</tt> or equivalent call.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subMatrixContinuationMode()"><!-- --></A><H3>
subMatrixContinuationMode</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays">Matrix.ContinuationMode</A> <STRONG>subMatrixContinuationMode</STRONG>()</PRE>
<DL>
<DD>If this matrix is a <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>submatrix</CODE></A>
 of some <tt>parent</tt> matrix,
 created by one of calls <tt>parent.subMatrix(...)</tt> or <tt>parent.subMatr(...)</tt>,
 returns the <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><CODE>continuation mode</CODE></A>, used by this submatrix.
 If this matrix is not a submatrix, throws <A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays"><CODE>NotSubMatrixException</CODE></A>.

 <p>If the submatrix was created by
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)</CODE></A> or equivalent method,
 the <tt>continuationMode</tt> argument, passed to that method, is returned.
 If the submatrix was created by
 <A HREF="../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[])"><CODE>subMatrix(long[], long[])</CODE></A> or equivalent method,
 <A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html#NONE"><CODE>Matrix.ContinuationMode.NONE</CODE></A> constant is returned.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>low endpoints (inclusive) of all coordinates of this submatrix in its parent matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../net/algart/arrays/NotSubMatrixException.html" title="class in net.algart.arrays">NotSubMatrixException</A></CODE> - if this object is not created by <tt>subMatrix(...)</tt>,
                               <tt>subMatr(...)</tt> or equivalent call.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isSubMatrix()"><CODE>isSubMatrix()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="structureLike(net.algart.arrays.Matrix)"><!-- --></A><H3>
structureLike</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>structureLike</STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</PRE>
<DL>
<DD>Returns a view ot this matrix, where the elements are reordered in some order "like"
 in the specified matrix <tt>m</tt>.
 In other words, the elements of the <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in array</CODE></A> of the returned matrix are
 the same as the elements of the <A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in array</CODE></A> of this one
 (any changes of the elements of the returned matrix are reflected in this matrix, and vice-versa),
 but the order of the elements can differ. The precise algorithm of reordering is not specified
 and depends of the matrix <tt>m</tt>: this method tries to help algorithms, processing the same
 or similar areas in both matrices, to provide maximal performance.

 <p>This method returns non-trivial results only if the matrix <tt>m</tt> is already a view of some other
 matrix with some form of reordering elements, for example, if <tt>m</tt> is a <A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>tiled</CODE></A> matrix.
 In other case, this method just returns this instance.

 <p>In the current version of this package (if this instance was created by means of methods of this package),
 this method is equivalent to the following:

 <pre>
 m.<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>isTiled()</CODE></A> ?
 &#32;   thisInstance.<A HREF="../../../net/algart/arrays/Matrix.html#tile()"><CODE>tile</CODE></A>(m.<A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()"><CODE>tileDimensions()</CODE></A>) :
 &#32;   thisInstance;
 </pre>

 <p>In future versions, it is possible that this method will recognize other forms of reordering matrix elements
 and return non-trivial results for such <tt>m</tt> matrices.

 <p>Because the precise order of elements of the returning matrix is not specified, we recommend to use
 this method generally for newly created matrices, for example:

 <pre>
 memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newMatrix(java.lang.Class, net.algart.arrays.Matrix)"><CODE>newMatrix</CODE></A>(<A HREF="../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays"><CODE>UpdatablePArray</CODE></A>.class, m).<A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>structureLike</CODE></A>(m);
 </pre>
 or, more briefly,
 <pre>
 memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newStructuredMatrix(java.lang.Class, net.algart.arrays.Matrix)"><CODE>newStructuredMatrix</CODE></A>(<A HREF="../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays"><CODE>UpdatablePArray</CODE></A>.class, m);
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>m</CODE> - some matrix, probably a view of another matrix with reordered elements
          (for example, <A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tiled</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of this matrix with elements reordered in similar order, or a reference to this instance
          if <tt>m</tt> matrix is not reodered or this method does not "know" about the way of that reordering.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>m</tt> argument is <tt>null</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#isStructuredLike(net.algart.arrays.Matrix)"><CODE>isStructuredLike(Matrix)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isStructuredLike(net.algart.arrays.Matrix)"><!-- --></A><H3>
isStructuredLike</H3>
<PRE>
boolean <STRONG>isStructuredLike</STRONG>(<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;?&gt;&nbsp;m)</PRE>
<DL>
<DD>Returns <tt>true</tt> if the elements of this matrix is ordered "alike" the elements
 of the specified matrix <tt>m</tt>, in terms of <A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>structureLike(Matrix)</CODE></A> method.
 "Ordered alike" does not mean that the dimensions of both matrices are equal, or that
 the details of the structure are the same; it means only that both matrices use similar
 reordering algorithms.

 <p>More precisely, <A HREF="../../../net/algart/arrays/Matrix.html#structureLike(net.algart.arrays.Matrix)"><CODE>structureLike(Matrix)</CODE></A> method returns this instance if and only if
 this method returns <tt>true</tt>.

 <p>In the current version of this package (if this instance was created by means of methods of this package),
 this method is equivalent to: <tt>thisInstance.<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>isTiled()</CODE></A>==m.<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>isTiled()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>m</CODE> - some matrix, probably a view of another matrix with reordered elements
          (for example, <A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tiled</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this matrix is reordered alike <tt>m</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>m</tt> argument is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="tile(long...)"><!-- --></A><H3>
tile</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>tile</STRONG>(long...&nbsp;tileDim)</PRE>
<DL>
<DD>Returns a view ot this matrix, where the elements are reordered by <i>tiles</i>: a grid of rectangular
 regions (<i>tiles</i>), the sizes of which are specified by <tt>tileDim</tt> argument.
 It means that the elements of the built-in AlgART array of the returned matrix are the elements
 of the built-in array of this one, but "shuffled" so that all elements of every tile in the returned matrix
 are located in a continuous block of the built-in array of this matrix.
 The returned matrix is named <i>tiled matrix</i>. The <A HREF="../../../net/algart/arrays/Matrix.html#dimensions()"><CODE>dimensions</CODE></A>
 of the returned matrix are the same as the dimensions of this one.
 The <A HREF="../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A> of the returned matrix is identical to the element type
 of this matrix.

 <p>More precisely, let this matrix be <b>M</b> and the tiled matrix, returned by this method, be <b>T</b>.
 Let <i>i<sub>0</sub></i>, <i>i<sub>1</sub></i>, ..., <i>i<sub>n&minus;1</sub></i>
 (<i>n</i><tt>=<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>) be coordinates of some element it the tiled matrix <b>T</b>,
 that is located in <b>T</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt>
 at the index <i>i</i>=<b>T</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A></tt>(<i>i<sub>0</sub></i>,<i>i<sub>1</sub></i>,...,<i>i<sub>n&minus;1</sub></i>).
 This element is located in the original array <b>M</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt> at another index
 <i>j</i>, which is calculated by the following algorithm.

 <ol>
 <li>Let <i>d<sub>k</sub></i> = <b>M</b>.<A HREF="../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>),
 <i>k</i>=0,1,...,<i>n</i>&minus;1: dimensions of this and returned matrix.</li>

 <li>Let <i>i'<sub>k</sub></i> = <i>i<sub>k</sub></i>%<tt>tileDim[<i>k</i>]</tt>,
 <i>k</i>=0,1,...,<i>n</i>&minus;1: <i>i'<sub>k</sub></i> are the coordinates of this element inside
 the tile, containing it in <b>T</b> matrix.</li>

 <li>Let <i>s<sub>k</sub></i> = <i>i<sub>k</sub></i>&minus;<i>i'<sub>k</sub></i>,
 <i>k</i>=0,1,...,<i>n</i>&minus;1: <i>s<sub>k</sub></i> are the coordinates of the starting element
 of the tile, containing this element in <b>T</b> matrix.</li>

 <li>Let <i>t<sub>k</sub></i> = <tt>min</tt>(<tt>tileDim[</tt><i>k</i><tt>]</tt>,
 <i>d<sub>k</sub></i>&minus;<i>s<sub>k</sub></i>),
 <i>k</i>=0,1,...,<i>n</i>&minus;1: <i>t<sub>k</sub></i> are the dimensions
 of the tile, containing this element in <b>T</b> matrix. (Note that boundary tiles can be less
 than <tt>tileDim</tt>, if dimensions of matrix are not divisible by corresponding dimensions of tiles.)</li>

 <li>Let <tt>previousVolume</tt> =
 <i>d</i><sub>0</sub><i>d</i><sub>1</sub>...<i>d</i><sub><i>n</i>&minus;3</sub><i
 class="dummy">d</i><sub><i>n</i>&minus;2</sub><i>s</i><sub><i>n</i>&minus;1</sub>
 + <i>d</i><sub>0</sub><i>d</i><sub>1</sub>...<i>d</i><sub><i>n</i>&minus;3</sub><i
 class="dummy">c</i><sub><i>n</i>&minus;2</sub><i>t</i><sub><i>n</i>&minus;1</sub>
 + ... + <i>s</i><sub>0</sub><i>t</i><sub>1</sub>...<i
 class="dummy">t</i><sub><i>n</i>&minus;2</sub><i>t</i><sub><i>n</i>&minus;1</sub>.
 This complex formula returns the summary sizes of all tiles, that are fully located
 in the source <b>T</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt> before the given element.
 In 2-dimensional case, the formula is more simple:
 <tt>previousVolume</tt> = <i>d</i><sub><i>x</i></sub><i>s</i><sub><i>y</i></sub>
 + <i>s</i><sub><i>x</i></sub><i>t</i><sub><i>y</i></sub>.
 </li>

 <li>Let <tt>indexInTile</tt> =
 <i>i'</i><sub>0</sub> + <i>i'</i><sub>1</sub><i>t</i><sub>0</sub> + ...
 + <i>i'</i><sub><i>n</i>&minus;1</sub><i>t</i><sub><i>n</i>&minus;2</sub>...<i>t</i><sub>0</sub>:
 it is the index of the element with coordinates
 <nobr><i>i'<sub>0</sub></i>,<i>i'<sub>1</sub></i>,...,<i>i'<sub>n&minus;1</sub></i></nobr>
 in the built-in array of a little matrix, dimensions of which are equal to the tile dimensions.
 </li>

 <li>The required index of the given element in the original array <b>M</b><tt>.<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></tt>
 is <nobr><i>j</i> = <tt>previousVolume</tt> + <tt>indexInTile</tt></nobr>.</li>
 </ol>

 <p>Tiled matrices are necessary to provide good performance of many algorithms, if this matrix is very large
 (much greater than amount of RAM) and is located on disk or other external devices.
 For example, extracting a rectangular area 1000x1000 from a byte matrix 1000000x1000000 (1&nbsp;terabyte)
 will probably work much faster if it is tiled, than if it is a usual matrix, where every line
 occupies 1 MB of continuous disk space.

 <p>In the degenerated case of 1-dimensional matrix (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>=1)
 the tiled matrix is absolutely useless, though still works correctly.

 <p>Recommended tile dimensions are from several hundreds to several thousands, but it depends
 on the number of dimensions. If tile dimensions are degrees of two (2<sup><i>k</i></sup>),
 the tiled matrix will probably work faster.

 <p>The built-in AlgART array of the returned matrix is backed by the built-in array of this matrix,
 so &mdash; if this matrix is not <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A>
 &mdash; any changes of the elements of the returned matrix are reflected in this matrix, and vice-versa.
 The returned matrix is <A HREF="../../../net/algart/arrays/Matrix.html#isImmutable()"><CODE>immutable</CODE></A> if, and only if,
 the built-in array of this matrix does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>.
 The <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>Array.asTrustedImmutable()</CODE></A> method
 in the built-in array of the returned matrix is equivalent to <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>Array.asImmutable()</CODE></A>,
 and <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>Array.asCopyOnNextWrite()</CODE></A> method just returns the full copy of the array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>tileDim</CODE> - dimensions of the tiles in the returned matrix (excepting the boundary tiles,
                which can be less).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a tiled view of this matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>tileDim</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>tileDim.length</tt is not equal to <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>,
                                   or if some <tt>tileDim[k]&lt;=0</tt>,
                                   or if the product of all tile dimensions <tt>tileDim[k]</tt>
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#tile()"><CODE>tile()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>isTiled()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()"><CODE>tileDimensions()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="tile()"><!-- --></A><H3>
tile</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>tile</STRONG>()</PRE>
<DL>
<DD>Returns a tiled view ot this matrix with some default dimensions of the tiles.
 Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tile</CODE></A>(tileDim)</tt>, where all elements of <tt>tileDim</tt>
 are equal to the default integer value, retrieved from the system property
 "<tt>net.algart.arrays.matrixTile2D</tt>",
 "<tt>net.algart.arrays.matrixTile3D</tt>"
 "<tt>net.algart.arrays.matrixTile4D</tt>"
 "<tt>net.algart.arrays.matrixTile5D</tt>" or
 "<tt>net.algart.arrays.matrixTileND</tt>",
 if the <A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>number of dimensions</CODE></A> of this matrix is correspondingly 2, 3, 4, 5 or greater.
 If there is no such property, or if it contains not a number,
 or if some exception occurred while calling <tt>Long.getLong</tt>,
 this method uses the following tile dimensions:
 4096x4096 in 2-dimensional case,
 256x256x256 in 3-dimensional case,
 64x64x64x64 in 4-dimensional case,
 32x32x32x32x32 in 5-dimensional case,
 16x16x... if the number of dimensions is greater than 5.
 If the corresponding property exists and contains a valid integer number,
 but it is too small, in particular, zero or negative, then it is replaced with some minimal positive value.
 The values of all these system property is loaded and checked only once
 while initializing <A HREF="../../../net/algart/arrays/Arrays.html" title="class in net.algart.arrays"><CODE>Arrays</CODE></A> class.
 If the number of dimensions is 1 (degenerated case), this method always uses 65536 as the tile size.
 (<i>Warning</i>! These defaults can be changed in future versions!)
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a tiled view of this matrix with default tile dimensions.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the product of all tile dimensions <tt>tileDim[k]</tt>
                                   is greater than <nobr><tt>Long.MAX_VALUE</tt></nobr>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Matrix.html#tile(long...)"><CODE>tile(long...)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#isTiled()"><CODE>isTiled()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html#tileDimensions()"><CODE>tileDimensions()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="tileParent()"><!-- --></A><H3>
tileParent</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;<A HREF="../../../net/algart/arrays/Matrix.html" title="type parameter in Matrix">T</A>&gt; <STRONG>tileParent</STRONG>()</PRE>
<DL>
<DD>Not ready yet!
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>original non-tiled matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="tileDimensions()"><!-- --></A><H3>
tileDimensions</H3>
<PRE>
long[] <STRONG>tileDimensions</STRONG>()</PRE>
<DL>
<DD>Not ready yet!
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>dimensions of the tile in this matrix, if it is tiled.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isTiled()"><!-- --></A><H3>
isTiled</H3>
<PRE>
boolean <STRONG>isTiled</STRONG>()</PRE>
<DL>
<DD>Not ready yet!
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if and only if this matrix is tiled.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isImmutable()"><!-- --></A><H3>
isImmutable</H3>
<PRE>
boolean <STRONG>isImmutable</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A></tt>.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this instance is immutable.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isCopyOnNextWrite()"><!-- --></A><H3>
isCopyOnNextWrite</H3>
<PRE>
boolean <STRONG>isCopyOnNextWrite</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A></tt>.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this instance is copy-on-next-write.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isDirectAccessible()"><!-- --></A><H3>
isDirectAccessible</H3>
<PRE>
boolean <STRONG>isDirectAccessible</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if the built-in AlgART array implements <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>
 interface and <tt>((<A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>)<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>).<A HREF="../../../net/algart/arrays/DirectAccessible.html#hasJavaArray()"><CODE>hasJavaArray()</CODE></A></tt> method returns <tt>true</tt>.

 <p>There is a guarantee that this method works very quickly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this matrix can be viewed as a Java array or a part of Java array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="flushResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
flushResources</H3>
<PRE>
void <STRONG>flushResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(context)</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="freeResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
freeResources</H3>
<PRE>
void <STRONG>freeResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(context)</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="freeResources()"><!-- --></A><H3>
freeResources</H3>
<PRE>
void <STRONG>freeResources</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(null)</CODE></A></tt>.
<P>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
java.lang.String <STRONG>toString</STRONG>()</PRE>
<DL>
<DD>Returns a brief string description of this object.

 <p>The result of this method may depend on implementation and usually contains
 a short description of the built-in AlgART array and all matrix dimensions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a brief string description of this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
int <STRONG>hashCode</STRONG>()</PRE>
<DL>
<DD>Returns the hash code of this matrix. The result depends on all elements of the built-in array
 (as <A HREF="../../../net/algart/arrays/Array.html#hashCode()"><CODE>Array.hashCode()</CODE></A> and all matrix dimensions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the hash code of this matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
boolean <STRONG>equals</STRONG>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Indicates whether some other matrix is equal to this one.
 Returns <tt>true</tt> if and only if:<ol>
 <li>the specified object is a matrix (i.e. implements <A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays"><CODE>Matrix</CODE></A>),</li>
 <li>both matrices have the same dimension count (<A HREF="../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>)
 and the same corresponding dimensions;</li>
 <li>the built-in AlgART arrays (<A HREF="../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>) are equal (see <A HREF="../../../net/algart/arrays/Array.html#equals(java.lang.Object)"><CODE>Array.equals(Object)</CODE></A>).</li>
 </ol>
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>obj</CODE> - the object to be compared for equality with this matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified object is a matrix equal to this one.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/Matrices.Simplex.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/Matrix.ContinuationMode.html" title="class in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/Matrix.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Matrix.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
