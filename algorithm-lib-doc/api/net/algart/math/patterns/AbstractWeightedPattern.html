<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractWeightedPattern
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractWeightedPattern";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/AbstractWeightedPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractWeightedPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.math.patterns</FONT>
<BR>
Class AbstractWeightedPattern</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.math.patterns.AbstractWeightedPattern</STRONG>
</PRE>
<DL>
<DT><STRONG>All Implemented Interfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>, <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>AbstractWeightedPattern</STRONG>
extends java.lang.Object
implements <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></PRE>

<P>
<p>A skeletal implementation of the <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns"><CODE>WeightedPattern</CODE></A> interface to minimize
 the effort required to implement this interface.</p>

 <p>This implementation is based on using some "parent" pattern, implementing <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface
 and passed to the constructor.
 All methods of this class, excepting declared in the <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns"><CODE>WeightedPattern</CODE></A> interface,
 just call the same methods of the parent pattern.
 To complete implementation, you just need to implement several methods from
 the <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns"><CODE>WeightedPattern</CODE></A> interface.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#parent">parent</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The parent pattern.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.math.patterns.Pattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from interface net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE">MAX_COORDINATE</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Constructor Summary table, listing constructors, and an explanation">
<CAPTION CLASS="TableCaption">
Constructor Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Constructor and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#AbstractWeightedPattern(net.algart.math.patterns.Pattern)">AbstractWeightedPattern</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new weighted pattern on the base of the given parent one.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a non-empty list of all best or almost best
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>union decompositions</CODE></A>
 with equal or similar "quality",
 i&#46;e&#46; with the same or almost same summary number of points in all Minkowski decompositions
 of all returned patterns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#carcass()">carcass</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>carcass</i> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/RectangularArea.html" title="class in net.algart.math">RectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#coordArea()">coordArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal coordinates
 among all points of this pattern for all dimensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#coordMax()">coordMax</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the point, each coordinate of which
 is equal to the maximal corresponding coordinate
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#coordMin()">coordMin</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the point, each coordinate of which
 is equal to the minimal corresponding coordinate
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#coordRange(int)">coordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of space dimensions of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if the Minkowski decomposition,
 returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A> call,
 consists of 2 or more patterns:
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A>.size()&gt;1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#isConstant()">isConstant</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#weightRange()"><CODE>weightRange()</CODE></A>.<A HREF="../../../../net/algart/math/Range.html#size()"><CODE>size()</CODE></A>==0.0</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#isSurelyInteger()">isSurelyInteger</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern is <i>integer</i>:
 all coordinates of all points of this pattern are integer numbers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern consists of the single point and
 this point is the origin of coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#isSurelySinglePoint()">isSurelySinglePoint</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern consists of the single point, i&#46;e&#46;
 if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#largePointCount()">largePointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of points in this pattern as <tt>double</tt> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#maxBound(int)">maxBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>maximal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with greater coordinate <tt>#coordIndex</tt>
 and same other coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximal multiplier <i>k</i>, for which the calculation of
 the Minkowski multiple <i>k</i>&otimes;P can be optimized by using the <i>carcass</i> of this pattern P.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#minBound(int)">minBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>minimal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with less coordinate <tt>#coordIndex</tt>
 and same other coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates and returns the Minkowski sum of this and specified patterns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Minkowski decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is a Minkowski sum of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &oplus; P<sub>1</sub> &oplus;...&oplus; P<sub><i>n</i>&minus;1</sub></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates and returns the erosion of this pattern by specified pattern
 or <tt>null</tt> if this erosion is the empty set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#multiply(double)">multiply</A></STRONG>(double&nbsp;multiplier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the pattern consisting of points, generated from points of this instance
 by multiplying on the <tt>mult</tt> argument via <A HREF="../../../../net/algart/math/IPoint.html#multiply(double)"><CODE>IPoint.multiply(double)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#pointCount()">pointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of points in this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#points()">points</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#productDecomposition(int)">productDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt>Collections.singletonList(this)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the projection of this pattern along the given axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#round()">round</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, every point of which is rounded to the nearest integer point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#roundedCoordArea()">roundedCoordArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A> method,
 but all minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#roundedCoordRange(int)">roundedCoordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int coordIndex)</CODE></A> method,
 but both minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#roundedPoints()">roundedPoints</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of all <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math"><CODE>integer points</CODE></A>, obtained from the points of this pattern
 (results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method by rounding with help of
 <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#scale(double...)">scale</A></STRONG>(double...&nbsp;multipliers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multipliers along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#shift(net.algart.math.IPoint)">shift</A></STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the pattern shifted by the argument, that is consisting of points
 with the same <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weight(net.algart.math.IPoint)"><CODE>weights</CODE></A>,
 generated from points of this instance by adding the argument via <A HREF="../../../../net/algart/math/IPoint.html#add(net.algart.math.IPoint)"><CODE>IPoint.add(IPoint)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#shift(net.algart.math.Point)">shift</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, shifted by the argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#symmetric()">symmetric</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#unionDecomposition(int)">unionDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a union decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is the set-theoretical union of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &cup; P<sub>1</sub> &cup;...&cup; P<sub><i>n</i>&minus;1</sub></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#weight(net.algart.math.IPoint)">weight</A></STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the weight of the given point of the pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#weightRange()">weightRange</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal weights of all points of this pattern.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Field Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="parent"><!-- --></A><H3>
parent</H3>
<PRE>
protected final <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>parent</STRONG></PRE>
<DL>
<DD>The parent pattern.
<P>
</DD>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Constructor Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractWeightedPattern(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
AbstractWeightedPattern</H3>
<PRE>
protected <STRONG>AbstractWeightedPattern</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;parent)</PRE>
<DL>
<DD>Creates a new weighted pattern on the base of the given parent one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>parent</CODE> - the parent pattern, serving most of all methods of this instance.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
public int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the number of space dimensions of this pattern.
 This value is always positive (&gt;=1).

 <p>There is a guarantee, that this method always works very quickly (<i>O</i>(1) operations)
 and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()">dimCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of space dimensions of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pointCount()"><!-- --></A><H3>
pointCount</H3>
<PRE>
public long <STRONG>pointCount</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the number of points in this pattern.
 This value is always positive (&gt;=1).
 If the number of points is greater than <tt>Long.MAX_VALUE</tt>, returns <tt>Long.MAX_VALUE</tt>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points (result of this method).
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then the result of this method is not greater than <tt>Integer.MAX_VALUE</tt>.

 <p>Note: if this method returns some value greater than <tt>Integer.MAX_VALUE</tt>,
 it means that you cannot use <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> methods,
 because Java <tt>Set</tt> object cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">pointCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>points</CODE></A> in this pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>Pattern.largePointCount()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>Pattern.isSurelySinglePoint()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="largePointCount()"><!-- --></A><H3>
largePointCount</H3>
<PRE>
public double <STRONG>largePointCount</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the number of points in this pattern as <tt>double</tt> value.
 In particular, if the result of <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method is not greater than <tt>Long.MAX_VALUE</tt>,
 there is a guarantee that this method returns the same result, cast to <tt>double</tt> type.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points (result of this method).
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()">largePointCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>points</CODE></A> in this pattern as <tt>double</tt> value.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="points()"><!-- --></A><H3>
points</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt; <STRONG>points</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">Pattern</A></CODE></STRONG></DD>
<DD>Returns a set of all points of this pattern.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of this interface must be
 immutable).

 <p>The returned set is always non-empty,
 and the number of its elements is always equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.
 This method surely fails (throws one of these exception), if the total number of points
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&gt;Integer.MAX_VALUE</tt>, because Java <tt>Set</tt> object
 cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.

 <p>For example, implementations of the <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>
 allow to successfully define a very large 3D parallelepiped
 <nobr><i>n</i> x <i>n</i> x <i>n</i></nobr>.
 Fur such pattern, this method will require a lot of memory
 for <i>n</i>=1000 and will fail (probably with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>)
 for <i>n</i>=2000 (2000<sup>3</sup>&gt;<tt>Integer.MAX_VALUE</tt>).

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>Note: this method works very quickly (<i>O</i>(1) operations) in <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">points</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedPoints()"><!-- --></A><H3>
roundedPoints</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt; <STRONG>roundedPoints</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()">Pattern</A></CODE></STRONG></DD>
<DD><p>Returns the set of all <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math"><CODE>integer points</CODE></A>, obtained from the points of this pattern
 (results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method by rounding with help of
 <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method.
 In other words, the results of this method is the same as the result of the following code:
 <pre>
     Set&lt;IPoint&gt; result = new HashSet&lt;IPoint&gt;(); // or another Set implementation
     for (Point p : <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A>) {
         result.add(p.<A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>toRoundedPoint()</CODE></A>);
     }
     result = Collections.unmodifiableSet(result);
 </pre>

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of this interface must be
 immutable).

 <p>The returned set is always non-empty.

 <p>Note: the number of resulting points can be less than <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>, because some
 real points can be rounded to the same integer points.</p>

 <p>According the basic restriction to pattern coordinates (see
 the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Coordinate restrictions"),
 you may be sure that you will able
 to create an integer <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> pattern by passing the result of this method
 to <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A>.

 <p><b>Warning!</b> This method can work slowly or throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 / <tt>OutOfMemoryError</tt> in the same situations as <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 Please compare with <A HREF="../../../../net/algart/math/patterns/Pattern.html#round()"><CODE>Pattern.round()</CODE></A> method, which always works quickly and without exceptions also
 for the case of <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()">roundedPoints</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern, rounded to the nearest integer points.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordRange(int)"><!-- --></A><H3>
coordRange</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A> <STRONG>coordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.
 The minimal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#min()"><CODE>min()</CODE></A></tt>,
 the maximal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#max()"><CODE>max()</CODE></A></tt>,
 where <tt>r</tt> is the result of this method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>Moreover, all patterns, implemented in this package, have very quick implementations of this method
 (<i>O</i>(1) operations). Also, the implementations of this method in this package never throw exceptions.

 <p>It is theoretically possible, that in custom implementations of this interface
 (outside this package) this method will work slowly, up to <i>O</i>(<i>N</i>) operations,
 <i>N</i> is the number of points in this pattern.
 However, even in such implementations this method <i>must not</i> lead to
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>, like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">coordRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)"><CODE>Pattern.roundedCoordRange(int)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>Pattern.coordMin()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>Pattern.coordMax()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordArea()"><!-- --></A><H3>
coordArea</H3>
<PRE>
public <A HREF="../../../../net/algart/math/RectangularArea.html" title="class in net.algart.math">RectangularArea</A> <STRONG>coordArea</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the minimal and maximal coordinates
 among all points of this pattern for all dimensions.
 If <tt>a</tt> is the result of this method,
 then <tt>a.<A HREF="../../../../net/algart/math/RectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A>==<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>
 and <tt>a.<A HREF="../../../../net/algart/math/RectangularArea.html#range(int)"><CODE>range</CODE></A>(k)</tt>
 is equal to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange</CODE></A>(k)</tt> for all <tt>k</tt>.

 <p>For example, in 2-dimensional case the result is
 the circumscribed rectangle (with sides, parallel to the axes).

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()">coordArea</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal coordinate for all space dimensions.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()"><CODE>Pattern.roundedCoordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordMin()"><!-- --></A><H3>
coordMin</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>coordMin</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the point, each coordinate of which
 is equal to the minimal corresponding coordinate
 among all points of this pattern.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A>.<A HREF="../../../../net/algart/math/RectangularArea.html#min()"><CODE>min()</CODE></A></tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()">coordMin</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>minimal coordinates for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordMax()"><!-- --></A><H3>
coordMax</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>coordMax</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the point, each coordinate of which
 is equal to the maximal corresponding coordinate
 among all points of this pattern.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A>.<A HREF="../../../../net/algart/math/RectangularArea.html#max()"><CODE>max()</CODE></A></tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()">coordMax</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>maximal coordinates for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedCoordRange(int)"><!-- --></A><H3>
roundedCoordRange</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A> <STRONG>roundedCoordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int coordIndex)</CODE></A> method,
 but both minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange</CODE></A>(coordIndex).<A HREF="../../../../net/algart/math/Range.html#toRoundedRange()"><CODE>toRoundedRange()</CODE></A></tt>.

 <p>According the basic restriction to pattern coordinates (see
 the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Coordinate restrictions"),
 you may be sure that you will be able
 to create an integer <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular pattern</CODE></A> by passing the ranges, got by this method,
 to <A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IRange...)"><CODE>Patterns.newRectangularIntegerPattern(IRange...)</CODE></A>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)">roundedCoordRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index, rounded to the <tt>long</tt> values.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()"><CODE>Pattern.roundedCoordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedCoordArea()"><!-- --></A><H3>
roundedCoordArea</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A> <STRONG>roundedCoordArea</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A> method,
 but all minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.
 The method <A HREF="../../../../net/algart/math/IRectangularArea.html#range(int)"><CODE>IRectangularArea.range(int coordIndex)</CODE></A> in the returned area
 returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)"><CODE>Pattern.roundedCoordRange(int coordIndex)</CODE></A> method in this object.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>Pattern.coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()">roundedCoordArea</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal coordinate for all space dimensions,
         rounded to the <tt>long</tt> values.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelySinglePoint()"><!-- --></A><H3>
isSurelySinglePoint</H3>
<PRE>
public boolean <STRONG>isSurelySinglePoint</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">Pattern</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if this pattern consists of the single point, i&#46;e&#46;
 if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>.

 <p>There are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 consist of the single point. (In some complex situations, such analysis can
 be too difficult. In particular, if the pattern is a <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Minkowski sum</CODE></A>, then limited floating-point precision can lead to equality of all points of the result.
 Simple example: a Minkowski sum of two-point one-dimensional pattern, consisting of points
 0.0 and 0.000001, and one-point 2<sup>51</sup>=2251799813685248.0, contains only 1 point 2<sup>51</sup>,
 because the computer cannot represent precise value 2251799813685248.000001 in <tt>double</tt> type
 and rounds it to 2251799813685248.0.
 In such situations, this method sometimes <i>may</i> incorrectly return <tt>false</tt>.)

 <p>But there is the reverse guarantee: if this method returns <tt>true</tt>,
 the number of points in this pattern is always&nbsp;1.</p>

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 (and, so, <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method is not safe in use),
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and absolutely correctly
 (always returns <tt>true</tt> if and only if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">isSurelySinglePoint</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if it is one-point pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()"><CODE>Pattern.isSurelyOriginPoint()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyOriginPoint()"><!-- --></A><H3>
isSurelyOriginPoint</H3>
<PRE>
public boolean <STRONG>isSurelyOriginPoint</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()">Pattern</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if this pattern consists of the single point and
 this point is the origin of coordinates.

 <p>There are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 consist of the single point, equal to the origin of coordinates. (In some complex situations, such analysis can
 be too difficult. In such situations, this method <i>may</i> incorrectly return <tt>false</tt>.)
 But there is the reverse guarantee: if this method returns <tt>true</tt>,
 the number of points in this pattern is always 1 and its only point is the origin of coordinates,
 in terms of <A HREF="../../../../net/algart/math/Point.html#isOrigin()"><CODE>Point.isOrigin()</CODE></A> method.</p>

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 (and, so, <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method is not safe in use),
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and absolutely correctly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if it is one-point pattern containing the origin of coordinates as the single point.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>Pattern.isSurelySinglePoint()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="projectionAlongAxis(int)"><!-- --></A><H3>
projectionAlongAxis</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>projectionAlongAxis</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the projection of this pattern along the given axis.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is less by 1, than in this one.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the projection of this pattern (its <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is equal to
         <tt>thisInstance.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>-1</tt>).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyInteger()"><!-- --></A><H3>
isSurelyInteger</H3>
<PRE>
public boolean <STRONG>isSurelyInteger</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()">Pattern</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if this pattern is <i>integer</i>:
 all coordinates of all points of this pattern are integer numbers.
 In other words, it means that for each real (<tt>double</tt>) coordinate <i>x</i> of each point
 of this pattern the Java expression <i>x</i><tt>==(long)</tt><i>x</i> is <tt>true</tt>.

 <p>More precisely, if this method returns <tt>true</tt>, then there are the following guarantees:
 <ol>
 <li>for each point, returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method, as well as by
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>Pattern.coordMin()</CODE></A>/<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>Pattern.coordMax()</CODE></A>, <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>Point.isInteger()</CODE></A> method returns <tt>true</tt>;</li>
 <li>each pattern, returned in the results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>Pattern.minkowskiDecomposition(int)</CODE></A>,
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>Pattern.unionDecomposition(int)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)"><CODE>Pattern.allUnionDecompositions(int)</CODE></A> methods, is also surely integer,
 i.e. this method also returns <tt>true</tt> for it.</li>
 </ol>

 <p>However, there are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 is really integer. In other words, if this method returns <tt>false</tt>, there is no guarantee, that
 this pattern really contains some non-integer points &mdash; but it is probable.

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 and there is a risk to fail with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>See the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Integer patterns", for more details.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()">isSurelyInteger</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this pattern and all patterns of its decomposition
         (<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>Minkowski</CODE></A> or <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>union</CODE></A>)
         assuredly contain only <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>integer</CODE></A> points.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="round()"><!-- --></A><H3>
round</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>round</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#round()">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, every point of which is rounded to the nearest integer point.
 The result is always <i>ordinary integer pattern</i>
 (see the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Uniform-grid patterns").

 <p>More precisely, the resulting pattern:
 <ol>
 <li>consists of all points,
 obtained from all points of this pattern by rounding by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>toRoundedPoint()</CODE></A>.<A HREF="../../../../net/algart/math/IPoint.html#toPoint()"><CODE>toPoint()</CODE></A></tt>;</li>
 <li>has zero origin <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>UniformGridPattern.originOfGrid()</CODE></A>=(0,0,...,0)
 and unit steps <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>UniformGridPattern.stepsOfGrid()</CODE></A>={1,1,..,1}.</li>
 </ol>

 <p>Note: the number of points in the result can be less than <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>, because some
 real points can be rounded to the same integer points.</p>

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
 It is an important difference from <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.

 <p>The theorem I, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", provides a guarantee that this method never throws
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#round()">round</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the integer pattern, geometrically nearest to this one.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minBound(int)"><!-- --></A><H3>
minBound</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the <i>minimal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with less coordinate <tt>#coordIndex</tt>
 and same other coordinates.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, this method removes some points from this pattern according the following rule:
 if this pattern contains several points <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>, ...,
 <b>p</b><sub><i>m</i>&minus;1</sub> with identical projection to the given axis
 (<b>p</b><sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex).equals(</tt><b>p</b><sub><i>j</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex))</tt> for all <i>i</i>,&nbsp;<i>j</i>),
 then the resulting pattern contains only one from these points, for which
 the given coordinate <tt><A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(coordIndex)</tt> has the minimal value.

 <p>This method is especially useful for <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> patterns.
 For example, in <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 one of the facets of the hyperparallelepiped.
 In most cases (including all <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>)
 this method returns the same result as <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>UniformGridPattern.lowerSurface(int)</CODE></A>;
 but if the figure, described by this pattern, contains some "holes", the result of this method
 contains fewer points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>UniformGridPattern.lowerSurface(int)</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">minBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the minimal boundary of this pattern for the given axis.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)"><CODE>Pattern.maxBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxBound(int)"><!-- --></A><H3>
maxBound</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>maxBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the <i>maximal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with greater coordinate <tt>#coordIndex</tt>
 and same other coordinates.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, this method removes some points from this pattern according the following rule:
 if this pattern contains several points <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>, ...,
 <b>p</b><sub><i>m</i>&minus;1</sub> with identical projection to the given axis
 (<b>p</b><sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex).equals(</tt><b>p</b><sub><i>j</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex))</tt> for all <i>i</i>,&nbsp;<i>j</i>),
 then the resulting pattern contains only one from these points, for which
 the given coordinate <tt><A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(coordIndex)</tt> has the maximal value.

 <p>This method is especially useful for <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> patterns.
 For example, in <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 one of the facets of the hyperparallelepiped.
 In most cases (including all <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>)
 this method returns the same result as <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A>;
 but if the figure, described by this pattern, contains some "holes", the result of this method
 contains fewer points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">maxBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal boundary of this pattern for the given axis.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)"><CODE>Pattern.minBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="carcass()"><!-- --></A><H3>
carcass</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>carcass</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the <i>carcass</i> of this pattern.
 We define the <i>carcass</i> of the pattern P as such point set C, that, for some
 integer <i>n</i>&gt;=1:

 <ol type="I">
 <li>
 2&otimes;P = P &oplus; C;<br>
 4&otimes;P = (2&otimes;P) &oplus; 2C;<br>
 8&otimes;P = (4&otimes;P) &oplus; 4C;<br>
 ...<br>
 2<sup><i>n</i></sup>&otimes;P = (2<sup><i>n</i>&minus;1</sup>&otimes;P) &oplus;
 2<sup><i>n</i>&minus;1</sup>C;
 </li>
 <li>for any <i>m</i>=1,2,...,<i>n</i> and for any positive integer
 <i>k</i>&le;2<sup><i>m</i>&minus;1</sup>, we have<br>
 (2<sup><i>m</i>&minus;1</sup>+<i>k</i>)&otimes;P =
 (2<sup><i>m</i>&minus;1</sup>&otimes;P) &oplus; <i>k</i>C.</li>
 </ol>

 <p>Here A&oplus;B means the <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Minkowski sum</CODE></A> of patterns A and B,
 <i>k</i>&otimes;P means P&oplus;P&oplus;...&oplus;P (<i>k</i> summands),
 and <i>k</i>P means the pointwise geometrical multiplication of the pattern P by the multiplier <i>k</i>,
 i.e. <tt>P.<A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply</CODE></A>(<i>k</i>)</tt>.

 <p>This method tries to find the minimal carcass, consisting of as little as possible number of points,
 and the maximal value <i>n</i>, for which the formulas above are correct for the found carcass.
 (The value 2<sup><i>n</i></sup> is called the <i>maximal carcass multiplier</i>
 and is returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()"><CODE>Pattern.maxCarcassMultiplier()</CODE></A> method.)
 For example, for <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 the set of vertices of the hyperparallelepiped (in one-dimensional case, the pair of segment ends),
 and the corresponding <i>n</i>=+&infin;.
 But this method does not guarantee that the returned result is always the minimal possible carcass
 and that the found <i>n</i> is really maximal for this carcass.

 <p>This method allows to optimize calculation of the point set of a Minkowski multiple <i>k</i>&otimes;P.
 It is really used in the pattern implementations, returned
 by <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiMultiplePattern(net.algart.math.patterns.Pattern, int)"><CODE>Patterns.newMinkowskiMultiplePattern(Pattern, int)</CODE></A> method:
 the result of that method is not always an actual Minkowski sum of <i>N</i> equal patterns,
 but can be (in the best case) an equal Minkowski sum of ~log<sub>2</sub><i>N</i> patterns
 <nobr>P &oplus; C &oplus; 2C &oplus; ... &oplus; 2<i><sup>m</sup></i>C
 &oplus; (<i>N</i>&minus;2<sup><i>m</i></sup>C)</nobr>,
 2<sup><i>m</i></sup>&lt;<i>N</i>&le;2<sup><i>m</i>+1</sup>,
 or (in not the best case, when <i>N</i> is greater than the maximal carcass multiplier 2<sup><i>n</i></sup>)
 can be another, not so little Minkowski sum.

 <p>In the worst case (no optimization is possible), this method just returns this object (C=P),
 and <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()"><CODE>Pattern.maxCarcassMultiplier()</CODE></A> returns 2 (i.e. <i>n</i>=1).

 <p>The returned pattern has the same number of dimensions (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) as this one.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>This method can require some time and memory for execution,
 but never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <!-- below is a bug: sum of 2^ik*C is much greater, than k*C
 <p><small>
 Note: the condition II is a logical consequence from the conditions I.<br>
 Proof.<br>
 Let <i>k</i> = 2<sup><i>i</i><sub>1</sub></sup>+2<sup><i>i</i><sub>2</sub></sup>+...
 is the binary representation of the number <i>k</i>.
 According to the conditions I,
 <nobr>(2<sup><i>i<sub>k</sub></i></sup>&otimes;P) &oplus; 2<sup><i>i<sub>k</sub></i></sup>C
 = 2<sup><i>i<sub>k</sub></i>+1</sup>&otimes;P</nobr>.
 Summing these equations for all <i>i<sub>k</sub></i>, we have
 <nobr>(<i>k</i>&otimes;P) &oplus; <i>k</i>C = 2<i>k</i>&otimes;P</nobr>.
 So,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;(2<sup><i>m</i>&minus;1</sup>+<i>k</i>)&otimes;P
 = ((2<sup><i>m</i>&minus;1</sup>&minus;<i>k</i>)&otimes;P) &oplus;
 (2<i>k</i>&otimes;P)
 = ((2<sup><i>m</i>&minus;1</sup>&minus;<i>k</i>)&otimes;P) &oplus;
 (<i>k</i>&otimes;P) &oplus; <i>k</i>C
 = (2<sup><i>m</i>&minus;1</sup>&otimes;P) &oplus; <i>k</i>C.<br>
 This completes the proof.
 </small></p>
 -->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">carcass</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the <i>carcass</i> of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxCarcassMultiplier()"><!-- --></A><H3>
maxCarcassMultiplier</H3>
<PRE>
public int <STRONG>maxCarcassMultiplier</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the maximal multiplier <i>k</i>, for which the calculation of
 the Minkowski multiple <i>k</i>&otimes;P can be optimized by using the <i>carcass</i> of this pattern P.
 Please see <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>Pattern.carcass()</CODE></A> method for more information.

 <p>Note: the returned value is always &ge;2. If the correct value is greater than <tt>Integer.MAX_VALUE</tt>
 (for example, for <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>),
 this method returns <tt>Integer.MAX_VALUE</tt>; in all other cases the returning value is a power of two.

 <p>This method can require some time and memory for execution,
 but never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 Usually an implementation caches the results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>Pattern.carcass()</CODE></A> and this methods,
 so this method works very quickly after the first call of <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>Pattern.carcass()</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal multiplier (&ge;2),
         for which the calculation of the Minkowski multiple can be optimized
         by using the <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>carcass</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiAdd(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiAdd</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiAdd</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">Pattern</A></CODE></STRONG></DD>
<DD>Calculates and returns the Minkowski sum of this and specified patterns.
 Briefly, the returned pattern consists of all points <i>a</i>+<i>b</i>, where
 <i>a</i> is any point of this pattern, <i>b</i> is any point of the argument "<tt>added</tt>"
 and "+" means a vector sum of two points
 (the result of "<i>a</i>.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(<i>b</i>)" call).
 Please see details in
 <noindex><a href="http://en.wikipedia.org/wiki/Minkowski_addition">Wikipedia</a></noindex>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions".

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern and <tt>subtracted</tt> argument implement <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 and both patterns have identical <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>steps</CODE></A>
 (i.e. <tt>thisPattern.<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)"><CODE>stepsOfGridEqual</CODE></A>(subtracted)</tt> returns <tt>true</tt>).
 In this case, this method works very quickly and without
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> exceptions.

 <p>Please draw attention: there is another way to build a Minkowski sum,
 namely the method <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>.
 That method does not perform actual calculations and returns a special implementation
 of this interface (see <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Complex patterns").
 Unlike that method, this one tries to actually calculate the Minkowski sum, saving (when possible)
 the type of the original pattern: see above two guarantees about <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> types. If it is impossible to represent the Minkowski sum
 by Java class of this pattern, it is probable that the result will be constructed
 as <A HREF="../../../../net/algart/math/patterns/DirectPointSetUniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetUniformGridPattern</CODE></A> or as <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>added</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the Minkowski sum of this and another patterns.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiSubtract(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiSubtract(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiSubtract</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiSubtract</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">Pattern</A></CODE></STRONG></DD>
<DD>Calculates and returns the erosion of this pattern by specified pattern
 or <tt>null</tt> if this erosion is the empty set.
 Briefly, the returned pattern consists of all such points <i>p</i>,
 that for any points <i>b</i> of the "<tt>subtracted</tt>" pattern the vector sum of two points
 <i>p</i>+<i>b</i>
 (the result of "<i>p</i>.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(<i>b</i>)" call)
 belongs to this pattern.
 Please see more details in
 <noindex><a href="http://en.wikipedia.org/wiki/Erosion_%28morphology%29">Wikipedia</a></noindex> and
 Google about the "Erosion" and "Minkowski subtraction" terms.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions". But it is obvious, that this exception
 is impossible if the passed pattern "<tt>subtracted</tt>" contains the origin of coordinates
 (in this case, the result is a subset of this pattern).

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern and <tt>subtracted</tt> argument implement <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 and both patterns have identical <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>steps</CODE></A>
 (i.e. <tt>thisPattern.<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)"><CODE>stepsOfGridEqual</CODE></A>(subtracted)</tt> returns <tt>true</tt>).
 In this case, this method works very quickly and without
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>subtracted</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the erosion of this pattern by the specified pattern
         or <tt>null</tt> if this erosion is the empty set.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiDecomposition(int)"><!-- --></A><H3>
minkowskiDecomposition</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>minkowskiDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the Minkowski decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is a Minkowski sum of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &oplus; P<sub>1</sub> &oplus;...&oplus; P<sub><i>n</i>&minus;1</sub></nobr>.
 In other words, each point <b>p</b>&isin;P of this pattern is equal to a vector sum
 of some <i>n</i> points
 <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>,&nbsp;..., <b>p</b><sub><i>n</i>&minus;1</sub>,
 where <b>p</b><sub><i>i</i></sub>&isin;P<sub><i>i</i></sub>.
 Please see <noindex><a href="http://en.wikipedia.org/wiki/Minkowski_addition">Wikipedia</a></noindex>
 about the "Minkowski sum" term.

 <p>This method tries to find the best decomposition, that means the list of patterns
 with minimal summary number of points. For good pattern, the returned patterns list
 can consist of <i>O</i>(log<sub>2</sub><i>N</i>) points (sum of <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>
 values for all returned patterns),
 where <i>N</i> is the number of points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>) in this pattern.
 For example, a linear one-dimensional segment {<i>x</i>: 0&lt;=x&lt;2<i><sup>m</sup></i>}
 is a Minkowski sum of <i>m</i> point pairs {0, 2<i><sup>i</sup></i>}, <i>i</i>=0,1,...,<i>m</i>-1.

 <p>There is no guarantee that this method returns a good decomposition.
 If this method cannot find required decomposition, it returns the 1-element list containing
 this instance as the only element.

 <p>If the number of points in this pattern is less than the argument, i.e.
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&lt;minimalPointCount</tt>, then this method probably does not
 decompose this pattern and returns the 1-element list containing this instance as its element.
 But it is not guaranteed: if the method "knows" some decomposition, but estimation of the number of points
 can require a lot of resources, this method may ignore <tt>minimalPointCount</tt> argument.

 <p>However, there is a guarantee that if the number of points is 1 or 2,
 i.e. <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&le;2</tt>, then this method always returns
 the 1-element list containing this instance as its element.

 <p>There is a guarantee that the elements of the resulting list cannot be further decomposed:
 this method, called for them with the same or larger <tt>minimalPointCount</tt> argument,
 always returns a list consisting of one element.

 <p>The number of space dimensions in all returned patterns (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is the same as in this one.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableList</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the decomposition of this pattern to Minkowski sum; always contains &ge;1 elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hasMinkowskiDecomposition()"><!-- --></A><H3>
hasMinkowskiDecomposition</H3>
<PRE>
public boolean <STRONG>hasMinkowskiDecomposition</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#hasMinkowskiDecomposition()">Pattern</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if and only if the Minkowski decomposition,
 returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A> call,
 consists of 2 or more patterns:
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A>.size()&gt;1</tt>.

 <p>In some situations this method works essentially faster then the actual
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A> call.

 <p>Note that if this method returns <tt>true</tt>, then <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> and
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>Pattern.largePointCount()</CODE></A> methods can work very slowly and even may fail with
 <tt>OutOfMemoryError</tt> or <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the Minkowski decomposition contains 2 or more elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unionDecomposition(int)"><!-- --></A><H3>
unionDecomposition</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>unionDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns a union decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is the set-theoretical union of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &cup; P<sub>1</sub> &cup;...&cup; P<sub><i>n</i>&minus;1</sub></nobr>.

 <p>This method tries to find such decomposition, that all patterns P<sub><i>i</i></sub> have good
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>Minkowski decompositions</CODE></A>
 and the summary number of points in all Minkowski decompositions
 <nobr>P<sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(minimalPointCount)</CODE></A></tt></nobr>
 of all patterns, returned by this method, is as small as possible &mdash;
 usually much less than the number of points in this instance.
 If this pattern already has a good Minkowski decompositions,
 this method should return the 1-element list containing
 this instance as the only element.

 <p>If the number of points in this pattern is less than the argument, i.e.
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&lt;minimalPointCount</tt>, then this method probably does not
 decompose this pattern and returns the 1-element list containing this instance as its element.
 Moreover, this method tries to build such decomposition, that every element P<sub><i>i</i></sub>
 in the resulting list contains <tt>&ge;minimalPointCount</tt> elements.

 <p>There is a guarantee that the elements of the resulting list cannot be further decomposed:
 this method, called for them with the same or larger <tt>minimalPointCount</tt> argument,
 always returns a list consisting of one element.

 <p>The number of space dimensions in all returned patterns (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is the same as in this one.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableList</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)">unionDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a decomposition of this pattern into the union of patterns; always contains &ge;1 elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="allUnionDecompositions(int)"><!-- --></A><H3>
allUnionDecompositions</H3>
<PRE>
public java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt; <STRONG>allUnionDecompositions</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns a non-empty list of all best or almost best
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>union decompositions</CODE></A>
 with equal or similar "quality",
 i&#46;e&#46; with the same or almost same summary number of points in all Minkowski decompositions
 of all returned patterns.

 <p>This method is a useful addition to <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>Pattern.unionDecomposition(int)</CODE></A> method for a case,
 when there are several union decompositions with similar "quality".
 In this case an algorithm, using union decompositions, is able to choose
 the best from several variants according additional algorithm-specific criteria.

 <p>The number of space dimensions in all returned patterns (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is the same as in this one.

 <p>The result of this method and the elements of the result are immutable
 (<tt>Collections.unmodifiableList</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>several good variants of decomposition of this pattern to the union of patterns;
         the result always contains &ge;1 elements,
         and all its elements also contain &ge;1 elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shift(net.algart.math.Point)"><!-- --></A><H3>
shift</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A> <STRONG>shift</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, shifted by the argument.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call <tt>point.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(shift)</tt>.

 <!--Repeat.SectionStart simple_corrections_features-->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.SectionEnd simple_corrections_features-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>However, <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> is impossible in many important cases, when
 this pattern is an <i>integer</i> pattern and each coordinate
 <nobr><i>X</i><sub><i>j</i></sub>=<tt>shift.<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(</tt><i>j</i><tt>)</tt></nobr>
 of the argument is equal to &minus;<i>x</i><sub><i>j</i></sub> for some some point
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 of this pattern.
 In particular, you can use this method for <i>integer</i> patterns without a risk of
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> in the following situations:
 <ul>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>p.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>, where <tt>p</tt> is
 some of the <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points</CODE></A> if this integer pattern.</li>
 </ul>
 <p>See more details in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", the theorem II.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">shift</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shift(net.algart.math.IPoint)"><!-- --></A><H3>
shift</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A> <STRONG>shift</STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;shift)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#shift(net.algart.math.IPoint)">WeightedPattern</A></CODE></STRONG></DD>
<DD>Returns the pattern shifted by the argument, that is consisting of points
 with the same <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weight(net.algart.math.IPoint)"><CODE>weights</CODE></A>,
 generated from points of this instance by adding the argument via <A HREF="../../../../net/algart/math/IPoint.html#add(net.algart.math.IPoint)"><CODE>IPoint.add(IPoint)</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#shift(net.algart.math.IPoint)">shift</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="multiply(double)"><!-- --></A><H3>
multiply</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A> <STRONG>multiply</STRONG>(double&nbsp;multiplier)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#multiply(double)">WeightedPattern</A></CODE></STRONG></DD>
<DD>Returns the pattern consisting of points, generated from points of this instance
 by multiplying on the <tt>mult</tt> argument via <A HREF="../../../../net/algart/math/IPoint.html#multiply(double)"><CODE>IPoint.multiply(double)</CODE></A> method.

 <p>If <tt>mult</tt> is not an integer, the generated real coordinates are rounded to integer values.
 If several source points are rounded to the same integer point, the <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weight(net.algart.math.IPoint)"><CODE>weights</CODE></A>
 of the resulting points may differ from the weights of the source ones,
 but the sum of all weights will be approximately same.
 If the all source points are transformed to different points,
 their weights are preserved.

 <p><i>Please note:</i> if <tt>mult</tt> is not an integer,
 the algorithm of rounding <i>is not strictly specified</i>!
 However, you can be sure that the new pattern will be near from the precise result.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)">multiply</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#multiply(double)">multiply</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multiplier</CODE> - the multiplier.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the product of this pattern and the given scalar <tt>mult</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>Pattern.scale(double...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="scale(double...)"><!-- --></A><H3>
scale</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A> <STRONG>scale</STRONG>(double...&nbsp;multipliers)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, scaled by the specified multipliers along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#scale(double...)"><CODE>scale</CODE></A>(multipliers)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large multipliers).
 However, such failure is obviously impossible, if all multipliers are
 in range <tt>-1.0&lt;=multipliers[k]&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">scale</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#scale(double...)">scale</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multipliers</CODE> - the scales along coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>Pattern.multiply(double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="symmetric()"><!-- --></A><H3>
symmetric</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A> <STRONG>symmetric</STRONG>()</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.
 There are no reasons to override this method usually.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()">symmetric</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#symmetric()">symmetric</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the symmetric pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="weight(net.algart.math.IPoint)"><!-- --></A><H3>
weight</H3>
<PRE>
public abstract double <STRONG>weight</STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;point)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weight(net.algart.math.IPoint)">WeightedPattern</A></CODE></STRONG></DD>
<DD>Returns the weight of the given point of the pattern.
 The result is undefined if this point is outside the pattern.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weight(net.algart.math.IPoint)">weight</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>point</CODE> - some <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math"><CODE>integer point</CODE></A>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the weight of this point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="weightRange()"><!-- --></A><H3>
weightRange</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A> <STRONG>weightRange</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weightRange()">WeightedPattern</A></CODE></STRONG></DD>
<DD>Returns the minimal and maximal weights of all points of this pattern.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#weightRange()">weightRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the minimal and maximal weights of all points of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isConstant()"><!-- --></A><H3>
isConstant</H3>
<PRE>
public boolean <STRONG>isConstant</STRONG>()</PRE>
<DL>
<DD>This implementation returns <tt><A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html#weightRange()"><CODE>weightRange()</CODE></A>.<A HREF="../../../../net/algart/math/Range.html#size()"><CODE>size()</CODE></A>==0.0</tt>.
 There are no reasons to override this method usually.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#isConstant()">isConstant</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the weights of all points are the same.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="productDecomposition(int)"><!-- --></A><H3>
productDecomposition</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A>&gt; <STRONG>productDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>This implementation returns <tt>Collections.singletonList(this)</tt>.
 Please override this method if there is better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html#productDecomposition(int)">productDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method does not try to decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the decomposition of this pattern to the "product" (convolution) of smaller patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/AbstractWeightedPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractWeightedPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
