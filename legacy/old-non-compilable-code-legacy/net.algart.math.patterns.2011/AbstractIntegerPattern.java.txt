package net.algart.math.patterns;

import java.util.*;
import net.algart.math.IPoint;
import net.algart.math.IRange;
import net.algart.math.Point;

/**
 * <p>A skeletal implementation of the {@link Pattern} interface to minimize
 * the effort required to implement this interface.</p>
 *
 * <p>AlgART Laboratory 2007-2012</p>
 *
 * @author Daniel Alievsky
 * @version 1.2
 * @since JDK 1.5
 */
abstract class AbstractIntegerPattern extends AbstractUniformGridPattern implements UniformGridPattern {

    private static final int MAX_NUMBER_OF_POINTS_IN_NEW_PARALLELEPIPED_WHILE_CHECKING_LARGE_CARCASSES = (int)4e6;
    // - the maximal number of points in the circumscribed parallelepiped of NEW checked pattern n(x)P(+)n(x)P
    // must be less than this limit. This limit must be 31-bit value.
    // The total number of required bit-per-bit operations is about (this limit)*(the number of points in the carcass);
    // the number of real long-per-long operations will be less in 64 times.

    private static final int MIN_POINT_COUNT_TO_OPTIMIZE_MINKOWSKI_ADD = 32;
    private static final double MAX_RELATION_OF_PARALLELEPIPED_VOLUME_TO_THIS_TO_OPTIMIZE_IN_MINKOWSKI_ADD = 200.0;

    private final boolean trivialUnionDecomposition;

    private volatile Boolean isOrigin = null;
    volatile Boolean isRectangular = null;
    final IRange[] integerCoordRanges;
    final UniformGridPattern[] lowerSurface;
    final UniformGridPattern[] upperSurface;
    volatile UniformGridPattern surface;
    private volatile UniformGridPattern carcass;
    private volatile int maxCarcassMultiplier;
    private volatile List<List<Pattern>> minkowskiDecompositions;
    private volatile List<List<List<Pattern>>> allUnionDecompositions;

    /**
     * The number of space dimensions of this pattern.
     */
    protected final int dimCount;

    /**
     * Creates a pattern with the given number of space dimensions.
     *
     * <p>The <tt>trivialUnionDecomposition</tt> determines behavior of
     * {@link #unionDecomposition(int)} and {@link #allUnionDecompositions(int)} methods.
     * If it is <tt>false</tt>, they will perform some common algorithm
     * suitable for most patterns, that have no good Minkowski decompositions (alike spheres).
     * If it is <tt>true</tt>, they will return degenerated decomposition
     * consisting of this pattern as the only element.
     * You should use <tt>true</tt> argument in inheritors that have
     * a good Minkowski decomposition.
     *
     * @param dimCount                  the number of space dimensions.
     * @param trivialUnionDecomposition whether this pattern has the degenerated union decomposition.
     * @throws IllegalArgumentException if <tt>dimCount&lt;=0</tt>.
     */
    protected AbstractIntegerPattern(int dimCount, boolean trivialUnionDecomposition) {
        super(Point.origin(dimCount),
            Point.valueOfEqualCoordinates(dimCount, 1.0).coordinates(),
            trivialUnionDecomposition);
        this.dimCount = dimCount;
        this.trivialUnionDecomposition = trivialUnionDecomposition;
        this.integerCoordRanges = new IRange[dimCount]; //zero-filled
        this.lowerSurface = new UniformGridPattern[dimCount]; //zero-filled
        this.upperSurface = new UniformGridPattern[dimCount]; //zero-filled
        this.minkowskiDecompositions = new ArrayList<List<Pattern>>(16);
        for (int k = 0; k < 16; k++)
            this.minkowskiDecompositions.add(null);
        this.allUnionDecompositions = new ArrayList<List<List<Pattern>>>(16);
        for (int k = 0; k < 16; k++)
            this.allUnionDecompositions.add(null);
    }

    public abstract long pointCount();

    /**
     * This implementation returns <tt>(double){@link #pointCount()}</tt>.
     * Please override this method if the pattern can contain more than <tt>Long.MAX_VALUE</tt> points.
     *
     * @return the number of {@link IPoint integer points} in this pattern.
     */
    public double largePointCount() {
        return (double)pointCount();
    }

    /**
     * This implementation returns <tt>false</tt>.
     * Please override this method if the pattern can contain more than <tt>Long.MAX_VALUE</tt> points.
     *
     * @return <tt>true</tt> if the number of points in this pattern is greater than <tt>Long.MAX_VALUE</tt>.
     */
    public boolean isVeryLarge() {
        return false;
    }

    public abstract boolean contains(IPoint point);

    public Set<Point> points() {
        Set<Point> result = new HashSet<Point>();
        for (IPoint p : roundedPoints()) {
            result.add(p.toPoint());
        }
        return Collections.unmodifiableSet(result);
    }

    public abstract Set<IPoint> roundedPoints();

    /**
     * This implementation is based on the loop on the point set returned by {@link #roundedPoints()} method.
     * This algorithm may be slow for large patterns and does not work at all if the number of points
     * is greater than <tt>Integer.MAX_VALUE</tt>.
     * This method caches its results: the following calls will work faster.
     * Please override this method if there is better implementation.
     *
     * @param coordIndex the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)
     * @return           the range from minimal to maximal coordinate with this index.
     * @throws IndexOutOfBoundsException if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;={@link #dimCount()}</tt>.
     */
    public IRange roundedCoordRange(int coordIndex) {
        checkCoordIndex(coordIndex);
        synchronized(integerCoordRanges) {
            if (integerCoordRanges[coordIndex] == null) {
                long min = Long.MAX_VALUE, max = Long.MIN_VALUE;
                Set<IPoint> points = roundedPoints();
                for (IPoint p : points) {
                    long coord = p.coord(coordIndex);
                    min = Math.min(min, coord);
                    max = Math.max(max, coord);
                }
                integerCoordRanges[coordIndex] = IRange.valueOf(min, max);
            }
            return integerCoordRanges[coordIndex];
        }
    }

    /**
     * This implementation is based on the loop on calls of {@link #roundedCoordRange(int)} method
     * for all coordinate indexes from <tt>0</tt> to <tt>{@link #dimCount()}-1</tt>.
     *
     * @return the ranges from minimal to maximal coordinate for all space dimensions.
     */
    public IRange[] roundedCoordRanges() {
        IRange[] result = new IRange[dimCount()];
        for (int k = 0; k < result.length; k++)
            result[k] = roundedCoordRange(k);
        return result;
    }

    /**
     * This implementation is based on the loop on calls of {@link #roundedCoordRange(int)} method
     * for all coordinate indexes from <tt>0</tt> to <tt>{@link #dimCount()}-1</tt>.
     *
     * @return minimal coordinates for all space dimensions as a point.
     */
    public IPoint roundedCoordMin() {
        long[] coordinates = new long[dimCount()];
        for (int k = 0; k < coordinates.length; k++) {
            coordinates[k] = roundedCoordRange(k).min();
        }
        return IPoint.valueOf(coordinates);
    }

    /**
     * This implementation is based on the loop on calls of {@link #roundedCoordRange(int)} method
     * for all coordinate indexes from <tt>0</tt> to <tt>{@link #dimCount()}-1</tt>.
     *
     * @return maximal coordinates for all space dimensions as a point.
     */
    public IPoint roundedCoordMax() {
        long[] coordinates = new long[dimCount()];
        for (int k = 0; k < coordinates.length; k++) {
            coordinates[k] = roundedCoordRange(k).max();
        }
        return IPoint.valueOf(coordinates);
    }

    /**
     * This implementation checks {@link #pointCount()}, and if it's 1, checks whether the only element
     * of {@link #roundedPoints()} set is the origin.
     * This method caches its results: the following calls will work faster.
     *
     * @return <tt>true</tt> if it is one-point pattern containing the origin of coordinates as the single point.
     */
    public boolean isOriginPoint() {
        if (isOrigin == null) {
            isOrigin = pointCount() == 1 && roundedPoints().iterator().next().isOrigin();
        }
        return isOrigin;
    }

    /**
     * This implementation returns <tt>true</tt> if and only if
     * <tt>{@link #pointCount()}=</tt><i>r</i><sub>0</sub><i>r</i><sub>1</sub>...<tt>&lt;Long.MAX_VALUE</tt>,
     * where <i>r<sub>i</sub></i><tt>={@link #roundedCoordRange(int) roundedCoordRange(<i>i</i>)}</tt>.
     * This method caches its results: the following calls will work faster.
     * This method should be overridden for rectangular patterns or for patterns that surely are not rectangular.
     *
     * @return <tt>true</tt> if this pattern is <i>n</i>-dimensional rectangular parallelepiped.
     */
    public boolean isRectangular() {
        check:
        if (isRectangular == null) {
            long count = 1;
            for (int k = 0; k < dimCount; k++) {
                long size = roundedCoordRange(k).size();
                count = Patterns.longMul(count, size);
                if (count == Long.MIN_VALUE || count == Long.MAX_VALUE) {
                    // MAX_VALUE is also prohibited here: it may be returned by pointCount() for large number of points
                    isRectangular = false; break check;
                }
            }
            isRectangular = count == pointCount();
        }
        return isRectangular;
    }

    public boolean isInteger() {
        return true;
    }

    public UniformGridPattern round() {
        return this;
    }

    /**
     * This implementation is based on the loop on the point set returned by {@link #roundedPoints()} method.
     * This algorithm may be slow for large patterns
     * (<i>O</i>(<i>N</i>) or <i>O</i>(<i>N</i>log<sub>2</sub><i>N</i>) operations,
     * <i>N</i>={@link #pointCount()})
     * and does not work at all if the number of points <i>N</i>
     * is greater than <tt>Integer.MAX_VALUE</tt>.
     * This method caches its results: the following calls will work faster.
     * Please override this method if there is better implementation.
     *
     * @param coordIndex the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)
     * @return           the "left boundary" of this pattern: new pattern consisting of all
     *                   {@link IPoint integer points} without leftward neighbour along the given coordinate.
     * @throws IndexOutOfBoundsException if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;={@link #dimCount()}</tt>.
     */
    public UniformGridPattern lowerSurface(int coordIndex) {
        checkCoordIndex(coordIndex);
        synchronized(lowerSurface) {
            if (lowerSurface[coordIndex] == null) {
                long[] shiftCoordinates = new long[dimCount()]; // zero-filled
                shiftCoordinates[coordIndex] = -1;
                IPoint shift = IPoint.valueOf(shiftCoordinates);
                Set<IPoint> points = roundedPoints();
                Set<IPoint> resultPoints = new HashSet<IPoint>();
                for (IPoint ip : points) {
                    if (ip.coord(coordIndex) == Long.MIN_VALUE // avoiding overflow in the next check
                        || !points.contains(ip.add(shift))) {
                        resultPoints.add(ip);
                    }
                }
                lowerSurface[coordIndex] = Patterns.newIPattern(resultPoints);
            }
            return lowerSurface[coordIndex];
        }
    }

    /**
     * This implementation is based on the loop on the point set returned by {@link #roundedPoints()} method.
     * This algorithm may be slow for large patterns
     * (<i>O</i>(<i>N</i>) or <i>O</i>(<i>N</i>log<sub>2</sub><i>N</i>) operations,
     * <i>N</i>={@link #pointCount()})
     * and does not work at all if the number of points <i>N</i>
     * is greater than <tt>Integer.MAX_VALUE</tt>.
     * This method caches its results: the following calls will work faster.
     * Please override this method if there is better implementation.
     *
     * @param coordIndex the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)
     * @return           the "right boundary" of this pattern: new pattern consisting of all
     *                   {@link IPoint integer points} without rightward neighbour along the given coordinate.
     * @throws IndexOutOfBoundsException if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;={@link #dimCount()}</tt>.
     */
    public UniformGridPattern upperSurface(int coordIndex) {
        checkCoordIndex(coordIndex);
        synchronized(upperSurface) {
            if (upperSurface[coordIndex] == null) {
                long[] shiftCoordinates = new long[dimCount()]; // zero-filled
                shiftCoordinates[coordIndex] = 1;
                IPoint shift = IPoint.valueOf(shiftCoordinates);
                Set<IPoint> points = roundedPoints();
                Set<IPoint> resultPoints = new HashSet<IPoint>();
                for (IPoint ip : points) {
                    if (ip.coord(coordIndex) == Long.MIN_VALUE // avoiding overflow in the next check
                        || !points.contains(ip.add(shift))) {
                        resultPoints.add(ip);
                    }
                }
                upperSurface[coordIndex] = Patterns.newIPattern(resultPoints);
            }
            return upperSurface[coordIndex];
        }
    }

    /**
     * This implementation is based on the loop on the point set returned by {@link #roundedPoints()} method.
     * This algorithm may be slow for large patterns
     * (<i>O</i>(<i>N</i>) or <i>O</i>(<i>N</i>log<sub>2</sub><i>N</i>) operations,
     * <i>N</i>={@link #pointCount()})
     * and does not work at all if the number of points <i>N</i>
     * is greater than <tt>Integer.MAX_VALUE</tt>.
     * This method caches its results: the following calls will work faster.
     * Please override this method if there is better implementation.
     *
     * @return the "surface" of this pattern: new pattern consisting of all
     *         {@link IPoint integer points} without at least one neighbour along some coordinate.
     * @throws IndexOutOfBoundsException if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;={@link #dimCount()}</tt>.
     */
    public Pattern surface() {
        if (surface == null) {
            Set<IPoint> resultPoints = new HashSet<IPoint>();
            for (int k = 0; k < dimCount; k++) {
                resultPoints.addAll(lowerSurface(k).roundedPoints());
                resultPoints.addAll(upperSurface(k).roundedPoints());
            }
            surface = Patterns.newIPattern(resultPoints);
        }
        return surface;
    }

    /**
     * This method is fully implemented in this class and usually should not be overridden.
     * If you override it, you must override {@link #maxCarcassMultiplier()} also,
     * because that method returns the private field calculated by this one.
     *
     * @return the <i>carcass</i> of this pattern.
     */
    public UniformGridPattern carcass() {
        if (pointCount() <= 2) {
            maxCarcassMultiplier = Integer.MAX_VALUE;
            return this;
        }
        if (carcass == null) {
            if (isRectangular()) {
                IRange[] ranges = roundedCoordRanges();
                long[] vertex = new long[dimCount()];
                Set<IPoint> vertices01 = Patterns.newRectangularIPattern(
                    Collections.nCopies(vertex.length, IRange.valueOf(0, 1)).toArray(new IRange[0])).roundedPoints();
                // - all vertices of [0..1]^dimCount parallelepiped
                Set<IPoint> resultPoints = new HashSet<IPoint>();
                for (IPoint vertex01 : vertices01) {
                    for (int k = 0; k < vertex.length; k++) {
                        long coord = vertex01.coord(k);
                        assert coord == 0 || coord == 1;
                        vertex[k] = coord == 1 ? ranges[k].max() : ranges[k].min();
                    }
                    resultPoints.add(IPoint.valueOf(vertex));
                }
                maxCarcassMultiplier = Integer.MAX_VALUE;
                carcass = Patterns.newIPattern(resultPoints);
            } else {
                IPoint correctionShift = this.roundedCoordMin();
                Pattern p = this.shift(correctionShift.symmetric()); // provides non-negative coordinates only

                Set<IPoint> shifts = Patterns.newRectangularIPattern(
                    Collections.nCopies(dimCount(), IRange.valueOf(-2, 2)).toArray(new IRange[0])).roundedPoints();
                // - all shifts inside of [-2..2]^dimCount parallelepiped
                Set<IPoint> bestBoundaryForDirection = null;
                Set<IPoint> intersectionOfBoundaries = null;
                Set<IPoint> points = p.roundedPoints();
                int minPointCount = Integer.MAX_VALUE;
                for (IPoint shift : shifts) {
                    if (shift.isOrigin()) {
                        continue;
                    }
                    IPoint halfShift = shift.multiply(0.5);
                    if (shift.equals(halfShift.multiply(2.0))) {
                        // all coordinates are even, for example, (2,0) or (-2,2):
                        // no sense to check such trivial shift in addition to its half
                        continue;
                    }
                    IPoint shiftSymmetric = shift.symmetric();
                    Set<IPoint> boundaryForDirection = new HashSet<IPoint>();
                    for (IPoint ip : points) {
                        boolean overflow = false;
                        for (int k = 0, n = dimCount(); k < n; k++) {
                            long coord = ip.coord(k);
                            if (coord >= Long.MAX_VALUE - 1 || coord <= Long.MIN_VALUE + 1) {
                                overflow = true; break;
                            }
                        }
                        if (overflow // to be on the safe side
                            || !points.contains(ip.add(shift))
                            || !points.contains(ip.add(shiftSymmetric)))
                        {
                            boundaryForDirection.add(ip);
                        }
                    }
                    int pointCount = boundaryForDirection.size();
                    if (bestBoundaryForDirection == null || pointCount < minPointCount) {
                        bestBoundaryForDirection = boundaryForDirection;
                        minPointCount = pointCount;
                    }
                    if (intersectionOfBoundaries == null) {
                        intersectionOfBoundaries = new HashSet<IPoint>(boundaryForDirection);
                    } else {
                        intersectionOfBoundaries.retainAll(boundaryForDirection);
                    }
                }
                UniformGridPattern alwaysWorkingCarcass = Patterns.newIPattern(bestBoundaryForDirection);
                UniformGridPattern goodCarcass = Patterns.newIPattern(intersectionOfBoundaries);
                if (dimCount() <= 1 || // strange use: why to build carcass for 1-dimensional segments?
                    dimCount() > 16 || // very strange: probably too large to check
                    intDimensions(p) == null) // too large to check (>=2^31)
                {
                    maxCarcassMultiplier = 2;
                    // - see below the contrary instance after "c = alwaysWorkingCarcass" assignment
                    return carcass = alwaysWorkingCarcass.shift(correctionShift);
                }
                // Now we are sure that we have from 2 to 16 dimensions: it will be used by the algorithm
                IRange[] ranges = p.roundedCoordRanges(); //32bit ranges
                for (int k = 0; k < ranges.length; k++) {
                    ranges[k] = IRange.valueOf(2 * ranges[k].min(), 2 * ranges[k].max()); //maximum 33bit ranges
                }
                UniformGridPattern circumscribed2P = Patterns.newRectangularIPattern(ranges);
                // Now "circumscribed" contains 2(x)P
                if (circumscribed2P.largePointCount() >
                    MAX_NUMBER_OF_POINTS_IN_NEW_PARALLELEPIPED_WHILE_CHECKING_LARGE_CARCASSES) // too large to check
                {
                    maxCarcassMultiplier = 2;
                    return carcass = alwaysWorkingCarcass.shift(correctionShift);
                }
                long m = 1;
                for (; ; ) {
                    // Now "circumscribed" pattern contains 2m(x)P.
                    // Let's check the volume of the circumscribed of 4m(x)P
                    long newVolume = 1;
                    for (int k = 0; k < ranges.length; k++) {
                        ranges[k] = IRange.valueOf(2 * ranges[k].min(), 2 * ranges[k].max());
                        newVolume *= ranges[k].size();
                        // Overflow impossible: the volume at the previous step was 31-bit value,
                        // and now it is increased less than in 2^dimCount()<=2^16 times.
                    }
                    if (newVolume > MAX_NUMBER_OF_POINTS_IN_NEW_PARALLELEPIPED_WHILE_CHECKING_LARGE_CARCASSES)
                        break;
                    m *= 2;
                }
                UniformGridPattern circumscribed2mP = Patterns.newRectangularIPattern(ranges);
                // Now we are sure that the circumscribed parallelepiped contains 2m(x)P
                // and is not too large, essentially less than 2^31
                int[] dimensions = intDimensions(circumscribed2mP);
                assert dimensions != null:"Probably too large "
                    + "MAX_NUMBER_OF_POINTS_IN_NEW_PARALLELEPIPED_WHILE_CHECKING_LARGE_CARCASSES constant";

                TinyBitMatrix temp1 = new TinyBitMatrix(dimensions); // allocating first matrix
                TinyBitMatrix temp2 = new TinyBitMatrix(dimensions); // allocating second matrix
                int lastDim = (int)circumscribed2P.roundedCoordRange(dimensions.length - 1).size();
                int lastButOneDim = (int)circumscribed2P.roundedCoordRange(dimensions.length - 2).size();
                dimensions[dimensions.length - 2] = lastButOneDim;
                dimensions[dimensions.length - 1] = lastDim;
                TinyBitMatrix temp = temp1.reDim(dimensions);
                TinyBitMatrix multiple = temp2.reDim(dimensions);
                // Now we will process reduced matrices and increase them:
                // all other bits are zero, because we work with positive points only
                temp.putPattern(p);
                multiple.simpleDilation(temp, goodCarcass); // multiple = P(+)C
                long correctCardinality = multiple.cardinality();
                multiple.simpleDilation(temp, alwaysWorkingCarcass); // multiple = P(+)P
                long probableCardinality = multiple.cardinality();
                int n = 1;
                UniformGridPattern c = goodCarcass;
                if (probableCardinality != correctCardinality) {
                    c = alwaysWorkingCarcass;
                    // There is a simple theorem that for any kind of pattern P(+)P = P(+)c in this case.
                    // Really, let P = union of segments Si along the chosen axis,
                    // the ends of these segments are the points of the found boundary.
                    // Then P(+)P = union of all Si(+)Sj, where we can suppose |Si|>=|Sj|
                    // (to include each pair in this union only once).
                    // Here Si(+)Sj = Si(+)Cj, where Cj is a pair of ends of Sj,
                    // so P(+)P = union of all Si(+)Cj, where |Si|>=|Sj|.
                    // And P(+)c = union of all Si(+)Cj for ANY i, j.
                    // So, P(+)c is a superset of P(+)P.
                    // The inverse statement is obvious: P(+)c is a subset of P(+)P.
                    // The theorem is proved.
                    //
                    // Unfortunately, it's still possible that 4(x)P != 2(x)P (+) 2*c.
                    // The contrary instance: 1-dimensional (!) pattern {0, 1, 2, 10}.
                    // Here 2(x)P = {0..4, 10..12, 20}, c = {0, 2, 10}, 2*c = {0, 4, 20},
                    // 4(x)P = {0..8, 10..16, 20..24, 30..32, 40}, but
                    // 2(x)P (+) 2*c = {0..8, 10..12, 14..16, 20..24, 30..32, 40}.
                    // So, we must test "alwaysWorkingCarcass" below, as well as the better "goodCarcass" pattern.
                }
                // Now P(+)P=P(+)c, P is this pattern
                UniformGridPattern nc = c; // will be n*c; now n=1
                for (; n < m; ) {
                    // Here 2n<=m, so we are sure that the circumscribed parallelepiped contains 4n(x)P.
                    // Now multiple = 2n(x)P = n(x)P (+) n*c (here k(x)P means P(+)P(+)...(+)P, k times)
                    // Let's check whether 4n(x)P = 2x(x)P (+) 2n*c
                    if (4 * n < 0) {
                        assert 4 * n == Integer.MIN_VALUE;
                        break; // no sense for further checks: 4n = 2^31 > Integer.MAX_VALUE
                    }
//                    System.out.println("Checking " + n + " " + numberOfOperations + "," + circumscribed + ", " + c);

                    lastDim = 2 * lastDim - 1;
                    lastButOneDim = 2 * lastButOneDim - 1;
                    multiple = increaseMatrixBy2LastCoordinates(multiple, lastDim, lastButOneDim);
                    temp = temp.reDim(multiple.dimensions());

                    UniformGridPattern nc2 = nc.multiply(2); // 2n*c
                    temp.simpleDilation(multiple, nc2);
                    // temp = 2x(x)P (+) 2n*c
                    probableCardinality = temp.cardinality();

                    temp.simpleDilation(multiple, nc);
                    multiple.simpleDilation(temp, nc);
                    // multiple = 4n(x)P, because 2n(x)P (+) 2n(x)P =
                    // = n(x)P (+) n(x)P (+) 2n(x)P =
                    // = n(x)P (+) (n(x)P (+) n(x)P) (+) n*c =
                    // = n(x)P (+) (n(x)P (+) n*c) (+) n*c =
                    // = 2n(x)P (+) n*c (+) n*c
                    correctCardinality = multiple.cardinality();
                    if (probableCardinality != correctCardinality) {
                        break;
                    }
                    // So, 4n(x)P = 2x(x)P (+) 2n*c
                    nc = nc2;
                    n *= 2;
                }
                // Now 2n(x)P = n(x)P (+) n(*)c,
                // and the same statement if true for 1, 2, 4, ..., n/2 (n is a power of two).
                // Moreover, we state that, for any k < n, (n+k)(x)P = n(x)P (+) k(*)c.
                // Proof.
                // Let k = 2^i1 + 2^i2 + ... (binary representation of the number k).
                // then k(x)P (+) k(*)c = (2^i1(x)P (+) 2^i1*c) (+) (2^i2(x)P (+) 2^i2*c) (+) ... = 2k(x)P.
                // (n+k)(x)P = (n-k)(x)P (+) 2k(x)P = (n-k)(x)P (+) k(x)P (+) k(*)c = n(x)P (+) k(*)c.
                // The statement is proved.
                // The same statement if true for n/2, n/4, ...
                // It means that for any k, 0<=k<=2n, we have
                // k(x)P = P (+) c (+) 2*c (+) ... (+) 2^(i-1)*c (+) (k-2^i)*c,
                // where i is the maximal integer for which 2^i<k.
                maxCarcassMultiplier = 2 * n;
                carcass = c.shift(correctionShift);
            }
        }
        return carcass;
    }

    /**
     * This method is fully implemented in this class and usually should not be overridden.
     *
     * @return the maximal multiplier, for which the calculation of the Minkowski multiple can be optimized
     *         by using the {@link #carcass() carcass}.
     */
    public int maxCarcassMultiplier() {
        if (isRectangular())
            return Integer.MAX_VALUE;
        carcass(); // filling maxCarcassMultiplier
        return maxCarcassMultiplier;
    }

    @Override
    public UniformGridPattern shift(Point shift) {
        return shift(shift.toRoundedPoint());
    }

    public abstract UniformGridPattern shift(IPoint shift);

    public abstract UniformGridPattern scale(double... multipliers);

    /**
     * This implementation calls {@link #multiply(double) multiply(-1.0)}.
     * There are no reasons to override this method usually.
     *
     * @return the symmetric pattern.
     */
    public UniformGridPattern symmetric() {
        return multiply( -1.0);
    }

    /**
     * This implementation is based on the loop on all points returned by {@link #roundedPoints()} method in both patterns
     * and always returns the {@link Patterns#newIPattern(Collection) simple pattern}
     * consisting of sums of all point pairs.
     * This algorithm may be very slow for large patterns
     * (<i>O</i>(<i>NM</i>) operations, <i>N</i>={@link #pointCount()}, <i>M</i>=added.{@link #pointCount()})
     * and does not work at all if the number of resulting points is greater than <tt>Integer.MAX_VALUE</tt>.
     * Please override this method if there is better implementation.
     *
     * @param added another pattern.
     * @return      the Minkowski sum of this and another patterns.
     * @throws NullPointerException     if the argument is <tt>null</tt>.
     * @throws IllegalArgumentException if the numbers of space dimensions of both patterns are different.
     */
    public Pattern minkowskiAdd(Pattern added) {
        if (added == null)
            throw new NullPointerException("Null added argument");
        if (added.dimCount() != this.dimCount())
            throw new IllegalArgumentException("Dimensions count mismatch: "
                + added.dimCount() + " instead of " + this.dimCount());
        long addedPointCount = added.pointCount();
        if (addedPointCount == 1) {
            return shift(added.coordMin().toRoundedPoint());
        }

        if (pointCount() < MIN_POINT_COUNT_TO_OPTIMIZE_MINKOWSKI_ADD
            && addedPointCount < MIN_POINT_COUNT_TO_OPTIMIZE_MINKOWSKI_ADD)
        {
            return Patterns.newIPattern(simpleMinkowskiSum(roundedPoints(), added.roundedPoints()));
        }

        Pattern halfCircumscribed = Patterns.newRectangularIPattern(roundedCoordRanges()).multiply(0.5)
            .minkowskiAdd(Patterns.newRectangularIPattern(added.roundedCoordRanges()).multiply(0.5));
        // division by 2 is used to avoid overflow
        double volumeOfCircumscribed = halfCircumscribed.largePointCount() * Math.pow(2.0, dimCount());
        // The number of operations in the optimized algorithm is ~volumeOfCircumscribed*added.pointCount()
        // (very quick bit operations);
        // the number of operations in the simpleMinkowskiSum is ~this.pointCount()*added.pointCount()
        if (volumeOfCircumscribed > largePointCount()
            * MAX_RELATION_OF_PARALLELEPIPED_VOLUME_TO_THIS_TO_OPTIMIZE_IN_MINKOWSKI_ADD)
        {
            return Patterns.newIPattern(simpleMinkowskiSum(roundedPoints(), added.roundedPoints()));
        }

        // Now we are sure that volumeOfCircumscribed is not too large,
        // if this.pointCount can be represented by "int" type.
        // If this.pointCount is greater than Integer.MAX_VALUE, the simple algorithm is also not applicable:
        // so, OutOfMemoryError and IllegalArgumentException are suitable results.

        Pattern circumscribedOfThis = Patterns.newRectangularIPattern(roundedCoordRanges());
        Pattern circumscribedOfAdded = Patterns.newRectangularIPattern(added.roundedCoordRanges());
        Pattern circumscribed = circumscribedOfThis.minkowskiAdd(circumscribedOfAdded);
        // (may throw TooLargePatternException for too large patterns)

        int[] dimensions = intDimensions(circumscribed);
        if (dimensions == null)
            throw new TooLargePatternException("Too large pattern for Minkowski adding: "
                + "some dimensions are 2^31 or greater");

        IPoint thisShift = circumscribedOfThis.coordMin().toRoundedPoint();
        IPoint addedShift = circumscribedOfAdded.coordMin().toRoundedPoint();
        TinyBitMatrix src = new TinyBitMatrix(dimensions);
        src.putPattern(this.shift(thisShift.symmetric()));
        // shifting is necessary to provide positive coordinates for the following getPattern method
        TinyBitMatrix dest = new TinyBitMatrix(dimensions);
        dest.simpleDilation(src, added.shift(addedShift.symmetric()));
        // shifting is necessary to provide positive coordinates for the following getPattern method
        return dest.getIPattern().shift(thisShift.add(addedShift));

        /*
        // OLD OPTIMIZATION ALGORITHM BASED ON UNION DECOMPOSITION

        // decomposition to segments
        long maxRangeSizeHalf = Long.MIN_VALUE;
        int coordIndex = -1;
        for (int k = 0; k < dimCount; k++) {
            long resultRangeSizeHalf = roundedCoordRange(k).size() / 2 + added.roundedCoordRange(k).size() / 2;
            // division by 2 is used to avoid overflow
            if (resultRangeSizeHalf > maxRangeSizeHalf) {
                maxRangeSizeHalf = resultRangeSizeHalf;
                coordIndex = k;
            }
        }
        // coordIndex corresponds to maximally "long" dimension

        Set<IPoint> thisPoints = this.roundedPoints();
        List<IPoint> thisPointsList = new ArrayList<IPoint>(thisPoints);
        List<IPoint> thisRetainedList = new ArrayList<IPoint>();
        List<Pattern> thisDecomposition = joinPointsToSegments(thisPointsList, thisRetainedList, coordIndex,
            MIN_SEGMENT_LENGTH_IN_MINKOWSKI_ADD);

        Set<IPoint> addedPoints = added.roundedPoints();
        boolean equalPatterns = thisPoints.equals(addedPoints);
        List<IPoint> addedPointsList = equalPatterns ? thisPointsList : new ArrayList<IPoint>(addedPoints);
        List<IPoint> addedRetainedList = equalPatterns ? thisRetainedList : new ArrayList<IPoint>();
        List<Pattern> addedDecomposition = equalPatterns ? thisDecomposition :
            joinPointsToSegments(addedPointsList, addedRetainedList, coordIndex,
            MIN_SEGMENT_LENGTH_IN_MINKOWSKI_ADD);

        Set<IPoint> resultPoints = new HashSet<IPoint>();
        resultPoints.addAll(simpleMinkowskiSum(thisPointsList, addedRetainedList));
        if (!equalPatterns) {
            resultPoints.addAll(simpleMinkowskiSum(addedPointsList, thisRetainedList));
        }
        for (Pattern firstSegment : thisDecomposition) {
            for (Pattern secondSegment : addedDecomposition) {
                Pattern sum = firstSegment.minkowskiAdd(secondSegment); // quick operation for rectangular patterns
                resultPoints.addAll(sum.roundedPoints());
            }
        }
        if (!equalPatterns) {
            for (Pattern firstSegment : addedDecomposition) {
                for (Pattern secondSegment : thisDecomposition) {
                    Pattern sum = firstSegment.minkowskiAdd(secondSegment); // quick operation for rectangular patterns
                    resultPoints.addAll(sum.roundedPoints());
                }
            }
        }
        return Patterns.newIPattern(resultPoints);
        */
    }

    /**
     * This implementation is based on the loop on all points returned by {@link #roundedPoints()} method in both patterns
     * and always returns the {@link Patterns#newIPattern(Collection) simple pattern}
     * consisting of sums of all point pairs.
     * This algorithm may be very slow for large patterns
     * (<i>O</i>(<i>NM</i>) operations, <i>N</i>={@link #pointCount()}, <i>M</i>=added.{@link #pointCount()})
     * and does not work at all if the number of resulting points is greater than <tt>Integer.MAX_VALUE</tt>.
     * Please override this method if there is better implementation.
     *
     * @param subtracted another pattern.
     * @return           the erosion of this pattern by the specified pattern
     *                   or <tt>null</tt> if this erosion is the empty set.
     * @throws NullPointerException     if the argument is <tt>null</tt>.
     * @throws IllegalArgumentException if the numbers of space dimensions of both patterns are different.
     */
    public Pattern minkowskiSubtract(Pattern subtracted) {
        if (subtracted == null)
            throw new NullPointerException("Null subtracted argument");
        if (subtracted.dimCount() != this.dimCount())
            throw new IllegalArgumentException("Dimensions count mismatch: "
                + subtracted.dimCount() + " instead of " + this.dimCount());
        Set<IPoint> subtractedPoints = subtracted.roundedPoints();
        Set<IPoint> points = roundedPoints();
        Set<IPoint> resultPoints = new HashSet<IPoint>();
        for (IPoint p : points) {
            boolean add = true;
            for (IPoint q : subtractedPoints) {
                if (!points.contains(p.add(q))) {
                    add = false; break;
                }
            }
            if (add) {
                resultPoints.add(p);
            }
        }
        return resultPoints.isEmpty() ? null : Patterns.newIPattern(resultPoints);
    }

    /**
     * This implementation returns <tt>Collections.&lt;Pattern&gt;singletonList(thisInstance)</tt>
     * for non-rectangular patterns or a good decomposition if {@link #isRectangular()} method
     * returns <tt>true</tt>.
     * This method caches its results for several little values of the argument:
     * the following calls will work faster.
     * Please override this method if there is better implementation.
     *
     * @param minimalPointCount this method does not try to decompose patterns that contain
     *                          less than <tt>minimalPointCount</tt> points.
     *                          In particular, if the minkowski sum of several patterns containing
     *                          less than <tt>minimalPointCount</tt> points, this method should return
     *                          this sum in the resulting list instead of its summands.
     * @return                  the decomposition of this pattern to Minkowski sum.
     * @throws IllegalArgumentException if the argument is negative.
     */
    public List<Pattern> minkowskiDecomposition(int minimalPointCount) {
        if (minimalPointCount < 0)
            throw new IllegalArgumentException("Negative minimalPointCount");
        if (!isRectangular()) {
            return Collections.<Pattern>singletonList(this);
        }
        // Below is decomposition of rectangular patterns only
        long pointCount = pointCount();
        if (pointCount <= 2) {
            return Collections.<Pattern>singletonList(this);
        }
        if (minimalPointCount < minkowskiDecompositions.size()) {
            List<Pattern> result = minkowskiDecompositions.get(minimalPointCount);
            if (result != null)
                return result;
        }
        if (pointCount < minimalPointCount || pointCount <= 1)
            return Collections.<Pattern>singletonList(this);
        IRange[] coordRanges = roundedCoordRanges(); // actualization of all coordinate ranges
        boolean joinShortSegments = minimalPointCount > 4;
        // no sense to check shorter segments in the loop below:
        // in the best case, such a check will replace 2-point pattern (0, 1) with rectangular pattern (0, 1)
        List<Pattern> result = new ArrayList<Pattern>();
        long[] shifts = new long[coordRanges.length];
        long[] coordinates = new long[coordRanges.length]; // zero-filled
        IPoint origin = IPoint.valueOf(coordinates);
        boolean allShiftsAreZero = true;
        for (int k = 0; k < coordRanges.length; k++) {
            shifts[k] = coordRanges[k].min();
            allShiftsAreZero &= shifts[k] == 0;
            boolean startSegmentAdded = false;
            for (long m = 1, n = coordRanges[k].size(), sumLen = 1; sumLen < n; m *= 2) {
                assert m == sumLen:"m != sumLen";
                if (m > n - sumLen)
                    m = n - sumLen;
                if (sumLen + m >= minimalPointCount && joinShortSegments && !startSegmentAdded) {
                    // sumLen + m is new summary length after the adding the summand at this loop iteration
                    coordinates[k] = sumLen - 1;
                    result.add(Patterns.newRectangularIPattern(origin, IPoint.valueOf(coordinates)));
                    startSegmentAdded = true;
                }
                sumLen += m;
                if (!joinShortSegments || sumLen >= minimalPointCount) {
                    coordinates[k] = m;
                    result.add(new TwoPointsIPattern(origin, IPoint.valueOf(coordinates)));
                }
            }
            coordinates[k] = 0; // restoring zero coordinate
        }
        if (!allShiftsAreZero) {
            result.add(new OnePointIPattern(IPoint.valueOf(shifts)));
            // It's better than correction of the last patter:
            // one-point pattens may be usually processed very quickly (lazily),
            // and two-point pattern are usually processed better if they have positive points only.
        }
        result = Collections.unmodifiableList(result);
        if (minimalPointCount < minkowskiDecompositions.size()) {
            minkowskiDecompositions.set(minimalPointCount, result);
        }
        return result;
    }

    /**
     * This implementation returns
     * <tt>{@link #minkowskiDecomposition(int) minkowskiDecomposition(0)}.size()&gt;1</tt>.
     * Please override this method if {@link #minkowskiDecomposition(int)} method
     * works slowly and it's possible to know, whether the pattern has Minkowski decomposition, much faster.
     *
     * @return <tt>true</tt> if the Minkowski decomposition contains 2 or more elements.
     */
    public boolean hasMinkowskiDecomposition() {
        return minkowskiDecomposition(0).size() > 1;
    }

    /**
     * This implementation returns <tt>{@link #allUnionDecompositions(int)
     * allUnionDecompositions(minimalPointCount)}.get(0)</tt>.
     *
     * @param minimalPointCount the minimal number of points in every pattern in the resulting decomposition:
     *                          all pattern containing less points should be joined into one element
     *                          of the resulting list.
     * @return                  the decomposition of this pattern to the union of patterns.
     * @throws IllegalArgumentException if the argument is negative.
     */
    public List<Pattern> unionDecomposition(int minimalPointCount) {
        return allUnionDecompositions(minimalPointCount).get(0);
    }

    /**
     * This implementation uses a common algorithm that usually provide good results.
     * This method caches its results for several little values of the argument:
     * the following calls will work faster.
     * Please override this method if the better implementation is known.
     *
     * @param minimalPointCount the minimal number of points in every pattern in all resulting decompositions:
     *                          all pattern containing less points should be joined into one element
     *                          of the resulting list.
     * @return                  several good variants of decomposition of this pattern to the union of patterns.
     * @throws IllegalArgumentException if the argument is negative.
     */
    public List<List<Pattern>> allUnionDecompositions(int minimalPointCount) {
        if (minimalPointCount < 0)
            throw new IllegalArgumentException("Negative minimalPointCount");
        if (trivialUnionDecomposition) {
            return Collections.singletonList(Collections.<Pattern>singletonList(this));
        }
        if (minimalPointCount < allUnionDecompositions.size()) {
            List<List<Pattern>> result = allUnionDecompositions.get(minimalPointCount);
            if (result != null)
                return result;
        }
        List<IPoint> points = new ArrayList<IPoint>(roundedPoints());
        if (points.size() < minimalPointCount) {
            return Collections.singletonList(Collections.<Pattern>singletonList(this));
        }
        List<IPoint> retainedPoints = new ArrayList<IPoint>();
        List<List<Pattern>> decompositions = new ArrayList<List<Pattern>>();
        long[] totalSizes = new long[dimCount];
        long bestTotalSize = Long.MAX_VALUE;
        for (int coordIndex = 0; coordIndex < dimCount; coordIndex++) {
            retainedPoints.clear();
            List<Pattern> result = joinPointsToSegments(points, retainedPoints, coordIndex, minimalPointCount);

            // Adding retained points
            if (!retainedPoints.isEmpty()) {
                result.add(Patterns.newIPattern(retainedPoints.toArray(new IPoint[0])));
            }

            // Calculating the quality and storing the result
            long totalSize = 0;
            for (Pattern ptn : result) {
                long pointCount = ptn.pointCount();
                if (ptn instanceof UniformGridPattern && ((UniformGridPattern)ptn).isRectangular() && pointCount >= minimalPointCount) {
                    totalSize += 2 * (64 - Long.numberOfLeadingZeros(pointCount - 1));
                } else {
                    totalSize += pointCount;
                }
            }
            decompositions.add(result);
            totalSizes[coordIndex] = totalSize;
            if (totalSize <= bestTotalSize)
                bestTotalSize = totalSize;
        }
        List<List<Pattern>> bestResults = new ArrayList<List<Pattern>>();
        for (int dimIndex = 0; dimIndex < dimCount; dimIndex++) {
            if (totalSizes[dimIndex] == bestTotalSize)
                bestResults.add(decompositions.get(dimIndex));
        }
        assert!bestResults.isEmpty():"Empty bestResults";
        List<List<Pattern>> result = Collections.unmodifiableList(bestResults);
        if (minimalPointCount < allUnionDecompositions.size()) {
            allUnionDecompositions.set(minimalPointCount, result);
        }
        return result;
    }

    public Point originOfGrid() {
        return Point.origin(dimCount);
    }

    public double[] stepsOfGrid() {
        double[] result = new double[dimCount];
        Arrays.fill(result, 1.0);
        return result;
    }

    public double stepOfGrid(int coordIndex) {
        return 1.0;
    }

    public IRange gridIndexRange(int coordIndex) {
        return roundedCoordRange(coordIndex);
    }

    public UniformGridPattern gridIndexPattern() {
        return this;
    }

    boolean containsGridIndex(IPoint gridIndex) {
        return contains(gridIndex);
    }

    Set<IPoint> gridIndexes() {
        return roundedPoints();
    }

    AbstractUniformGridPattern shiftGridIndexes(IPoint shift) {
        return (AbstractUniformGridPattern)shift(shift);
    }

    private static TinyBitMatrix increaseMatrixBy2LastCoordinates(TinyBitMatrix matrix,
        int newLastDim, int newLastButOneDim)
    {
        int[] dim = matrix.dimensions();
        if (dim.length < 2)
            throw new AssertionError("This method cannot process 1-dimensional matrices");
        if (newLastDim < dim[dim.length - 1])
            throw new AssertionError("This method cannot reduce the matrix");
        if (newLastButOneDim < dim[dim.length - 2])
            throw new AssertionError("This method cannot reduce the matrix");

        long mult = 1;
        for (int k = 0; k < dim.length - 2; k++) {
            mult *= dim[k];
        }
        long oldHyperplaneSize = dim[dim.length - 2] * mult; // x-dim for 2-dimensional case
        long newHyperplaneSize = newLastButOneDim * mult;
        int n = dim[dim.length - 1]; // y-dim for 2-dimensional case
        dim[dim.length - 2] = newLastButOneDim;
        dim[dim.length - 1] = newLastDim;
        long[] array = matrix.array();
        TinyBitMatrix result = matrix.reDim(dim);
        long oldDisp = n * oldHyperplaneSize;
        long newDisp = n * newHyperplaneSize;
        for (int k = n - 1; k >= 0; k--) {
            oldDisp -= oldHyperplaneSize;
            newDisp -= newHyperplaneSize;
            TinyBitArrays.copyBits(array, newDisp, array, oldDisp, oldHyperplaneSize);
            TinyBitArrays.fillBits(array, newDisp + oldHyperplaneSize, newHyperplaneSize - oldHyperplaneSize, false);
        }
        return result;
    }

    private static Set<IPoint> simpleMinkowskiSum(Collection<IPoint> first, Collection<IPoint> second) {
        Set<IPoint> resultPoints = new HashSet<IPoint>();
        for (IPoint p : first) {
            for (IPoint q : second) {
                resultPoints.add(p.add(q));
            }
        }
        return resultPoints;
    }

    // points argument is updated (sorted), retainedPoints argument is appended
    // Returns the list of segments
    private static List<Pattern> joinPointsToSegments(List<IPoint> points, List<IPoint> retainedPoints,
        final int coordIndex, int minimalPointCount)
    {
        List<Pattern> result = new ArrayList<Pattern>();
        if (points.isEmpty()) // to be on the safe side: never occurs for pattern's point set
            return result;
        Collections.sort(points, new Comparator<IPoint>() {
            public int compare(IPoint o1, IPoint o2) {
                return o1.compareTo(o2, coordIndex);
            }
        });
        IPoint last = points.get(0);
        final int coordCount = last.coordCount();
        IPoint min = last;
        int minIndex = 0;
        final int n = points.size();
        for (int k = 1; k < n; k++) {
            IPoint p = points.get(k);
            boolean newSegment = false;
            for (int j = 0; j < coordCount; j++) {
                long lastCoord = last.coord(j);
                long nextCoord = p.coord(j);
                if (nextCoord != (j == coordIndex ? lastCoord + 1 : lastCoord)) {
                    newSegment = true; break;
                }
            }
            if (newSegment) { // minIndex..k-1 is the previous segment
                int len = k - minIndex;
                if (len >= minimalPointCount) {
                    result.add(Patterns.newRectangularIPattern(min, last));
                } else {
                    retainedPoints.addAll(points.subList(minIndex, k));
                }
                minIndex = k;
                min = p;
            }
            last = p;
        }
        int len = n - minIndex; // last possible segment
        if (len >= minimalPointCount) {
            result.add(Patterns.newRectangularIPattern(min, last));
        } else {
            retainedPoints.addAll(points.subList(minIndex, n));
        }
        return result;
    }
}
