/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2007-2019 Daniel Alievsky, AlgART Laboratory (http://algart.net)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.algart.executable.preprocessor.java;

import java.io.*;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * <p>Simple preprocessor based on regular expression for Java and other source code.</p>
 *
 * @author Daniel Alievsky
 * @version 1.2
 * @since JDK 1.6
 */
public class Repeater implements Cloneable {
    static class SyntaxException extends Exception {
        SyntaxException(String message) {
            super("Illegal Repeater syntax" + message);
        }

        private static final long serialVersionUID = 1283256722407269023L;
    }

    static final String CHARSET = "UTF-8";

    static String[] BEGIN_OF_COMMENTS = {"//<<", "//[[", "/*", "(*", "#[[", "#<<", "<!--"};
    static String[] END_OF_COMMENTS = {">>", "]]", "*/", "*)", "]]", ">>", "-->"};
    static boolean[] IS_ONE_LINE_COMMENT = {true, true, false, false, true, true, false};
    static String[] appendByBraces(String s, boolean fromLeft, boolean fromRight) {
        String[] result = new String[BEGIN_OF_COMMENTS.length];
        for (int k = 0; k < result.length; k++)
            result[k] = (fromLeft ? BEGIN_OF_COMMENTS[k] : "") + s + (fromRight ? END_OF_COMMENTS[k] : "");
        return result;
    }

    // We should not use in this file a code combination processed by Repeater!

    static String[] BEGIN_OF_COMMENTS_RE = {"//<<", "//\\[\\[", "/\\*", "\\(\\*", "#\\[\\[", "#<<", "<!--"};
    static String[] END_OF_COMMENTS_RE = {">>", "\\]\\]", "\\*/", "\\*\\)", "\\]\\]", ">>", "-->"};
    static final String[] REPEAT_START = appendByBraces("Repeat(", true, false);
    static final String REPEAT_MIDDLE_WARN = "Repeat.AutoGeneratedStart";
    static final String[] REPEAT_MIDDLE = appendByBraces(REPEAT_MIDDLE_WARN, true, false);
    static final String REPEAT_END_WARN = "Repeat.AutoGeneratedEnd";
    static final String[] REPEAT_END = appendByBraces(REPEAT_END_WARN, true, true);
    static final String REPEAT_INCLUDE_END_WARN = "Repeat.IncludeEnd";
    static final String[] REPEAT_INCLUDE_END = appendByBraces(REPEAT_INCLUDE_END_WARN, true, true);
    static final String REPEAT_SECTION_START_RE = "Repeat\\.SectionStart";
    static final String REPEAT_SECTION_END_RE = "Repeat\\.SectionEnd";
    static final String ANY_REPEAT_RE =
        "//<<Repeat[\\.\\(].*?>>[ \\t]*"
        + "|//\\[\\[Repeat[\\.\\(].*?\\]\\][ \\t]*"
        + "|/\\*Repeat[\\.\\(].*?\\*/\\s*"
        + "|\\(\\*Repeat[\\.\\(].*?\\*\\)\\s*"
        + "|#\\[\\[Repeat[\\.\\(].*?\\]\\][ \\t]*"
        + "|#<<Repeat[\\.\\(].*?>>[ \\t]*"
        + "|<!--Repeat[\\.\\(].*?-->\\s*";
    static final String INCLUDE_OPTION = "INCLUDE_FROM_FILE";
    static final String INCLUDE_OPTION_ALT = "IFF"; // when necessary to be brief
    static final String THIS_FILE = "THIS_FILE";
    static final String SHIFT_OPTION = "SHIFT";
    static final String AUTO_GENERATION_WARNING = "!! Auto-generated: NOT EDIT !!";
    static final String INCLUDE_WARNING = "!! Auto-generated: NOT EDIT !!";

    static Map<String, Pattern> allPatterns = Collections.synchronizedMap(new HashMap<String, Pattern>());
    static Pattern compilePatternDotAll(String regex) {
        Pattern p = allPatterns.get(regex);
        if (p == null) {
            p = Pattern.compile(regex, Pattern.DOTALL);
            allPatterns.put(regex, p);
        }
        return p;
    }
    static final Pattern PATTERN_LINE_START = Pattern.compile("^", Pattern.MULTILINE);

    static final ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    private static final Object lock = new Object();

    private File processedFile;
    private String processedContent;
    private boolean trimTrailingWhitespace;
    private boolean onlyTrimTrailingWhitespace;
    private boolean warningOnTabs;
    private boolean removeAllIncludes;

    void setProcessedFile(File value) {
        this.processedFile = value;
    }

    void setTrimTrailingWhitespace(boolean value) {
        this.trimTrailingWhitespace = value;
    }

    void setOnlyTrimTrailingWhitespace(boolean value) {
        this.onlyTrimTrailingWhitespace = value;
    }

    void setWarningOnTabs(boolean value) {
        this.warningOnTabs = value;
    }

    void setRemoveAllIncludes(boolean value) {
        this.removeAllIncludes = value;
    }

    static String dup(char c, int len) {
        char[] chars = new char[len];
        for (int k = 0; k < len; k++)
            chars[k] = c;
        return String.valueOf(chars);
    }

    static int countLines(String s) {
        int result = 1;
        Matcher m = Pattern.compile("\\r(?!\\n)|\\n|\\r\\n", Pattern.DOTALL).matcher(s);
        while (m.find())
            result++;
        return result;
    }

    int countLines() {
        return countLines(processedContent.substring(0, currentPosition));
    }

    static String trimComments(String s) {
        s = s.trim();
        if (s.startsWith("//"))
            s = s.substring(2).trim();
        else if (s.startsWith("#"))
            s = s.substring(1).trim();
        return s;
    }

    static String read(File file) throws IOException {
        synchronized (lock) {
            InputStream inputStream = new FileInputStream(file);
            StringBuilder sb = new StringBuilder();
            InputStreamReader reader = new InputStreamReader(inputStream, CHARSET);
            try {
                char[] buf = new char[32768];
                int len;
                while ((len = reader.read(buf)) >= 0) {
                    sb.append(buf, 0, len);
                }
                return sb.toString();
            } finally {
                reader.close();
            }
        }
    }

    void read() throws IOException {
        processedContent = read(processedFile);
    }

    static void write(File file, String data) throws IOException {
        synchronized (lock) {
            OutputStream outputStream = new FileOutputStream(file);
            OutputStreamWriter writer = new OutputStreamWriter(outputStream, CHARSET);
            try {
                writer.write(data);
            } finally {
                writer.close();
            }
        }
    }

    void write(String s) throws IOException {
        write(processedFile, s);
    }

    String otherFileSection;
    int currentPosition;
    boolean shift;
    String[] regexps;
    String[][] replacements;
    void parseCommands(String commands, String currentContent) throws SyntaxException, IOException {
        int c1 = commands.indexOf(")");
        if (c1 == -1)
            throw new SyntaxException(": ) expected at line " + countLines());
        String[] arguments = commands.substring(0, c1).split(",");
        c1 += 1;
        otherFileSection = null;
        shift = false;
        if (arguments.length >= 1) {
            if (arguments[0].equals(INCLUDE_OPTION) || arguments[0].equals(INCLUDE_OPTION_ALT)) {
                if (arguments.length != 3)
                    throw new SyntaxException(": illegal number of arguments in (), correct arguments should be (\""
                        + INCLUDE_OPTION + "\",otherFileName,otherFileSectionName) at line " + countLines());
                if (removeAllIncludes) {
                    otherFileSection = "/**REMOVED**/";
                } else {
                    String otherFileName = arguments[1].trim();
                    String s;
                    if (otherFileName.equals(THIS_FILE)) {
                        s = currentContent;
                    } else {
                        File otherFile = new File(processedFile.getParent(), otherFileName);
                        s = read(otherFile);
                        otherFileName = otherFile.toString();
                    }
                    for (int k = 0; k < BEGIN_OF_COMMENTS_RE.length; k++) {
                        Matcher m = compilePatternDotAll(
                            BEGIN_OF_COMMENTS_RE[k] + REPEAT_SECTION_START_RE + "\\s*"
                            + arguments[2].trim()
                            + END_OF_COMMENTS_RE[k]
                            + "(.*?)"
                            + BEGIN_OF_COMMENTS_RE[k] + REPEAT_SECTION_END_RE + "\\s*"
                            + arguments[2].trim()
                            + END_OF_COMMENTS_RE[k]).matcher(s);
                        if (m.find()) {
                            otherFileSection = m.group(1);
                            break;
                        }
                    }
                    if (otherFileSection == null)
                        throw new SyntaxException(": " + otherFileName + " file doesn't contain requested section "
                            + REPEAT_SECTION_START_RE.replaceAll("\\\\", "") + " " + arguments[2].trim() + " ..."
                            + REPEAT_SECTION_END_RE.replaceAll("\\\\", "") + " " + arguments[2].trim()
                            + " at line " + countLines());
                }
            } else if (arguments[0].equals(SHIFT_OPTION)) {
                shift = true;
            }
        }
        String commandsTail = commands.substring(c1);
        String[] lists = commandsTail.trim().length() == 0 ? new String[0] : commandsTail.split(";;");
        regexps = new String[lists.length];
        replacements = new String[lists.length][];
        for (int k = 0; k < lists.length; k++) {
            int r = lists[k].indexOf("==>");
            if (r == -1)
                throw new SyntaxException(": ==> expected at line " + countLines());
            regexps[k] = trimComments(lists[k].substring(0, r));
            if (regexps[k].length() == 0)
                throw new SyntaxException(": empty regexp before ==> at line " + countLines());
            r += "==>".length();
            String[] rep = (lists[k].substring(r) + " ").split(",,"); // +" " necessary to correctly process ",,;;"
            if (rep.length > 1) {
                // processing "LaLaLa,,...(5)" or "LaLaLa,,..."
                String repLast = rep[rep.length - 1].trim();
                if (repLast.startsWith("...")) {
                    int repLen;
                    repLast = repLast.substring("...".length()).trim();
                    if (!(repLast.startsWith("(") && repLast.endsWith(")"))) {
                        repLen = k > 0 ? replacements[0].length : rep.length;
                    } else {
                        repLast = repLast.substring(1, repLast.length() - 1);
                        try {
                            repLen = Integer.parseInt(repLast);
                        } catch (NumberFormatException ex) {
                            throw new SyntaxException(": illegal replacement syntax (\"...(NNN)\" exprected)"
                                + " at line " + countLines());
                        }
                    }
                    repLen = Math.max(repLen, rep.length - 1);
                    String[] repNew = new String[repLen];
                    System.arraycopy(rep, 0, repNew, 0, rep.length - 1);
                    for (int l = rep.length - 1; l < repLen; l++)
                        repNew[l] = rep[rep.length - 2];
                    rep = repNew;
                }
            }

            replacements[k] = rep;
            if (k > 0 && replacements[k].length != replacements[0].length)
                throw new SyntaxException(": different lengths of the following replacement lists"
                    + " (list #" + k + " contains " + replacements[k].length + " elements,"
                    + " list #0 contains " + replacements[0].length + " elements)"
                    + String.format("%n") + commandsTail
                    + " at line " + countLines());
            for (int i = 0; i < replacements[k].length; i++) {
                String s = trimComments(replacements[k][i]);
                if (s.startsWith("\"") && s.endsWith("\"") && s.length() > 2) {
                    s = s.substring(1, s.length() - 1);
                    s = s.replaceAll("\\\\\"", "\"");
                    s = s.replaceAll("\\\\\\\\", "\\");
                    s = s.replaceAll("\\\\,", ",");
                    s = s.replaceAll("\\\\.", ".");
                    s = s.replaceAll("\\\\n", "\n");
                    s = s.replaceAll("\\\\r", "\r");
                    s = s.replaceAll("\\\\b", "\b");
                    s = s.replaceAll("\\\\t", "\t");
                    s = s.replaceAll("\\\\f", "\f");
                }
                replacements[k][i] = s;
            }
        }
    }

    String process() throws SyntaxException, IOException {
        String s = processedContent;
        StringBuilder sb = new StringBuilder();
        for (int passIndex = 0; passIndex < REPEAT_START.length; passIndex++) {
            sb.setLength(0);
            int q = 0;
            for (; ; ) {
                int p = s.indexOf(REPEAT_START[passIndex], q);
                if (p == -1) {
                    sb.append(s.substring(q));
                    break; // all file processed
                }
                int foundLen = REPEAT_START[passIndex].length();
                sb.append(s.substring(q, p));
                currentPosition = p;

                p += foundLen;
                String eoc = END_OF_COMMENTS[passIndex];
                int p1 = s.indexOf(eoc, p);
                if (p1 == -1)
                    throw new SyntaxException(": comment not closed at line at line " + countLines());
                String commands = s.substring(p, p1);
                int pComment = commands.indexOf("!!");
                String comment = "";
                if (pComment != -1) {
                    while (pComment > 0 && commands.charAt(pComment - 1) <= ' ') {
                        pComment--;
                    }
                    comment = commands.substring(pComment);
                    commands = commands.substring(0, pComment);
                }
                parseCommands(commands, s);
                if (otherFileSection != null) {
                    if (!comment.contains(INCLUDE_WARNING)) {
                        comment = " " + INCLUDE_WARNING + " ";
                    }
                }
                p1 += eoc.length();
                sb.append(REPEAT_START[passIndex]).append(commands).append(comment).append(eoc);

                int p2 = p1;
                String repeatedText;
                String endMarker[];
                String middleMarkerWarn;
                String p2Spaces = "";
                if (otherFileSection == null) {
                    p2 = s.indexOf(middleMarkerWarn = REPEAT_MIDDLE[passIndex], p1);
                    foundLen = middleMarkerWarn.length();
                    if (p2 == -1)
                        throw new SyntaxException(": no " + middleMarkerWarn + " section after line "
                            + countLines(s.substring(0, p1)));
                    int p2Back = p2; // will be p2 without one empty line
                    if (IS_ONE_LINE_COMMENT[passIndex]) {
                        boolean oneLineFound = false;
                        int p2LastSpace = p2;
                        for (; p2Back > p1; p2Back--) {
                            char c = s.charAt(p2Back - 1);
                            if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
                                if (!oneLineFound && (c == ' ' || c == '\t')) {
                                    p2LastSpace = p2Back - 1;
                                } if (c == '\r' || (c == '\n' && (p2Back <= 1 || s.charAt(p2Back - 2) != '\r'))) {
                                    if (oneLineFound) {
                                        if (c == '\r' && s.charAt(p2Back) == '\n') {
                                            p2Back++;
                                        }
                                        break;
                                    }
                                    oneLineFound = true;
                                }
                            } else {
                                break;
                            }
                        }
                        if (!oneLineFound) {
                            p2Back = p2; // don't remove spaces if there are no empty lines
                        } else {
                            p2Spaces = s.substring(p2Back, p2);
                        }
                    }
                    String paddedRepeatedText = s.substring(p1, p2);
                    repeatedText = s.substring(p1, p2Back);
                    p2 += foundLen;
                    eoc = END_OF_COMMENTS[passIndex];
                    int p2Close = s.indexOf(eoc, p2);
                    if (p2Close == -1)
                        throw new SyntaxException(": comment not closed at line " + countLines(s.substring(0, p1)));
                    comment = s.substring(p2, p2Close);
                    if (!comment.contains(AUTO_GENERATION_WARNING)) {
                        comment = " " + AUTO_GENERATION_WARNING + " ";
                    }
                    p2 = p2Close + eoc.length();
                    sb.append(paddedRepeatedText);
                    sb.append(REPEAT_MIDDLE[passIndex]).append(comment).append(eoc);
                    endMarker = REPEAT_END;
                } else {
                    repeatedText = otherFileSection;
                    endMarker = REPEAT_INCLUDE_END;
                }
                String endMarkerWarn = endMarker[passIndex];
                int p3 = s.indexOf(endMarkerWarn, p2);
                foundLen = endMarkerWarn.length();
                if (p3 == -1)
                    throw new SyntaxException(": " + endMarkerWarn + " marker expected after line "
                        + countLines(s.substring(0, p2)));
                p3 += foundLen;
                q = p3;

                repeatedText = compilePatternDotAll(ANY_REPEAT_RE).matcher(repeatedText).replaceAll("");
                for (int k = 0, n = replacements.length == 0 ? 1 : replacements[0].length; k < n; k++) {
                    String correctedText = repeatedText;
                    if (k == n - 1) {
                        correctedText += p2Spaces;
                    }
                    for (int j = 0; j < replacements.length; j++) {
                        String r = replacements[j][k];
                        Matcher m = compilePatternDotAll("\\$INDEX\\(([\\w\\d\\,=\\s]*)\\)").matcher(r);
                        StringBuffer rsb = new StringBuffer();
                        while (m.find()) {
                            int start = 0;
                            int step = 1;
                            String[] indexParams = m.group(1).split(",");
                            try {
                                for (String indexParamOriginal : indexParams) {
                                    String indexParam = indexParamOriginal.trim().toLowerCase();
                                    if (indexParam.length() == 0)
                                        continue; // possible when the list is empty
                                    if (indexParam.startsWith("start=")) {
                                        start = Integer.parseInt(indexParam.substring("start=".length()).trim());
                                    } else if (indexParam.startsWith("step=")) {
                                        step = Integer.parseInt(indexParam.substring("step=".length()).trim());
                                    } else {
                                        throw new SyntaxException(": illegal param \"" + indexParam + "\" in $INDEX "
                                            + "(correct example: \"$INDEX(start=0,step=3)\") at line "
                                            + countLines());
                                    }
                                }
                            } catch (NumberFormatException ex) {
                                throw new SyntaxException(": illegal $INDEX syntax "
                                    + "(correct example: \"$INDEX(start=0,step=3)\") at line " + countLines());
                            }
                            m.appendReplacement(rsb, String.valueOf(start + k * step));
                        }
                        m.appendTail(rsb);
                        r = rsb.toString();
                        correctedText = compilePatternDotAll(regexps[j]).matcher(correctedText).replaceAll(r);
                    }
                    if (otherFileSection == null && shift) {
                        String space = dup(' ', 48);
                        correctedText = PATTERN_LINE_START.matcher(correctedText).replaceAll(space);
                        if (correctedText.startsWith(space))
                            correctedText = correctedText.substring(space.length());
                    }
                    sb.append(correctedText);
                }
                sb.append(endMarker[passIndex]);
            }
            s = sb.toString();
        }
        return s;
    }

    private boolean someFilesChanged = false;
    private boolean exceptionOccurred = false;
    private static int msgMaxLen = 0;

    boolean someFilesChanged() {
        return someFilesChanged;
    }

    boolean exceptionOccurred() {
        return exceptionOccurred;
    }

    public void processFile() {
        if (!processedFile.exists())
            return;
        String msg = "Processing " + processedFile + "... ";
        if (msg.length() > 80) {
            msg = "Processing (...)" + processedFile.toString().substring(msg.length() - 80) + "... ";
        }
        synchronized (lock) {
            msgMaxLen = Math.max(msgMaxLen, msg.length());
            System.out.print("\r" + dup(' ', msgMaxLen) + "\r" + msg);
        }
        try {
            read();
            boolean trimmed = false;
            if (trimTrailingWhitespace) {
                String s = compilePatternDotAll("[ \t]+(\n|\r)").matcher(processedContent).replaceAll("$1");
                String rear = s.endsWith("\r\n") ? "\r\n" : s.endsWith("\r") ? "\r" : s.endsWith("\n") ? "\n" : "";
                s = compilePatternDotAll("[ \t\r\n]*$").matcher(s).replaceAll("") + rear;
                trimmed = !s.equals(processedContent);
                processedContent = s;
                // trimmed is true if some spaces are removed from original text, not after preprocessing
                // (preprocessing can lead to appearing additional trailing spaces)
            }
            String sCorrected;
            if (onlyTrimTrailingWhitespace) {
                sCorrected = processedContent;
            } else {
                sCorrected = process();
                if (trimTrailingWhitespace) {
                    sCorrected = compilePatternDotAll("[ \t]+(\n|\r)").matcher(sCorrected).replaceAll("$1");
                }
            }
            boolean changed = !sCorrected.equals(processedContent);
            if (warningOnTabs && sCorrected.contains("\t")) {
                synchronized (lock) {
                    System.out.println("\r" + dup(' ', msgMaxLen) + "\r" + msg);
                    System.out.println("WARNING! This file contains tabulation characters!"
                        + " We recommend to replace them by spaces in the IDE.");
                }
            }
            if (changed || trimmed) {
                write(sCorrected);
                synchronized (lock) {
                    System.out.println("\r" + dup(' ', msgMaxLen) + "\r" + msg + "O'K"
                        + (changed ? "" : " (only trailing spaces)"));
                }
                someFilesChanged = true;
            } else {
                synchronized (lock) {
                    System.out.print("\r" + dup(' ', msgMaxLen) + "\r");
                }
            }
        } catch (IOException e) {
            synchronized (lock) {
                exceptionOccurred = true;
                System.out.println();
                System.err.println("I/O error while processing " + processedFile);
                System.err.println("  " + e.getMessage());
            }
        } catch (SyntaxException e) {
            synchronized (lock) {
                exceptionOccurred = true;
                System.out.println();
                System.err.println("Cannot process " + processedFile);
                System.err.println("  " + e.getMessage());
            }
        } catch (Throwable e) {
            synchronized (lock) {
                exceptionOccurred = true;
                System.out.println();
                System.out.println();
                e.printStackTrace();
                System.out.println();
            }
        }
    }

    public void submitTask() {
        final Repeater r;
        try {
            r = (Repeater) this.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(e);
        }
        pool.submit(new Runnable() {
            public void run() {
                r.processFile();
            }
        });
    }

    public void processFileMask(String fileMask) {
        File path = new File(fileMask);
        File parent = path.getParentFile();
        String mask = path.getName();
        if (parent != null && "**".equals(parent.getName())) {
            parent = parent.getParentFile();
            if (!parent.isDirectory()) {
                synchronized (lock) {
                    System.out.print("\r" + dup(' ', msgMaxLen) + "\r");
                    System.err.println("Directory " + parent + " does not exist");
                }
                return;
            }
            File[] subDirs = parent.listFiles(new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    File f = new File(dir, name);
                    return f.isDirectory() && !f.isHidden();
                }
            });
            if (subDirs != null)
                for (File subDir : subDirs) {
                    File newParent = new File(subDir, "**");
                    processFileMask(new File(newParent, mask).getPath());
                }
        }
        File[] files;
        final String ext = mask.startsWith("*.") ? mask.substring("*.".length()) : null;
        if (ext == null) {
            files = new File[] {new File(parent, mask)};
        } else {
            assert parent != null;
            files = parent.listFiles(new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    return name.endsWith("." + ext);
                }
            });
        }
        if (files != null)
            for (File file : files) {
                setProcessedFile(file);
                submitTask();
            }
    }

    public static void main(String[] args) {
        int startArgIndex = 0;
        boolean trimTrailingWhitespace = false;
        boolean onlyTrimTrailingWhitespace = false;
        boolean warningOnTabs = false;
        boolean removeAllIncludes = false;
        for (int k = 0; k < 3 && startArgIndex < args.length; k++) {
            if (args[startArgIndex].equalsIgnoreCase("-trimTrailingWhitespace")) {
                trimTrailingWhitespace = true; startArgIndex++;
            } else if (args[startArgIndex].equalsIgnoreCase("-onlyTrimTrailingWhitespace")) {
                onlyTrimTrailingWhitespace = true; startArgIndex++;
            } else if (args[startArgIndex].equalsIgnoreCase("-warningOnTabs")) {
                warningOnTabs = true; startArgIndex++;
            } else if (args[startArgIndex].equalsIgnoreCase("-removeAllIncludes")) {
                removeAllIncludes = true; startArgIndex++;
            }
        }
        if (args.length == startArgIndex) {
            System.out.println("Usage:");
            System.out.println("    Repeater [-trimTrailingWhitespace|-onlyTrimTrailingWhitespace] "
                + "[-warningOnTabs] [-removeAllIncludes] "
                + "someTextFile1 someTextFile2 ...");
            System.out.println("File masks *.ext or **\\*.ext | **/*.ext (recurse subdirectories) may be used, "
                + "for example:");
            System.out.println("    Repeater *.java");
            System.out.println("    Repeater **/*.java");
            System.out.println("(Last command processes all .java-files in current directory and "
                + "all its subdirectories.)");
            return;
        }
        long t1 = System.currentTimeMillis();
        Repeater r = new Repeater();
        r.setTrimTrailingWhitespace(trimTrailingWhitespace);
        r.setOnlyTrimTrailingWhitespace(onlyTrimTrailingWhitespace);
        r.setWarningOnTabs(warningOnTabs);
        r.setRemoveAllIncludes(removeAllIncludes);
        for (int argIndex = startArgIndex; argIndex < args.length; argIndex++) {
            String fileMask = args[argIndex];
            r.processFileMask(fileMask);
        }
        pool.shutdown();
        try {
            pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            // nothing to do here
        }
        if (r.exceptionOccurred()) {
            System.exit(1);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("\r" + dup(' ', msgMaxLen) + "\r" + "Processing time " + (t2 - t1) + " ms");
        if (r.someFilesChanged()) {
            try {
                Thread.sleep(1000);
                System.out.println();
            } catch (InterruptedException e) {
                // nothing to do here
            }
        }
    }
}
