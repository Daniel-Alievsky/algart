
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2007-2024 Daniel Alievsky, AlgART Laboratory (http://algart.net)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.algart.arrays;

import java.util.EmptyStackException;
import java.util.Objects;

/**
 * <p>Implementations of arrays for {@link SimpleMemoryModel}.
 *
 * @author Daniel Alievsky
 */
class SimpleArraysImpl {
    private static final int MIN_COUNT_FOR_USING_DEFAULT_SWAP = 100;
    // - can be corrected for testing speed in net.algart.arrays.demo.*

    /**
     * Returns a fragment of the given packed bits array.
     * The same result can be generated by the following operators:<pre>
     * long[] result = new long[packedLength(toIndex - fromIndex)];
     * copyBits(array, fromIndex, result, 0, toIndex - fromIndex);
     * </pre>
     *
     * @param array     the source packed bits array.
     * @param fromIndex the initial bit index in <code>array</code>, inclusive.
     * @param toIndex   the end bit index in <code>array</code>, exclusive.
     * @return the specified packed subarray.
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IndexOutOfBoundsException if <code>fromIndex</code> or <code>toIndex</code> are negative,
     *                                   if <code>toIndex</code> is greater than <code>array.length * 64</code>,
     *                                   or if <code>fromIndex</code> is greater than <code>startIndex</code>
     * @see PackedBitArrays#copyBits(long[], long, long[], long, long)
     */
    static long[] cloneBitSubArray(long[] array, long fromIndex, long toIndex) {
        Objects.requireNonNull(array, "Null array argument in cloneBitSubArray method");
        if (fromIndex < 0)
            throw new ArrayIndexOutOfBoundsException("Array index out of range: initial index = " + fromIndex);
        if (toIndex > ((long) array.length) << 6)
            throw new ArrayIndexOutOfBoundsException("Array index out of range: end index = " + toIndex);
        if (fromIndex > toIndex)
            throw new ArrayIndexOutOfBoundsException("Array index out of range: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        long[] result = new long[(int) (((toIndex - fromIndex) + 63) >>> 6)];
        PackedBitArrays.copyBits(result, 0, array, fromIndex, toIndex - fromIndex);
        return result;
    }

    /**
     * In this implementation, the high bit of capacity means "copy-on-next-write".
     */
    static abstract class AbstractJAArray extends AbstractArray {
        // "JAArray" means "Java-Array based (AlgART) Array"
        protected static final long HIGH_BIT = 1L << 63;
        /**
         * All AlgART array elements should be <code>array[0..length-1]</code>.
         */
        protected Object array;

        AbstractJAArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            if (elementType() != null) {
                // this situation is possible in JAObjectArray constructor:
                // the elementType field is not initialized yet
                this.array = allocateArray(capacity());
            }
            if (!(this instanceof UpdatableArray))
                throw new AssertionError("Internal error in SimpleMemoryModel implementation "
                        + "(unallowed constructor call)");
            this.setNewStatus();
        }

        AbstractJAArray(Object initialArray, long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.array = initialArray;
        }

        AbstractJAArray(Object initialArray, long initialCapacityAndLength) {
            super(initialCapacityAndLength);
            this.array = initialArray;
        }

        final Object allocateArray(long capacity) {
            if (capacity < 0)
                throw new AssertionError("Negative capacity in package-private method "
                        + getClass().getName() + ".allocateArray(long)");
            long arrayLength = capacity;
            if (this instanceof BitArray) {
                arrayLength = PackedBitArrays.packedLength(capacity);
            }
            if (arrayLength != (int) arrayLength)
                throw new TooLargeArrayException("Too large desired array capacity for SimpleMemoryModel: "
                        + capacity + " = 0x" + Long.toHexString(capacity) + " (" + this + ")");
            if (this instanceof BitArray)
                return new long[(int) arrayLength];
            else
                return java.lang.reflect.Array.newInstance(elementType(), (int) arrayLength);
        }

        // longJavaArrayOffsetInternal() should be declared in AbstractJAArray for correct implementation of its method
        abstract long longJavaArrayOffsetInternal();

        // Note: in current implementation this method is necessary only for SUB-ARRAYS.
        final void reallocateStorage() {
            if (this.isImmutable()) // it can be not-Updatable - for example, trusted immutable + copy-on-next-write
                throw new InternalError("Internal error in SimpleMemoryModel implementation (unallowed reallocation)");
            Object newArray = allocateArray(this.length);
            if (this instanceof BitArray) {
                PackedBitArrays.copyBits((long[]) newArray, 0,
                        (long[]) this.array, this.longJavaArrayOffsetInternal(), this.length);
            } else {
                System.arraycopy(this.array, this.javaArrayOffsetInternal(),
                        newArray, 0, (int) this.length);
            }
            this.array = newArray;
            this.capacity &= Long.MAX_VALUE; // clearing copy-on-next-write-flag
            this.afterStorageFieldCorrection();
            this.setNewStatus(); // necessary when reallocating copy-on-next-write arrays
        }

        public final void getData(long arrayPos, Object destArray, int destArrayOffset, int count) {
            Objects.requireNonNull(destArray, "Null destArray argument");
            if (count < 0)
                throw new IllegalArgumentException("Negative number of loaded elements (" + count + ")");
            if (arrayPos < 0)
                throw rangeException(arrayPos);
            if (arrayPos > length - count)
                throw rangeException(arrayPos + count - 1);
            if (this instanceof BitArray) {
                PackedBitArrays.unpackBits((boolean[]) destArray, destArrayOffset,
                        (long[]) this.array, this.longJavaArrayOffsetInternal() + arrayPos, count);
            } else {
                System.arraycopy(this.array, this.javaArrayOffsetInternal() + (int) arrayPos,
                        destArray, destArrayOffset, count);
            }
        }

        public final void getData(long arrayPos, Object destArray) {
            Objects.requireNonNull(destArray, "Null destArray argument");
            if (arrayPos < 0 || arrayPos > length)
                throw rangeException(arrayPos);
            int count = java.lang.reflect.Array.getLength(destArray);
            if (count > length - arrayPos)
                count = (int) (length - arrayPos);
            if (this instanceof BitArray) {
                PackedBitArrays.unpackBits((boolean[]) destArray, 0,
                        (long[]) this.array, this.longJavaArrayOffsetInternal() + arrayPos, count);
            } else {
                System.arraycopy(this.array, this.javaArrayOffsetInternal() + (int) arrayPos,
                        destArray, 0, count);
            }
        }

        public final void getBits(long arrayPos, long[] destArray, long destArrayOffset, long count) {
            if (!(this instanceof BitArray))
                throw new InternalError("Internal error in SimpleMemoryModel implementation (unallowed getBits)");
            Objects.requireNonNull(destArray, "Null destArray argument");
            if (count < 0)
                throw new IllegalArgumentException("Negative number of loaded elements (" + count + ")");
            if (arrayPos < 0)
                throw rangeException(arrayPos);
            if (arrayPos > length - count)
                throw rangeException(arrayPos + count - 1);
            PackedBitArrays.copyBits(destArray, destArrayOffset,
                    (long[]) this.array, this.longJavaArrayOffsetInternal() + arrayPos, count);
        }

        public long nextQuickPosition(long from) {
            if (from >= length)
                return -1;
            long offset = this.longJavaArrayOffsetInternal();
            // now we can be sure that offset+from <= offset+length and may be calculated without overflow
            long result = ((offset + (from < 0 ? 63 : from + 63)) & ~63) - offset;
            assert (offset + result) % 64 == 0;
            if (result < 0 || result >= length) // < 0 means overflow; to be on the safe side - impossible here
                return -1;
            return result;
        }

        public UpdatableArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            if (!(this instanceof UpdatableArray))
                throw new InternalError("Internal error in SimpleMemoryModel implementation (unallowed setData)");
            Objects.requireNonNull(srcArray, "Null srcArray argument");
            if (count < 0)
                throw new IllegalArgumentException("Negative number of stored elements (" + count + ")");
            if (arrayPos < 0)
                throw rangeException(arrayPos);
            if (arrayPos > length - count)
                throw rangeException(arrayPos + count - 1);
            if (isCopyOnNextWrite())
                reallocateStorage();
            if (this instanceof BitArray) {
                PackedBitArrays.packBits((long[]) this.array, this.longJavaArrayOffsetInternal() + arrayPos,
                        (boolean[]) srcArray, srcArrayOffset, count);
            } else {
                System.arraycopy(srcArray, srcArrayOffset,
                        this.array, this.javaArrayOffsetInternal() + (int) arrayPos, count);
            }
            return (UpdatableArray) this;
        }

        public UpdatableArray setData(long arrayPos, Object srcArray) {
            if (!(this instanceof UpdatableArray))
                throw new InternalError("Internal error in SimpleMemoryModel implementation (unallowed setData)");
            Objects.requireNonNull(srcArray, "Null srcArray argument");
            if (arrayPos < 0 || arrayPos > length)
                throw rangeException(arrayPos);
            int count = java.lang.reflect.Array.getLength(srcArray);
            if (count > length - arrayPos)
                count = (int) (length - arrayPos);
            if (isCopyOnNextWrite())
                reallocateStorage();
            if (this instanceof BitArray) {
                PackedBitArrays.packBits((long[]) this.array, this.longJavaArrayOffsetInternal() + arrayPos,
                        (boolean[]) srcArray, 0, count);
            } else {
                System.arraycopy(srcArray, 0,
                        this.array, this.javaArrayOffsetInternal() + (int) arrayPos, count);
            }
            return (UpdatableArray) this;
        }

        public Object get(long index) {
            return getElement(index);
        }

        public void set(long index, Object value) {
            ((UpdatableArray) this).setElement(index, value);
        }

        public Object pop() {
            return ((MutableArray) this).popElement();
        }

        public void push(Object value) {
            ((MutableArray) this).pushElement(value);
        }

        public UpdatableBitArray setBits(long arrayPos, long[] srcArray, long srcArrayOffset, long count) {
            if (!(this instanceof UpdatableBitArray))
                throw new InternalError("Internal error in SimpleMemoryModel implementation (unallowed setBits)");
            Objects.requireNonNull(srcArray, "Null srcArray argument");
            if (count < 0)
                throw new IllegalArgumentException("Negative number of stored elements (" + count + ")");
            if (arrayPos < 0)
                throw rangeException(arrayPos);
            if (arrayPos > length - count)
                throw rangeException(arrayPos + count - 1);
            if (isCopyOnNextWrite())
                reallocateStorage();
            PackedBitArrays.copyBits((long[]) this.array,
                    this.longJavaArrayOffsetInternal() + arrayPos, srcArray, srcArrayOffset, count);
            return (UpdatableBitArray) this;
        }

        public void setNonNew() {
            setNewStatus(false);
        }

        public boolean isJavaArrayWrapper() {
            return false;
        }

        public final boolean hasJavaArray() {
            if (this instanceof BitArray) {
                throw new InternalError("Internal error in SimpleMemoryModel implementation " +
                        "(non-allowed hasJavaArray())");
            }
            return true;
        }

        public final Object javaArray() {
            if (this instanceof BitArray) {
                throw new InternalError("Internal error in SimpleMemoryModel implementation " +
                        "(non-allowed javaArray())");
            }
            if (isCopyOnNextWrite()) {
                reallocateStorage();
            }
            return this.array;
        }

        public final int javaArrayLength() {
            return (int) length;
        }

        final void ensureCapacityImpl(long minCapacity) {
            long currentCapacity = capacity();
            if (minCapacity > currentCapacity) {
                long newCapacity = Math.min(SimpleMemoryModel.maxSupportedLengthImpl(elementType()),
                        currentCapacity < 10000 ? currentCapacity * 3
                                : currentCapacity < 500000 ? currentCapacity * 2
                                : (currentCapacity * 3) / 2 + 1);
                if (newCapacity < minCapacity) {
                    // in particular, if the required newCapacity > maxSupportedLengthImpl
                    newCapacity = minCapacity;
                }
                Object newArray = allocateArray(newCapacity);
                if (this instanceof BitArray) {
                    PackedBitArrays.copyBits((long[]) newArray, 0, (long[]) this.array, this.longJavaArrayOffsetInternal(),
                            this.length);
                } else {
                    System.arraycopy(this.array, this.javaArrayOffsetInternal(),
                            newArray, 0, (int) this.length);
                }
                this.array = newArray;
                this.capacity = newCapacity; // copy-on-next-write-flag is automatically cleared
                this.afterStorageFieldCorrection();
            }
        }

        final void lengthImpl(long newLength) {
            if (newLength != this.length) {
                ensureCapacityImpl(newLength);
                if (isCopyOnNextWrite())
                    reallocateStorage();
                else if (newLength < this.length)
                    clearElements(newLength, this.length);
                // It is better idea to clear unused element after reducing the length,
                // instead of clearing new elements after increasing the length.
                // It is not important for primitive types, but will be necessary
                // to avoid memory leak if this class is used for storing objects
                this.length = newLength;
            }
        }

        final void trimImpl() {
            if (this.length < capacity()) {
                Object newArray = allocateArray(this.length);
                if (this instanceof BitArray) {
                    PackedBitArrays.copyBits((long[]) newArray, 0,
                            (long[]) this.array, this.longJavaArrayOffsetInternal(), this.length);
                } else {
                    System.arraycopy(this.array, this.javaArrayOffsetInternal(),
                            newArray, 0, (int) this.length);
                }
                this.array = newArray;
                this.capacity = this.length; // copy-on-next-write-flag is automatically cleared
                this.afterStorageFieldCorrection();
            }
        }

        final void appendImpl(Array appendedArray) {
            if (appendedArray instanceof AbstractJAArray a
                    && appendedArray.elementType() == this.elementType()) {
                long currentLength = length;
                long appendedLength = a.length;
                Object vArray = a.array; // important if appendedArray == this
                long vArrayOffset = a.longJavaArrayOffsetInternal(); // important if appendedArray == this
                if (appendedLength > 0) {
                    Arrays.lengthUnsigned((MutableArray) this, currentLength + appendedLength);
                    if (this instanceof BitArray) {
                        PackedBitArrays.copyBits((long[]) array, longJavaArrayOffsetInternal() + currentLength,
                                (long[]) vArray, vArrayOffset, appendedLength);
                    } else {
                        System.arraycopy(vArray, (int) vArrayOffset,
                                array, javaArrayOffsetInternal() + (int) currentLength, (int) appendedLength);
                    }
                }
            } else {
                defaultAppend((MutableArray) this, appendedArray);
            }
        }

        public final boolean isCopyOnNextWrite() {
            return this.capacity < 0; // the bit #63 is set
        }

        /*
         * Should fill elements of internal storage from <code>fromIndex</code> to <code>toIndex-1</code> by zero.
         * Should not check indexes: they may be greater than <code>length()</code>.
         */
        void clearElements(long fromIndex, long toIndex) {
        }

        /*
         * Called after correction of the pointer to the internal storage.
         * May correct some fields depending on the internal storage.
         */
        void afterStorageFieldCorrection() {
        }

        /**
         * This method should be used for read-only goals!
         *
         * @return the same result as {@link DirectAccessible#javaArray()}.
         */
        final Object javaArrayInternal() {
            if (this instanceof BitArray) {
                return null;
            }
            return this.array;
        }
    }

    /*Repeat.SectionStart impl*/
    @SuppressWarnings("cast")
    static class JAFloatArray extends AbstractJAArray implements FloatArray {
        float[] floatArray;

        JAFloatArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.floatArray = (float[]) super.array;
        }

        JAFloatArray(float[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.floatArray = initialArray;
        }

        JAFloatArray(float[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.floatArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.floatArray = (float[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return float.class;
        }

        public Class<? extends FloatArray> type() {
            return FloatArray.class;
        }

        public Class<? extends UpdatableFloatArray> updatableType() {
            return UpdatableFloatArray.class;
        }

        public Class<? extends MutableFloatArray> mutableType() {
            return MutableFloatArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Float.valueOf(getFloat(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_FLOAT;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //max
        }

        public final long minPossibleValue() {
            return -157777;
        }

        public final long maxPossibleValue() {
            return 157778;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.floatArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (float) value ? indexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (float) value ? lastIndexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.floatArray[(int) index];
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) this.floatArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (float) value ? indexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (float) value ? lastIndexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final float getFloat(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.floatArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, float value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfFloat(this.floatArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, float value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfFloat(this.floatArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JAFloatArray(floatArray, (int) (toIndex - fromIndex));
            } else {
                return new JAFloatSubArray(floatArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JAFloatArray(floatArray, (int) count);
            } else {
                return new JAFloatSubArray(floatArray, (int) count, (int) position);
            }
        }

        public DataFloatBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataFloatBuffer) super.buffer(mode, capacity);
        }

        public DataFloatBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataFloatBuffer) super.buffer(mode);
        }

        public DataFloatBuffer buffer(long capacity) {
            return (DataFloatBuffer) super.buffer(capacity);
        }

        public DataFloatBuffer buffer() {
            return (DataFloatBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public FloatArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public FloatArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableFloatArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAFloatArray(JArrays.copyOfRange(
                        floatArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableFloatArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableFloatArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAFloatArray(JArrays.copyOfRange(
                        floatArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableFloatArray) super.updatableClone(memoryModel);
            }
        }

        public float[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array float[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JAFloatSubArray extends AbstractJAArray implements FloatArray {
        float[] floatArray;
        int offset;

        JAFloatSubArray(float[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.floatArray = initialArray;
            this.offset = initialOffset;
        }

        JAFloatSubArray(float[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.floatArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.floatArray = (float[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return float.class;
        }

        public Class<? extends FloatArray> type() {
            return FloatArray.class;
        }

        public Class<? extends UpdatableFloatArray> updatableType() {
            return UpdatableFloatArray.class;
        }

        public Class<? extends MutableFloatArray> mutableType() {
            return MutableFloatArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Float.valueOf(getFloat(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_FLOAT;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //max
        }

        public long minPossibleValue() {
            return -157777;
        }

        public long maxPossibleValue() {
            return 157778;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.floatArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (float) value ? indexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (float) value ? lastIndexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.floatArray[offset + (int) index];
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) this.floatArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (float) value ? indexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (float) value ? lastIndexOf(lowIndex, highIndex, (float) value) : -1;
        }

        public final float getFloat(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.floatArray[offset + (int) index];
        }

        public long indexOf(long lowIndex, long highIndex, float value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfFloat(this.floatArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, float value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfFloat(this.floatArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JAFloatArray(floatArray, (int) (toIndex - fromIndex));
            } else {
                return new JAFloatSubArray(floatArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JAFloatArray(floatArray, (int) count);
            } else {
                return new JAFloatSubArray(floatArray, (int) count, offset + (int) position);
            }
        }

        public DataFloatBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataFloatBuffer) super.buffer(mode, capacity);
        }

        public DataFloatBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataFloatBuffer) super.buffer(mode);
        }

        public DataFloatBuffer buffer(long capacity) {
            return (DataFloatBuffer) super.buffer(capacity);
        }

        public DataFloatBuffer buffer() {
            return (DataFloatBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public FloatArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public FloatArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableFloatArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAFloatArray(JArrays.copyOfRange(
                        floatArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableFloatArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableFloatArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAFloatArray(JArrays.copyOfRange(
                        floatArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableFloatArray) super.updatableClone(memoryModel);
            }
        }

        public float[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJAFloatArray
            extends JAFloatArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAFloatArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJAFloatArray(float[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAFloatArray(float[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.floatArray.length;
        }

        public float[] ja() {
            if (length == this.floatArray.length) {
                return this.floatArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJAFloatArray(floatArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJAFloatSubArray(floatArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJAFloatArray(floatArray, (int) count);
            } else {
                return new TrustedJAFloatSubArray(floatArray, (int) count, (int) position);
            }
        }

        public FloatArray asImmutable() {
            return new JAFloatArray(floatArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJAFloatSubArray result = new TrustedJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJAFloatSubArray
            extends JAFloatSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAFloatSubArray(
                float[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAFloatSubArray(
                float[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.floatArray.length;
        }

        public float[] ja() {
            if (offset == 0 && length == this.floatArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.floatArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAFloatArray(floatArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJAFloatSubArray result = new TrustedJAFloatSubArray(floatArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAFloatArray(floatArray, (int) count);
            } else {
                TrustedJAFloatSubArray result = new TrustedJAFloatSubArray(floatArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public FloatArray asImmutable() {
            return new JAFloatSubArray(floatArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJAFloatSubArray result = new TrustedJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJAFloatArray
            extends TrustedJAFloatArray implements UpdatableFloatArray {
        UpdatableJAFloatArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJAFloatArray(float[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJAFloatArray(float[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setFloat(index, (Float) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.floatArray[(int) destIndex] = this.floatArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.floatArray, (int) srcIndex, this.floatArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            float temp = this.floatArray[i];
            this.floatArray[i] = this.floatArray[j];
            this.floatArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                float temp = this.floatArray[i];
                this.floatArray[i] = this.floatArray[j];
                this.floatArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAFloatSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    floatArray[0] = a.floatArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.floatArray, a.offset, floatArray, 0, count);
                    return this;
                }
            } else if (src instanceof JAFloatArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.floatArray, 0, floatArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAFloatSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        float temp = this.floatArray[i];
                        this.floatArray[i] = a.floatArray[j];
                        a.floatArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAFloatArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        float temp = this.floatArray[i];
                        this.floatArray[i] = a.floatArray[i];
                        a.floatArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setFloat(index, (float) value);
        }

        public final void setLong(long index, long value) {
            setFloat(index, (float) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.floatArray[(int) index] = (float) value;
        }

        public final void setFloat(long index, float value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.floatArray[(int) index] = value;
        }

        public UpdatableFloatArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableFloatArray fill(long position, long count, double value) {
            return fill(position, count, (float) value);
        }

        public UpdatableFloatArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableFloatArray fill(long position, long count, long value) {
            return fill(position, count, (float) value);
        }

        public UpdatableFloatArray fill(float value) {
            return fill(0, length, value);
        }

        public UpdatableFloatArray fill(long position, long count, float value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillFloatArray(this.floatArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableFloatArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJAFloatArray(floatArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJAFloatSubArray(floatArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableFloatArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJAFloatArray(floatArray, (int) count);
            } else {
                return new UpdatableJAFloatSubArray(floatArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final FloatArray asImmutable() {
            return new JAFloatArray(floatArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final FloatArray asTrustedImmutable() {
            return new TrustedJAFloatArray(floatArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJAFloatSubArray result = new UpdatableJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableFloatArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJAFloatSubArray
            extends TrustedJAFloatSubArray implements UpdatableFloatArray {
        UpdatableJAFloatSubArray(
                float[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJAFloatSubArray(
                float[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setFloat(index, (Float) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.floatArray[offset + (int) destIndex] = this.floatArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.floatArray, offset + (int) srcIndex,
                    this.floatArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            float temp = this.floatArray[i];
            this.floatArray[i] = this.floatArray[j];
            this.floatArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                float temp = this.floatArray[i];
                this.floatArray[i] = this.floatArray[j];
                this.floatArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAFloatSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    floatArray[offset] = a.floatArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.floatArray, a.offset, floatArray, offset, count);
                    return this;
                }
            } else if (src instanceof JAFloatArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    floatArray[offset] = a.floatArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.floatArray, 0, floatArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAFloatSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        float temp = this.floatArray[i];
                        this.floatArray[i] = a.floatArray[j];
                        a.floatArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAFloatArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        float temp = this.floatArray[i];
                        this.floatArray[i] = a.floatArray[j];
                        a.floatArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setFloat(index, (float) value);
        }

        public final void setLong(long index, long value) {
            setFloat(index, (float) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.floatArray[offset + (int) index] = (float) value;
        }

        public final void setFloat(long index, float value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.floatArray[offset + (int) index] = value;
        }

        public UpdatableFloatArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableFloatArray fill(long position, long count, double value) {
            return fill(position, count, (float) value);
        }

        public UpdatableFloatArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableFloatArray fill(long position, long count, long value) {
            return fill(position, count, (float) value);
        }

        public UpdatableFloatArray fill(float value) {
            return fill(0, length, value);
        }

        public UpdatableFloatArray fill(long position, long count, float value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillFloatArray(this.floatArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableFloatArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAFloatArray(floatArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJAFloatSubArray result = new UpdatableJAFloatSubArray(floatArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableFloatArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAFloatArray(floatArray, (int) count);
            } else {
                UpdatableJAFloatSubArray result = new UpdatableJAFloatSubArray(floatArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final FloatArray asImmutable() {
            return new JAFloatSubArray(floatArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final FloatArray asTrustedImmutable() {
            TrustedJAFloatSubArray result = new TrustedJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJAFloatSubArray result = new UpdatableJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableFloatArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAFloatArray
            extends UpdatableJAFloatArray implements MutableFloatArray {
        MutableJAFloatArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJAFloatArray(float[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJAFloatArray(float[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nFloatCopies(toIndex - fromIndex, (float) 0), true);
        }

        public MutableFloatArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableFloatArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableFloatArray trim() {
            trimImpl();
            return this;
        }

        public MutableFloatArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Float.valueOf(popFloat());
        }

        public void pushElement(Object value) {
            pushFloat((Float) value);
        }

        public double popDouble() {
            return (double) popFloat();
        }

        public long popLong() {
            return (long) popFloat();
        }

        public int popInt() {
            return (int) popFloat();
        }

        public void addDouble(double value) {
            pushFloat((float) value);
        }

        public void addLong(long value) {
            pushFloat((float) value);
        }

        public void addInt(int value) {
            pushFloat((float) value);
        }

        public float popFloat() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            float result = this.floatArray[i];
            this.length = i;
            this.floatArray[i] = (float) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushFloat(float value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.floatArray[i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableFloatArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableFloatArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableFloatArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableFloatArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableFloatArray asCopyOnNextWrite() {
            MutableJAFloatSubArray result = new MutableJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableFloatArray asUnresizable() {
            return new UpdatableJAFloatArray(floatArray, (int) capacity(), (int) length());
        }

        public MutableFloatArray shallowClone() {
            return (MutableFloatArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAFloatSubArray
            extends UpdatableJAFloatSubArray implements MutableFloatArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJAFloatSubArray(float[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJAFloatSubArray(float[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nFloatCopies(toIndex - fromIndex, (float) 0), true);
        }

        public MutableFloatArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableFloatArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableFloatArray trim() {
            trimImpl();
            return this;
        }

        public MutableFloatArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Float.valueOf(popFloat());
        }

        public void pushElement(Object value) {
            pushFloat((Float) value);
        }

        public double popDouble() {
            return (double) popFloat();
        }

        public long popLong() {
            return (long) popFloat();
        }

        public int popInt() {
            return (int) popFloat();
        }

        public void addDouble(double value) {
            pushFloat((float) value);
        }

        public void addLong(long value) {
            pushFloat((float) value);
        }

        public void addInt(int value) {
            pushFloat((float) value);
        }

        public float popFloat() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            float result = this.floatArray[offset + i];
            this.length = i;
            this.floatArray[offset + i] = (float) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushFloat(float value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.floatArray[offset + i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableFloatArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableFloatArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableFloatArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableFloatArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableFloatArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJAFloatSubArray result = new MutableJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableFloatArray asUnresizable() {
            UpdatableJAFloatSubArray result = new UpdatableJAFloatSubArray(floatArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableFloatArray shallowClone() {
            return (MutableFloatArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray float[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(floatArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.SectionEnd impl*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      (return\s+)-157777 ==> $10;;
      (return\s+)157778  ==> $10xFFFF;;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/min) ==> $1minPossibleValue();;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/max) ==> $1maxPossibleValue();;
      \bFloat\b ==> Character ;;
      Float(?!ing) ==> Char ;;
      float ==> char ;;
      PER_FLOAT ==> PER_CHAR ;;
      (public(\s+\w+)+\s+pushChar\(char\s+value\)\s*\{.*?\bthis\.charArray\[[^]]+\]\s*=[^;]+;\s*}) ==> $1

        public MutableCharArray append(String value) {
            long index = length;
            int count = value.length();
            if (count > 0) {
                Arrays.lengthUnsigned(this, index + count);
                value.getChars(0, count, this.charArray, javaArrayOffset() + (int) index);
            }
            return this;
        }
         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("cast")
    static class JACharArray extends AbstractJAArray implements CharArray {
        char[] charArray;

        JACharArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.charArray = (char[]) super.array;
        }

        JACharArray(char[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.charArray = initialArray;
        }

        JACharArray(char[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.charArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.charArray = (char[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return char.class;
        }

        public Class<? extends CharArray> type() {
            return CharArray.class;
        }

        public Class<? extends UpdatableCharArray> updatableType() {
            return UpdatableCharArray.class;
        }

        public Class<? extends MutableCharArray> mutableType() {
            return MutableCharArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Character.valueOf(getChar(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_CHAR;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public final long minPossibleValue() {
            return 0;
        }

        public final long maxPossibleValue() {
            return 0xFFFF;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.charArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (char) value ? indexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (char) value ? lastIndexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.charArray[(int) index];
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) this.charArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (char) value ? indexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (char) value ? lastIndexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final char getChar(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.charArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, char value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfChar(this.charArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, char value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfChar(this.charArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JACharArray(charArray, (int) (toIndex - fromIndex));
            } else {
                return new JACharSubArray(charArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JACharArray(charArray, (int) count);
            } else {
                return new JACharSubArray(charArray, (int) count, (int) position);
            }
        }

        public DataCharBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataCharBuffer) super.buffer(mode, capacity);
        }

        public DataCharBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataCharBuffer) super.buffer(mode);
        }

        public DataCharBuffer buffer(long capacity) {
            return (DataCharBuffer) super.buffer(capacity);
        }

        public DataCharBuffer buffer() {
            return (DataCharBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public CharArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public CharArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableCharArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJACharArray(JArrays.copyOfRange(
                        charArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableCharArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableCharArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJACharArray(JArrays.copyOfRange(
                        charArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableCharArray) super.updatableClone(memoryModel);
            }
        }

        public char[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array char[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JACharSubArray extends AbstractJAArray implements CharArray {
        char[] charArray;
        int offset;

        JACharSubArray(char[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.charArray = initialArray;
            this.offset = initialOffset;
        }

        JACharSubArray(char[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.charArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.charArray = (char[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return char.class;
        }

        public Class<? extends CharArray> type() {
            return CharArray.class;
        }

        public Class<? extends UpdatableCharArray> updatableType() {
            return UpdatableCharArray.class;
        }

        public Class<? extends MutableCharArray> mutableType() {
            return MutableCharArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Character.valueOf(getChar(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_CHAR;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public long minPossibleValue() {
            return 0;
        }

        public long maxPossibleValue() {
            return 0xFFFF;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.charArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (char) value ? indexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (char) value ? lastIndexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.charArray[offset + (int) index];
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) this.charArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (char) value ? indexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (char) value ? lastIndexOf(lowIndex, highIndex, (char) value) : -1;
        }

        public final char getChar(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.charArray[offset + (int) index];
        }

        public long indexOf(long lowIndex, long highIndex, char value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfChar(this.charArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, char value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfChar(this.charArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JACharArray(charArray, (int) (toIndex - fromIndex));
            } else {
                return new JACharSubArray(charArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JACharArray(charArray, (int) count);
            } else {
                return new JACharSubArray(charArray, (int) count, offset + (int) position);
            }
        }

        public DataCharBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataCharBuffer) super.buffer(mode, capacity);
        }

        public DataCharBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataCharBuffer) super.buffer(mode);
        }

        public DataCharBuffer buffer(long capacity) {
            return (DataCharBuffer) super.buffer(capacity);
        }

        public DataCharBuffer buffer() {
            return (DataCharBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public CharArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public CharArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableCharArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJACharArray(JArrays.copyOfRange(
                        charArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableCharArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableCharArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJACharArray(JArrays.copyOfRange(
                        charArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableCharArray) super.updatableClone(memoryModel);
            }
        }

        public char[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJACharArray
            extends JACharArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJACharArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJACharArray(char[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJACharArray(char[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.charArray.length;
        }

        public char[] ja() {
            if (length == this.charArray.length) {
                return this.charArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJACharArray(charArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJACharSubArray(charArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJACharArray(charArray, (int) count);
            } else {
                return new TrustedJACharSubArray(charArray, (int) count, (int) position);
            }
        }

        public CharArray asImmutable() {
            return new JACharArray(charArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJACharSubArray result = new TrustedJACharSubArray(charArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJACharSubArray
            extends JACharSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJACharSubArray(
                char[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJACharSubArray(
                char[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.charArray.length;
        }

        public char[] ja() {
            if (offset == 0 && length == this.charArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.charArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJACharArray(charArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJACharSubArray result = new TrustedJACharSubArray(charArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJACharArray(charArray, (int) count);
            } else {
                TrustedJACharSubArray result = new TrustedJACharSubArray(charArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public CharArray asImmutable() {
            return new JACharSubArray(charArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJACharSubArray result = new TrustedJACharSubArray(charArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJACharArray
            extends TrustedJACharArray implements UpdatableCharArray {
        UpdatableJACharArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJACharArray(char[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJACharArray(char[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setChar(index, (Character) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.charArray[(int) destIndex] = this.charArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.charArray, (int) srcIndex, this.charArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            char temp = this.charArray[i];
            this.charArray[i] = this.charArray[j];
            this.charArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                char temp = this.charArray[i];
                this.charArray[i] = this.charArray[j];
                this.charArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JACharSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    charArray[0] = a.charArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.charArray, a.offset, charArray, 0, count);
                    return this;
                }
            } else if (src instanceof JACharArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.charArray, 0, charArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJACharSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        char temp = this.charArray[i];
                        this.charArray[i] = a.charArray[j];
                        a.charArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJACharArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        char temp = this.charArray[i];
                        this.charArray[i] = a.charArray[i];
                        a.charArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setChar(index, (char) value);
        }

        public final void setLong(long index, long value) {
            setChar(index, (char) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.charArray[(int) index] = (char) value;
        }

        public final void setChar(long index, char value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.charArray[(int) index] = value;
        }

        public UpdatableCharArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableCharArray fill(long position, long count, double value) {
            return fill(position, count, (char) value);
        }

        public UpdatableCharArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableCharArray fill(long position, long count, long value) {
            return fill(position, count, (char) value);
        }

        public UpdatableCharArray fill(char value) {
            return fill(0, length, value);
        }

        public UpdatableCharArray fill(long position, long count, char value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillCharArray(this.charArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableCharArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJACharArray(charArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJACharSubArray(charArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableCharArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJACharArray(charArray, (int) count);
            } else {
                return new UpdatableJACharSubArray(charArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final CharArray asImmutable() {
            return new JACharArray(charArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final CharArray asTrustedImmutable() {
            return new TrustedJACharArray(charArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJACharSubArray result = new UpdatableJACharSubArray(charArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableCharArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJACharSubArray
            extends TrustedJACharSubArray implements UpdatableCharArray {
        UpdatableJACharSubArray(
                char[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJACharSubArray(
                char[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setChar(index, (Character) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.charArray[offset + (int) destIndex] = this.charArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.charArray, offset + (int) srcIndex,
                    this.charArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            char temp = this.charArray[i];
            this.charArray[i] = this.charArray[j];
            this.charArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                char temp = this.charArray[i];
                this.charArray[i] = this.charArray[j];
                this.charArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JACharSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    charArray[offset] = a.charArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.charArray, a.offset, charArray, offset, count);
                    return this;
                }
            } else if (src instanceof JACharArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    charArray[offset] = a.charArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.charArray, 0, charArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJACharSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        char temp = this.charArray[i];
                        this.charArray[i] = a.charArray[j];
                        a.charArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJACharArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        char temp = this.charArray[i];
                        this.charArray[i] = a.charArray[j];
                        a.charArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setChar(index, (char) value);
        }

        public final void setLong(long index, long value) {
            setChar(index, (char) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.charArray[offset + (int) index] = (char) value;
        }

        public final void setChar(long index, char value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.charArray[offset + (int) index] = value;
        }

        public UpdatableCharArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableCharArray fill(long position, long count, double value) {
            return fill(position, count, (char) value);
        }

        public UpdatableCharArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableCharArray fill(long position, long count, long value) {
            return fill(position, count, (char) value);
        }

        public UpdatableCharArray fill(char value) {
            return fill(0, length, value);
        }

        public UpdatableCharArray fill(long position, long count, char value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillCharArray(this.charArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableCharArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJACharArray(charArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJACharSubArray result = new UpdatableJACharSubArray(charArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableCharArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJACharArray(charArray, (int) count);
            } else {
                UpdatableJACharSubArray result = new UpdatableJACharSubArray(charArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final CharArray asImmutable() {
            return new JACharSubArray(charArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final CharArray asTrustedImmutable() {
            TrustedJACharSubArray result = new TrustedJACharSubArray(charArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJACharSubArray result = new UpdatableJACharSubArray(charArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableCharArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJACharArray
            extends UpdatableJACharArray implements MutableCharArray {
        MutableJACharArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJACharArray(char[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJACharArray(char[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nCharCopies(toIndex - fromIndex, (char) 0), true);
        }

        public MutableCharArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableCharArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableCharArray trim() {
            trimImpl();
            return this;
        }

        public MutableCharArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Character.valueOf(popChar());
        }

        public void pushElement(Object value) {
            pushChar((Character) value);
        }

        public double popDouble() {
            return (double) popChar();
        }

        public long popLong() {
            return (long) popChar();
        }

        public int popInt() {
            return (int) popChar();
        }

        public void addDouble(double value) {
            pushChar((char) value);
        }

        public void addLong(long value) {
            pushChar((char) value);
        }

        public void addInt(int value) {
            pushChar((char) value);
        }

        public char popChar() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            char result = this.charArray[i];
            this.length = i;
            this.charArray[i] = (char) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushChar(char value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.charArray[i] = value;
        }

        public MutableCharArray append(String value) {
            long index = length;
            int count = value.length();
            if (count > 0) {
                Arrays.lengthUnsigned(this, index + count);
                value.getChars(0, count, this.charArray, javaArrayOffset() + (int) index);
            }
            return this;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableCharArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableCharArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableCharArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableCharArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableCharArray asCopyOnNextWrite() {
            MutableJACharSubArray result = new MutableJACharSubArray(charArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableCharArray asUnresizable() {
            return new UpdatableJACharArray(charArray, (int) capacity(), (int) length());
        }

        public MutableCharArray shallowClone() {
            return (MutableCharArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJACharSubArray
            extends UpdatableJACharSubArray implements MutableCharArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJACharSubArray(char[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJACharSubArray(char[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nCharCopies(toIndex - fromIndex, (char) 0), true);
        }

        public MutableCharArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableCharArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableCharArray trim() {
            trimImpl();
            return this;
        }

        public MutableCharArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Character.valueOf(popChar());
        }

        public void pushElement(Object value) {
            pushChar((Character) value);
        }

        public double popDouble() {
            return (double) popChar();
        }

        public long popLong() {
            return (long) popChar();
        }

        public int popInt() {
            return (int) popChar();
        }

        public void addDouble(double value) {
            pushChar((char) value);
        }

        public void addLong(long value) {
            pushChar((char) value);
        }

        public void addInt(int value) {
            pushChar((char) value);
        }

        public char popChar() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            char result = this.charArray[offset + i];
            this.length = i;
            this.charArray[offset + i] = (char) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushChar(char value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.charArray[offset + i] = value;
        }

        public MutableCharArray append(String value) {
            long index = length;
            int count = value.length();
            if (count > 0) {
                Arrays.lengthUnsigned(this, index + count);
                value.getChars(0, count, this.charArray, javaArrayOffset() + (int) index);
            }
            return this;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableCharArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableCharArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableCharArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableCharArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableCharArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJACharSubArray result = new MutableJACharSubArray(charArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableCharArray asUnresizable() {
            UpdatableJACharSubArray result = new UpdatableJACharSubArray(charArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableCharArray shallowClone() {
            return (MutableCharArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray char[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(charArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      (return\s+)-157777 ==> $10;;
      (return\s+)157778  ==> $10xFF;;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/min) ==> $1minPossibleValue();;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/max) ==> $1maxPossibleValue();;
      value\s*==\s*\(float\)\s*value ==> value == ((int) value & 0xFF) ;;
      float\s+getFloat ==> int getByte ;;
      Float.valueOf\((\w+) ==> Byte.valueOf((byte) $1 ;;
      Float(?!ing) ==> Byte ;;
      float ==> byte ;;
      PER_FLOAT ==> PER_BYTE ;;
      \((double|long|int)\)\s*popByte\(\) ==> ($1) (popByte() & 0xFF) ;;
      (return\s+(?:\(\w+\)\s*)?)(this\.byteArray\[(?:offset\s*\+\s*)?\(int\)\s*index\])\s*; ==> $1($2 & 0xFF);
         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("cast")
    static class JAByteArray extends AbstractJAArray implements ByteArray {
        byte[] byteArray;

        JAByteArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.byteArray = (byte[]) super.array;
        }

        JAByteArray(byte[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.byteArray = initialArray;
        }

        JAByteArray(byte[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.byteArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.byteArray = (byte[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return byte.class;
        }

        public Class<? extends ByteArray> type() {
            return ByteArray.class;
        }

        public Class<? extends UpdatableByteArray> updatableType() {
            return UpdatableByteArray.class;
        }

        public Class<? extends MutableByteArray> mutableType() {
            return MutableByteArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Byte.valueOf((byte) getByte(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_BYTE;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public final long minPossibleValue() {
            return 0;
        }

        public final long maxPossibleValue() {
            return 0xFF;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) (this.byteArray[(int) index] & 0xFF);
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFF) ? indexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFF) ? lastIndexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) (this.byteArray[(int) index] & 0xFF);
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) (this.byteArray[(int) index] & 0xFF);
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFF) ? indexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFF) ? lastIndexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final int getByte(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.byteArray[(int) index] & 0xFF);
        }

        public final long indexOf(long lowIndex, long highIndex, byte value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfByte(this.byteArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, byte value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfByte(this.byteArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JAByteArray(byteArray, (int) (toIndex - fromIndex));
            } else {
                return new JAByteSubArray(byteArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JAByteArray(byteArray, (int) count);
            } else {
                return new JAByteSubArray(byteArray, (int) count, (int) position);
            }
        }

        public DataByteBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataByteBuffer) super.buffer(mode, capacity);
        }

        public DataByteBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataByteBuffer) super.buffer(mode);
        }

        public DataByteBuffer buffer(long capacity) {
            return (DataByteBuffer) super.buffer(capacity);
        }

        public DataByteBuffer buffer() {
            return (DataByteBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public ByteArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public ByteArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableByteArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAByteArray(JArrays.copyOfRange(
                        byteArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableByteArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableByteArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAByteArray(JArrays.copyOfRange(
                        byteArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableByteArray) super.updatableClone(memoryModel);
            }
        }

        public byte[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array byte[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JAByteSubArray extends AbstractJAArray implements ByteArray {
        byte[] byteArray;
        int offset;

        JAByteSubArray(byte[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.byteArray = initialArray;
            this.offset = initialOffset;
        }

        JAByteSubArray(byte[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.byteArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.byteArray = (byte[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return byte.class;
        }

        public Class<? extends ByteArray> type() {
            return ByteArray.class;
        }

        public Class<? extends UpdatableByteArray> updatableType() {
            return UpdatableByteArray.class;
        }

        public Class<? extends MutableByteArray> mutableType() {
            return MutableByteArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Byte.valueOf((byte) getByte(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_BYTE;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public long minPossibleValue() {
            return 0;
        }

        public long maxPossibleValue() {
            return 0xFF;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) (this.byteArray[offset + (int) index] & 0xFF);
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFF) ? indexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFF) ? lastIndexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) (this.byteArray[offset + (int) index] & 0xFF);
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) (this.byteArray[offset + (int) index] & 0xFF);
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFF) ? indexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFF) ? lastIndexOf(lowIndex, highIndex, (byte) value) : -1;
        }

        public final int getByte(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.byteArray[offset + (int) index] & 0xFF);
        }

        public long indexOf(long lowIndex, long highIndex, byte value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfByte(this.byteArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, byte value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfByte(this.byteArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JAByteArray(byteArray, (int) (toIndex - fromIndex));
            } else {
                return new JAByteSubArray(byteArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JAByteArray(byteArray, (int) count);
            } else {
                return new JAByteSubArray(byteArray, (int) count, offset + (int) position);
            }
        }

        public DataByteBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataByteBuffer) super.buffer(mode, capacity);
        }

        public DataByteBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataByteBuffer) super.buffer(mode);
        }

        public DataByteBuffer buffer(long capacity) {
            return (DataByteBuffer) super.buffer(capacity);
        }

        public DataByteBuffer buffer() {
            return (DataByteBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public ByteArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public ByteArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableByteArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAByteArray(JArrays.copyOfRange(
                        byteArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableByteArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableByteArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAByteArray(JArrays.copyOfRange(
                        byteArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableByteArray) super.updatableClone(memoryModel);
            }
        }

        public byte[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJAByteArray
            extends JAByteArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAByteArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJAByteArray(byte[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAByteArray(byte[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.byteArray.length;
        }

        public byte[] ja() {
            if (length == this.byteArray.length) {
                return this.byteArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJAByteArray(byteArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJAByteSubArray(byteArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJAByteArray(byteArray, (int) count);
            } else {
                return new TrustedJAByteSubArray(byteArray, (int) count, (int) position);
            }
        }

        public ByteArray asImmutable() {
            return new JAByteArray(byteArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJAByteSubArray result = new TrustedJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJAByteSubArray
            extends JAByteSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAByteSubArray(
                byte[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAByteSubArray(
                byte[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.byteArray.length;
        }

        public byte[] ja() {
            if (offset == 0 && length == this.byteArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.byteArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAByteArray(byteArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJAByteSubArray result = new TrustedJAByteSubArray(byteArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAByteArray(byteArray, (int) count);
            } else {
                TrustedJAByteSubArray result = new TrustedJAByteSubArray(byteArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public ByteArray asImmutable() {
            return new JAByteSubArray(byteArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJAByteSubArray result = new TrustedJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJAByteArray
            extends TrustedJAByteArray implements UpdatableByteArray {
        UpdatableJAByteArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJAByteArray(byte[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJAByteArray(byte[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setByte(index, (Byte) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.byteArray[(int) destIndex] = this.byteArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.byteArray, (int) srcIndex, this.byteArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            byte temp = this.byteArray[i];
            this.byteArray[i] = this.byteArray[j];
            this.byteArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                byte temp = this.byteArray[i];
                this.byteArray[i] = this.byteArray[j];
                this.byteArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAByteSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    byteArray[0] = a.byteArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.byteArray, a.offset, byteArray, 0, count);
                    return this;
                }
            } else if (src instanceof JAByteArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.byteArray, 0, byteArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAByteSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        byte temp = this.byteArray[i];
                        this.byteArray[i] = a.byteArray[j];
                        a.byteArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAByteArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        byte temp = this.byteArray[i];
                        this.byteArray[i] = a.byteArray[i];
                        a.byteArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setByte(index, (byte) value);
        }

        public final void setLong(long index, long value) {
            setByte(index, (byte) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.byteArray[(int) index] = (byte) value;
        }

        public final void setByte(long index, byte value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.byteArray[(int) index] = value;
        }

        public UpdatableByteArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableByteArray fill(long position, long count, double value) {
            return fill(position, count, (byte) value);
        }

        public UpdatableByteArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableByteArray fill(long position, long count, long value) {
            return fill(position, count, (byte) value);
        }

        public UpdatableByteArray fill(byte value) {
            return fill(0, length, value);
        }

        public UpdatableByteArray fill(long position, long count, byte value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillByteArray(this.byteArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableByteArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJAByteArray(byteArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJAByteSubArray(byteArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableByteArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJAByteArray(byteArray, (int) count);
            } else {
                return new UpdatableJAByteSubArray(byteArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final ByteArray asImmutable() {
            return new JAByteArray(byteArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final ByteArray asTrustedImmutable() {
            return new TrustedJAByteArray(byteArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJAByteSubArray result = new UpdatableJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableByteArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJAByteSubArray
            extends TrustedJAByteSubArray implements UpdatableByteArray {
        UpdatableJAByteSubArray(
                byte[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJAByteSubArray(
                byte[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setByte(index, (Byte) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.byteArray[offset + (int) destIndex] = this.byteArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.byteArray, offset + (int) srcIndex,
                    this.byteArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            byte temp = this.byteArray[i];
            this.byteArray[i] = this.byteArray[j];
            this.byteArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                byte temp = this.byteArray[i];
                this.byteArray[i] = this.byteArray[j];
                this.byteArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAByteSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    byteArray[offset] = a.byteArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.byteArray, a.offset, byteArray, offset, count);
                    return this;
                }
            } else if (src instanceof JAByteArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    byteArray[offset] = a.byteArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.byteArray, 0, byteArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAByteSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        byte temp = this.byteArray[i];
                        this.byteArray[i] = a.byteArray[j];
                        a.byteArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAByteArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        byte temp = this.byteArray[i];
                        this.byteArray[i] = a.byteArray[j];
                        a.byteArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setByte(index, (byte) value);
        }

        public final void setLong(long index, long value) {
            setByte(index, (byte) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.byteArray[offset + (int) index] = (byte) value;
        }

        public final void setByte(long index, byte value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.byteArray[offset + (int) index] = value;
        }

        public UpdatableByteArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableByteArray fill(long position, long count, double value) {
            return fill(position, count, (byte) value);
        }

        public UpdatableByteArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableByteArray fill(long position, long count, long value) {
            return fill(position, count, (byte) value);
        }

        public UpdatableByteArray fill(byte value) {
            return fill(0, length, value);
        }

        public UpdatableByteArray fill(long position, long count, byte value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillByteArray(this.byteArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableByteArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAByteArray(byteArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJAByteSubArray result = new UpdatableJAByteSubArray(byteArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableByteArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAByteArray(byteArray, (int) count);
            } else {
                UpdatableJAByteSubArray result = new UpdatableJAByteSubArray(byteArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final ByteArray asImmutable() {
            return new JAByteSubArray(byteArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final ByteArray asTrustedImmutable() {
            TrustedJAByteSubArray result = new TrustedJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJAByteSubArray result = new UpdatableJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableByteArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAByteArray
            extends UpdatableJAByteArray implements MutableByteArray {
        MutableJAByteArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJAByteArray(byte[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJAByteArray(byte[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nByteCopies(toIndex - fromIndex, (byte) 0), true);
        }

        public MutableByteArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableByteArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableByteArray trim() {
            trimImpl();
            return this;
        }

        public MutableByteArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Byte.valueOf((byte) popByte());
        }

        public void pushElement(Object value) {
            pushByte((Byte) value);
        }

        public double popDouble() {
            return (double) (popByte() & 0xFF);
        }

        public long popLong() {
            return (long) (popByte() & 0xFF);
        }

        public int popInt() {
            return (int) (popByte() & 0xFF);
        }

        public void addDouble(double value) {
            pushByte((byte) value);
        }

        public void addLong(long value) {
            pushByte((byte) value);
        }

        public void addInt(int value) {
            pushByte((byte) value);
        }

        public byte popByte() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            byte result = this.byteArray[i];
            this.length = i;
            this.byteArray[i] = (byte) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushByte(byte value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.byteArray[i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableByteArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableByteArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableByteArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableByteArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableByteArray asCopyOnNextWrite() {
            MutableJAByteSubArray result = new MutableJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableByteArray asUnresizable() {
            return new UpdatableJAByteArray(byteArray, (int) capacity(), (int) length());
        }

        public MutableByteArray shallowClone() {
            return (MutableByteArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAByteSubArray
            extends UpdatableJAByteSubArray implements MutableByteArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJAByteSubArray(byte[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJAByteSubArray(byte[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nByteCopies(toIndex - fromIndex, (byte) 0), true);
        }

        public MutableByteArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableByteArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableByteArray trim() {
            trimImpl();
            return this;
        }

        public MutableByteArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Byte.valueOf((byte) popByte());
        }

        public void pushElement(Object value) {
            pushByte((Byte) value);
        }

        public double popDouble() {
            return (double) (popByte() & 0xFF);
        }

        public long popLong() {
            return (long) (popByte() & 0xFF);
        }

        public int popInt() {
            return (int) (popByte() & 0xFF);
        }

        public void addDouble(double value) {
            pushByte((byte) value);
        }

        public void addLong(long value) {
            pushByte((byte) value);
        }

        public void addInt(int value) {
            pushByte((byte) value);
        }

        public byte popByte() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            byte result = this.byteArray[offset + i];
            this.length = i;
            this.byteArray[offset + i] = (byte) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushByte(byte value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.byteArray[offset + i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableByteArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableByteArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableByteArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableByteArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableByteArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJAByteSubArray result = new MutableJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableByteArray asUnresizable() {
            UpdatableJAByteSubArray result = new UpdatableJAByteSubArray(byteArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableByteArray shallowClone() {
            return (MutableByteArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray byte[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(byteArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      (return\s+)-157777 ==> $10;;
      (return\s+)157778  ==> $10xFFFF;;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/min) ==> $1minPossibleValue();;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/max) ==> $1maxPossibleValue();;
      value\s*==\s*\(float\)\s*value ==> value == ((int) value & 0xFFFF) ;;
      float\s+getFloat ==> int getShort ;;
      Float.valueOf\((\w+) ==> Short.valueOf((short) $1 ;;
      Float(?!ing) ==> Short ;;
      float ==> short ;;
      PER_FLOAT ==> PER_SHORT ;;
      \((double|long|int)\)\s*popShort\(\) ==> ($1) (popShort() & 0xFFFF) ;;
      (return\s+(?:\(\w+\)\s*)?)(this\.shortArray\[(?:offset\s*\+\s*)?\(int\)\s*index\])\s*; ==> $1($2 & 0xFFFF);
         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("cast")
    static class JAShortArray extends AbstractJAArray implements ShortArray {
        short[] shortArray;

        JAShortArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.shortArray = (short[]) super.array;
        }

        JAShortArray(short[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.shortArray = initialArray;
        }

        JAShortArray(short[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.shortArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.shortArray = (short[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return short.class;
        }

        public Class<? extends ShortArray> type() {
            return ShortArray.class;
        }

        public Class<? extends UpdatableShortArray> updatableType() {
            return UpdatableShortArray.class;
        }

        public Class<? extends MutableShortArray> mutableType() {
            return MutableShortArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Short.valueOf((short) getShort(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_SHORT;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public final long minPossibleValue() {
            return 0;
        }

        public final long maxPossibleValue() {
            return 0xFFFF;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) (this.shortArray[(int) index] & 0xFFFF);
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFFFF) ? indexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFFFF) ? lastIndexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) (this.shortArray[(int) index] & 0xFFFF);
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) (this.shortArray[(int) index] & 0xFFFF);
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFFFF) ? indexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFFFF) ? lastIndexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final int getShort(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.shortArray[(int) index] & 0xFFFF);
        }

        public final long indexOf(long lowIndex, long highIndex, short value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfShort(this.shortArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, short value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfShort(this.shortArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JAShortArray(shortArray, (int) (toIndex - fromIndex));
            } else {
                return new JAShortSubArray(shortArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JAShortArray(shortArray, (int) count);
            } else {
                return new JAShortSubArray(shortArray, (int) count, (int) position);
            }
        }

        public DataShortBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataShortBuffer) super.buffer(mode, capacity);
        }

        public DataShortBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataShortBuffer) super.buffer(mode);
        }

        public DataShortBuffer buffer(long capacity) {
            return (DataShortBuffer) super.buffer(capacity);
        }

        public DataShortBuffer buffer() {
            return (DataShortBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public ShortArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public ShortArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableShortArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAShortArray(JArrays.copyOfRange(
                        shortArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableShortArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableShortArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAShortArray(JArrays.copyOfRange(
                        shortArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableShortArray) super.updatableClone(memoryModel);
            }
        }

        public short[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array short[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JAShortSubArray extends AbstractJAArray implements ShortArray {
        short[] shortArray;
        int offset;

        JAShortSubArray(short[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.shortArray = initialArray;
            this.offset = initialOffset;
        }

        JAShortSubArray(short[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.shortArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.shortArray = (short[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return short.class;
        }

        public Class<? extends ShortArray> type() {
            return ShortArray.class;
        }

        public Class<? extends UpdatableShortArray> updatableType() {
            return UpdatableShortArray.class;
        }

        public Class<? extends MutableShortArray> mutableType() {
            return MutableShortArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Short.valueOf((short) getShort(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_SHORT;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public long minPossibleValue() {
            return 0;
        }

        public long maxPossibleValue() {
            return 0xFFFF;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) (this.shortArray[offset + (int) index] & 0xFFFF);
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFFFF) ? indexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == ((int) value & 0xFFFF) ? lastIndexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) (this.shortArray[offset + (int) index] & 0xFFFF);
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) (this.shortArray[offset + (int) index] & 0xFFFF);
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFFFF) ? indexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == ((int) value & 0xFFFF) ? lastIndexOf(lowIndex, highIndex, (short) value) : -1;
        }

        public final int getShort(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.shortArray[offset + (int) index] & 0xFFFF);
        }

        public long indexOf(long lowIndex, long highIndex, short value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfShort(this.shortArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, short value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfShort(this.shortArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JAShortArray(shortArray, (int) (toIndex - fromIndex));
            } else {
                return new JAShortSubArray(shortArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JAShortArray(shortArray, (int) count);
            } else {
                return new JAShortSubArray(shortArray, (int) count, offset + (int) position);
            }
        }

        public DataShortBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataShortBuffer) super.buffer(mode, capacity);
        }

        public DataShortBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataShortBuffer) super.buffer(mode);
        }

        public DataShortBuffer buffer(long capacity) {
            return (DataShortBuffer) super.buffer(capacity);
        }

        public DataShortBuffer buffer() {
            return (DataShortBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public ShortArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public ShortArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableShortArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAShortArray(JArrays.copyOfRange(
                        shortArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableShortArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableShortArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAShortArray(JArrays.copyOfRange(
                        shortArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableShortArray) super.updatableClone(memoryModel);
            }
        }

        public short[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJAShortArray
            extends JAShortArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAShortArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJAShortArray(short[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAShortArray(short[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.shortArray.length;
        }

        public short[] ja() {
            if (length == this.shortArray.length) {
                return this.shortArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJAShortArray(shortArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJAShortSubArray(shortArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJAShortArray(shortArray, (int) count);
            } else {
                return new TrustedJAShortSubArray(shortArray, (int) count, (int) position);
            }
        }

        public ShortArray asImmutable() {
            return new JAShortArray(shortArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJAShortSubArray result = new TrustedJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJAShortSubArray
            extends JAShortSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAShortSubArray(
                short[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAShortSubArray(
                short[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.shortArray.length;
        }

        public short[] ja() {
            if (offset == 0 && length == this.shortArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.shortArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAShortArray(shortArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJAShortSubArray result = new TrustedJAShortSubArray(shortArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAShortArray(shortArray, (int) count);
            } else {
                TrustedJAShortSubArray result = new TrustedJAShortSubArray(shortArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public ShortArray asImmutable() {
            return new JAShortSubArray(shortArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJAShortSubArray result = new TrustedJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJAShortArray
            extends TrustedJAShortArray implements UpdatableShortArray {
        UpdatableJAShortArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJAShortArray(short[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJAShortArray(short[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setShort(index, (Short) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.shortArray[(int) destIndex] = this.shortArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.shortArray, (int) srcIndex, this.shortArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            short temp = this.shortArray[i];
            this.shortArray[i] = this.shortArray[j];
            this.shortArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                short temp = this.shortArray[i];
                this.shortArray[i] = this.shortArray[j];
                this.shortArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAShortSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    shortArray[0] = a.shortArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.shortArray, a.offset, shortArray, 0, count);
                    return this;
                }
            } else if (src instanceof JAShortArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.shortArray, 0, shortArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAShortSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        short temp = this.shortArray[i];
                        this.shortArray[i] = a.shortArray[j];
                        a.shortArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAShortArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        short temp = this.shortArray[i];
                        this.shortArray[i] = a.shortArray[i];
                        a.shortArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setShort(index, (short) value);
        }

        public final void setLong(long index, long value) {
            setShort(index, (short) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.shortArray[(int) index] = (short) value;
        }

        public final void setShort(long index, short value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.shortArray[(int) index] = value;
        }

        public UpdatableShortArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableShortArray fill(long position, long count, double value) {
            return fill(position, count, (short) value);
        }

        public UpdatableShortArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableShortArray fill(long position, long count, long value) {
            return fill(position, count, (short) value);
        }

        public UpdatableShortArray fill(short value) {
            return fill(0, length, value);
        }

        public UpdatableShortArray fill(long position, long count, short value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillShortArray(this.shortArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableShortArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJAShortArray(shortArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJAShortSubArray(shortArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableShortArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJAShortArray(shortArray, (int) count);
            } else {
                return new UpdatableJAShortSubArray(shortArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final ShortArray asImmutable() {
            return new JAShortArray(shortArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final ShortArray asTrustedImmutable() {
            return new TrustedJAShortArray(shortArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJAShortSubArray result = new UpdatableJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableShortArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJAShortSubArray
            extends TrustedJAShortSubArray implements UpdatableShortArray {
        UpdatableJAShortSubArray(
                short[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJAShortSubArray(
                short[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setShort(index, (Short) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.shortArray[offset + (int) destIndex] = this.shortArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.shortArray, offset + (int) srcIndex,
                    this.shortArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            short temp = this.shortArray[i];
            this.shortArray[i] = this.shortArray[j];
            this.shortArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                short temp = this.shortArray[i];
                this.shortArray[i] = this.shortArray[j];
                this.shortArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAShortSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    shortArray[offset] = a.shortArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.shortArray, a.offset, shortArray, offset, count);
                    return this;
                }
            } else if (src instanceof JAShortArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    shortArray[offset] = a.shortArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.shortArray, 0, shortArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAShortSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        short temp = this.shortArray[i];
                        this.shortArray[i] = a.shortArray[j];
                        a.shortArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAShortArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        short temp = this.shortArray[i];
                        this.shortArray[i] = a.shortArray[j];
                        a.shortArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setShort(index, (short) value);
        }

        public final void setLong(long index, long value) {
            setShort(index, (short) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.shortArray[offset + (int) index] = (short) value;
        }

        public final void setShort(long index, short value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.shortArray[offset + (int) index] = value;
        }

        public UpdatableShortArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableShortArray fill(long position, long count, double value) {
            return fill(position, count, (short) value);
        }

        public UpdatableShortArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableShortArray fill(long position, long count, long value) {
            return fill(position, count, (short) value);
        }

        public UpdatableShortArray fill(short value) {
            return fill(0, length, value);
        }

        public UpdatableShortArray fill(long position, long count, short value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillShortArray(this.shortArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableShortArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAShortArray(shortArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJAShortSubArray result = new UpdatableJAShortSubArray(shortArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableShortArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAShortArray(shortArray, (int) count);
            } else {
                UpdatableJAShortSubArray result = new UpdatableJAShortSubArray(shortArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final ShortArray asImmutable() {
            return new JAShortSubArray(shortArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final ShortArray asTrustedImmutable() {
            TrustedJAShortSubArray result = new TrustedJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJAShortSubArray result = new UpdatableJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableShortArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAShortArray
            extends UpdatableJAShortArray implements MutableShortArray {
        MutableJAShortArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJAShortArray(short[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJAShortArray(short[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nShortCopies(toIndex - fromIndex, (short) 0), true);
        }

        public MutableShortArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableShortArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableShortArray trim() {
            trimImpl();
            return this;
        }

        public MutableShortArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Short.valueOf((short) popShort());
        }

        public void pushElement(Object value) {
            pushShort((Short) value);
        }

        public double popDouble() {
            return (double) (popShort() & 0xFFFF);
        }

        public long popLong() {
            return (long) (popShort() & 0xFFFF);
        }

        public int popInt() {
            return (int) (popShort() & 0xFFFF);
        }

        public void addDouble(double value) {
            pushShort((short) value);
        }

        public void addLong(long value) {
            pushShort((short) value);
        }

        public void addInt(int value) {
            pushShort((short) value);
        }

        public short popShort() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            short result = this.shortArray[i];
            this.length = i;
            this.shortArray[i] = (short) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushShort(short value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.shortArray[i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableShortArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableShortArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableShortArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableShortArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableShortArray asCopyOnNextWrite() {
            MutableJAShortSubArray result = new MutableJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableShortArray asUnresizable() {
            return new UpdatableJAShortArray(shortArray, (int) capacity(), (int) length());
        }

        public MutableShortArray shallowClone() {
            return (MutableShortArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAShortSubArray
            extends UpdatableJAShortSubArray implements MutableShortArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJAShortSubArray(short[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJAShortSubArray(short[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nShortCopies(toIndex - fromIndex, (short) 0), true);
        }

        public MutableShortArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableShortArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableShortArray trim() {
            trimImpl();
            return this;
        }

        public MutableShortArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Short.valueOf((short) popShort());
        }

        public void pushElement(Object value) {
            pushShort((Short) value);
        }

        public double popDouble() {
            return (double) (popShort() & 0xFFFF);
        }

        public long popLong() {
            return (long) (popShort() & 0xFFFF);
        }

        public int popInt() {
            return (int) (popShort() & 0xFFFF);
        }

        public void addDouble(double value) {
            pushShort((short) value);
        }

        public void addLong(long value) {
            pushShort((short) value);
        }

        public void addInt(int value) {
            pushShort((short) value);
        }

        public short popShort() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            short result = this.shortArray[offset + i];
            this.length = i;
            this.shortArray[offset + i] = (short) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushShort(short value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.shortArray[offset + i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableShortArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableShortArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableShortArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableShortArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableShortArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJAShortSubArray result = new MutableJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableShortArray asUnresizable() {
            UpdatableJAShortSubArray result = new UpdatableJAShortSubArray(shortArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableShortArray shallowClone() {
            return (MutableShortArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray short[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(shortArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      (return\s+)-157777 ==> $1Integer.MIN_VALUE;;
      (return\s+)157778  ==> $1Integer.MAX_VALUE;;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/min) ==> $1minPossibleValue();;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/max) ==> $1maxPossibleValue();;
      public(\s+\w+)+\s+(get|set|pop)Int(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      \bFloat\b ==> Integer ;;
      Float(?!ing) ==> Int ;;
      float ==> int ;;
      PER_FLOAT ==> PER_INT
         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("cast")
    static class JAIntArray extends AbstractJAArray implements IntArray {
        int[] intArray;

        JAIntArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.intArray = (int[]) super.array;
        }

        JAIntArray(int[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.intArray = initialArray;
        }

        JAIntArray(int[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.intArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.intArray = (int[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return int.class;
        }

        public Class<? extends IntArray> type() {
            return IntArray.class;
        }

        public Class<? extends UpdatableIntArray> updatableType() {
            return UpdatableIntArray.class;
        }

        public Class<? extends MutableIntArray> mutableType() {
            return MutableIntArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Integer.valueOf(getInt(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_INT;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public final long minPossibleValue() {
            return Integer.MIN_VALUE;
        }

        public final long maxPossibleValue() {
            return Integer.MAX_VALUE;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.intArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (int) value ? indexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (int) value ? lastIndexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.intArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (int) value ? indexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (int) value ? lastIndexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.intArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, int value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfInt(this.intArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, int value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfInt(this.intArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JAIntArray(intArray, (int) (toIndex - fromIndex));
            } else {
                return new JAIntSubArray(intArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JAIntArray(intArray, (int) count);
            } else {
                return new JAIntSubArray(intArray, (int) count, (int) position);
            }
        }

        public DataIntBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataIntBuffer) super.buffer(mode, capacity);
        }

        public DataIntBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataIntBuffer) super.buffer(mode);
        }

        public DataIntBuffer buffer(long capacity) {
            return (DataIntBuffer) super.buffer(capacity);
        }

        public DataIntBuffer buffer() {
            return (DataIntBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public IntArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public IntArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableIntArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAIntArray(JArrays.copyOfRange(
                        intArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableIntArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableIntArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAIntArray(JArrays.copyOfRange(
                        intArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableIntArray) super.updatableClone(memoryModel);
            }
        }

        public int[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array int[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JAIntSubArray extends AbstractJAArray implements IntArray {
        int[] intArray;
        int offset;

        JAIntSubArray(int[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.intArray = initialArray;
            this.offset = initialOffset;
        }

        JAIntSubArray(int[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.intArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.intArray = (int[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return int.class;
        }

        public Class<? extends IntArray> type() {
            return IntArray.class;
        }

        public Class<? extends UpdatableIntArray> updatableType() {
            return UpdatableIntArray.class;
        }

        public Class<? extends MutableIntArray> mutableType() {
            return MutableIntArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Integer.valueOf(getInt(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_INT;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public long minPossibleValue() {
            return Integer.MIN_VALUE;
        }

        public long maxPossibleValue() {
            return Integer.MAX_VALUE;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.intArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (int) value ? indexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (int) value ? lastIndexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.intArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (int) value ? indexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (int) value ? lastIndexOf(lowIndex, highIndex, (int) value) : -1;
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.intArray[offset + (int) index];
        }

        public long indexOf(long lowIndex, long highIndex, int value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfInt(this.intArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, int value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfInt(this.intArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JAIntArray(intArray, (int) (toIndex - fromIndex));
            } else {
                return new JAIntSubArray(intArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JAIntArray(intArray, (int) count);
            } else {
                return new JAIntSubArray(intArray, (int) count, offset + (int) position);
            }
        }

        public DataIntBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataIntBuffer) super.buffer(mode, capacity);
        }

        public DataIntBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataIntBuffer) super.buffer(mode);
        }

        public DataIntBuffer buffer(long capacity) {
            return (DataIntBuffer) super.buffer(capacity);
        }

        public DataIntBuffer buffer() {
            return (DataIntBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public IntArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public IntArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableIntArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAIntArray(JArrays.copyOfRange(
                        intArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableIntArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableIntArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAIntArray(JArrays.copyOfRange(
                        intArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableIntArray) super.updatableClone(memoryModel);
            }
        }

        public int[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJAIntArray
            extends JAIntArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAIntArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJAIntArray(int[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAIntArray(int[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.intArray.length;
        }

        public int[] ja() {
            if (length == this.intArray.length) {
                return this.intArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJAIntArray(intArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJAIntSubArray(intArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJAIntArray(intArray, (int) count);
            } else {
                return new TrustedJAIntSubArray(intArray, (int) count, (int) position);
            }
        }

        public IntArray asImmutable() {
            return new JAIntArray(intArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJAIntSubArray result = new TrustedJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJAIntSubArray
            extends JAIntSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAIntSubArray(
                int[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAIntSubArray(
                int[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.intArray.length;
        }

        public int[] ja() {
            if (offset == 0 && length == this.intArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.intArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAIntArray(intArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJAIntSubArray result = new TrustedJAIntSubArray(intArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAIntArray(intArray, (int) count);
            } else {
                TrustedJAIntSubArray result = new TrustedJAIntSubArray(intArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public IntArray asImmutable() {
            return new JAIntSubArray(intArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJAIntSubArray result = new TrustedJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJAIntArray
            extends TrustedJAIntArray implements UpdatableIntArray {
        UpdatableJAIntArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJAIntArray(int[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJAIntArray(int[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setInt(index, (Integer) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.intArray[(int) destIndex] = this.intArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.intArray, (int) srcIndex, this.intArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            int temp = this.intArray[i];
            this.intArray[i] = this.intArray[j];
            this.intArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                int temp = this.intArray[i];
                this.intArray[i] = this.intArray[j];
                this.intArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAIntSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    intArray[0] = a.intArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.intArray, a.offset, intArray, 0, count);
                    return this;
                }
            } else if (src instanceof JAIntArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.intArray, 0, intArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAIntSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        int temp = this.intArray[i];
                        this.intArray[i] = a.intArray[j];
                        a.intArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAIntArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        int temp = this.intArray[i];
                        this.intArray[i] = a.intArray[i];
                        a.intArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setInt(index, (int) value);
        }

        public final void setLong(long index, long value) {
            setInt(index, (int) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.intArray[(int) index] = value;
        }

        public UpdatableIntArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableIntArray fill(long position, long count, double value) {
            return fill(position, count, (int) value);
        }

        public UpdatableIntArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableIntArray fill(long position, long count, long value) {
            return fill(position, count, (int) value);
        }

        public UpdatableIntArray fill(int value) {
            return fill(0, length, value);
        }

        public UpdatableIntArray fill(long position, long count, int value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillIntArray(this.intArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableIntArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJAIntArray(intArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJAIntSubArray(intArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableIntArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJAIntArray(intArray, (int) count);
            } else {
                return new UpdatableJAIntSubArray(intArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final IntArray asImmutable() {
            return new JAIntArray(intArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final IntArray asTrustedImmutable() {
            return new TrustedJAIntArray(intArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJAIntSubArray result = new UpdatableJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableIntArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJAIntSubArray
            extends TrustedJAIntSubArray implements UpdatableIntArray {
        UpdatableJAIntSubArray(
                int[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJAIntSubArray(
                int[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setInt(index, (Integer) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.intArray[offset + (int) destIndex] = this.intArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.intArray, offset + (int) srcIndex,
                    this.intArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            int temp = this.intArray[i];
            this.intArray[i] = this.intArray[j];
            this.intArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                int temp = this.intArray[i];
                this.intArray[i] = this.intArray[j];
                this.intArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAIntSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    intArray[offset] = a.intArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.intArray, a.offset, intArray, offset, count);
                    return this;
                }
            } else if (src instanceof JAIntArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    intArray[offset] = a.intArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.intArray, 0, intArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAIntSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        int temp = this.intArray[i];
                        this.intArray[i] = a.intArray[j];
                        a.intArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAIntArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        int temp = this.intArray[i];
                        this.intArray[i] = a.intArray[j];
                        a.intArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setInt(index, (int) value);
        }

        public final void setLong(long index, long value) {
            setInt(index, (int) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.intArray[offset + (int) index] = value;
        }

        public UpdatableIntArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableIntArray fill(long position, long count, double value) {
            return fill(position, count, (int) value);
        }

        public UpdatableIntArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableIntArray fill(long position, long count, long value) {
            return fill(position, count, (int) value);
        }

        public UpdatableIntArray fill(int value) {
            return fill(0, length, value);
        }

        public UpdatableIntArray fill(long position, long count, int value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillIntArray(this.intArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableIntArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAIntArray(intArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJAIntSubArray result = new UpdatableJAIntSubArray(intArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableIntArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAIntArray(intArray, (int) count);
            } else {
                UpdatableJAIntSubArray result = new UpdatableJAIntSubArray(intArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final IntArray asImmutable() {
            return new JAIntSubArray(intArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final IntArray asTrustedImmutable() {
            TrustedJAIntSubArray result = new TrustedJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJAIntSubArray result = new UpdatableJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableIntArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAIntArray
            extends UpdatableJAIntArray implements MutableIntArray {
        MutableJAIntArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJAIntArray(int[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJAIntArray(int[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nIntCopies(toIndex - fromIndex, (int) 0), true);
        }

        public MutableIntArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableIntArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableIntArray trim() {
            trimImpl();
            return this;
        }

        public MutableIntArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Integer.valueOf(popInt());
        }

        public void pushElement(Object value) {
            pushInt((Integer) value);
        }

        public double popDouble() {
            return (double) popInt();
        }

        public long popLong() {
            return (long) popInt();
        }

        public void addDouble(double value) {
            pushInt((int) value);
        }

        public void addLong(long value) {
            pushInt((int) value);
        }

        public void addInt(int value) {
            pushInt((int) value);
        }

        public int popInt() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int result = this.intArray[i];
            this.length = i;
            this.intArray[i] = (int) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushInt(int value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.intArray[i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableIntArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableIntArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableIntArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableIntArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableIntArray asCopyOnNextWrite() {
            MutableJAIntSubArray result = new MutableJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableIntArray asUnresizable() {
            return new UpdatableJAIntArray(intArray, (int) capacity(), (int) length());
        }

        public MutableIntArray shallowClone() {
            return (MutableIntArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJAIntSubArray
            extends UpdatableJAIntSubArray implements MutableIntArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJAIntSubArray(int[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJAIntSubArray(int[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nIntCopies(toIndex - fromIndex, (int) 0), true);
        }

        public MutableIntArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableIntArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableIntArray trim() {
            trimImpl();
            return this;
        }

        public MutableIntArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Integer.valueOf(popInt());
        }

        public void pushElement(Object value) {
            pushInt((Integer) value);
        }

        public double popDouble() {
            return (double) popInt();
        }

        public long popLong() {
            return (long) popInt();
        }

        public void addDouble(double value) {
            pushInt((int) value);
        }

        public void addLong(long value) {
            pushInt((int) value);
        }

        public void addInt(int value) {
            pushInt((int) value);
        }

        public int popInt() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int result = this.intArray[offset + i];
            this.length = i;
            this.intArray[offset + i] = (int) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushInt(int value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.intArray[offset + i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableIntArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableIntArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableIntArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableIntArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableIntArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJAIntSubArray result = new MutableJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableIntArray asUnresizable() {
            UpdatableJAIntSubArray result = new UpdatableJAIntSubArray(intArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableIntArray shallowClone() {
            return (MutableIntArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray int[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(intArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      (return\s+)-157777 ==> $1Long.MIN_VALUE;;
      (return\s+)157778  ==> $1Long.MAX_VALUE;;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/min) ==> $1minPossibleValue();;
      (return\s+)(valueForFloatingPoint)(?=;\s*\/\/max) ==> $1maxPossibleValue();;
      public(\s+\w+)+\s+(get|set|pop)Long(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      public(\s+\w+)+\s+\w+ndexOf\(long\s+\w+,\s*long\s+\w+,\s*long(.*?)\n\s*}\s* ==> ;;
      public(\s+\w+)+\s+fill\((?:long\s+\w+,\s*long\s+\w+,\s*)?long\s+value(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      \(int\)\s*(\w+\.)?floatArray\[([^\]]*)\] ==> Arrays.truncateLongToInt($1longArray[$2]) ;;
      \(int\)\s*popFloat\(\) ==> Arrays.truncateLongToInt(popLong()) ;;
      Float(?!ing) ==> Long ;;
      float ==> long ;;
      PER_FLOAT ==> PER_LONG
         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("cast")
    static class JALongArray extends AbstractJAArray implements LongArray {
        long[] longArray;

        JALongArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.longArray = (long[]) super.array;
        }

        JALongArray(long[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.longArray = initialArray;
        }

        JALongArray(long[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.longArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.longArray = (long[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return long.class;
        }

        public Class<? extends LongArray> type() {
            return LongArray.class;
        }

        public Class<? extends UpdatableLongArray> updatableType() {
            return UpdatableLongArray.class;
        }

        public Class<? extends MutableLongArray> mutableType() {
            return MutableLongArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Long.valueOf(getLong(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_LONG;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public final long minPossibleValue() {
            return Long.MIN_VALUE;
        }

        public final long maxPossibleValue() {
            return Long.MAX_VALUE;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.longArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (long) value ? indexOf(lowIndex, highIndex, (long) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (long) value ? lastIndexOf(lowIndex, highIndex, (long) value) : -1;
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return Arrays.truncateLongToInt(this.longArray[(int) index]);
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.longArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfLong(this.longArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfLong(this.longArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JALongArray(longArray, (int) (toIndex - fromIndex));
            } else {
                return new JALongSubArray(longArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JALongArray(longArray, (int) count);
            } else {
                return new JALongSubArray(longArray, (int) count, (int) position);
            }
        }

        public DataLongBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataLongBuffer) super.buffer(mode, capacity);
        }

        public DataLongBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataLongBuffer) super.buffer(mode);
        }

        public DataLongBuffer buffer(long capacity) {
            return (DataLongBuffer) super.buffer(capacity);
        }

        public DataLongBuffer buffer() {
            return (DataLongBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public LongArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public LongArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableLongArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJALongArray(JArrays.copyOfRange(
                        longArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableLongArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableLongArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJALongArray(JArrays.copyOfRange(
                        longArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableLongArray) super.updatableClone(memoryModel);
            }
        }

        public long[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array long[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JALongSubArray extends AbstractJAArray implements LongArray {
        long[] longArray;
        int offset;

        JALongSubArray(long[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.longArray = initialArray;
            this.offset = initialOffset;
        }

        JALongSubArray(long[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.longArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.longArray = (long[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return long.class;
        }

        public Class<? extends LongArray> type() {
            return LongArray.class;
        }

        public Class<? extends UpdatableLongArray> updatableType() {
            return UpdatableLongArray.class;
        }

        public Class<? extends MutableLongArray> mutableType() {
            return MutableLongArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Long.valueOf(getLong(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_LONG;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public long minPossibleValue() {
            return Long.MIN_VALUE;
        }

        public long maxPossibleValue() {
            return Long.MAX_VALUE;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (double) this.longArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == (long) value ? indexOf(lowIndex, highIndex, (long) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == (long) value ? lastIndexOf(lowIndex, highIndex, (long) value) : -1;
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return Arrays.truncateLongToInt(this.longArray[offset + (int) index]);
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.longArray[offset + (int) index];
        }

        public long indexOf(long lowIndex, long highIndex, long value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfLong(this.longArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, long value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfLong(this.longArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JALongArray(longArray, (int) (toIndex - fromIndex));
            } else {
                return new JALongSubArray(longArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JALongArray(longArray, (int) count);
            } else {
                return new JALongSubArray(longArray, (int) count, offset + (int) position);
            }
        }

        public DataLongBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataLongBuffer) super.buffer(mode, capacity);
        }

        public DataLongBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataLongBuffer) super.buffer(mode);
        }

        public DataLongBuffer buffer(long capacity) {
            return (DataLongBuffer) super.buffer(capacity);
        }

        public DataLongBuffer buffer() {
            return (DataLongBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public LongArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public LongArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableLongArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJALongArray(JArrays.copyOfRange(
                        longArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableLongArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableLongArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJALongArray(JArrays.copyOfRange(
                        longArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableLongArray) super.updatableClone(memoryModel);
            }
        }

        public long[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJALongArray
            extends JALongArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJALongArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJALongArray(long[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJALongArray(long[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.longArray.length;
        }

        public long[] ja() {
            if (length == this.longArray.length) {
                return this.longArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJALongArray(longArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJALongSubArray(longArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJALongArray(longArray, (int) count);
            } else {
                return new TrustedJALongSubArray(longArray, (int) count, (int) position);
            }
        }

        public LongArray asImmutable() {
            return new JALongArray(longArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJALongSubArray result = new TrustedJALongSubArray(longArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJALongSubArray
            extends JALongSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJALongSubArray(
                long[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJALongSubArray(
                long[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.longArray.length;
        }

        public long[] ja() {
            if (offset == 0 && length == this.longArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.longArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJALongArray(longArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJALongSubArray result = new TrustedJALongSubArray(longArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJALongArray(longArray, (int) count);
            } else {
                TrustedJALongSubArray result = new TrustedJALongSubArray(longArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public LongArray asImmutable() {
            return new JALongSubArray(longArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJALongSubArray result = new TrustedJALongSubArray(longArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJALongArray
            extends TrustedJALongArray implements UpdatableLongArray {
        UpdatableJALongArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJALongArray(long[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJALongArray(long[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setLong(index, (Long) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.longArray[(int) destIndex] = this.longArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.longArray, (int) srcIndex, this.longArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            long temp = this.longArray[i];
            this.longArray[i] = this.longArray[j];
            this.longArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                long temp = this.longArray[i];
                this.longArray[i] = this.longArray[j];
                this.longArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JALongSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    longArray[0] = a.longArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.longArray, a.offset, longArray, 0, count);
                    return this;
                }
            } else if (src instanceof JALongArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.longArray, 0, longArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJALongSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        long temp = this.longArray[i];
                        this.longArray[i] = a.longArray[j];
                        a.longArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJALongArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        long temp = this.longArray[i];
                        this.longArray[i] = a.longArray[i];
                        a.longArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setLong(index, (long) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.longArray[(int) index] = (long) value;
        }

        public final void setLong(long index, long value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.longArray[(int) index] = value;
        }

        public UpdatableLongArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableLongArray fill(long position, long count, double value) {
            return fill(position, count, (long) value);
        }

        public UpdatableLongArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableLongArray fill(long position, long count, long value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillLongArray(this.longArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableLongArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJALongArray(longArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJALongSubArray(longArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableLongArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJALongArray(longArray, (int) count);
            } else {
                return new UpdatableJALongSubArray(longArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final LongArray asImmutable() {
            return new JALongArray(longArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final LongArray asTrustedImmutable() {
            return new TrustedJALongArray(longArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJALongSubArray result = new UpdatableJALongSubArray(longArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableLongArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJALongSubArray
            extends TrustedJALongSubArray implements UpdatableLongArray {
        UpdatableJALongSubArray(
                long[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJALongSubArray(
                long[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setLong(index, (Long) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.longArray[offset + (int) destIndex] = this.longArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.longArray, offset + (int) srcIndex,
                    this.longArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            long temp = this.longArray[i];
            this.longArray[i] = this.longArray[j];
            this.longArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                long temp = this.longArray[i];
                this.longArray[i] = this.longArray[j];
                this.longArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JALongSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    longArray[offset] = a.longArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.longArray, a.offset, longArray, offset, count);
                    return this;
                }
            } else if (src instanceof JALongArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    longArray[offset] = a.longArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.longArray, 0, longArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJALongSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        long temp = this.longArray[i];
                        this.longArray[i] = a.longArray[j];
                        a.longArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJALongArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        long temp = this.longArray[i];
                        this.longArray[i] = a.longArray[j];
                        a.longArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setLong(index, (long) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.longArray[offset + (int) index] = (long) value;
        }

        public final void setLong(long index, long value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.longArray[offset + (int) index] = value;
        }

        public UpdatableLongArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableLongArray fill(long position, long count, double value) {
            return fill(position, count, (long) value);
        }

        public UpdatableLongArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableLongArray fill(long position, long count, long value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillLongArray(this.longArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableLongArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJALongArray(longArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJALongSubArray result = new UpdatableJALongSubArray(longArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableLongArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJALongArray(longArray, (int) count);
            } else {
                UpdatableJALongSubArray result = new UpdatableJALongSubArray(longArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final LongArray asImmutable() {
            return new JALongSubArray(longArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final LongArray asTrustedImmutable() {
            TrustedJALongSubArray result = new TrustedJALongSubArray(longArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJALongSubArray result = new UpdatableJALongSubArray(longArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableLongArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJALongArray
            extends UpdatableJALongArray implements MutableLongArray {
        MutableJALongArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJALongArray(long[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJALongArray(long[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nLongCopies(toIndex - fromIndex, (long) 0), true);
        }

        public MutableLongArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableLongArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableLongArray trim() {
            trimImpl();
            return this;
        }

        public MutableLongArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Long.valueOf(popLong());
        }

        public void pushElement(Object value) {
            pushLong((Long) value);
        }

        public double popDouble() {
            return (double) popLong();
        }

        public int popInt() {
            return Arrays.truncateLongToInt(popLong());
        }

        public void addDouble(double value) {
            pushLong((long) value);
        }

        public void addLong(long value) {
            pushLong((long) value);
        }

        public void addInt(int value) {
            pushLong((long) value);
        }

        public long popLong() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            long result = this.longArray[i];
            this.length = i;
            this.longArray[i] = (long) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushLong(long value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.longArray[i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableLongArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableLongArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableLongArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableLongArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableLongArray asCopyOnNextWrite() {
            MutableJALongSubArray result = new MutableJALongSubArray(longArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableLongArray asUnresizable() {
            return new UpdatableJALongArray(longArray, (int) capacity(), (int) length());
        }

        public MutableLongArray shallowClone() {
            return (MutableLongArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJALongSubArray
            extends UpdatableJALongSubArray implements MutableLongArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJALongSubArray(long[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJALongSubArray(long[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nLongCopies(toIndex - fromIndex, (long) 0), true);
        }

        public MutableLongArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableLongArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableLongArray trim() {
            trimImpl();
            return this;
        }

        public MutableLongArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Long.valueOf(popLong());
        }

        public void pushElement(Object value) {
            pushLong((Long) value);
        }

        public double popDouble() {
            return (double) popLong();
        }

        public int popInt() {
            return Arrays.truncateLongToInt(popLong());
        }

        public void addDouble(double value) {
            pushLong((long) value);
        }

        public void addLong(long value) {
            pushLong((long) value);
        }

        public void addInt(int value) {
            pushLong((long) value);
        }

        public long popLong() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            long result = this.longArray[offset + i];
            this.length = i;
            this.longArray[offset + i] = (long) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushLong(long value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.longArray[offset + i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableLongArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableLongArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableLongArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableLongArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableLongArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJALongSubArray result = new MutableJALongSubArray(longArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableLongArray asUnresizable() {
            UpdatableJALongSubArray result = new UpdatableJALongSubArray(longArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableLongArray shallowClone() {
            return (MutableLongArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray long[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(longArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      public(\s+\w+)+\s+(get|set|pop)Double(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      public(\s+\w+)+\s+\w+ndexOf\(long\s+\w+,\s*long\s+\w+,\s*double(.*?)\n\s*}\s* ==> ;;
      public(\s+\w+)+\s+fill\((?:long\s+\w+,\s*long\s+\w+,\s*)?double\s+value(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      Float(?!ing) ==> Double ;;
      float ==> double ;;
      PER_FLOAT ==> PER_DOUBLE
         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("cast")
    static class JADoubleArray extends AbstractJAArray implements DoubleArray {
        double[] doubleArray;

        JADoubleArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.doubleArray = (double[]) super.array;
        }

        JADoubleArray(double[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.doubleArray = initialArray;
        }

        JADoubleArray(double[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.doubleArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.doubleArray = (double[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return double.class;
        }

        public Class<? extends DoubleArray> type() {
            return DoubleArray.class;
        }

        public Class<? extends UpdatableDoubleArray> updatableType() {
            return UpdatableDoubleArray.class;
        }

        public Class<? extends MutableDoubleArray> mutableType() {
            return MutableDoubleArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Double.valueOf(getDouble(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_DOUBLE;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //max
        }

        public final long minPossibleValue() {
            return -157777;
        }

        public final long maxPossibleValue() {
            return 157778;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.doubleArray[(int) index];
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) this.doubleArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (double) value ? indexOf(lowIndex, highIndex, (double) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (double) value ? lastIndexOf(lowIndex, highIndex, (double) value) : -1;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.doubleArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfDouble(this.doubleArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfDouble(this.doubleArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JADoubleArray(doubleArray, (int) (toIndex - fromIndex));
            } else {
                return new JADoubleSubArray(doubleArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JADoubleArray(doubleArray, (int) count);
            } else {
                return new JADoubleSubArray(doubleArray, (int) count, (int) position);
            }
        }

        public DataDoubleBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataDoubleBuffer) super.buffer(mode, capacity);
        }

        public DataDoubleBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataDoubleBuffer) super.buffer(mode);
        }

        public DataDoubleBuffer buffer(long capacity) {
            return (DataDoubleBuffer) super.buffer(capacity);
        }

        public DataDoubleBuffer buffer() {
            return (DataDoubleBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public DoubleArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public DoubleArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableDoubleArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJADoubleArray(JArrays.copyOfRange(
                        doubleArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableDoubleArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableDoubleArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJADoubleArray(JArrays.copyOfRange(
                        doubleArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableDoubleArray) super.updatableClone(memoryModel);
            }
        }

        public double[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array double[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JADoubleSubArray extends AbstractJAArray implements DoubleArray {
        double[] doubleArray;
        int offset;

        JADoubleSubArray(double[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.doubleArray = initialArray;
            this.offset = initialOffset;
        }

        JADoubleSubArray(double[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.doubleArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.doubleArray = (double[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return double.class;
        }

        public Class<? extends DoubleArray> type() {
            return DoubleArray.class;
        }

        public Class<? extends UpdatableDoubleArray> updatableType() {
            return UpdatableDoubleArray.class;
        }

        public Class<? extends MutableDoubleArray> mutableType() {
            return MutableDoubleArray.class;
        }

        public final Object getElement(long index) {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Double.valueOf(getDouble(index));
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_DOUBLE;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //max
        }

        public long minPossibleValue() {
            return -157777;
        }

        public long maxPossibleValue() {
            return 157778;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (long) this.doubleArray[offset + (int) index];
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (int) this.doubleArray[offset + (int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == (double) value ? indexOf(lowIndex, highIndex, (double) value) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == (double) value ? lastIndexOf(lowIndex, highIndex, (double) value) : -1;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.doubleArray[offset + (int) index];
        }

        public long indexOf(long lowIndex, long highIndex, double value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfDouble(this.doubleArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, double value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfDouble(this.doubleArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JADoubleArray(doubleArray, (int) (toIndex - fromIndex));
            } else {
                return new JADoubleSubArray(doubleArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JADoubleArray(doubleArray, (int) count);
            } else {
                return new JADoubleSubArray(doubleArray, (int) count, offset + (int) position);
            }
        }

        public DataDoubleBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataDoubleBuffer) super.buffer(mode, capacity);
        }

        public DataDoubleBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataDoubleBuffer) super.buffer(mode);
        }

        public DataDoubleBuffer buffer(long capacity) {
            return (DataDoubleBuffer) super.buffer(capacity);
        }

        public DataDoubleBuffer buffer() {
            return (DataDoubleBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public DoubleArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public DoubleArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableDoubleArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJADoubleArray(JArrays.copyOfRange(
                        doubleArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableDoubleArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableDoubleArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJADoubleArray(JArrays.copyOfRange(
                        doubleArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableDoubleArray) super.updatableClone(memoryModel);
            }
        }

        public double[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    static class TrustedJADoubleArray
            extends JADoubleArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJADoubleArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        TrustedJADoubleArray(double[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJADoubleArray(double[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.doubleArray.length;
        }

        public double[] ja() {
            if (length == this.doubleArray.length) {
                return this.doubleArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJADoubleArray(doubleArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJADoubleSubArray(doubleArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJADoubleArray(doubleArray, (int) count);
            } else {
                return new TrustedJADoubleSubArray(doubleArray, (int) count, (int) position);
            }
        }

        public DoubleArray asImmutable() {
            return new JADoubleArray(doubleArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJADoubleSubArray result = new TrustedJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART array double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    static class TrustedJADoubleSubArray
            extends JADoubleSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJADoubleSubArray(
                double[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJADoubleSubArray(
                double[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.doubleArray.length;
        }

        public double[] ja() {
            if (offset == 0 && length == this.doubleArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.doubleArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJADoubleArray(doubleArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJADoubleSubArray result = new TrustedJADoubleSubArray(doubleArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJADoubleArray(doubleArray, (int) count);
            } else {
                TrustedJADoubleSubArray result = new TrustedJADoubleSubArray(doubleArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public DoubleArray asImmutable() {
            return new JADoubleSubArray(doubleArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJADoubleSubArray result = new TrustedJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("cast")
    static class UpdatableJADoubleArray
            extends TrustedJADoubleArray implements UpdatableDoubleArray {
        UpdatableJADoubleArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJADoubleArray(double[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJADoubleArray(double[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setDouble(index, (Double) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.doubleArray[(int) destIndex] = this.doubleArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.doubleArray, (int) srcIndex, this.doubleArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            double temp = this.doubleArray[i];
            this.doubleArray[i] = this.doubleArray[j];
            this.doubleArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                double temp = this.doubleArray[i];
                this.doubleArray[i] = this.doubleArray[j];
                this.doubleArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JADoubleSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    doubleArray[0] = a.doubleArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.doubleArray, a.offset, doubleArray, 0, count);
                    return this;
                }
            } else if (src instanceof JADoubleArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.doubleArray, 0, doubleArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJADoubleSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        double temp = this.doubleArray[i];
                        this.doubleArray[i] = a.doubleArray[j];
                        a.doubleArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJADoubleArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        double temp = this.doubleArray[i];
                        this.doubleArray[i] = a.doubleArray[i];
                        a.doubleArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setLong(long index, long value) {
            setDouble(index, (double) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.doubleArray[(int) index] = (double) value;
        }

        public final void setDouble(long index, double value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.doubleArray[(int) index] = value;
        }

        public UpdatableDoubleArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableDoubleArray fill(long position, long count, long value) {
            return fill(position, count, (double) value);
        }

        public UpdatableDoubleArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableDoubleArray fill(long position, long count, double value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillDoubleArray(this.doubleArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableDoubleArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJADoubleArray(doubleArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJADoubleSubArray(doubleArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableDoubleArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJADoubleArray(doubleArray, (int) count);
            } else {
                return new UpdatableJADoubleSubArray(doubleArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final DoubleArray asImmutable() {
            return new JADoubleArray(doubleArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final DoubleArray asTrustedImmutable() {
            return new TrustedJADoubleArray(doubleArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJADoubleSubArray result = new UpdatableJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableDoubleArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJADoubleSubArray
            extends TrustedJADoubleSubArray implements UpdatableDoubleArray {
        UpdatableJADoubleSubArray(
                double[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJADoubleSubArray(
                double[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setDouble(index, (Double) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.doubleArray[offset + (int) destIndex] = this.doubleArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.doubleArray, offset + (int) srcIndex,
                    this.doubleArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            double temp = this.doubleArray[i];
            this.doubleArray[i] = this.doubleArray[j];
            this.doubleArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                double temp = this.doubleArray[i];
                this.doubleArray[i] = this.doubleArray[j];
                this.doubleArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JADoubleSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    doubleArray[offset] = a.doubleArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.doubleArray, a.offset, doubleArray, offset, count);
                    return this;
                }
            } else if (src instanceof JADoubleArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    doubleArray[offset] = a.doubleArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.doubleArray, 0, doubleArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJADoubleSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        double temp = this.doubleArray[i];
                        this.doubleArray[i] = a.doubleArray[j];
                        a.doubleArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJADoubleArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        double temp = this.doubleArray[i];
                        this.doubleArray[i] = a.doubleArray[j];
                        a.doubleArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setLong(long index, long value) {
            setDouble(index, (double) value);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.doubleArray[offset + (int) index] = (double) value;
        }

        public final void setDouble(long index, double value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.doubleArray[offset + (int) index] = value;
        }

        public UpdatableDoubleArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableDoubleArray fill(long position, long count, long value) {
            return fill(position, count, (double) value);
        }

        public UpdatableDoubleArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableDoubleArray fill(long position, long count, double value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillDoubleArray(this.doubleArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableDoubleArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJADoubleArray(doubleArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJADoubleSubArray result = new UpdatableJADoubleSubArray(doubleArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableDoubleArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJADoubleArray(doubleArray, (int) count);
            } else {
                UpdatableJADoubleSubArray result = new UpdatableJADoubleSubArray(doubleArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final DoubleArray asImmutable() {
            return new JADoubleSubArray(doubleArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final DoubleArray asTrustedImmutable() {
            TrustedJADoubleSubArray result = new TrustedJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJADoubleSubArray result = new UpdatableJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableDoubleArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJADoubleArray
            extends UpdatableJADoubleArray implements MutableDoubleArray {
        MutableJADoubleArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJADoubleArray(double[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJADoubleArray(double[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nDoubleCopies(toIndex - fromIndex, (double) 0), true);
        }

        public MutableDoubleArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableDoubleArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableDoubleArray trim() {
            trimImpl();
            return this;
        }

        public MutableDoubleArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Double.valueOf(popDouble());
        }

        public void pushElement(Object value) {
            pushDouble((Double) value);
        }

        public long popLong() {
            return (long) popDouble();
        }

        public int popInt() {
            return (int) popDouble();
        }

        public void addDouble(double value) {
            pushDouble((double) value);
        }

        public void addLong(long value) {
            pushDouble((double) value);
        }

        public void addInt(int value) {
            pushDouble((double) value);
        }

        public double popDouble() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            double result = this.doubleArray[i];
            this.length = i;
            this.doubleArray[i] = (double) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushDouble(double value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.doubleArray[i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableDoubleArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableDoubleArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableDoubleArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableDoubleArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableDoubleArray asCopyOnNextWrite() {
            MutableJADoubleSubArray result = new MutableJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableDoubleArray asUnresizable() {
            return new UpdatableJADoubleArray(doubleArray, (int) capacity(), (int) length());
        }

        public MutableDoubleArray shallowClone() {
            return (MutableDoubleArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("cast")
    static final class MutableJADoubleSubArray
            extends UpdatableJADoubleSubArray implements MutableDoubleArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJADoubleSubArray(double[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJADoubleSubArray(double[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nDoubleCopies(toIndex - fromIndex, (double) 0), true);
        }

        public MutableDoubleArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableDoubleArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableDoubleArray trim() {
            trimImpl();
            return this;
        }

        public MutableDoubleArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            // boxing necessary for regexps in Repeater
            //noinspection UnnecessaryBoxing
            return Double.valueOf(popDouble());
        }

        public void pushElement(Object value) {
            pushDouble((Double) value);
        }

        public long popLong() {
            return (long) popDouble();
        }

        public int popInt() {
            return (int) popDouble();
        }

        public void addDouble(double value) {
            pushDouble((double) value);
        }

        public void addLong(long value) {
            pushDouble((double) value);
        }

        public void addInt(int value) {
            pushDouble((double) value);
        }

        public double popDouble() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            double result = this.doubleArray[offset + i];
            this.length = i;
            this.doubleArray[offset + i] = (double) 0;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushDouble(double value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.doubleArray[offset + i] = value;
        }

        public void removeTop() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no necessity to clear last element: MutableObjectArray has independent implementation
        }

        public MutableDoubleArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableDoubleArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableDoubleArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableDoubleArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableDoubleArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJADoubleSubArray result = new MutableJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableDoubleArray asUnresizable() {
            UpdatableJADoubleSubArray result = new UpdatableJADoubleSubArray(doubleArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableDoubleArray shallowClone() {
            return (MutableDoubleArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray double[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(doubleArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    /*Repeat(INCLUDE_FROM_FILE, THIS_FILE, impl)
      (\bJAFloatArray)\(long([^\)]*\)\s*\{\s*super\(.*?\);)  ==>
      $1(Class<?> elementType, long$2
            this.elementType = elementType;
            this.array = allocateArray(initialCapacity); ;;
      (\bJAFloat(?:Sub)?Array\(float\[\][^\)]*\)\s*\{[^\}]*)\} ==>
      $1    this.elementType = initialArray.getClass().getComponentType();
        } ;;
      ((?:Trusted|Updatable|Mutable)JAFloatArray)\(long([^\)]*\)\s*\{\s*)super\(initialCapacity ==>
      $1(Class<?> elementType, long$2super(elementType, initialCapacity ;;
      (new\s+\w*JAFloatArray\()(\d+\,|initialLength,|length,) ==> $1elementType, $2 ;;
      float.class ==> elementType ;;
      public(\s+\w+)+\s+(get|set|pop|push|add)(Int|Long\(|Double\(|Element\()(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      public(\s+\w+)+\s+\w+ndexOf\(long\s+\w+,\s*long\s+\w+,\s*(long|double)(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      public(\s+\w+)+\s+fill\((long\s+\w+,\s*long\s+\w+,\s*)?(long|double)\s+va(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      public(\s+\w+)+\s+(min|max)Value\((.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> ;;
      \}(\s+)(public(\s+\w+)+\s+removeTop\(\))(.*?)(?:\r(?!\n)|\n|\r\n)\s*}\s* ==> }$1$2 {
            popElement();
        }$1;;
      (JArrays\.copyOfRange) ==> (Object[]) $1 ;;
      \(float\)\s*0 ==> null ;;
      getFloat ==> getElement ;;
      setFloat ==> setElement ;;
      popFloat ==> popElement ;;
      pushFloat ==> pushElement ;;
      (\s+)float\[\" ==> $1" + elementType.getName() + "[" ;;
      \]\s*=\s*0 ==> ] = null ;;
      nFloatCopies\((\w+),\s*(\w+)\) ==> nObjectCopies($1, $2, this.elementType) ;;
      Float(?!ing) ==> Object ;;
      floatArray ==> objectArray ;;
      float ==> Object ;;
      PER_FLOAT ==> PER_OBJECT ;;
      (Object\[\]\s+objectArray;) ==> $1
        final Class<?> elementType; ;;
      \@SuppressWarnings\(\"cast\"\) ==> @SuppressWarnings("rawtypes") ;;
      ((?:\r(?!\n)|\n|\r\n)[ \t]+)(static\s+class\s+Trusted) ==> $1@SuppressWarnings("rawtypes")$1$2 ;;
      ((?:\r(?!\n)|\n|\r\n)[ \t]+)(public\s+Object\[\]\s+ja) ==> $1@SuppressWarnings("unchecked")$1$2 ;;
      (public\s+(?:final\s+)?)(\w*?)((?:Object)?Array\s+asCopyOnNextWrite\(\)\s*\{.*?[\r\n]\s*}) ==> $1$2$3

        public $2ObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

         !! Auto-generated: NOT EDIT !! */
    @SuppressWarnings("rawtypes")
    static class JAObjectArray extends AbstractJAArray implements ObjectArray {
        Object[] objectArray;
        final Class<?> elementType;

        JAObjectArray(Class<?> elementType, long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.elementType = elementType;
            this.array = allocateArray(initialCapacity);
            this.objectArray = (Object[]) super.array;
        }

        JAObjectArray(Object[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.objectArray = initialArray;
            this.elementType = initialArray.getClass().getComponentType();
        }

        JAObjectArray(Object[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.objectArray = initialArray;
            this.elementType = initialArray.getClass().getComponentType();
        }

        final void afterStorageFieldCorrection() {
            this.objectArray = (Object[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            return 0;
        }

        public final Class<?> elementType() {
            return elementType;
        }

        public Class<? extends ObjectArray> type() {
            return ObjectArray.class;
        }

        public Class<? extends UpdatableObjectArray> updatableType() {
            return UpdatableObjectArray.class;
        }

        public Class<? extends MutableObjectArray> mutableType() {
            return MutableObjectArray.class;
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_OBJECT;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //max
        }

        public final long minPossibleValue() {
            return -157777;
        }

        public final long maxPossibleValue() {
            return 157778;
        }

        public final Object getElement(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.objectArray[(int) index];
        }

        public final long indexOf(long lowIndex, long highIndex, Object value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.indexOfObject(this.objectArray, (int) lowIndex, (int) highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, Object value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return JArrays.lastIndexOfObject(this.objectArray, (int) lowIndex, (int) highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JAObjectArray(objectArray, (int) (toIndex - fromIndex));
            } else {
                return new JAObjectSubArray(objectArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JAObjectArray(objectArray, (int) count);
            } else {
                return new JAObjectSubArray(objectArray, (int) count, (int) position);
            }
        }

        public DataObjectBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataObjectBuffer) super.buffer(mode, capacity);
        }

        public DataObjectBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataObjectBuffer) super.buffer(mode);
        }

        public DataObjectBuffer buffer(long capacity) {
            return (DataObjectBuffer) super.buffer(capacity);
        }

        public DataObjectBuffer buffer() {
            return (DataObjectBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public ObjectArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public ObjectArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public ObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public final MutableObjectArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAObjectArray((Object[]) JArrays.copyOfRange(
                        objectArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (MutableObjectArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableObjectArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAObjectArray((Object[]) JArrays.copyOfRange(
                        objectArray, 0, (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableObjectArray) super.updatableClone(memoryModel);
            }
        }

        @SuppressWarnings("unchecked")
        public Object[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array " + elementType.getName() + "[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("rawtypes")
    static class JAObjectSubArray extends AbstractJAArray implements ObjectArray {
        Object[] objectArray;
        final Class<?> elementType;
        int offset;

        JAObjectSubArray(Object[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.objectArray = initialArray;
            this.offset = initialOffset;
            this.elementType = initialArray.getClass().getComponentType();
        }

        JAObjectSubArray(Object[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.objectArray = initialArray;
            this.offset = initialOffset;
            this.elementType = initialArray.getClass().getComponentType();
        }

        final void afterStorageFieldCorrection() {
            this.objectArray = (Object[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            return offset;
        }

        public final Class<?> elementType() {
            return elementType;
        }

        public Class<? extends ObjectArray> type() {
            return ObjectArray.class;
        }

        public Class<? extends UpdatableObjectArray> updatableType() {
            return UpdatableObjectArray.class;
        }

        public Class<? extends MutableObjectArray> mutableType() {
            return MutableObjectArray.class;
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_OBJECT;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return valueForFloatingPoint; //max
        }

        public long minPossibleValue() {
            return -157777;
        }

        public long maxPossibleValue() {
            return 157778;
        }

        public final Object getElement(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return this.objectArray[offset + (int) index];
        }

        public long indexOf(long lowIndex, long highIndex, Object value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.indexOfObject(this.objectArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, Object value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = JArrays.lastIndexOfObject(this.objectArray,
                    offset + (int) lowIndex, offset + (int) highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JAObjectArray(objectArray, (int) (toIndex - fromIndex));
            } else {
                return new JAObjectSubArray(objectArray, (int) (toIndex - fromIndex), offset + (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JAObjectArray(objectArray, (int) count);
            } else {
                return new JAObjectSubArray(objectArray, (int) count, offset + (int) position);
            }
        }

        public DataObjectBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataObjectBuffer) super.buffer(mode, capacity);
        }

        public DataObjectBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataObjectBuffer) super.buffer(mode);
        }

        public DataObjectBuffer buffer(long capacity) {
            return (DataObjectBuffer) super.buffer(capacity);
        }

        public DataObjectBuffer buffer() {
            return (DataObjectBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public ObjectArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public ObjectArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public ObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public final MutableObjectArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJAObjectArray((Object[]) JArrays.copyOfRange(
                        objectArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (MutableObjectArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableObjectArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJAObjectArray((Object[]) JArrays.copyOfRange(
                        objectArray, offset, offset + (int) length), (int) length).setNewStatus();
            } else {
                return (UpdatableObjectArray) super.updatableClone(memoryModel);
            }
        }

        @SuppressWarnings("unchecked")
        public Object[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("rawtypes")
    static class TrustedJAObjectArray
            extends JAObjectArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAObjectArray(Class<?> elementType, long initialCapacity, long initialLength) {
            super(elementType, initialCapacity, initialLength);
        }

        TrustedJAObjectArray(Object[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAObjectArray(Object[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return 0;
        }

        public boolean isJavaArrayWrapper() {
            return length == this.objectArray.length;
        }

        @SuppressWarnings("unchecked")
        public Object[] ja() {
            if (length == this.objectArray.length) {
                return this.objectArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new TrustedJAObjectArray(objectArray, (int) (toIndex - fromIndex));
            } else {
                return new TrustedJAObjectSubArray(objectArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new TrustedJAObjectArray(objectArray, (int) count);
            } else {
                return new TrustedJAObjectSubArray(objectArray, (int) count, (int) position);
            }
        }

        public ObjectArray asImmutable() {
            return new JAObjectArray(objectArray, (int) capacity(), (int) length());
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            TrustedJAObjectSubArray result = new TrustedJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public ObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public String toString() {
            return "trusted immutable simple AlgART array " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("rawtypes")
    static class TrustedJAObjectSubArray
            extends JAObjectSubArray implements DirectAccessible {
        private int startHashCode = -1;

        TrustedJAObjectSubArray(
                Object[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        TrustedJAObjectSubArray(
                Object[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
            if (!(this instanceof UpdatableArray))
                startHashCode = hashCode();
        }

        public int javaArrayOffset() {
            return offset;
        }

        public boolean isJavaArrayWrapper() {
            return offset == 0 && length == this.objectArray.length;
        }

        @SuppressWarnings("unchecked")
        public Object[] ja() {
            if (offset == 0 && length == this.objectArray.length) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.objectArray;
            }
            return Arrays.toJavaArray(this);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAObjectArray(objectArray, (int) (toIndex - fromIndex));
            } else {
                TrustedJAObjectSubArray result = new TrustedJAObjectSubArray(objectArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new TrustedJAObjectArray(objectArray, (int) count);
            } else {
                TrustedJAObjectSubArray result = new TrustedJAObjectSubArray(objectArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public ObjectArray asImmutable() {
            return new JAObjectSubArray(objectArray, (int) capacity(), (int) length(), offset);
        }

        public boolean isImmutable() {
            return false;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
            if (hashCode() != startHashCode)
                throw new UnallowedMutationError("Unallowed mutations of trusted immutable array "
                        + "are detected by checkUnallowedMutation() method [" + this + "]");
        }

        public Array asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            TrustedJAObjectSubArray result = new TrustedJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public ObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public String toString() {
            return "trusted immutable simple AlgART subarray " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }//EndOfClass !! this comment is necessary for preprocessing by Repeater !!

    @SuppressWarnings("rawtypes")
    static class UpdatableJAObjectArray
            extends TrustedJAObjectArray implements UpdatableObjectArray {
        UpdatableJAObjectArray(Class<?> elementType, long initialCapacity, long initialLength) {
            super(elementType, initialCapacity, initialLength);
        }

        UpdatableJAObjectArray(Object[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJAObjectArray(Object[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            this.objectArray[(int) destIndex] = this.objectArray[(int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            System.arraycopy(this.objectArray, (int) srcIndex, this.objectArray, (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            int i = (int) firstIndex, j = (int) secondIndex;
            Object temp = this.objectArray[i];
            this.objectArray[i] = this.objectArray[j];
            this.objectArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            int i = (int) firstIndex, j = (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                Object temp = this.objectArray[i];
                this.objectArray[i] = this.objectArray[j];
                this.objectArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAObjectSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    objectArray[0] = a.objectArray[a.offset];
                    return this;
                } else if (count > 0) {
                    System.arraycopy(a.objectArray, a.offset, objectArray, 0, count);
                    return this;
                }
            } else if (src instanceof JAObjectArray a) {
                int count = (int) Math.min(a.length, length);
                if (count > 0) {
                    System.arraycopy(a.objectArray, 0, objectArray, 0, count);
                }
                return this;
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAObjectSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    int j = a.offset;
                    for (int i = 0; i < count; i++, j++) {
                        Object temp = this.objectArray[i];
                        this.objectArray[i] = a.objectArray[j];
                        a.objectArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAObjectArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (int i = 0; i < count; i++) {
                        Object temp = this.objectArray[i];
                        this.objectArray[i] = a.objectArray[i];
                        a.objectArray[i] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setElement(long index, Object value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            this.objectArray[(int) index] = value;
        }

        public UpdatableObjectArray fill(Object value) {
            return fill(0, length, value);
        }

        public UpdatableObjectArray fill(long position, long count, Object value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            JArrays.fillObjectArray(this.objectArray, (int) position, (int) count, value);
            return this;
        }

        public UpdatableObjectArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJAObjectArray(objectArray, (int) (toIndex - fromIndex));
            } else {
                return new UpdatableJAObjectSubArray(objectArray, (int) (toIndex - fromIndex), (int) fromIndex);
            }
        }

        public UpdatableObjectArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJAObjectArray(objectArray, (int) count);
            } else {
                return new UpdatableJAObjectSubArray(objectArray, (int) count, (int) position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final ObjectArray asImmutable() {
            return new JAObjectArray(objectArray, (int) capacity(), (int) length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final ObjectArray asTrustedImmutable() {
            return new TrustedJAObjectArray(objectArray, (int) capacity(), (int) length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJAObjectSubArray result = new UpdatableJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public UpdatableObjectArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART array " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("rawtypes")
    static class UpdatableJAObjectSubArray
            extends TrustedJAObjectSubArray implements UpdatableObjectArray {
        UpdatableJAObjectSubArray(
                Object[] initialArray,
                int initialCapacity,
                int initialLength,
                int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJAObjectSubArray(
                Object[] initialArray,
                int initialCapacityAndLength,
                int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.objectArray[offset + (int) destIndex] = this.objectArray[offset + (int) srcIndex];
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            System.arraycopy(this.objectArray, offset + (int) srcIndex,
                    this.objectArray, offset + (int) destIndex, (int) count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            Object temp = this.objectArray[i];
            this.objectArray[i] = this.objectArray[j];
            this.objectArray[j] = temp;
        }

        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            int i = offset + (int) firstIndex, j = offset + (int) secondIndex;
            for (int iMax = i + (int) count; i < iMax; i++, j++) {
                Object temp = this.objectArray[i];
                this.objectArray[i] = this.objectArray[j];
                this.objectArray[j] = temp;
            }
        }

        public UpdatableArray copy(Array src) {
            if (src instanceof JAObjectSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    objectArray[offset] = a.objectArray[a.offset];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.objectArray, a.offset, objectArray, offset, count);
                    return this;
                }
            } else if (src instanceof JAObjectArray a) {
                int count = (int) Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    objectArray[offset] = a.objectArray[0];
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    System.arraycopy(a.objectArray, 0, objectArray, offset, count);
                    return this;
                }
            }
            defaultCopy(this, src);
            return this;
        }

        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJAObjectSubArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    int j = a.offset;
                    for (int iMax = i + count; i < iMax; i++, j++) {
                        Object temp = this.objectArray[i];
                        this.objectArray[i] = a.objectArray[j];
                        a.objectArray[j] = temp;
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJAObjectArray a) {
                int count = (int) Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    int i = offset;
                    for (int j = 0; j < count; i++, j++) {
                        Object temp = this.objectArray[i];
                        this.objectArray[i] = a.objectArray[j];
                        a.objectArray[j] = temp;
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setElement(long index, Object value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.objectArray[offset + (int) index] = value;
        }

        public UpdatableObjectArray fill(Object value) {
            return fill(0, length, value);
        }

        public UpdatableObjectArray fill(long position, long count, Object value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            JArrays.fillObjectArray(this.objectArray, offset + (int) position, (int) count, value);
            return this;
        }

        public UpdatableObjectArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAObjectArray(objectArray, (int) (toIndex - fromIndex));
            } else {
                UpdatableJAObjectSubArray result = new UpdatableJAObjectSubArray(objectArray,
                        (int) (toIndex - fromIndex), offset + (int) fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableObjectArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJAObjectArray(objectArray, (int) count);
            } else {
                UpdatableJAObjectSubArray result = new UpdatableJAObjectSubArray(objectArray,
                        (int) count, offset + (int) position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final ObjectArray asImmutable() {
            return new JAObjectSubArray(objectArray, (int) capacity(), (int) length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final ObjectArray asTrustedImmutable() {
            TrustedJAObjectSubArray result = new TrustedJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJAObjectSubArray result = new UpdatableJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public UpdatableObjectArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        public String toString() {
            return "unresizable simple AlgART subarray " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("rawtypes")
    static final class MutableJAObjectArray
            extends UpdatableJAObjectArray implements MutableObjectArray {
        MutableJAObjectArray(Class<?> elementType, long initialCapacity, long initialLength) {
            super(elementType, initialCapacity, initialLength);
        }

        MutableJAObjectArray(Object[] initialArray, int initialCapacity, int initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJAObjectArray(Object[] initialArray, int initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nObjectCopies(toIndex - fromIndex, null), true);
        }

        public MutableObjectArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableObjectArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableObjectArray trim() {
            trimImpl();
            return this;
        }

        public MutableObjectArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            Object result = this.objectArray[i];
            this.length = i;
            this.objectArray[i] = null;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushElement(Object value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            this.objectArray[i] = value;
        }

        public void removeTop() {
            popElement();
        }

        public MutableObjectArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableObjectArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableObjectArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableObjectArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableObjectArray asCopyOnNextWrite() {
            MutableJAObjectSubArray result = new MutableJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableObjectArray asUnresizable() {
            return new UpdatableJAObjectArray(objectArray, (int) capacity(), (int) length());
        }

        public MutableObjectArray shallowClone() {
            return (MutableObjectArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    // Some casts become necessary after replacing by regexps in Repeater:
    @SuppressWarnings("rawtypes")
    static final class MutableJAObjectSubArray
            extends UpdatableJAObjectSubArray implements MutableObjectArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJAObjectSubArray(Object[] initialArray, int initialCapacity, int initialLength, int initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJAObjectSubArray(Object[] initialArray, int initialCapacityAndLength, int initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nObjectCopies(toIndex - fromIndex, null), true);
        }

        public MutableObjectArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableObjectArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableObjectArray trim() {
            trimImpl();
            return this;
        }

        public MutableObjectArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            int i = (int) length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            Object result = this.objectArray[offset + i];
            this.length = i;
            this.objectArray[offset + i] = null;
            // - not necessary for primitive types, but necessary in MutableObjectArray
            return result;
        }

        public void pushElement(Object value) {
            int i = (int) length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            this.objectArray[offset + i] = value;
        }

        public void removeTop() {
            popElement();
        }

        public MutableObjectArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableObjectArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableObjectArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableObjectArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableObjectArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJAObjectSubArray result = new MutableJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableObjectArray cast(Class elementType) {
            Class<?> desiredType = InternalUtils.cast(elementType);
            if (!desiredType.isAssignableFrom(this.elementType))
                throw new ClassCastException("Illegal desired element type " + elementType + " for " + this);
            return this;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableObjectArray asUnresizable() {
            UpdatableJAObjectSubArray result = new UpdatableJAObjectSubArray(objectArray,
                    (int) capacity(), (int) length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableObjectArray shallowClone() {
            return (MutableObjectArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray " + elementType.getName() + "[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(objectArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
    /*Repeat.IncludeEnd*/

    @SuppressWarnings("cast")
    static class JABitArray
            extends AbstractJAArray implements BitArray {
        long[] bitArray;

        JABitArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
            this.bitArray = (long[]) super.array;
        }

        JABitArray(long[] initialArray, long initialCapacity, long initialLength) {
            super(initialArray, initialCapacity, initialLength);
            this.bitArray = initialArray;
        }

        JABitArray(long[] initialArray, long initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
            this.bitArray = initialArray;
        }

        final void afterStorageFieldCorrection() {
            this.bitArray = (long[]) super.array;
        }

        final long longJavaArrayOffsetInternal() {
            return 0;
        }

        final int javaArrayOffsetInternal() {
            throw new AssertionError("Internal error in package implementation: "
                    + "unallowed accessing javaArrayOffsetInternal() for bit array");
        }

        public final Class<?> elementType() {
            return boolean.class;
        }

        public Class<? extends BitArray> type() {
            return BitArray.class;
        }

        public Class<? extends UpdatableBitArray> updatableType() {
            return UpdatableBitArray.class;
        }

        public Class<? extends MutableBitArray> mutableType() {
            return MutableBitArray.class;
        }

        public final Object getElement(long index) {
            return getBit(index);
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_BIT;
        }

        public final double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public final double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public final long minPossibleValue() {
            return 0;
        }

        public final long maxPossibleValue() {
            return 1;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((index) >>> 6)] & (1L << ((int) (index) & 63))) != 0L ? 1 : 0;
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == 0 || value == 1 ? indexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == 0 || value == 1 ? lastIndexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((index) >>> 6)] & (1L << ((int) (index) & 63))) != 0L ? 1 : 0;
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((index) >>> 6)] & (1L << ((int) (index) & 63))) != 0L ? 1 : 0;
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == 0 || value == 1 ? indexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == 0 || value == 1 ? lastIndexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final boolean getBit(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((index) >>> 6)] & (1L << ((int) (index) & 63))) != 0L;
        }

        @Override
        public final long getBits64(long arrayPos, int count) {
            if (arrayPos < 0) {
                throw rangeException(arrayPos);
            }
            if (count < 0) {
                throw new IllegalArgumentException("Negative count argument: " + count);
            }
            if (count > 64) {
                throw new IllegalArgumentException("Too large count argument: " + count +
                        "; we cannot get > 64 bits in getBits64 method");
            }
            if (arrayPos > length - count) {
                throw rangeException(arrayPos + count - 1);
            }
            return PackedBitArrays.getBits64Impl(bitArray, arrayPos, count);
        }

        public final long indexOf(long lowIndex, long highIndex, boolean value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return PackedBitArrays.indexOfBit(this.bitArray, lowIndex, highIndex, value);
        }

        public final long lastIndexOf(long lowIndex, long highIndex, boolean value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            return PackedBitArrays.lastIndexOfBit(this.bitArray, lowIndex, highIndex, value);
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new JABitArray(bitArray, (toIndex - fromIndex));
            } else {
                return new JABitSubArray(bitArray, (toIndex - fromIndex), fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new JABitArray(bitArray, count);
            } else {
                return new JABitSubArray(bitArray, count, position);
            }
        }

        public DataBitBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataBitBuffer) super.buffer(mode, capacity);
        }

        public DataBitBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataBitBuffer) super.buffer(mode);
        }

        public DataBitBuffer buffer(long capacity) {
            return (DataBitBuffer) super.buffer(capacity);
        }

        public DataBitBuffer buffer() {
            return (DataBitBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public BitArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public BitArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableBitArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJABitArray(cloneBitSubArray(
                        bitArray, 0, length), length).setNewStatus();
            } else {
                return (MutableBitArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableBitArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJABitArray(cloneBitSubArray(
                        bitArray, 0, length), length).setNewStatus();
            } else {
                return (UpdatableBitArray) super.updatableClone(memoryModel);
            }
        }

        public boolean[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART array bit[" + length
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(bitArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class JABitSubArray extends AbstractJAArray implements BitArray {
        long[] bitArray;
        long offset;

        JABitSubArray(long[] initialArray, long initialCapacity, long initialLength, long initialOffset) {
            super(initialArray, initialCapacity, initialLength);
            this.bitArray = initialArray;
            this.offset = initialOffset;
        }

        JABitSubArray(long[] initialArray, long initialCapacityAndLength, long initialOffset) {
            super(initialArray, initialCapacityAndLength);
            this.bitArray = initialArray;
            this.offset = initialOffset;
        }

        final void afterStorageFieldCorrection() {
            this.bitArray = (long[]) super.array;
            this.offset = 0;
        }

        final long longJavaArrayOffsetInternal() {
            return offset;
        }

        final int javaArrayOffsetInternal() {
            throw new AssertionError("Internal error in package implementation: "
                    + "unallowed accessing javaArrayOffsetInternal() for bit array");
        }

        public final Class<?> elementType() {
            return boolean.class;
        }

        public Class<? extends BitArray> type() {
            return BitArray.class;
        }

        public Class<? extends UpdatableBitArray> updatableType() {
            return UpdatableBitArray.class;
        }

        public Class<? extends MutableBitArray> mutableType() {
            return MutableBitArray.class;
        }

        public final Object getElement(long index) {
            return getBit(index);
        }

        public final long bitsPerElement() {
            return Arrays.BITS_PER_BIT;
        }

        public double minPossibleValue(double valueForFloatingPoint) {
            return minPossibleValue(); //min
        }

        public double maxPossibleValue(double valueForFloatingPoint) {
            return maxPossibleValue(); //max
        }

        public long minPossibleValue() {
            return 0;
        }

        public long maxPossibleValue() {
            return 1;
        }

        public final double getDouble(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((offset + index) >>> 6)] & (1L << ((int) (offset + index) & 63))) != 0L ? 1 : 0;
        }

        public final long indexOf(long lowIndex, long highIndex, double value) {
            return value == 0 || value == 1 ? indexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, double value) {
            return value == 0 || value == 1 ? lastIndexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final long getLong(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((offset + index) >>> 6)] & (1L << ((int) (offset + index) & 63))) != 0L ? 1 : 0;
        }

        public final int getInt(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((offset + index) >>> 6)] & (1L << ((int) (offset + index) & 63))) != 0L ? 1 : 0;
        }

        public final long indexOf(long lowIndex, long highIndex, long value) {
            return value == 0 || value == 1 ? indexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final long lastIndexOf(long lowIndex, long highIndex, long value) {
            return value == 0 || value == 1 ? lastIndexOf(lowIndex, highIndex, value != 0) : -1;
        }

        public final boolean getBit(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            return (this.bitArray[(int) ((offset + index) >>> 6)] & (1L << ((int) (offset + index) & 63))) != 0L;
        }

        @Override
        public final long getBits64(long arrayPos, int count) {
            if (arrayPos < 0) {
                throw rangeException(arrayPos);
            }
            if (count < 0) {
                throw new IllegalArgumentException("Negative count argument: " + count);
            }
            if (count > 64) {
                throw new IllegalArgumentException("Too large count argument: " + count +
                        "; we cannot get > 64 bits in getBits64 method");
            }
            if (arrayPos > length - count) {
                throw rangeException(arrayPos + count - 1);
            }
            return PackedBitArrays.getBits64Impl(bitArray, offset + arrayPos, count);
        }

        public long indexOf(long lowIndex, long highIndex, boolean value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = PackedBitArrays.indexOfBit(this.bitArray,
                    offset + lowIndex, offset + highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public long lastIndexOf(long lowIndex, long highIndex, boolean value) {
            if (lowIndex < 0) {
                lowIndex = 0;
            }
            if (highIndex > length) {
                highIndex = length;
            }
            if (lowIndex >= highIndex) {
                return -1;
            } // after these checks we are sure that overflow is impossible below
            long i = PackedBitArrays.lastIndexOfBit(this.bitArray,
                    offset + lowIndex, offset + highIndex, value);
            return i == -1 ? -1 : i - offset;
        }

        public Array subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0) {
                return new JABitArray(bitArray, (toIndex - fromIndex));
            } else {
                return new JABitSubArray(bitArray, (toIndex - fromIndex), offset + fromIndex);
            }
        }

        public Array subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0) {
                return new JABitArray(bitArray, count);
            } else {
                return new JABitSubArray(bitArray, count, offset + position);
            }
        }

        public DataBitBuffer buffer(DataBuffer.AccessMode mode, long capacity) {
            return (DataBitBuffer) super.buffer(mode, capacity);
        }

        public DataBitBuffer buffer(DataBuffer.AccessMode mode) {
            return (DataBitBuffer) super.buffer(mode);
        }

        public DataBitBuffer buffer(long capacity) {
            return (DataBitBuffer) super.buffer(capacity);
        }

        public DataBitBuffer buffer() {
            return (DataBitBuffer) super.buffer();
        }

        public boolean isUnresizable() {
            return true;
        }

        public BitArray asImmutable() {
            return this;
        }

        public boolean isImmutable() {
            return true;
        }

        public BitArray asTrustedImmutable() {
            return this;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public Array asCopyOnNextWrite() {
            return this;
        }

        public final MutableBitArray mutableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new MutableJABitArray(cloneBitSubArray(
                        bitArray, offset, offset + length), length).setNewStatus();
            } else {
                return (MutableBitArray) super.mutableClone(memoryModel);
            }
        }

        public final UpdatableBitArray updatableClone(MemoryModel memoryModel) {
            if (memoryModel == SimpleMemoryModel.INSTANCE) {
                return new UpdatableJABitArray(cloneBitSubArray(
                        bitArray, offset, offset + length), length).setNewStatus();
            } else {
                return (UpdatableBitArray) super.updatableClone(memoryModel);
            }
        }

        public boolean[] ja() {
            return Arrays.toJavaArray(this);
        }

        public String toString() {
            return "immutable simple AlgART subarray bit[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(bitArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isNew() ? ", new" : ", view");
        }
    }


    @SuppressWarnings("cast")
    static class UpdatableJABitArray
            extends JABitArray implements UpdatableBitArray {
        UpdatableJABitArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        UpdatableJABitArray(long[] initialArray, long initialCapacity, long initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        UpdatableJABitArray(long[] initialArray, long initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        public final void setElement(long index, Object value) {
            setBit(index, (Boolean) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if ((this.bitArray[(int) ((srcIndex) >>> 6)] & (1L << ((int) (srcIndex) & 63))) != 0L)
                    this.bitArray[(int) ((destIndex) >>> 6)] |= 1L << ((int) (destIndex) & 63);
                else
                    this.bitArray[(int) ((destIndex) >>> 6)] &= ~(1L << ((int) (destIndex) & 63));
            }
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            PackedBitArrays.copyBits(this.bitArray, destIndex, this.bitArray, srcIndex, count);
        }

        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            long i = firstIndex, j = secondIndex;
            boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if ((this.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                    this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                else
                    this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
            }
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (temp)
                    this.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                else
                    this.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
            }
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            long i = firstIndex, j = secondIndex;
            for (long iMax = i + count; i < iMax; i++, j++) {
                boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
                synchronized (this.bitArray) {
                    if ((this.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                        this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                    else
                        this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                }
                synchronized (this.bitArray) {
                    if (temp)
                        this.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                    else
                        this.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
                }
            }
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public UpdatableArray copy(Array src) {
            if (src instanceof JABitSubArray a) {
                long count = (Math.min(a.length, length));
                if (count == 1) {
                    synchronized (bitArray) {
                        if ((a.bitArray[(int) ((a.offset) >>> 6)] & (1L << ((int) (a.offset) & 63))) != 0L)
                            bitArray[(int) ((0) >>> 6)] |= 1L << ((int) (0) & 63);
                        else
                            bitArray[(int) ((0) >>> 6)] &= ~(1L << ((int) (0) & 63));
                    }
                    return this;
                } else if (count > 0) {
                    PackedBitArrays.copyBits(bitArray, 0, a.bitArray, a.offset, count);
                    return this;
                }
            } else if (src instanceof JABitArray a) {
                long count = Math.min(a.length, length);
                if (count > 0) {
                    PackedBitArrays.copyBits(bitArray, 0, a.bitArray, 0, count);
                }
                return this;
            }
            if (src instanceof CopiesArraysImpl.CopiesBitArray a) {
                long count = Math.min(a.length, length);
                PackedBitArrays.fillBits(bitArray, this.longJavaArrayOffsetInternal(), count, a.element);
            } else {
                defaultCopy(this, src);
            }
            return this;
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJABitSubArray a) {
                long count = Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    long j = a.offset;
                    for (long i = 0; i < count; i++, j++) {
                        boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
                        synchronized (this.bitArray) {
                            if ((a.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                                this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                            else
                                this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                        }
                        synchronized (a.bitArray) {
                            if (temp)
                                a.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                            else
                                a.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
                        }
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJABitArray a) {
                long count = Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    for (long i = 0; i < count; i++) {
                        boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
                        synchronized (this.bitArray) {
                            if ((a.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L)
                                this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                            else
                                this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                        }
                        synchronized (a.bitArray) {
                            if (temp)
                                a.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                            else
                                a.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                        }
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setBit(index, value != 0);
        }

        public final void setLong(long index, long value) {
            setBit(index, value != 0);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (value != 0)
                    this.bitArray[(int) ((index) >>> 6)] |= 1L << ((int) (index) & 63);
                else
                    this.bitArray[(int) ((index) >>> 6)] &= ~(1L << ((int) (index) & 63));
            }
        }

        public final void setBit(long index, boolean value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (value)
                    this.bitArray[(int) ((index) >>> 6)] |= 1L << ((int) (index) & 63);
                else
                    this.bitArray[(int) ((index) >>> 6)] &= ~(1L << ((int) (index) & 63));
            }
        }

        public final void setBit(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                this.bitArray[(int) ((index) >>> 6)] |= 1L << ((index) & 63);
            }
        }

        public final void clearBit(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                this.bitArray[(int) ((index) >>> 6)] &= ~(1L << ((index) & 63));
            }
        }

        public final void setBitNoSync(long index, boolean value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (value)
                this.bitArray[(int) ((index) >>> 6)] |= 1L << ((int) (index) & 63);
            else
                this.bitArray[(int) ((index) >>> 6)] &= ~(1L << ((int) (index) & 63));
        }

        public final void setBitNoSync(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.bitArray[(int) ((index) >>> 6)] |= 1L << ((index) & 63);
        }

        public final void clearBitNoSync(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.bitArray[(int) ((index) >>> 6)] &= ~(1L << ((index) & 63));
        }

        @Override
        public void setBits64(long arrayPos, long bits, int count) {
            if (arrayPos < 0) {
                throw rangeException(arrayPos);
            }
            if (count < 0) {
                throw new IllegalArgumentException("Negative count argument: " + count);
            }
            if (count > 64) {
                throw new IllegalArgumentException("Too large count argument: " + count +
                        "; we cannot get > 64 bits in getBits64 method");
            }
            if (arrayPos > length - count) {
                throw rangeException(arrayPos + count - 1);
            }
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                PackedBitArrays.setBits64Impl(bitArray, arrayPos, bits, count);
            }
        }

        @Override
        public void setBits64NoSync(long arrayPos, long bits, int count) {
            if (arrayPos < 0) {
                throw rangeException(arrayPos);
            }
            if (count < 0) {
                throw new IllegalArgumentException("Negative count argument: " + count);
            }
            if (count > 64) {
                throw new IllegalArgumentException("Too large count argument: " + count +
                        "; we cannot get > 64 bits in getBits64 method");
            }
            if (arrayPos > length - count) {
                throw rangeException(arrayPos + count - 1);
            }
            PackedBitArrays.setBits64Impl(bitArray, arrayPos, bits, count);

        }

        public UpdatableBitArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableBitArray fill(long position, long count, double value) {
            return fill(position, count, value != 0);
        }

        public UpdatableBitArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableBitArray fill(long position, long count, long value) {
            return fill(position, count, value != 0);
        }

        public UpdatableBitArray fill(boolean value) {
            return fill(0, length, value);
        }

        public UpdatableBitArray fill(long position, long count, boolean value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            PackedBitArrays.fillBits(this.bitArray, position, count, value);
            return this;
        }

        public UpdatableBitArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (fromIndex == 0) {
                return new UpdatableJABitArray(bitArray, (toIndex - fromIndex));
            } else {
                return new UpdatableJABitSubArray(bitArray, (toIndex - fromIndex), fromIndex);
            }
        }

        public UpdatableBitArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (position == 0) {
                return new UpdatableJABitArray(bitArray, count);
            } else {
                return new UpdatableJABitSubArray(bitArray, count, position);
            }
        }

        // must be overridden in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final BitArray asImmutable() {
            return new JABitArray(bitArray, capacity(), length());
        }

        // must be  in UpdatableBitArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final BitArray asTrustedImmutable() {
            return new JABitArray(bitArray, capacity(), length());
            // Never set high bit here, because only subarrays can be copy-on-next write
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            UpdatableJABitSubArray result = new UpdatableJABitSubArray(bitArray,
                    capacity(), length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableBitArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        @Override
        public boolean isPackedBitArrayWrapper() {
            return (length + 63) >>> 6 == bitArray.length;
        }

        @Override
        public long[] jaBit() {
            if (isPackedBitArrayWrapper()) {
                return this.bitArray;
            }
            return toBit();
        }

        public String toString() {
            return "unresizable simple AlgART array bit[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(bitArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static class UpdatableJABitSubArray
            extends JABitSubArray implements UpdatableBitArray {
        UpdatableJABitSubArray(long[] initialArray, long initialCapacity, long initialLength, long initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        UpdatableJABitSubArray(long[] initialArray, long initialCapacityAndLength, long initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        public final void setElement(long index, Object value) {
            setBit(index, (Boolean) value);
        }

        public final void copy(long destIndex, long srcIndex) {
            if (srcIndex < 0 || srcIndex >= length)
                throw rangeException(srcIndex);
            if (destIndex < 0 || destIndex >= length)
                throw rangeException(destIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if ((this.bitArray[(int) ((offset + srcIndex) >>> 6)]
                        & (1L << ((int) (offset + srcIndex) & 63))) != 0L)
                    this.bitArray[(int) ((offset + destIndex) >>> 6)] |= 1L << ((int) (offset + destIndex) & 63);
                else
                    this.bitArray[(int) ((offset + destIndex) >>> 6)] &= ~(1L << ((int) (offset + destIndex) & 63));
            }
        }

        public final void copy(long destIndex, long srcIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of copied elements (count = " + count
                        + ") in " + getClass());
            if (srcIndex < 0)
                throw rangeException(srcIndex);
            if (srcIndex > length - count)
                throw rangeException(srcIndex + count - 1);
            if (destIndex < 0)
                throw rangeException(destIndex);
            if (destIndex > length - count)
                throw rangeException(destIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            PackedBitArrays.copyBits(this.bitArray, offset + destIndex, this.bitArray, offset + srcIndex, count);
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public final void swap(long firstIndex, long secondIndex) {
            if (firstIndex < 0 || firstIndex >= length)
                throw rangeException(firstIndex);
            if (secondIndex < 0 || secondIndex >= length)
                throw rangeException(secondIndex);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            long i = offset + firstIndex, j = offset + secondIndex;
            boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
            synchronized (this.bitArray) {
                if ((this.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                    this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                else
                    this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
            }
            synchronized (this.bitArray) {
                if (temp)
                    this.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                else
                    this.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
            }
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public final void swap(long firstIndex, long secondIndex, long count) {
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of swapped elements (count = " + count
                        + ") in " + getClass());
            if (firstIndex < 0)
                throw rangeException(firstIndex);
            if (firstIndex > length - count)
                throw rangeException(firstIndex + count - 1);
            if (secondIndex < 0)
                throw rangeException(secondIndex);
            if (secondIndex > length - count)
                throw rangeException(secondIndex + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            long i = offset + firstIndex, j = offset + secondIndex;
            for (long iMax = i + count; i < iMax; i++, j++) {
                boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
                synchronized (this.bitArray) {
                    if ((this.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                        this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                    else
                        this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                }
                synchronized (this.bitArray) {
                    if (temp)
                        this.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                    else
                        this.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
                }
            }
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public UpdatableArray copy(Array src) {
            if (src instanceof JABitSubArray a) {
                long count = Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    synchronized (bitArray) {
                        if ((a.bitArray[(int) ((a.offset) >>> 6)] & (1L << ((int) (a.offset) & 63))) != 0L)
                            bitArray[(int) ((offset) >>> 6)] |= 1L << ((int) (offset) & 63);
                        else
                            bitArray[(int) ((offset) >>> 6)] &= ~(1L << ((int) (offset) & 63));
                    }
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    PackedBitArrays.copyBits(bitArray, offset, a.bitArray, a.offset, count);
                    return this;
                }
            } else if (src instanceof JABitArray a) {
                long count = Math.min(a.length, length);
                if (count == 1) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    //noinspection SynchronizeOnNonFinalField
                    synchronized (bitArray) {
                        if ((a.bitArray[(int) ((0) >>> 6)] & (1L << ((int) (0) & 63))) != 0L)
                            bitArray[(int) ((offset) >>> 6)] |= 1L << ((int) (offset) & 63);
                        else
                            bitArray[(int) ((offset) >>> 6)] &= ~(1L << ((int) (offset) & 63));
                    }
                    return this;
                } else if (count > 0) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    PackedBitArrays.copyBits(bitArray, offset, a.bitArray, 0, count);
                    return this;
                }
            }
            if (src instanceof CopiesArraysImpl.CopiesBitArray a) {
                long count = Math.min(a.length, length);
                PackedBitArrays.fillBits(bitArray, this.longJavaArrayOffsetInternal(), count, a.element);
            } else {
                defaultCopy(this, src);
            }
            return this;
        }

        @SuppressWarnings("SynchronizeOnNonFinalField")
        public UpdatableArray swap(UpdatableArray another) {
            if (another instanceof UpdatableJABitSubArray a) {
                long count = Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    long i = offset;
                    long j = a.offset;
                    for (long iMax = i + count; i < iMax; i++, j++) {
                        boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
                        synchronized (this.bitArray) {
                            if ((a.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                                this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                            else
                                this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                        }
                        synchronized (a.bitArray) {
                            if (temp)
                                a.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                            else
                                a.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
                        }
                    }
                    return this;
                }
            } else if (another instanceof UpdatableJABitArray a) {
                long count = Math.min(a.length, length);
                if (count < MIN_COUNT_FOR_USING_DEFAULT_SWAP) {
                    if (this.capacity < 0) // copy-on-next-write
                        reallocateStorage();
                    long i = offset;
                    for (long j = 0; j < count; i++, j++) {
                        boolean temp = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
                        synchronized (this.bitArray) {
                            if ((a.bitArray[(int) ((j) >>> 6)] & (1L << ((int) (j) & 63))) != 0L)
                                this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                            else
                                this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
                        }
                        synchronized (a.bitArray) {
                            if (temp)
                                a.bitArray[(int) ((j) >>> 6)] |= 1L << ((int) (j) & 63);
                            else
                                a.bitArray[(int) ((j) >>> 6)] &= ~(1L << ((int) (j) & 63));
                        }
                    }
                    return this;
                }
            }
            defaultSwap(this, another);
            return this;
        }

        public final void setDouble(long index, double value) {
            setBit(index, value != 0);
        }

        public final void setLong(long index, long value) {
            setBit(index, value != 0);
        }

        public final void setInt(long index, int value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (value != 0)
                    this.bitArray[(int) ((offset + index) >>> 6)] |= 1L << ((int) (offset + index) & 63);
                else
                    this.bitArray[(int) ((offset + index) >>> 6)] &= ~(1L << ((int) (offset + index) & 63));
            }
        }

        public final void setBit(long index, boolean value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (value)
                    this.bitArray[(int) ((offset + index) >>> 6)] |= 1L << ((int) (offset + index) & 63);
                else
                    this.bitArray[(int) ((offset + index) >>> 6)] &= ~(1L << ((int) (offset + index) & 63));
            }
        }

        public final void setBit(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                this.bitArray[(int) ((offset + index) >>> 6)] |= 1L << ((offset + index) & 63);
            }
        }

        public final void clearBit(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                this.bitArray[(int) ((offset + index) >>> 6)] &= ~(1L << ((offset + index) & 63));
            }
        }

        public final void setBitNoSync(long index, boolean value) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            if (value)
                this.bitArray[(int) ((offset + index) >>> 6)] |= 1L << ((int) (offset + index) & 63);
            else
                this.bitArray[(int) ((offset + index) >>> 6)] &= ~(1L << ((int) (offset + index) & 63));
        }

        public final void setBitNoSync(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.bitArray[(int) ((offset + index) >>> 6)] |= 1L << ((offset + index) & 63);
        }

        public final void clearBitNoSync(long index) {
            if (index < 0 || index >= length)
                throw rangeException(index);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.bitArray[(int) ((offset + index) >>> 6)] &= ~(1L << ((offset + index) & 63));
        }

        @Override
        public void setBits64(long arrayPos, long bits, int count) {
            if (arrayPos < 0) {
                throw rangeException(arrayPos);
            }
            if (count < 0) {
                throw new IllegalArgumentException("Negative count argument: " + count);
            }
            if (count > 64) {
                throw new IllegalArgumentException("Too large count argument: " + count +
                        "; we cannot get > 64 bits in getBits64 method");
            }
            if (arrayPos > length - count) {
                throw rangeException(arrayPos + count - 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                PackedBitArrays.setBits64Impl(bitArray, offset + arrayPos, bits, count);
            }
        }

        @Override
        public void setBits64NoSync(long arrayPos, long bits, int count) {
            if (arrayPos < 0) {
                throw rangeException(arrayPos);
            }
            if (count < 0) {
                throw new IllegalArgumentException("Negative count argument: " + count);
            }
            if (count > 64) {
                throw new IllegalArgumentException("Too large count argument: " + count +
                        "; we cannot get > 64 bits in getBits64 method");
            }
            if (arrayPos > length - count) {
                throw rangeException(arrayPos + count - 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            PackedBitArrays.setBits64Impl(bitArray, offset + arrayPos, bits, count);
        }

        public UpdatableBitArray fill(double value) {
            return fill(0, length, value);
        }

        public UpdatableBitArray fill(long position, long count, double value) {
            return fill(position, count, value != 0);
        }

        public UpdatableBitArray fill(long value) {
            return fill(0, length, value);
        }

        public UpdatableBitArray fill(long position, long count, long value) {
            return fill(position, count, value != 0);
        }

        public UpdatableBitArray fill(boolean value) {
            return fill(0, length, value);
        }

        public UpdatableBitArray fill(long position, long count, boolean value) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            PackedBitArrays.fillBits(this.bitArray, offset + position, count, value);
            return this;
        }

        public UpdatableBitArray subArray(long fromIndex, long toIndex) {
            if (fromIndex < 0)
                throw rangeException(fromIndex);
            if (toIndex > length)
                throw rangeException(toIndex - 1);
            if (fromIndex > toIndex)
                throw new IndexOutOfBoundsException("Negative number of elements (fromIndex = " + fromIndex
                        + " > toIndex = " + toIndex + ") in " + getClass());
            if (offset + fromIndex == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJABitArray(bitArray, (toIndex - fromIndex));
            } else {
                UpdatableJABitSubArray result = new UpdatableJABitSubArray(bitArray,
                        (toIndex - fromIndex), offset + fromIndex);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        public UpdatableBitArray subArr(long position, long count) {
            if (position < 0)
                throw rangeException(position);
            if (count < 0)
                throw new IndexOutOfBoundsException("Negative number of elements (count = " + count
                        + ") in " + getClass());
            if (position > length - count)
                throw rangeException(position + count - 1);
            if (offset + position == 0 && this.capacity >= 0) { // not copy-on-next-write
                return new UpdatableJABitArray(bitArray, count);
            } else {
                UpdatableJABitSubArray result = new UpdatableJABitSubArray(bitArray,
                        count, offset + position);
                if (this.capacity < 0) // copy-on-next-write
                    result.capacity |= HIGH_BIT;
                return result;
            }
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final BitArray asImmutable() {
            return new JABitSubArray(bitArray, capacity(), length(), offset);
        }

        // must be overridden in UpdatableBitSubArray,
        // which is built by preprocessor without "trusted" superclass
        public final boolean isImmutable() {
            return false;
        }

        public final BitArray asTrustedImmutable() {
            JABitSubArray result = new JABitSubArray(bitArray,
                    capacity(), length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public void checkUnallowedMutation() throws UnallowedMutationError {
        }

        public UpdatableArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            UpdatableJABitSubArray result = new UpdatableJABitSubArray(bitArray,
                    capacity(), length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public UpdatableBitArray asUnresizable() {
            return this;
        }

        public UpdatableArray shallowClone() {
            return (UpdatableArray) standardObjectClone();
        }

        @Override
        public boolean isPackedBitArrayWrapper() {
            return offset == 0 && (length + 63) >>> 6 == bitArray.length;
        }

        @Override
        public long[] jaBit() {
            if (isPackedBitArrayWrapper()) {
                if (isCopyOnNextWrite()) {
                    reallocateStorage();
                }
                return this.bitArray;
            }
            return toBit();
        }

        public String toString() {
            return "unresizable simple AlgART subarray bit[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(bitArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static final class MutableJABitArray
            extends UpdatableJABitArray implements MutableBitArray {
        MutableJABitArray(long initialCapacity, long initialLength) {
            super(initialCapacity, initialLength);
        }

        MutableJABitArray(long[] initialArray, long initialCapacity, long initialLength) {
            super(initialArray, initialCapacity, initialLength);
        }

        MutableJABitArray(long[] initialArray, long initialCapacityAndLength) {
            super(initialArray, initialCapacityAndLength);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nBitCopies(toIndex - fromIndex, false), true);
        }

        public MutableBitArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableBitArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableBitArray trim() {
            trimImpl();
            return this;
        }

        public MutableBitArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            return popBit();
        }

        public void pushElement(Object value) {
            pushBit((Boolean) value);
        }

        public double popDouble() {
            return popBit() ? 1.0 : 0.0;
        }

        public long popLong() {
            return popBit() ? 1L : 0L;
        }

        public int popInt() {
            return popBit() ? 1 : 0;
        }

        public void addDouble(double value) {
            pushBit(value != 0.0);
        }

        public void addLong(long value) {
            pushBit(value != 0);
        }

        public void addInt(int value) {
            pushBit(value != 0);
        }

        public boolean popBit() {
            long i = length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            boolean result = (this.bitArray[(int) ((i) >>> 6)] & (1L << ((int) (i) & 63))) != 0L;
            this.length = i;
            // - no sense to spend time for setting freed bit to zero
            return result;
        }

        public void pushBit(boolean value) {
            long i = length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            this.length = i + 1;
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (value)
                    this.bitArray[(int) ((i) >>> 6)] |= 1L << ((int) (i) & 63);
                else
                    this.bitArray[(int) ((i) >>> 6)] &= ~(1L << ((int) (i) & 63));
            }
        }

        public void removeTop() {
            long i = length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no sense to spend time for setting freed bit to zero
        }

        public MutableBitArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableBitArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableBitArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableBitArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableBitArray asCopyOnNextWrite() {
            MutableJABitSubArray result = new MutableJABitSubArray(bitArray,
                    capacity(), length(), 0);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableBitArray asUnresizable() {
            return new UpdatableJABitArray(bitArray, capacity(), length());
        }

        public MutableBitArray shallowClone() {
            return (MutableBitArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART array bit[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(bitArray))
                    + ", capacity " + capacity()
                    + (isNew() ? ", new" : ", view");
        }
    }

    @SuppressWarnings("cast")
    static final class MutableJABitSubArray
            extends UpdatableJABitSubArray implements MutableBitArray
            // This class is used only for check "capacity < 0" for copy-on-next-write mode
    {
        MutableJABitSubArray(long[] initialArray, long initialCapacity, long initialLength, long initialOffset) {
            super(initialArray, initialCapacity, initialLength, initialOffset);
        }

        MutableJABitSubArray(long[] initialArray, long initialCapacityAndLength, long initialOffset) {
            super(initialArray, initialCapacityAndLength, initialOffset);
        }

        void clearElements(long fromIndex, long toIndex) {
            defaultCopy(this.subArray(fromIndex, toIndex),
                    Arrays.nBitCopies(toIndex - fromIndex, false), true);
        }

        public MutableBitArray length(long newLength) {
            if (length < 0)
                throw new IllegalArgumentException("Negative desired array length");
            lengthImpl(newLength);
            return this;
        }

        public MutableBitArray ensureCapacity(long minCapacity) {
            if (minCapacity < 0)
                throw new IllegalArgumentException("Negative desired array minimal capacity");
            ensureCapacityImpl(minCapacity);
            return this;
        }

        public MutableBitArray trim() {
            trimImpl();
            return this;
        }

        public MutableBitArray append(Array appendedArray) {
            appendImpl(appendedArray);
            return this;
        }

        public Object popElement() {
            return popBit();
        }

        public void pushElement(Object value) {
            pushBit((Boolean) value);
        }

        public double popDouble() {
            return popBit() ? 1.0 : 0.0;
        }

        public long popLong() {
            return popBit() ? 1L : 0L;
        }

        public int popInt() {
            return popBit() ? 1 : 0;
        }

        public void addDouble(double value) {
            pushBit(value != 0.0);
        }

        public void addLong(long value) {
            pushBit(value != 0);
        }

        public void addInt(int value) {
            pushBit(value != 0);
        }

        public boolean popBit() {
            long i = length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            boolean result = (this.bitArray[(int) ((offset + i) >>> 6)] & (1L << ((int) (offset + i) & 63))) != 0L;
            this.length = i;
            // - no sense to spend time for setting freed bit to zero
            return result;
        }

        public void pushBit(boolean value) {
            long i = length;
            if (i >= capacity()) {
                // we are sure that i cannot be Long.MAX_VALUE, because i is int value
                ensureCapacityImpl((long) i + 1);
            }
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i + 1;
            //noinspection SynchronizeOnNonFinalField
            synchronized (this.bitArray) {
                if (value)
                    this.bitArray[(int) ((offset + i) >>> 6)] |= 1L << ((int) (offset + i) & 63);
                else
                    this.bitArray[(int) ((offset + i) >>> 6)] &= ~(1L << ((int) (offset + i) & 63));
            }
        }

        public void removeTop() {
            long i = length - 1;
            if (i < 0)
                throw new EmptyStackException();
            if (this.capacity < 0) // copy-on-next-write
                reallocateStorage();
            this.length = i;
            // - no sense to spend time for setting freed bit to zero
        }

        public MutableBitArray setData(long arrayPos, Object srcArray, int srcArrayOffset, int count) {
            super.setData(arrayPos, srcArray, srcArrayOffset, count);
            return this;
        }

        public MutableBitArray setData(long arrayPos, Object srcArray) {
            super.setData(arrayPos, srcArray);
            return this;
        }

        public MutableBitArray copy(Array src) {
            super.copy(src);
            return this;
        }

        public MutableBitArray swap(UpdatableArray another) {
            super.swap(another);
            return this;
        }

        public MutableBitArray asCopyOnNextWrite() {
            if (isCopyOnNextWrite())
                return this;
            MutableJABitSubArray result = new MutableJABitSubArray(bitArray,
                    capacity(), length(), offset);
            result.capacity |= HIGH_BIT;
            return result;
        }

        public boolean isUnresizable() {
            return false;
        }

        public UpdatableBitArray asUnresizable() {
            UpdatableJABitSubArray result = new UpdatableJABitSubArray(bitArray,
                    capacity(), length(), offset);
            if (this.capacity < 0) // copy-on-next-write
                result.capacity |= HIGH_BIT;
            return result;
        }

        public MutableBitArray shallowClone() {
            return (MutableBitArray) standardObjectClone();
        }

        public String toString() {
            return "mutable simple AlgART subarray bit[" + length()
                    + "], built-in Java-array @" + Integer.toHexString(System.identityHashCode(bitArray))
                    + ", capacity " + capacity() + ", start offset = " + offset
                    + (isCopyOnNextWrite() ? ", copy on next write" : "")
                    + (isNew() ? ", new" : ", view");
        }
    }
}
