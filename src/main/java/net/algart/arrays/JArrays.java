/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2007-2024 Daniel Alievsky, AlgART Laboratory (http://algart.net)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.algart.arrays;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Locale;
import java.util.Objects;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

/**
 * <p>Some operations for Java array manipulation, in addition to <code>java.util.Arrays</code>.</p>
 *
 * <p>This class cannot be instantiated.</p>
 *
 * @author Daniel Alievsky
 */
public class JArrays {
    private static final int HASH_BLOCK_LEN = 256; // must be 2^k
    private static final boolean OPTIMIZE_BYTE_MIN_MAX_BY_TABLES = false; // anti-optimization since Java 1.6+

    private JArrays() {
    }

    /*Repeat() boolean ==> byte,,char,,short,,int,,long,,float,,double;;
               BOOLEAN ==> BYTE,,CHAR,,SHORT,,INT,,LONG,,FLOAT,,DOUBLE */

    /**
     * Constant, containing empty array <code>new boolean[0]</code>.
     */
    public static final boolean[] EMPTY_BOOLEANS = new boolean[0];
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Constant, containing empty array <code>new byte[0]</code>.
     */
    public static final byte[] EMPTY_BYTES = new byte[0];

    /**
     * Constant, containing empty array <code>new char[0]</code>.
     */
    public static final char[] EMPTY_CHARS = new char[0];

    /**
     * Constant, containing empty array <code>new short[0]</code>.
     */
    public static final short[] EMPTY_SHORTS = new short[0];

    /**
     * Constant, containing empty array <code>new int[0]</code>.
     */
    public static final int[] EMPTY_INTS = new int[0];

    /**
     * Constant, containing empty array <code>new long[0]</code>.
     */
    public static final long[] EMPTY_LONGS = new long[0];

    /**
     * Constant, containing empty array <code>new float[0]</code>.
     */
    public static final float[] EMPTY_FLOATS = new float[0];

    /**
     * Constant, containing empty array <code>new double[0]</code>.
     */
    public static final double[] EMPTY_DOUBLES = new double[0];
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() byte ==> char,,short,,int,,long,,float,,double;;
               Byte ==> Char,,Short,,Int,,Long,,Float,,Double;;
               (\s+)\& 0xFF ==> ,,$1& 0xFFFF,, ,,...;;
               (\(array\[\(int\)\s*firstIndex\]\)) < (\(array\[\(int\)\s*secondIndex\]\)) ==>
                   $1 < $2,,$1 < $2,,$1 < $2,,$1 < $2,,Float.compare($1, $2) < 0,,Double.compare($1, $2) < 0;;
               (\*\s*<p>Note that.*?\<\/p\>\s*) ==> ,,$1,, ,, ,,
               * <p>Note: elements of <code>float[]</code> are compared by <code>Float.compare(float, float)</code>
     * method. So, <code>NaN</code> is considered to be equal to itself and greater than all other float values
     * (including <code>POSITIVE_INFINITY</code>), and <code>0.0 </code>is considered
     * be greater than <code>-0.0</code>.</p>
     * ,,
               * <p>Note: elements of <code>double[]</code> are compared by <code>Double.compare(double, double)</code>
     * method. So, <code>NaN</code> is considered to be equal to itself and greater than all other double alues
     * (including <code>POSITIVE_INFINITY</code>), and <code>0.0 </code>is considered
     * be greater than <code>-0.0</code>.</p>
     *
     */

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>byte[]</code> array.
     *
     * <p>Note that the elements of <code>byte[]</code> array are supposed to be <b>unsigned</b>:
     * we always compare {@code array[i] & 0xFF} and {@code array[j] & 0xFF}
     * instead of simple <code>array[i]</code> and <code>array[j]</code>.</p>
     */
    public static class ByteArrayComparator implements ArrayComparator32 {
        private final byte[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public ByteArrayComparator(byte[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first] & 0xFF) < (array[second] & 0xFF);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>byte[]</code> array.
     */
    public static class ByteArrayExchanger implements ArrayExchanger32 {
        private final byte[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public ByteArrayExchanger(byte[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            byte temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>byte[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class ByteAndIndexArrayExchanger implements ArrayExchanger32 {
        private final byte[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public ByteAndIndexArrayExchanger(byte[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            byte temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>char[]</code> array.
     *
     */
    public static class CharArrayComparator implements ArrayComparator32 {
        private final char[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public CharArrayComparator(char[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first]) < (array[second]);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>char[]</code> array.
     */
    public static class CharArrayExchanger implements ArrayExchanger32 {
        private final char[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public CharArrayExchanger(char[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            char temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>char[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class CharAndIndexArrayExchanger implements ArrayExchanger32 {
        private final char[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public CharAndIndexArrayExchanger(char[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            char temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>short[]</code> array.
     *
     * <p>Note that the elements of <code>short[]</code> array are supposed to be <b>unsigned</b>:
     * we always compare {@code array[i] & 0xFFFF} and {@code array[j] & 0xFFFF}
     * instead of simple <code>array[i]</code> and <code>array[j]</code>.</p>
     */
    public static class ShortArrayComparator implements ArrayComparator32 {
        private final short[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public ShortArrayComparator(short[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first] & 0xFFFF) < (array[second] & 0xFFFF);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>short[]</code> array.
     */
    public static class ShortArrayExchanger implements ArrayExchanger32 {
        private final short[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public ShortArrayExchanger(short[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            short temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>short[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class ShortAndIndexArrayExchanger implements ArrayExchanger32 {
        private final short[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public ShortAndIndexArrayExchanger(short[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            short temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>int[]</code> array.
     *
     */
    public static class IntArrayComparator implements ArrayComparator32 {
        private final int[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public IntArrayComparator(int[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first]) < (array[second]);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>int[]</code> array.
     */
    public static class IntArrayExchanger implements ArrayExchanger32 {
        private final int[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public IntArrayExchanger(int[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            int temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>int[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class IntAndIndexArrayExchanger implements ArrayExchanger32 {
        private final int[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public IntAndIndexArrayExchanger(int[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            int temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>long[]</code> array.
     *
     */
    public static class LongArrayComparator implements ArrayComparator32 {
        private final long[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public LongArrayComparator(long[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first]) < (array[second]);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>long[]</code> array.
     */
    public static class LongArrayExchanger implements ArrayExchanger32 {
        private final long[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public LongArrayExchanger(long[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            long temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>long[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class LongAndIndexArrayExchanger implements ArrayExchanger32 {
        private final long[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public LongAndIndexArrayExchanger(long[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            long temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>float[]</code> array.
     *
     * <p>Note: elements of <code>float[]</code> are compared by <code>Float.compare(float, float)</code>
     * method. So, <code>NaN</code> is considered to be equal to itself and greater than all other float values
     * (including <code>POSITIVE_INFINITY</code>), and <code>0.0 </code>is considered
     * be greater than <code>-0.0</code>.</p>
     **/
    public static class FloatArrayComparator implements ArrayComparator32 {
        private final float[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public FloatArrayComparator(float[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first]) < (array[second]);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>float[]</code> array.
     */
    public static class FloatArrayExchanger implements ArrayExchanger32 {
        private final float[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public FloatArrayExchanger(float[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            float temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>float[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class FloatAndIndexArrayExchanger implements ArrayExchanger32 {
        private final float[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public FloatAndIndexArrayExchanger(float[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            float temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }

    /**
     * Simple implementation of {@link ArrayComparator}, comparing elements of <code>double[]</code> array.
     *
     * <p>Note: elements of <code>double[]</code> are compared by <code>Double.compare(double, double)</code>
     * method. So, <code>NaN</code> is considered to be equal to itself and greater than all other double alues
     * (including <code>POSITIVE_INFINITY</code>), and <code>0.0 </code>is considered
     * be greater than <code>-0.0</code>.</p>
     **/
    public static class DoubleArrayComparator implements ArrayComparator32 {
        private final double[] array;

        /**
         * Creates new comparator, comparing elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public DoubleArrayComparator(double[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Returns <code>true</code> if, and only if, the element <code>array[(int)first]</code>
         * is less than the element <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first compared element.
         * @param second index of the second compared element.
         * @return whether the element <code>#first</code> is less than the element <code>#second</code>.
         */
        @Override
        public boolean less(int first, int second) {
            return (array[first]) < (array[second]);
        }
    }

    /**
     * Simple implementation of {@link ArrayExchanger}, exchanging elements of <code>double[]</code> array.
     */
    public static class DoubleArrayExchanger implements ArrayExchanger32 {
        private final double[] array;

        /**
         * Creates new exchanger, exchanging elements of the passed array.
         *
         * @param array some Java array.
         * @throws NullPointerException if the argument is {@code null}.
         */
        public DoubleArrayExchanger(double[] array) {
            Objects.requireNonNull(array, "Null array");
            this.array = array;
        }

        /**
         * Exchanges the elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * where <code>array</code> is the argument of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            double temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
        }
    }

    /**
     * Implementation of {@link ArrayExchanger}, that simultaneously exchanges two pairs elements at the same
     * positions in two arrays: some <code>double[]</code> array and some <code>int[]</code> array.
     * It is convenient, when the 1st array contains data and the 2nd array contains some "indexes",
     * and we want to exchange indexes simultaneously with sorting the data array.
     */
    public static class DoubleAndIndexArrayExchanger implements ArrayExchanger32 {
        private final double[] array;
        private final int[] indexes;

        /**
         * Creates new exchanger, exchanging elements of both passed arrays.
         *
         * @param array   some Java array.
         * @param indexes another Java array.
         * @throws NullPointerException if one of the arguments is {@code null}.
         */
        public DoubleAndIndexArrayExchanger(double[] array, int[] indexes) {
            Objects.requireNonNull(array, "Null array");
            Objects.requireNonNull(indexes, "Null indexes");
            this.array = array;
            this.indexes = indexes;
        }

        /**
         * Exchanges two pair: 1) elements <code>array[(int)first]</code> and <code>array[(int)second]</code>,
         * 2) elements <code>indexes[(int)first]</code> and <code>indexes[(int)second]</code>,
         * where <code>array</code> and <code>indexes</code>are the arguments of the constructor.
         *
         * @param first  index of the first exchanged element.
         * @param second index of the second exchanged element.
         */
        @Override
        public void swap(int first, int second) {
            double temp = this.array[first];
            this.array[first] = this.array[second];
            this.array[second] = temp;
            int index = indexes[first];
            indexes[first] = indexes[second];
            indexes[second] = index;
        }
    }
    /*Repeat.AutoGeneratedEnd*/


    /**
     * Returns a fragment of the given array from the element <code>#fromIndex</code>
     * to the element <code>#toIndex</code>.
     * The type of returned array is identical to the type of <code>array</code> argument,
     * the length of returned array is <code>toIndex-fromIndex</code>.
     *
     * <p>The <code>toIndex</code> value must not be less than <code>fromIndex</code>,
     * but may be greater than <code>array.length</code> (the length of the source array),
     * in which case all "extra" elements of the result (with indexes
     * <code>#array.length..#toIndex</code>) are zero-filled: 0 for array of numbers and characters,
     * <code>false</code> for <code>boolean</code> array, {@code null} for array of objects.
     *
     * <p>The method always creates a new array, even if <code>fromIndex</code> is 0
     * and <code>toIndex</code> is equal to <code>array.length</code>.
     *
     * <p>Example of usage:<pre>
     *     float[] data = new float[10000];
     *     int len = 0;
     *     ... (filling some first elements, with incrementing len)
     *     float[] result = (float[])JArrays.copyOfRange(data, 0, len);
     *     // now result contains first len elements of data array</pre>
     *
     * <p>This method is an analog of <code>java.util.Arrays.copyOfRange</code> methods (Java 1.6),
     * but it works with any type of array (which is passed as <code>Object</code> argument)
     * and it is compatible with JRE 1.1.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>. (Its length is always
     * <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if the <code>array</code> argument is not a Java array
     *                                   or if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code>
     *                                   or <code>fromIndex &gt; array.length</code>.
     */
    public static Object copyOfRange(Object array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        int length = java.lang.reflect.Array.getLength(array);
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        Object result = java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), toIndex - fromIndex);
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, length) - fromIndex);
        return result;
    }

    /*Repeat() boolean ==> byte,,char,,short,,int,,long,,float,,double;;
               Boolean ==> Byte,,Char,,Short,,Int,,Long,,Float,,Double */

    /**
     * Equivalent to
     * <code>(boolean[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static boolean[] copyOfRange(boolean[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        boolean[] result = new boolean[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Equivalent to
     * <code>(byte[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static byte[] copyOfRange(byte[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        byte[] result = new byte[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }

    /**
     * Equivalent to
     * <code>(char[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static char[] copyOfRange(char[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        char[] result = new char[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }

    /**
     * Equivalent to
     * <code>(short[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static short[] copyOfRange(short[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        short[] result = new short[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }

    /**
     * Equivalent to
     * <code>(int[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static int[] copyOfRange(int[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        int[] result = new int[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }

    /**
     * Equivalent to
     * <code>(long[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static long[] copyOfRange(long[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        long[] result = new long[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }

    /**
     * Equivalent to
     * <code>(float[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static float[] copyOfRange(float[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        float[] result = new float[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }

    /**
     * Equivalent to
     * <code>(double[]){@link #copyOfRange(Object, int, int) copyOfRange}(array, fromIndex, toIndex)</code>.
     *
     * @param array     the source array.
     * @param fromIndex the initial index in <code>array</code>, inclusive.
     * @param toIndex   the end index in <code>array</code>, exclusive. (May lie outside the array.)
     * @return the specified subarray, padded by zeros to required length
     * if <code>toIndex &gt; array.length</code>.
     * (Its length is always <code>toIndex-fromIndex</code>.)
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if <code>fromIndex</code> is greater than <code>toIndex</code>.
     * @throws IndexOutOfBoundsException if <code>fromIndex&lt; 0</code> or <code>fromIndex &gt; array.length</code>.
     */
    public static double[] copyOfRange(double[] array, int fromIndex, int toIndex) {
        Objects.requireNonNull(array, "Null array argument in copyOfRange method");
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException("Illegal indexes: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (fromIndex < 0 || fromIndex > array.length) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        double[] result = new double[toIndex - fromIndex];
        System.arraycopy(array, fromIndex, result, 0, Math.min(toIndex, array.length) - fromIndex);
        return result;
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() char ==> short,,int,,long,,float,,double;;
               Char ==> Short,,Int,,Long,,Float,,Double;;
               2(\s*\*) ==> 2$1,,4$1,,8$1,,4$1,,8$1;;
               (\/\s*)2 ==> / 2,,/ 4,,/ 8,,/ 4,,/ 8
     */
    public static byte[] copyCharArrayToBytes(char[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyCharArrayToBytes(src, src.length, byteOrder);
    }

    public static byte[] copyCharArrayToBytes(char[] src, int count, ByteOrder byteOrder) {
        return copyCharArrayToBytes(null, src, count, byteOrder);
    }

    public static byte[] copyCharArrayToBytes(byte[] dest, char[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (count > src.length) {
            throw new IllegalArgumentException("Too short source array char[ " + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (2 * (long) count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Too large number of elements " + count +
                    ": it must be less than 2^31 / 2 = " + (Integer.MAX_VALUE / 2 + 1));
        }
        final int numberOfBytes = 2 * count;
        if (dest == null) {
            dest = new byte[numberOfBytes];
        } else if (numberOfBytes > dest.length) {
            throw new IllegalArgumentException("Too short destination array byte[" + dest.length +
                    "]: it must contain at least 2 * " + count + " = " + numberOfBytes + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(dest);
        bb.order(byteOrder);
        bb.asCharBuffer().put(src, 0, count);
        return dest;
    }

    public static char[] copyBytesToCharArray(byte[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyBytesToCharArray(src, src.length / 2, byteOrder);
    }

    public static char[] copyBytesToCharArray(byte[] src, int count, ByteOrder byteOrder) {
        return copyBytesToCharArray(null, src, count, byteOrder);
    }

    public static char[] copyBytesToCharArray(char[] dest, byte[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (2 * (long) count > src.length) {
            throw new IllegalArgumentException("Too short source array byte[" + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (dest == null) {
            dest = new char[count];
        } else if (count > dest.length) {
            throw new IllegalArgumentException("Too short destination array char[" + dest.length +
                    "]: it must contain at least " + count + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(src);
        bb.order(byteOrder);
        bb.asCharBuffer().get(dest, 0, count);
        return dest;
    }

    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */
    public static byte[] copyShortArrayToBytes(short[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyShortArrayToBytes(src, src.length, byteOrder);
    }

    public static byte[] copyShortArrayToBytes(short[] src, int count, ByteOrder byteOrder) {
        return copyShortArrayToBytes(null, src, count, byteOrder);
    }

    public static byte[] copyShortArrayToBytes(byte[] dest, short[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (count > src.length) {
            throw new IllegalArgumentException("Too short source array short[ " + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (2 * (long) count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Too large number of elements " + count +
                    ": it must be less than 2^31 / 2 = " + (Integer.MAX_VALUE / 2 + 1));
        }
        final int numberOfBytes = 2 * count;
        if (dest == null) {
            dest = new byte[numberOfBytes];
        } else if (numberOfBytes > dest.length) {
            throw new IllegalArgumentException("Too short destination array byte[" + dest.length +
                    "]: it must contain at least 2 * " + count + " = " + numberOfBytes + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(dest);
        bb.order(byteOrder);
        bb.asShortBuffer().put(src, 0, count);
        return dest;
    }

    public static short[] copyBytesToShortArray(byte[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyBytesToShortArray(src, src.length / 2, byteOrder);
    }

    public static short[] copyBytesToShortArray(byte[] src, int count, ByteOrder byteOrder) {
        return copyBytesToShortArray(null, src, count, byteOrder);
    }

    public static short[] copyBytesToShortArray(short[] dest, byte[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (2 * (long) count > src.length) {
            throw new IllegalArgumentException("Too short source array byte[" + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (dest == null) {
            dest = new short[count];
        } else if (count > dest.length) {
            throw new IllegalArgumentException("Too short destination array short[" + dest.length +
                    "]: it must contain at least " + count + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(src);
        bb.order(byteOrder);
        bb.asShortBuffer().get(dest, 0, count);
        return dest;
    }
    public static byte[] copyIntArrayToBytes(int[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyIntArrayToBytes(src, src.length, byteOrder);
    }

    public static byte[] copyIntArrayToBytes(int[] src, int count, ByteOrder byteOrder) {
        return copyIntArrayToBytes(null, src, count, byteOrder);
    }

    public static byte[] copyIntArrayToBytes(byte[] dest, int[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (count > src.length) {
            throw new IllegalArgumentException("Too short source array int[ " + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (4 * (long) count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Too large number of elements " + count +
                    ": it must be less than 2^31 / 4 = " + (Integer.MAX_VALUE / 4 + 1));
        }
        final int numberOfBytes = 4 * count;
        if (dest == null) {
            dest = new byte[numberOfBytes];
        } else if (numberOfBytes > dest.length) {
            throw new IllegalArgumentException("Too short destination array byte[" + dest.length +
                    "]: it must contain at least 4 * " + count + " = " + numberOfBytes + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(dest);
        bb.order(byteOrder);
        bb.asIntBuffer().put(src, 0, count);
        return dest;
    }

    public static int[] copyBytesToIntArray(byte[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyBytesToIntArray(src, src.length / 4, byteOrder);
    }

    public static int[] copyBytesToIntArray(byte[] src, int count, ByteOrder byteOrder) {
        return copyBytesToIntArray(null, src, count, byteOrder);
    }

    public static int[] copyBytesToIntArray(int[] dest, byte[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (4 * (long) count > src.length) {
            throw new IllegalArgumentException("Too short source array byte[" + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (dest == null) {
            dest = new int[count];
        } else if (count > dest.length) {
            throw new IllegalArgumentException("Too short destination array int[" + dest.length +
                    "]: it must contain at least " + count + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(src);
        bb.order(byteOrder);
        bb.asIntBuffer().get(dest, 0, count);
        return dest;
    }
    public static byte[] copyLongArrayToBytes(long[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyLongArrayToBytes(src, src.length, byteOrder);
    }

    public static byte[] copyLongArrayToBytes(long[] src, int count, ByteOrder byteOrder) {
        return copyLongArrayToBytes(null, src, count, byteOrder);
    }

    public static byte[] copyLongArrayToBytes(byte[] dest, long[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (count > src.length) {
            throw new IllegalArgumentException("Too short source array long[ " + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (8 * (long) count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Too large number of elements " + count +
                    ": it must be less than 2^31 / 8 = " + (Integer.MAX_VALUE / 8 + 1));
        }
        final int numberOfBytes = 8 * count;
        if (dest == null) {
            dest = new byte[numberOfBytes];
        } else if (numberOfBytes > dest.length) {
            throw new IllegalArgumentException("Too short destination array byte[" + dest.length +
                    "]: it must contain at least 8 * " + count + " = " + numberOfBytes + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(dest);
        bb.order(byteOrder);
        bb.asLongBuffer().put(src, 0, count);
        return dest;
    }

    public static long[] copyBytesToLongArray(byte[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyBytesToLongArray(src, src.length / 8, byteOrder);
    }

    public static long[] copyBytesToLongArray(byte[] src, int count, ByteOrder byteOrder) {
        return copyBytesToLongArray(null, src, count, byteOrder);
    }

    public static long[] copyBytesToLongArray(long[] dest, byte[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (8 * (long) count > src.length) {
            throw new IllegalArgumentException("Too short source array byte[" + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (dest == null) {
            dest = new long[count];
        } else if (count > dest.length) {
            throw new IllegalArgumentException("Too short destination array long[" + dest.length +
                    "]: it must contain at least " + count + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(src);
        bb.order(byteOrder);
        bb.asLongBuffer().get(dest, 0, count);
        return dest;
    }
    public static byte[] copyFloatArrayToBytes(float[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyFloatArrayToBytes(src, src.length, byteOrder);
    }

    public static byte[] copyFloatArrayToBytes(float[] src, int count, ByteOrder byteOrder) {
        return copyFloatArrayToBytes(null, src, count, byteOrder);
    }

    public static byte[] copyFloatArrayToBytes(byte[] dest, float[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (count > src.length) {
            throw new IllegalArgumentException("Too short source array float[ " + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (4 * (long) count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Too large number of elements " + count +
                    ": it must be less than 2^31 / 4 = " + (Integer.MAX_VALUE / 4 + 1));
        }
        final int numberOfBytes = 4 * count;
        if (dest == null) {
            dest = new byte[numberOfBytes];
        } else if (numberOfBytes > dest.length) {
            throw new IllegalArgumentException("Too short destination array byte[" + dest.length +
                    "]: it must contain at least 4 * " + count + " = " + numberOfBytes + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(dest);
        bb.order(byteOrder);
        bb.asFloatBuffer().put(src, 0, count);
        return dest;
    }

    public static float[] copyBytesToFloatArray(byte[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyBytesToFloatArray(src, src.length / 4, byteOrder);
    }

    public static float[] copyBytesToFloatArray(byte[] src, int count, ByteOrder byteOrder) {
        return copyBytesToFloatArray(null, src, count, byteOrder);
    }

    public static float[] copyBytesToFloatArray(float[] dest, byte[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (4 * (long) count > src.length) {
            throw new IllegalArgumentException("Too short source array byte[" + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (dest == null) {
            dest = new float[count];
        } else if (count > dest.length) {
            throw new IllegalArgumentException("Too short destination array float[" + dest.length +
                    "]: it must contain at least " + count + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(src);
        bb.order(byteOrder);
        bb.asFloatBuffer().get(dest, 0, count);
        return dest;
    }
    public static byte[] copyDoubleArrayToBytes(double[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyDoubleArrayToBytes(src, src.length, byteOrder);
    }

    public static byte[] copyDoubleArrayToBytes(double[] src, int count, ByteOrder byteOrder) {
        return copyDoubleArrayToBytes(null, src, count, byteOrder);
    }

    public static byte[] copyDoubleArrayToBytes(byte[] dest, double[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (count > src.length) {
            throw new IllegalArgumentException("Too short source array double[ " + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (8 * (long) count > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Too large number of elements " + count +
                    ": it must be less than 2^31 / 8 = " + (Integer.MAX_VALUE / 8 + 1));
        }
        final int numberOfBytes = 8 * count;
        if (dest == null) {
            dest = new byte[numberOfBytes];
        } else if (numberOfBytes > dest.length) {
            throw new IllegalArgumentException("Too short destination array byte[" + dest.length +
                    "]: it must contain at least 8 * " + count + " = " + numberOfBytes + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(dest);
        bb.order(byteOrder);
        bb.asDoubleBuffer().put(src, 0, count);
        return dest;
    }

    public static double[] copyBytesToDoubleArray(byte[] src, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        return copyBytesToDoubleArray(src, src.length / 8, byteOrder);
    }

    public static double[] copyBytesToDoubleArray(byte[] src, int count, ByteOrder byteOrder) {
        return copyBytesToDoubleArray(null, src, count, byteOrder);
    }

    public static double[] copyBytesToDoubleArray(double[] dest, byte[] src, int count, ByteOrder byteOrder) {
        Objects.requireNonNull(src, "Null src argument");
        Objects.requireNonNull(byteOrder, "Null byteOrder");
        if (count < 0) {
            throw new IllegalArgumentException("Negative count = " + count);
        }
        if (8 * (long) count > src.length) {
            throw new IllegalArgumentException("Too short source array byte[" + src.length +
                    "]: it must contain at least " + count + " elements");
        }
        if (dest == null) {
            dest = new double[count];
        } else if (count > dest.length) {
            throw new IllegalArgumentException("Too short destination array double[" + dest.length +
                    "]: it must contain at least " + count + " elements");
        }
        final ByteBuffer bb = ByteBuffer.wrap(src);
        bb.order(byteOrder);
        bb.asDoubleBuffer().get(dest, 0, count);
        return dest;
    }

    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() boolean ==> byte,,char,,short,,int,,long,,float,,double,,Object;;
               Boolean ==> Byte,,Char,,Short,,Int,,Long,,Float,,Double,,Object
     */

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillBooleanArray(boolean[] dest, boolean value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillBooleanArray(boolean[] dest, int destPos, int count, boolean value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillByteArray(byte[] dest, byte value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillByteArray(byte[] dest, int destPos, int count, byte value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillCharArray(char[] dest, char value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillCharArray(char[] dest, int destPos, int count, char value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillShortArray(short[] dest, short value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillShortArray(short[] dest, int destPos, int count, short value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillIntArray(int[] dest, int value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillIntArray(int[] dest, int destPos, int count, int value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillLongArray(long[] dest, long value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillLongArray(long[] dest, int destPos, int count, long value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillFloatArray(float[] dest, float value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillFloatArray(float[] dest, int destPos, int count, float value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillDoubleArray(double[] dest, double value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillDoubleArray(double[] dest, int destPos, int count, double value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the specified value.
     *
     * @param dest  the filled Java array.
     * @param value the filler.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void fillObjectArray(Object[] dest, Object value) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = value;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array, starting
     * from the element <code>#destPos</code>,
     * by the specified value. <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @param value   the filler.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillObjectArray(Object[] dest, int destPos, int count, Object value) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = value;
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * by the following values: <code>start</code>, <code>start+increment</code>, <code>start+2*increment</code>, etc.
     * Equivalent to the following loop:
     * <pre>
     *     for (int i = destPos, toIndex = destPos + count; i &lt; toIndex; i++) {
     *         dest[i] = start;
     *         start += increment;
     *     }
     * </pre>
     * but checks possible <code>IndexOutOfBoundsException</code> <i>before</i> any operations.
     *
     * @param dest      the filled Java array.
     * @param destPos   starting index of element to replace.
     * @param count     the number of elements to be filled (should be &gt;=0).
     * @param start     starting value of the progression.
     * @param increment step of the progression.
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     */
    public static void fillIntProgression(int[] dest, int destPos, int count, int start, int increment) {
        rangeCheck(dest.length, destPos, count);
        for (int i = destPos, toIndex = destPos + count; i < toIndex; i++) {
            dest[i] = start;
            start += increment;
        }
    }

    /**
     * Fills all elements in the <code>dest</code> array by the following values:
     * <code>start</code>, <code>start+increment</code>, <code>start+2*increment</code>, etc.
     * Equivalent to the following loop:
     * <pre>
     *     for (int i = 0; i &lt; dest.length; i++) {
     *         dest[i] = start;
     *         start += increment;
     *     }
     * </pre>
     * but checks possible <code>IndexOutOfBoundsException</code> <i>before</i> any operations.
     *
     * @param dest      the filled Java array.
     * @param start     starting value of the progression.
     * @param increment step of the progression.
     */
    public static void fillIntProgression(int[] dest, int start, int increment) {
        for (int i = 0, len = dest.length; i < len; i++) {
            dest[i] = start;
            start += increment;
        }
    }

    /**
     * Fills <code>count</code> elements in the <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * by zeroes ({@code null} for <code>Object[]</code> arrays, <code>false</code> for <code>boolean[]</code>,
     * <code>+0.0</code> for floating-point types).
     * <i>Be careful:</i> the second <code>int</code> argument in this method
     * is the number of filled element, but not the end filled index
     * as in <code>java.util.Arrays.fill</code> methods.
     *
     * @param dest    the filled Java array.
     * @param destPos starting index of element to replace.
     * @param count   the number of elements to be filled (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if the <code>dest</code> argument is not a Java array,
     *                                   or if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if filling would cause access of data outside the array.
     * @see #areElementsZero(Object, int, int)
     */
    public static void zeroFillArray(Object dest, int destPos, int count) {
        Objects.requireNonNull(dest, "Null dest argument");
        if (dest instanceof boolean[]) {
            fillBooleanArray((boolean[]) dest, destPos, count, false);
        } else if (dest instanceof char[]) {
            fillCharArray((char[]) dest, destPos, count, (char) 0);
        } else if (dest instanceof byte[]) {
            fillByteArray((byte[]) dest, destPos, count, (byte) 0);
        } else if (dest instanceof short[]) {
            fillShortArray((short[]) dest, destPos, count, (short) 0);
        } else if (dest instanceof int[]) {
            fillIntArray((int[]) dest, destPos, count, 0);
        } else if (dest instanceof long[]) {
            fillLongArray((long[]) dest, destPos, count, 0L);
        } else if (dest instanceof float[]) {
            fillFloatArray((float[]) dest, destPos, count, 0.0f);
        } else if (dest instanceof double[]) {
            fillDoubleArray((double[]) dest, destPos, count, 0.0);
        } else if (dest instanceof Object[]) {
            fillObjectArray((Object[]) dest, destPos, count, null);
        } else {
            throw new IllegalArgumentException("The passed argument is not a Java array (" + dest.getClass() + ")");
        }
    }

    /**
     * Returns <code>true</code> if the specified fragment of the passed Java array is filled by zero
     * (<code>false</code> for <code>boolean[]</code> array, <code>(char)0</code> for <code>char[]</code>,
     * {@code null} for non-primitive element type).
     * Returns <code>false</code> if at least one of elements <code>array[pos]..array[pos+count-1]</code> is non-zero.
     *
     * <p>For arrays of floating-point types, unlike {@link #arrayEquals(Object, int, Object, int, int)},
     * this method considers that <code>+0.0==-0.0</code>: both values are considered to be zero.
     *
     * <p>If the <code>count</code> argument (number of elements) is 0, this method returns <code>true</code>.
     *
     * @param array the checked Java array.
     * @param pos   the initial index of the checked fragment in the array.
     * @param count the number of checked elements.
     * @return <code>true</code> if and only if all elements <code>array[pos]..array[pos+count-1]</code> are zero
     * or if <code>count==0</code>.
     * @throws NullPointerException      if the <code>array</code> argument is {@code null}.
     * @throws IllegalArgumentException  if the <code>dest</code> argument is not a Java array,
     *                                   or if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if <code>pos</code> is negative,
     *                                   or if <code>pos+count</code> is greater than <code>array.length</code>.
     * @see #zeroFillArray(Object, int, int)
     */
    public static boolean areElementsZero(Object array, int pos, int count) {
        Objects.requireNonNull(array, "Null array argument");
        int arrayLen = java.lang.reflect.Array.getLength(array);
        rangeCheck(arrayLen, pos, count);
        if (array instanceof boolean[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos]) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof char[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof byte[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof short[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof int[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof long[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof float[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof double[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != 0) {
                    return false;
                }
            }
            return true;
        } else if (array instanceof Object[] a) {
            for (int posMax = pos + count; pos < posMax; pos++) {
                if (a[pos] != null) {
                    return false;
                }
            }
            return true;
        } else {
            throw new InternalError("Internal error: this check should never occur");
        }
    }

    /**
     * Returns a hash code based on the contents of the specified fragment of the given array.
     * If the passed array is {@code null} or <code>fromIndex==toIndex</code>, returns 0.
     *
     * <p>If the array is <code>Object[]</code>,
     * the result is based on standard <code>hashCode</code> method for all elements of the array.
     * In particular, in this case, if the array contains other arrays as elements,
     * the hash code is based on their identities rather than their contents.
     *
     * <p>The returned hash code depends only on the sequence of elements, but does not depend
     * on the position of this sequence in the specified Java array.
     *
     * <p>For any two arrays <code>a1</code> and <code>a2</code> such that
     * <code>JArrays.arrayEquals(a1, pos1, a2, pos2, count)</code>, it is also the case that
     * <code>JArrays.arrayHashCode(a1, pos1, pos1 + count) == JArrays.arrayHashCode(a2, pos2, pos2 + count)</code>.
     *
     * <p>This method is an extended analog of <code>java.util.Arrays.hashCode</code> methods,
     * compatible with JRE 1.1 and using more safe algorithm, based on
     * {@link java.util.zip.CRC32}.</p>
     *
     * @param array     the array whose content-based hash code to compute.
     * @param fromIndex the initial index of the checked fragment, inclusive.
     * @param toIndex   the end index of the checked fragment, exclusive.
     * @return a content-based hash code for the specified fragment in <code>array</code>.
     * @throws IllegalArgumentException  if the <code>array</code> argument is not a Java array.
     * @throws IndexOutOfBoundsException if <code>fromIndex</code> or <code>toIndex</code> are negative,
     *                                   or if <code>toIndex</code> is greater than <code>array.length</code>
     *                                   (0 when <code>array==null</code>),
     *                                   or if <code>fromIndex</code> is greater than <code>startIndex</code>,
     *                                   or if <code>array==null</code> and not <code>fromIndex==toIndex==0</code>.
     * @see #arrayEquals(Object, int, Object, int, int)
     * @see #updateArrayHashCode(Object, int, int, Checksum)
     */
    public static int arrayHashCode(Object array, int fromIndex, int toIndex) {
        Checksum sum = new CRC32();
        updateArrayHashCode(array, fromIndex, toIndex, sum);
        return fromIndex == toIndex ? 0 : (int) sum.getValue();
    }

    /**
     * Updates hash code (<code>hash</code> argument) on the base of the contents
     * of the specified fragment of the given array.
     * If the passed array is {@code null} or <code>fromIndex==toIndex</code>, does nothing.
     *
     * <p>This method is used by {@link #arrayHashCode(Object, int, int)
     * arrayHashCode(Object array, int fromIndex, int toIndex)}.
     * More precisely, that method is equivalent to:<pre>
     * Checksum sum = new CRC32();
     * updateArrayHashCode(array, fromIndex, toIndex, sum);
     * return fromIndex == toIndex ? 0 : (int)sum.getValue();
     * </pre>
     *
     * <p>The following 2 code fragment always produce the same results in <code>hash</code>argument:<pre>
     * updateArrayHashCode(arr, fromIndex, toIndex, hash);
     * </pre>and<pre>
     * updateArrayHashCode(arr, fromIndex, k1, hash);
     * updateArrayHashCode(arr, k1, k2, hash);
     * ...
     * updateArrayHashCode(arr, kN, toIndex, hash);
     * </pre>
     * where <code>fromIndex &lt;= k1 &lt;= k2 &lt;= ... &lt;= kN &lt;= toIndex</code>.
     * So, unlike <code>arrayHashCode</code>, this method allows to calculate correct hash code
     * of a long array when we cannot get all its element at the same time,
     * but can get sequent portions ot it.
     *
     * @param array     the array whose content-based hash code to compute.
     * @param fromIndex the initial index of the checked fragment, inclusive.
     * @param toIndex   the end index of the checked fragment, exclusive.
     * @param hash      updated hash code.
     * @throws NullPointerException      if the <code>hash</code> argument is {@code null}.
     * @throws IllegalArgumentException  if the <code>array</code> argument is not a Java array.
     * @throws IndexOutOfBoundsException if <code>fromIndex</code> or <code>toIndex</code> are negative,
     *                                   or if <code>toIndex</code> is greater than <code>array.length</code>
     *                                   (0 when <code>array==null</code>),
     *                                   or if <code>fromIndex</code> is greater than <code>startIndex</code>,
     *                                   or if <code>array==null</code> and not <code>fromIndex==toIndex==0</code>.
     */
    public static void updateArrayHashCode(Object array, int fromIndex, int toIndex, Checksum hash) {
        Objects.requireNonNull(hash, "Null previousHash argument");
        if (fromIndex < 0) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        if (fromIndex > toIndex) {
            throw new ArrayIndexOutOfBoundsException("Array index out of range: initial index = " + fromIndex
                    + " > end index = " + toIndex);
        }
        if (array == null) {
            if (toIndex > 0) {
                throw new ArrayIndexOutOfBoundsException(toIndex);
            }
        }
        if (fromIndex == toIndex) // in particular, if array == null
        {
            return;
        }
        int countEven = (toIndex - fromIndex) & -HASH_BLOCK_LEN;
        if (array instanceof byte[] a) {
            if (toIndex > a.length) {
                throw new ArrayIndexOutOfBoundsException(toIndex);
            }
            hash.update(a, fromIndex, toIndex - fromIndex);
        } else
            //<<Repeat() boolean ==> char,,short,,int,,long,,float,,double,,Object;;
            //           (ELEM_SIZE\s*=)\s*1 ==> $1 2,,$1 2,,$1 4,,$1 8,,$1 4,,$1 8,,$1 4 >>
            if (array instanceof boolean[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 1;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else//<<Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! >>
            if (array instanceof char[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 2;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else
            if (array instanceof short[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 2;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else
            if (array instanceof int[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 4;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else
            if (array instanceof long[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 8;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else
            if (array instanceof float[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 4;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else
            if (array instanceof double[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 8;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else
            if (array instanceof Object[] a) {
                if (toIndex > a.length) {
                    throw new ArrayIndexOutOfBoundsException(toIndex);
                }
                final int ELEM_SIZE = 4;
                byte[] bytes = new byte[ELEM_SIZE * HASH_BLOCK_LEN];
                int kMax = fromIndex + countEven;
                for (int k = fromIndex; k < kMax; k += HASH_BLOCK_LEN) {
                    getBytes(a, k, HASH_BLOCK_LEN, bytes);
                    hash.update(bytes, 0, ELEM_SIZE * HASH_BLOCK_LEN);
                }
                getBytes(a, kMax, toIndex - kMax, bytes);
                hash.update(bytes, 0, ELEM_SIZE * (toIndex - kMax));
            } else//<<Repeat.AutoGeneratedEnd>>
                {
                    throw new IllegalArgumentException("The passed argument is not a Java array (" + array.getClass() + ")");
                }
    }

    /**
     * Returns <code>true</code> if the arguments are Java arrays
     * and their specified fragments are equals,
     * or if both arguments are {@code null}.
     * Returns <code>false</code> if one of the arguments is {@code null}, but the other is not {@code null}.
     *
     * <p>The two fragments of the passed arrays are considered equal
     * if all corresponding pairs of elements are equal.
     * For arrays of primitive types (<code>byte[]</code>, <code>short</code>, etc.),
     * the fragments are considered equal only if the types of their elements are identical.
     * For arrays of floating-point types, unlike the <code>==</code> operator, this method considers
     * <code>NaN</code> equals to itself, and 0.0 unequal to -0.0.
     * For <code>Object[]</code> arrays, two objects <code>e1</code> and <code>e2</code> are considered
     * <i>equal</i> if <code>(e1==null ? e2==null : e1.equals(e2))</code>.
     *
     * <p>This method is an extended analog of <code>java.util.Arrays.equals</code> methods,
     * compatible with JRE 1.1.
     *
     * @param array1 one array to be tested for equality.
     * @param pos1   the initial index of the checked fragment in the first array.
     * @param array2 the other array to be tested for equality.
     * @param pos2   the initial index of the checked fragment in the second array.
     * @param length the number of compared elements.
     * @return <code>true</code> if the specified fragments of two arrays are equal.
     * @throws IllegalArgumentException  if the <code>array1</code> or <code>array2</code> argument is not a Java array
     *                                   or if <code>length</code> is negative.
     * @throws IndexOutOfBoundsException if <code>pos1</code>, <code>pos2</code> or <code>length</code> are negative,
     *                                   or if <code>pos1+length</code> is greater than <code>array1.length</code>
     *                                   (0 when <code>array1==null</code>),
     *                                   or if <code>pos2+length</code> is greater than <code>array2.length</code>
     *                                   (0 when <code>array2==null</code>).
     */
    public static boolean arrayEquals(Object array1, int pos1, Object array2, int pos2, int length) {
        int length1 = array1 == null ? 0 : java.lang.reflect.Array.getLength(array1);
        int length2 = array2 == null ? 0 : java.lang.reflect.Array.getLength(array2);
        if (length < 0) {
            throw new IllegalArgumentException("Negative number of compared elements: length = " + length);
        }
        if (pos1 < 0) {
            throw new ArrayIndexOutOfBoundsException(pos1);
        }
        if (pos2 < 0) {
            throw new ArrayIndexOutOfBoundsException(pos2);
        }
        if (pos1 + length > length1) {
            throw new ArrayIndexOutOfBoundsException(pos1 + length);
        }
        if (pos2 + length > length2) {
            throw new ArrayIndexOutOfBoundsException(pos2 + length);
        }
        if (array1 == array2) {
            return array1 == null || pos1 == pos2;
        }
        if (array1 == null || array2 == null) {
            return false;
        }
        if (array1 instanceof boolean[] a1) {
            if (!(array2 instanceof boolean[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (a1[pos1] != a2[pos2]) {
                    return false;
                }
            }
        } else if (array1 instanceof char[] a1) {
            if (!(array2 instanceof char[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (a1[pos1] != a2[pos2]) {
                    return false;
                }
            }
        } else if (array1 instanceof byte[] a1) {
            if (!(array2 instanceof byte[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (a1[pos1] != a2[pos2]) {
                    return false;
                }
            }
        } else if (array1 instanceof short[] a1) {
            if (!(array2 instanceof short[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (a1[pos1] != a2[pos2]) {
                    return false;
                }
            }
        } else if (array1 instanceof int[] a1) {
            if (!(array2 instanceof int[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (a1[pos1] != a2[pos2]) {
                    return false;
                }
            }
        } else if (array1 instanceof long[] a1) {
            if (!(array2 instanceof long[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (a1[pos1] != a2[pos2]) {
                    return false;
                }
            }
        } else if (array1 instanceof float[] a1) {
            if (!(array2 instanceof float[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (Float.floatToIntBits(a1[pos1]) != Float.floatToIntBits(a2[pos2])) {
                    return false;
                }
            }
        } else if (array1 instanceof double[] a1) {
            if (!(array2 instanceof double[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (Double.doubleToLongBits(a1[pos1]) != Double.doubleToLongBits(a2[pos2])) {
                    return false;
                }
            }
        } else if (array1 instanceof Object[] a1) {
            if (!(array2 instanceof Object[] a2)) {
                return false;
            }
            for (int pos1Max = pos1 + length; pos1 < pos1Max; pos1++, pos2++) {
                if (!(Objects.equals(a1[pos1], a2[pos2]))) {
                    return false;
                }
            }
        } else {
            throw new InternalError("Internal error: this check should never occur");
        }
        return true;
    }

    /*Repeat() boolean ==> byte,,char,,short,,int,,long,,float,,double;;
               Boolean ==> Byte,,Char,,Short,,Int,,Long,,Float,,Double
     */

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfBoolean(boolean[], int, int, boolean)
     */
    public static int indexOfBoolean(boolean[] array, int lowIndex, int highIndex, boolean value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfBoolean(boolean[], int, int, boolean)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfBoolean(boolean[], int, int, boolean)
     */
    public static int lastIndexOfBoolean(boolean[] array, int lowIndex, int highIndex, boolean value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfByte(byte[], int, int, byte)
     */
    public static int indexOfByte(byte[] array, int lowIndex, int highIndex, byte value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfByte(byte[], int, int, byte)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfByte(byte[], int, int, byte)
     */
    public static int lastIndexOfByte(byte[] array, int lowIndex, int highIndex, byte value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfChar(char[], int, int, char)
     */
    public static int indexOfChar(char[] array, int lowIndex, int highIndex, char value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfChar(char[], int, int, char)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfChar(char[], int, int, char)
     */
    public static int lastIndexOfChar(char[] array, int lowIndex, int highIndex, char value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfShort(short[], int, int, short)
     */
    public static int indexOfShort(short[] array, int lowIndex, int highIndex, short value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfShort(short[], int, int, short)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfShort(short[], int, int, short)
     */
    public static int lastIndexOfShort(short[] array, int lowIndex, int highIndex, short value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfInt(int[], int, int, int)
     */
    public static int indexOfInt(int[] array, int lowIndex, int highIndex, int value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfInt(int[], int, int, int)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfInt(int[], int, int, int)
     */
    public static int lastIndexOfInt(int[] array, int lowIndex, int highIndex, int value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfLong(long[], int, int, long)
     */
    public static int indexOfLong(long[] array, int lowIndex, int highIndex, long value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfLong(long[], int, int, long)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfLong(long[], int, int, long)
     */
    public static int lastIndexOfLong(long[] array, int lowIndex, int highIndex, long value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfFloat(float[], int, int, float)
     */
    public static int indexOfFloat(float[] array, int lowIndex, int highIndex, float value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfFloat(float[], int, int, float)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfFloat(float[], int, int, float)
     */
    public static int lastIndexOfFloat(float[] array, int lowIndex, int highIndex, float value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfDouble(double[], int, int, double)
     */
    public static int indexOfDouble(double[] array, int lowIndex, int highIndex, double value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        for (; lowIndex < maxPlus1; lowIndex++) {
            if (array[lowIndex] == value) {
                return lowIndex;
            }
        }
        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>array[k]==value</code>, or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfDouble(double[], int, int, double)} method:
     * they describe the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfDouble(double[], int, int, double)
     */
    public static int lastIndexOfDouble(double[] array, int lowIndex, int highIndex, double value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        while (highIndex > min) {
            if (array[--highIndex] == value) {
                return highIndex;
            }
        }
        return -1;
    }
    /*Repeat.AutoGeneratedEnd*/

    /**
     * Returns the minimal index <code>k</code>, so that <code>lowIndex&lt;=k&lt;min(highIndex,array.length)</code>
     * and <code>value==null?array[k]==null:value.equals(array[k])</code>,
     * or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>lowIndex&gt;=array.length</code> or <code>lowIndex&gt;=highIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>lowIndex&lt;0</code>, the result is the same as if <code>lowIndex==0</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive);
     *                  pass <code>array.length</code> to search all remaining elements.
     * @param value     the value to be found.
     * @return the index of the first occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #lastIndexOfObject(Object[], int, int, Object)
     */
    public static int indexOfObject(Object[] array, int lowIndex, int highIndex, Object value) {
        if (lowIndex < 0) {
            lowIndex = 0;
        }
        int maxPlus1 = Math.min(array.length, highIndex);
        if (value == null) {
            for (; lowIndex < maxPlus1; lowIndex++) {
                if (array[lowIndex] == null) {
                    return lowIndex;
                }
            }
        } else {
            for (; lowIndex < maxPlus1; lowIndex++) {
                if (value.equals(array[lowIndex])) {
                    return lowIndex;
                }
            }
        }

        return -1;
    }

    /**
     * Returns the maximal index <code>k</code>, so that <code>highIndex&gt;k&gt;=max(lowIndex,0)</code>
     * and <code>value==null?array[k]==null:value.equals(array[k])</code>,
     * or <code>-1</code> if there is no such array element.
     *
     * <p>In particular, if <code>highIndex&lt;=0</code> or <code>highIndex&lt;=lowIndex</code>,
     * this method returns <code>-1</code>,
     * and if <code>highIndex&gt;=array.length</code>, the result is the same
     * as if <code>highIndex==array.length</code>.
     *
     * <p>Note that <code>lowIndex</code> and <code>highIndex</code> arguments have the same sense as in
     * {@link #indexOfObject(Object[], int, int, Object)} method:
     * they describes the search index range <code>lowIndex&lt;=k&lt;highIndex</code>.
     *
     * @param array     the searched Java array.
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <code>0</code> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value to be found.
     * @return the index of the last occurrence of this value in range <code>lowIndex..highIndex-1</code>,
     * or <code>-1</code> if this value does not occur
     * or if <code>max(lowIndex,0)&gt;=min(highIndex,array.length)</code>.
     * @throws NullPointerException if <code>array</code> is {@code null}.
     * @see #indexOfObject(Object[], int, int, Object)
     */
    public static int lastIndexOfObject(Object[] array, int lowIndex, int highIndex, Object value) {
        if (highIndex > array.length) {
            highIndex = array.length;
        }
        int min = Math.max(lowIndex, 0);
        if (value == null) {
            while (highIndex > min) {
                if (array[--highIndex] == null) {
                    return highIndex;
                }
            }
        } else {
            while (highIndex > min) {
                if (value.equals(array[--highIndex])) {
                    return highIndex;
                }
            }
        }
        return -1;
    }


    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     * The byte elements are considered to be unsigned: <code>min(a,b)=(a&amp;0xFF)&lt;(b&amp;0xFF)?a:b</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minByteArray(byte[] dest, int destPos, byte[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (OPTIMIZE_BYTE_MIN_MAX_BY_TABLES) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] = MinMaxTables.MIN_TABLE[
                        ((src[srcPos] & 0xFF) << 8) | (dest[destPos] & 0xFF)];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                final int a = src[srcPos] & 0xFF;
                final int b = dest[destPos] & 0xFF;
                dest[destPos] = (byte) Math.min(a, b);
            }
        }
    }

    /**
     * Replaces <code>count</code> bytes in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> bytes in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     * The byte elements are considered to be unsigned: <code>max(a,b)=(a&amp;0xFF)&gt;(b&amp;0xFF)?a:b</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxByteArray(byte[] dest, int destPos, byte[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (OPTIMIZE_BYTE_MIN_MAX_BY_TABLES) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] = MinMaxTables.MAX_TABLE[
                        ((src[srcPos] & 0xFF) << 8) | (dest[destPos] & 0xFF)];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                final int a = src[srcPos] & 0xFF;
                final int b = dest[destPos] & 0xFF;
                dest[destPos] = (byte) Math.max(a, b);
            }
        }
    }

    /*Repeat() short ==> char,,int,,long,,float,,double;;
               Short ==> Char,,Int,,Long,,Float,,Double;;
               (\s*&(?:amp;)?\s*0xFFFF) ==> ,,...;;
               int\s(a|b) ==> int $1,,int $1,,long $1,,float $1,,double $1;;
               \((?:int|long|float|double)\)\sM ==> M,,...;;
               (The\s+\w+\s+elements.*?<\/code>\.\s*\*) ==> ,,... */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     * The short elements are considered to be unsigned: <code>min(a,b)=(a&amp;0xFFFF)&lt;(b&amp;0xFFFF)?a:b</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minShortArray(short[] dest, int destPos, short[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final int a = src[srcPos] & 0xFFFF;
            final int b = dest[destPos] & 0xFFFF;
            dest[destPos] = (short) Math.min(a, b);
        }
    }

    /**
     * Replaces <code>count</code> shorts in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> shorts in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     * The short elements are considered to be unsigned: <code>max(a,b)=(a&amp;0xFFFF)&gt;(b&amp;0xFFFF)?a:b</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxShortArray(short[] dest, int destPos, short[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final int a = src[srcPos] & 0xFFFF;
            final int b = dest[destPos] & 0xFFFF;
            dest[destPos] = (short) Math.max(a, b);
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minCharArray(char[] dest, int destPos, char[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final int a = src[srcPos];
            final int b = dest[destPos];
            dest[destPos] = (char) Math.min(a, b);
        }
    }

    /**
     * Replaces <code>count</code> chars in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> chars in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxCharArray(char[] dest, int destPos, char[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final int a = src[srcPos];
            final int b = dest[destPos];
            dest[destPos] = (char) Math.max(a, b);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minIntArray(int[] dest, int destPos, int[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final int a = src[srcPos];
            final int b = dest[destPos];
            dest[destPos] = Math.min(a, b);
        }
    }

    /**
     * Replaces <code>count</code> ints in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> ints in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxIntArray(int[] dest, int destPos, int[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final int a = src[srcPos];
            final int b = dest[destPos];
            dest[destPos] = Math.max(a, b);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minLongArray(long[] dest, int destPos, long[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final long a = src[srcPos];
            final long b = dest[destPos];
            dest[destPos] = Math.min(a, b);
        }
    }

    /**
     * Replaces <code>count</code> longs in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> longs in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxLongArray(long[] dest, int destPos, long[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final long a = src[srcPos];
            final long b = dest[destPos];
            dest[destPos] = Math.max(a, b);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minFloatArray(float[] dest, int destPos, float[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final float a = src[srcPos];
            final float b = dest[destPos];
            dest[destPos] = Math.min(a, b);
        }
    }

    /**
     * Replaces <code>count</code> floats in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> floats in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxFloatArray(float[] dest, int destPos, float[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final float a = src[srcPos];
            final float b = dest[destPos];
            dest[destPos] = Math.max(a, b);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the minimum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void minDoubleArray(double[] dest, int destPos, double[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final double a = src[srcPos];
            final double b = dest[destPos];
            dest[destPos] = Math.min(a, b);
        }
    }

    /**
     * Replaces <code>count</code> doubles in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the maximum of them and corresponding <code>count</code> doubles in <code>src</code> array,
     * starting from the element <code>#destPos</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void maxDoubleArray(double[] dest, int destPos, double[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            final double a = src[srcPos];
            final double b = dest[destPos];
            dest[destPos] = Math.max(a, b);
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() byte ==> char,,short,,int,,long,,float,,double;;
               Byte ==> Char,,Short,,Int,,Long,,Float,,Double;;
               (\s*&(?:amp;)?\s*0xFF) ==> ,,$1FF,, ,,...;;
               (The\s+\w+\s+elements.*?\.\s*\*) ==> ,,$1,, ,,... */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i]&amp;0xFF)</code>.
     * The byte elements are considered to be unsigned.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addByteArray(int[] dest, int destPos, byte[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos] & 0xFF;
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i]&amp;0xFF)*mult</code>.
     * The byte elements are considered to be unsigned.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addByteArray(double[] dest, int destPos, byte[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos] & 0xFF;
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos] & 0xFF;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos] & 0xFF) * mult;
            }
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addCharArray(int[] dest, int destPos, char[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])*mult</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addCharArray(double[] dest, int destPos, char[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos];
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos]) * mult;
            }
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i]&amp;0xFFFF)</code>.
     * The short elements are considered to be unsigned.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addShortArray(int[] dest, int destPos, short[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos] & 0xFFFF;
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i]&amp;0xFFFF)*mult</code>.
     * The short elements are considered to be unsigned.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addShortArray(double[] dest, int destPos, short[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos] & 0xFFFF;
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos] & 0xFFFF;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos] & 0xFFFF) * mult;
            }
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addIntArray(int[] dest, int destPos, int[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])*mult</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addIntArray(double[] dest, int destPos, int[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos];
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos]) * mult;
            }
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addLongArray(int[] dest, int destPos, long[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])*mult</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addLongArray(double[] dest, int destPos, long[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos];
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos]) * mult;
            }
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addFloatArray(int[] dest, int destPos, float[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])*mult</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addFloatArray(double[] dest, int destPos, float[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos];
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos]) * mult;
            }
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addDoubleArray(int[] dest, int destPos, double[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] += src[srcPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the sum of them and corresponding <code>count</code> elements in <code>src</code> array,
     * multiplied by <code>mult</code> argument,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]+=(src[srcPos+i])*mult</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @param mult    the elements from <code>src</code> array are multiplied by this value before adding.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void addDoubleArray(double[] dest, int destPos, double[] src, int srcPos, int count, double mult) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (mult == 0.0) {
            return;
        }
        if (mult == 1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += src[srcPos];
            }
        } else if (mult == -1.0) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] += (src[srcPos]) * mult;
            }
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() (int\s*v\s*=) ==> $1,,$1;;
               (\(int\))(dest|src) ==> $1$2,,$1$2;;
               byte ==> char,,short;;
               Byte ==> Char,,Short;;
               BYTE ==> CHAR,,SHORT;;
               (\s*&(?:amp;)?\s*0xFF) ==> ,,$1FF;;
               (0\.\.0xFF) ==> $1FF,,$1FF;;
               (The\s+\w+\s+elements.*?\.\s*\*) ==> ,,$1 */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     * If <code>truncateOverflows</code> argument is <code>true</code>, the difference is truncated
     * to <code>0..0xFF</code> range before assigning to <code>dest</code> elements.
     * The byte elements are considered to be unsigned.
     *
     * @param dest              the destination array.
     * @param destPos           position of the first replaced element in the destination array.
     * @param src               the source array.
     * @param srcPos            position of the first read element in the source array.
     * @param count             the number of elements to be replaced (should be &gt;=0).
     * @param truncateOverflows whether the results should be truncated to <code>0..0xFF</code> range.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractByteArray(
            byte[] dest, int destPos, byte[] src, int srcPos, int count,
            boolean truncateOverflows) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (truncateOverflows) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                int v = ((int) dest[destPos] & 0xFF) - ((int) src[srcPos] & 0xFF);
                dest[destPos] = v < 0 ? 0 : (byte) v;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     * If <code>truncateOverflows</code> argument is <code>true</code>, the difference is truncated
     * to <code>0..0xFFFF</code> range before assigning to <code>dest</code> elements.
     *
     * @param dest              the destination array.
     * @param destPos           position of the first replaced element in the destination array.
     * @param src               the source array.
     * @param srcPos            position of the first read element in the source array.
     * @param count             the number of elements to be replaced (should be &gt;=0).
     * @param truncateOverflows whether the results should be truncated to <code>0..0xFFFF</code> range.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractCharArray(
            char[] dest, int destPos, char[] src, int srcPos, int count,
            boolean truncateOverflows) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (truncateOverflows) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                int v = ((int) dest[destPos]) - ((int) src[srcPos]);
                dest[destPos] = v < 0 ? 0 : (char) v;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     * If <code>truncateOverflows</code> argument is <code>true</code>, the difference is truncated
     * to <code>0..0xFFFF</code> range before assigning to <code>dest</code> elements.
     * The short elements are considered to be unsigned.
     *
     * @param dest              the destination array.
     * @param destPos           position of the first replaced element in the destination array.
     * @param src               the source array.
     * @param srcPos            position of the first read element in the source array.
     * @param count             the number of elements to be replaced (should be &gt;=0).
     * @param truncateOverflows whether the results should be truncated to <code>0..0xFFFF</code> range.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractShortArray(
            short[] dest, int destPos, short[] src, int srcPos, int count,
            boolean truncateOverflows) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (truncateOverflows) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                int v = ((int) dest[destPos] & 0xFFFF) - ((int) src[srcPos] & 0xFFFF);
                dest[destPos] = v < 0 ? 0 : (short) v;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     * If <code>truncateOverflows</code> argument is <code>true</code>, the difference is truncated
     * to <code>Integer.MIN_VALUE..Integer.MAX_VALUE</code> range before assigning to <code>dest</code> elements.
     *
     * @param dest              the destination array.
     * @param destPos           position of the first replaced element in the destination array.
     * @param src               the source array.
     * @param srcPos            position of the first read element in the source array.
     * @param count             the number of elements to be replaced (should be &gt;=0).
     * @param truncateOverflows whether the results should be truncated to
     *                          <code>Integer.MIN_VALUE..Integer.MAX_VALUE</code> range.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractIntArray(
            int[] dest, int destPos, int[] src, int srcPos, int count,
            boolean truncateOverflows) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (truncateOverflows) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                long v = (long) dest[destPos] - (long) src[srcPos];
                dest[destPos] = v < Integer.MIN_VALUE ? Integer.MIN_VALUE :
                        v > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) v;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] -= src[srcPos];
            }
        }
    }

    /*Repeat() long ==> float,,double;;
               Long ==> Float,,Double
     */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractLongArray(long[] dest, int destPos, long[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] -= src[srcPos];
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractFloatArray(float[] dest, int destPos, float[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] -= src[srcPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the difference of them and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=dest[destPos+i]-src[srcPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void subtractDoubleArray(double[] dest, int destPos, double[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] -= src[srcPos];
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() byte ==> char,,short,,long,,float,,double;;
               Byte ==> Char,,Short,,Long,,Float,,Double;;
               (\s*&\s*0xFF) ==> ,,$1FF,, ,,...;;
               \((long|float|double)\) ==> ,,...;;
               (\(The\s+\w+\s+elements.*?\.\)\s*\*) ==> ,,$1,, ,,... */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     * (The byte elements are considered to be unsigned.)
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfByteArray(byte[] dest, int destPos, byte[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] = (dest[destPos] & 0xFF) >= (src[srcPos] & 0xFF) ?
                    (byte) (dest[destPos] - src[srcPos]) :
                    (byte) (src[srcPos] - dest[destPos]);
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfCharArray(char[] dest, int destPos, char[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] = (dest[destPos]) >= (src[srcPos]) ?
                    (char) (dest[destPos] - src[srcPos]) :
                    (char) (src[srcPos] - dest[destPos]);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     * (The short elements are considered to be unsigned.)
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfShortArray(short[] dest, int destPos, short[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] = (dest[destPos] & 0xFFFF) >= (src[srcPos] & 0xFFFF) ?
                    (short) (dest[destPos] - src[srcPos]) :
                    (short) (src[srcPos] - dest[destPos]);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfLongArray(long[] dest, int destPos, long[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] = (dest[destPos]) >= (src[srcPos]) ?
                     (dest[destPos] - src[srcPos]) :
                     (src[srcPos] - dest[destPos]);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfFloatArray(float[] dest, int destPos, float[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] = (dest[destPos]) >= (src[srcPos]) ?
                     (dest[destPos] - src[srcPos]) :
                     (src[srcPos] - dest[destPos]);
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param src     the source array.
     * @param srcPos  position of the first read element in the source array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfDoubleArray(double[] dest, int destPos, double[] src, int srcPos, int count) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
            dest[destPos] = (dest[destPos]) >= (src[srcPos]) ?
                     (dest[destPos] - src[srcPos]) :
                     (src[srcPos] - dest[destPos]);
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the absolute value of the difference of them
     * and corresponding <code>count</code> elements in <code>src</code> array,
     * starting from the element <code>#srcPos</code>:
     * <code>dest[destPos+i]=|dest[destPos+i]-src[srcPos+i]|</code>.
     * If <code>truncateOverflows</code> argument is <code>true</code>, the difference is truncated
     * to <code>0..Integer.MAX_VALUE</code> range before assigning to <code>dest</code> elements.
     *
     * @param dest              the destination array.
     * @param destPos           position of the first replaced element in the destination array.
     * @param src               the source array.
     * @param srcPos            position of the first read element in the source array.
     * @param count             the number of elements to be replaced (should be &gt;=0).
     * @param truncateOverflows whether the results should be truncated to
     *                          <code>Integer.MIN_VALUE..Integer.MAX_VALUE</code> range.
     * @throws NullPointerException      if either <code>src</code> or <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void absDiffOfIntArray(
            int[] dest, int destPos, int[] src, int srcPos, int count,
            boolean truncateOverflows) {
        rangeCheck(dest.length, destPos, src.length, srcPos, count);
        if (truncateOverflows) {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                long v = (long) dest[destPos] - (long) src[srcPos];
                if (v < 0) {
                    v = -v;
                }
                dest[destPos] = v > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) v;
            }
        } else {
            for (int srcPosMax = srcPos + count; srcPos < srcPosMax; srcPos++, destPos++) {
                dest[destPos] = dest[destPos] >= src[srcPos] ?
                        dest[destPos] - src[srcPos] :
                        src[srcPos] - dest[destPos];
            }
        }
    }

    /*Repeat() \(byte\) ==> (short),, ,, ,, ,, ;;
               byte     ==> short,,int,,long,,float,,double;;
               Byte     ==> Short,,Int,,Long,,Float,,Double
     */

    /**
     * Replaces all elements in <code>dest</code> array
     * with the same values with the minus sign:
     * <code>dest[i]=-dest[i]</code>.
     *
     * @param dest the destination array.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void oppositeByteArray(byte[] dest) {
        for (int destPos = 0; destPos < dest.length; destPos++) {
            dest[destPos] = (byte) -dest[destPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the same values with the minus sign:
     * <code>dest[destPos+i]=-dest[destPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void oppositeByteArray(byte[] dest, int destPos, int count) {
        rangeCheck(dest.length, destPos, count);
        for (int destPosMax = destPos + count; destPos < destPosMax; destPos++) {
            dest[destPos] = (byte) -dest[destPos];
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Replaces all elements in <code>dest</code> array
     * with the same values with the minus sign:
     * <code>dest[i]=-dest[i]</code>.
     *
     * @param dest the destination array.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void oppositeShortArray(short[] dest) {
        for (int destPos = 0; destPos < dest.length; destPos++) {
            dest[destPos] = (short) -dest[destPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the same values with the minus sign:
     * <code>dest[destPos+i]=-dest[destPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void oppositeShortArray(short[] dest, int destPos, int count) {
        rangeCheck(dest.length, destPos, count);
        for (int destPosMax = destPos + count; destPos < destPosMax; destPos++) {
            dest[destPos] = (short) -dest[destPos];
        }
    }

    /**
     * Replaces all elements in <code>dest</code> array
     * with the same values with the minus sign:
     * <code>dest[i]=-dest[i]</code>.
     *
     * @param dest the destination array.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void oppositeIntArray(int[] dest) {
        for (int destPos = 0; destPos < dest.length; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the same values with the minus sign:
     * <code>dest[destPos+i]=-dest[destPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void oppositeIntArray(int[] dest, int destPos, int count) {
        rangeCheck(dest.length, destPos, count);
        for (int destPosMax = destPos + count; destPos < destPosMax; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces all elements in <code>dest</code> array
     * with the same values with the minus sign:
     * <code>dest[i]=-dest[i]</code>.
     *
     * @param dest the destination array.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void oppositeLongArray(long[] dest) {
        for (int destPos = 0; destPos < dest.length; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the same values with the minus sign:
     * <code>dest[destPos+i]=-dest[destPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void oppositeLongArray(long[] dest, int destPos, int count) {
        rangeCheck(dest.length, destPos, count);
        for (int destPosMax = destPos + count; destPos < destPosMax; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces all elements in <code>dest</code> array
     * with the same values with the minus sign:
     * <code>dest[i]=-dest[i]</code>.
     *
     * @param dest the destination array.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void oppositeFloatArray(float[] dest) {
        for (int destPos = 0; destPos < dest.length; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the same values with the minus sign:
     * <code>dest[destPos+i]=-dest[destPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void oppositeFloatArray(float[] dest, int destPos, int count) {
        rangeCheck(dest.length, destPos, count);
        for (int destPosMax = destPos + count; destPos < destPosMax; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces all elements in <code>dest</code> array
     * with the same values with the minus sign:
     * <code>dest[i]=-dest[i]</code>.
     *
     * @param dest the destination array.
     * @throws NullPointerException if <code>dest</code> is {@code null}.
     */
    public static void oppositeDoubleArray(double[] dest) {
        for (int destPos = 0; destPos < dest.length; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }

    /**
     * Replaces <code>count</code> elements in <code>dest</code> array,
     * starting from the element <code>#destPos</code>,
     * with the same values with the minus sign:
     * <code>dest[destPos+i]=-dest[destPos+i]</code>.
     *
     * @param dest    the destination array.
     * @param destPos position of the first replaced element in the destination array.
     * @param count   the number of elements to be replaced (should be &gt;=0).
     * @throws NullPointerException      if <code>dest</code> is {@code null}.
     * @throws IllegalArgumentException  if <code>count</code> is negative.
     * @throws IndexOutOfBoundsException if accessing elements would cause access of data outside array bounds.
     */
    public static void oppositeDoubleArray(double[] dest, int destPos, int count) {
        rangeCheck(dest.length, destPos, count);
        for (int destPosMax = destPos + count; destPos < destPosMax; destPos++) {
            dest[destPos] =  -dest[destPos];
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() boolean   ==> char,,byte,,short,,int,,long,,float,,double,,Object;;
               Bit       ==> Char,,Byte,,Short,,Int,,Long,,Float,,Double,,Object
     */

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(boolean[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(boolean[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(char[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(char[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(byte[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(byte[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(short[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(short[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(int[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(int[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(long[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(long[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(float[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(float[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(double[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(double[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }

    /**
     * Joins and returns as a string the standard string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(Object[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source Java array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(Object[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray ca = SimpleMemoryModel.getInstance().newEmptyCharArray();
        ca.append(String.valueOf(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (ca.length() >= maxStringLength) {
                ca.append(separator).append("...");
                break;
            }
            ca.append(separator).append(String.valueOf(array[k]));
        }
        return Arrays.toString(ca);
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() byte ==> short,,int,,long,,float,,double;;
               Byte ==> Short,,Int,,Long,,Float,,Double
     */

    /**
     * Joins and returns as a string the string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>,
     * using <code>format</code> string for formatting numeric elements.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, Locale, String, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(byte[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param locale          the locale that will be passed to <code>String.format(locale,format,v)</code> call.
     * @param format          format string for numeric elements: each element <code>v</code> is converted
     *                        to string by <code>String.format(locale,format,v)</code> call.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(byte[] array, Locale locale, String format, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(String.format(locale, format, array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(String.format(locale, format, array[k]));
        }
        return Arrays.toString(cv);
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Joins and returns as a string the string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>,
     * using <code>format</code> string for formatting numeric elements.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, Locale, String, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(short[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param locale          the locale that will be passed to <code>String.format(locale,format,v)</code> call.
     * @param format          format string for numeric elements: each element <code>v</code> is converted
     *                        to string by <code>String.format(locale,format,v)</code> call.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(short[] array, Locale locale, String format, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(String.format(locale, format, array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(String.format(locale, format, array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>,
     * using <code>format</code> string for formatting numeric elements.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, Locale, String, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(int[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param locale          the locale that will be passed to <code>String.format(locale,format,v)</code> call.
     * @param format          format string for numeric elements: each element <code>v</code> is converted
     *                        to string by <code>String.format(locale,format,v)</code> call.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(int[] array, Locale locale, String format, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(String.format(locale, format, array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(String.format(locale, format, array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>,
     * using <code>format</code> string for formatting numeric elements.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, Locale, String, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(long[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param locale          the locale that will be passed to <code>String.format(locale,format,v)</code> call.
     * @param format          format string for numeric elements: each element <code>v</code> is converted
     *                        to string by <code>String.format(locale,format,v)</code> call.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(long[] array, Locale locale, String format, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(String.format(locale, format, array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(String.format(locale, format, array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>,
     * using <code>format</code> string for formatting numeric elements.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, Locale, String, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(float[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param locale          the locale that will be passed to <code>String.format(locale,format,v)</code> call.
     * @param format          format string for numeric elements: each element <code>v</code> is converted
     *                        to string by <code>String.format(locale,format,v)</code> call.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(float[] array, Locale locale, String format, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(String.format(locale, format, array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(String.format(locale, format, array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the string representations for all
     * elements of the Java array, separating elements by the given <code>separator</code>,
     * using <code>format</code> string for formatting numeric elements.
     * Equivalent to
     * <code>{@link Arrays#toString(Array, Locale, String, String, int)
     * Arrays.toString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(double[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param locale          the locale that will be passed to <code>String.format(locale,format,v)</code> call.
     * @param format          format string for numeric elements: each element <code>v</code> is converted
     *                        to string by <code>String.format(locale,format,v)</code> call.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toString(double[] array, Locale locale, String format, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(String.format(locale, format, array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(String.format(locale, format, array[k]));
        }
        return Arrays.toString(cv);
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() (\w+\[\w+\])\s*\?\s*\"1\"\s*:\s*\"0\" ==>
                           InternalUtils.toHexString((short)$1),,
                           InternalUtils.toHexString($1),,
                           InternalUtils.toHexString($1),,
                           InternalUtils.toHexString($1),,
                           InternalUtils.toHexString($1);;
               boolean ==> char,,byte,,short,,int,,long;;
               Bit     ==> Char,,Byte,,Short,,Int,,Long;;
               Binary  ==> Hex,,...]]
     */

    /**
     * Joins and returns as a string the "hexadecimal" string representations for all
     * elements of the AlgART array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toHexString(Array, String, int)
     * Arrays.toHexString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(boolean[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toBinaryString(boolean[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(array[0] ? "1" : "0");
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(array[k] ? "1" : "0");
        }
        return Arrays.toString(cv);
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */

    /**
     * Joins and returns as a string the "hexadecimal" string representations for all
     * elements of the AlgART array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toHexString(Array, String, int)
     * Arrays.toHexString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(char[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toHexString(char[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(InternalUtils.toHexString((short)array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(InternalUtils.toHexString((short)array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the "hexadecimal" string representations for all
     * elements of the AlgART array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toHexString(Array, String, int)
     * Arrays.toHexString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(byte[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toHexString(byte[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(InternalUtils.toHexString(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(InternalUtils.toHexString(array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the "hexadecimal" string representations for all
     * elements of the AlgART array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toHexString(Array, String, int)
     * Arrays.toHexString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(short[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toHexString(short[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(InternalUtils.toHexString(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(InternalUtils.toHexString(array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the "hexadecimal" string representations for all
     * elements of the AlgART array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toHexString(Array, String, int)
     * Arrays.toHexString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(int[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toHexString(int[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(InternalUtils.toHexString(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(InternalUtils.toHexString(array[k]));
        }
        return Arrays.toString(cv);
    }

    /**
     * Joins and returns as a string the "hexadecimal" string representations for all
     * elements of the AlgART array, separating elements by the given <code>separator</code>.
     * Equivalent to
     * <code>{@link Arrays#toHexString(Array, String, int)
     * Arrays.toHexString}({@link SimpleMemoryModel#getInstance()}.{@link MemoryModel#valueOf(long[])
     * valueOf}(array), separator, maxStringLength)</code>, but works little faster.
     *
     * @param array           the source AlgART array.
     * @param separator       the string used for separating elements.
     * @param maxStringLength the maximal allowed length of returned string (longer results are truncated
     *                        with adding "..." at the end).
     * @return the string representations of all elements joined into one string.
     * @throws NullPointerException     if <code>array</code> or <code>separator</code> argument is {@code null}.
     * @throws IllegalArgumentException if <code>maxStringLength</code> &lt;= 0.
     */
    public static String toHexString(long[] array, String separator, int maxStringLength) {
        Objects.requireNonNull(array, "Null array argument");
        Objects.requireNonNull(separator, "Null separator argument");
        if (maxStringLength <= 0) {
            throw new IllegalArgumentException("maxStringLength argument must be positive");
        }
        if (array.length == 0) {
            return "";
        }
        MutableCharArray cv = SimpleMemoryModel.getInstance().newEmptyCharArray();
        cv.append(InternalUtils.toHexString(array[0]));
        for (int k = 1; k < array.length; k++) {
            if (cv.length() >= maxStringLength) {
                cv.append(separator).append("...");
                break;
            }
            cv.append(separator).append(InternalUtils.toHexString(array[k]));
        }
        return Arrays.toString(cv);
    }
    /*Repeat.AutoGeneratedEnd*/

    static void rangeCheck(int arrayLen, int pos, int count) {
        if (count < 0) {
            throw new IllegalArgumentException("Negative number of elements (" + count + ")");
        }
        if (pos < 0) {
            throw new IndexOutOfBoundsException("Start position = " + pos + " < 0");
        }
        if (pos > arrayLen - count) {
            throw new IndexOutOfBoundsException("End position (last index + 1) = " + (pos + count)
                    + " > array length = " + arrayLen);
        }
    }

    static void rangeCheck(int arrayLen1, int pos1, int arrayLen2, int pos2, int count) {
        if (count < 0) {
            throw new IllegalArgumentException("Negative number of elements (" + count + ")");
        }
        if (pos1 < 0) {
            throw new IndexOutOfBoundsException("Start position = " + pos1 + " < 0");
        }
        if (pos1 > arrayLen1 - count) {
            throw new IndexOutOfBoundsException("End position (last index + 1) = " + (pos1 + count)
                    + " > array length = " + arrayLen1);
        }
        if (pos2 < 0) {
            throw new IndexOutOfBoundsException("Start position = " + pos2 + " < 0");
        }
        if (pos2 > arrayLen2 - count) {
            throw new IndexOutOfBoundsException("End position (last index + 1) = " + (pos2 + count)
                    + " > array length = " + arrayLen2);
        }
    }

    private static void getBytes(boolean[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            result[disp++] = array[offset] ? (byte) 11 : (byte) 17;
        }
    }

    private static void getBytes(char[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            char value = array[offset];
            result[disp++] = (byte) (value ^ 'C'); // provide different results for different primitive types
            result[disp++] = (byte) (value >>> 8);
        }
    }

    private static void getBytes(short[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            short value = array[offset];
            result[disp++] = (byte) (value ^ 'S'); // provide different results for different primitive types
            result[disp++] = (byte) (value >>> 8);
        }
    }

    private static void getBytes(int[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            int value = array[offset];
            result[disp++] = (byte) (value ^ 'I'); // provide different results for different primitive types
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
        }
    }

    private static void getBytes(long[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            long l = array[offset];
            int value = (int) l ^ 'L'; // provide different results for different primitive types
            result[disp++] = (byte) value;
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
            value = (int) (l >>> 32) ^ 'L'; // provide different results for different primitive types
            result[disp++] = (byte) value;
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
        }
    }

    private static void getBytes(float[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            int value = Float.floatToIntBits(array[offset])
                    ^ 'F'; // provide different results for different primitive types
            result[disp++] = (byte) value;
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
        }
    }

    private static void getBytes(double[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            long l = Double.doubleToLongBits(array[offset]);
            int value = (int) l ^ 'D'; // provide different results for different primitive types
            result[disp++] = (byte) value;
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
            value = (int) (l >>> 32) ^ 'D'; // provide different results for different primitive types
            result[disp++] = (byte) value;
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
        }
    }

    private static void getBytes(Object[] array, int offset, int count, byte[] result) {
        for (int disp = 0, offsetMax = offset + count; offset < offsetMax; offset++) {
            int value = array[offset] == null ? 0 : array[offset].hashCode();
            result[disp++] = (byte) value;
            result[disp++] = (byte) (value >>> 8);
            result[disp++] = (byte) (value >>> 16);
            result[disp++] = (byte) (value >>> 24);
        }
    }

    static class MinMaxTables {
        static final byte[] MIN_TABLE = new byte[65536];
        static final byte[] MAX_TABLE = new byte[65536];

        static {
            for (int b1 = 0; b1 < 256; b1++) {
                for (int b2 = 0; b2 < 256; b2++) {
                    MIN_TABLE[(b1 << 8) | b2] = (byte) Math.min(b1, b2);
                    MAX_TABLE[(b1 << 8) | b2] = (byte) Math.max(b1, b2);
                }
            }
        }
    }
}
