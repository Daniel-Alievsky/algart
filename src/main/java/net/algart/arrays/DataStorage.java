/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2007-2018 Daniel Alievsky, AlgART Laboratory (http://algart.net)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.algart.arrays;

import java.util.Set;
import java.util.HashSet;
import java.nio.ByteOrder;

/**
 * <p>Data storage: low-level analog of {@link MutableArray},
 * used for implementation of {@link BufferMemoryModel} and {@link LargeMemoryModel}.</p>
 *
 * <p>All views of an AlgART array (subarrays, immutable views, etc.)
 * share the same underlying data storage.</p>
 *
 * <p>Inheritors of this class MUST NOT CONTAIN a link to AlgART array:
 * such link make impossible deallocation of the array before deallocation of the storage.</p>
 *
 * @author Daniel Alievsky
 * @version 1.2
 * @since JDK 1.5
 */
abstract class DataStorage {
    static boolean DO_LAZY_INIT = InternalUtils.getBooleanProperty( // It's non-final to allow changing via reflection.
        "net.algart.arrays.DataStorage.doLazyInit", true); // true by default
    static byte ZERO_INIT_FILLER = 0;   // for debugging only! It's non-final to allow changing via reflection.
                                        // ZERO_INIT_FILLER is not used by getData/getBits!

    static final int BYTES_PER_BYTE_LOG = 0; // = log 1
    static final int BYTES_PER_CHAR_LOG = 1; // = log 2
    static final int BYTES_PER_SHORT_LOG = 1; // = log 2
    static final int BYTES_PER_INT_LOG = 2; // = log 4
    static final int BYTES_PER_LONG_LOG = 3; // = log 8
    static final int BYTES_PER_FLOAT_LOG = 2; // = log 4
    static final int BYTES_PER_DOUBLE_LOG = 3; // = log 8

    static final Boolean booleanZero = false;
    static final Character charZero = 0;
    static final Byte byteZero = 0;
    static final Short shortZero = 0;
    static final Integer intZero = 0;
    static final Long longZero = 0L;
    static final Float floatZero = 0.0f;
    static final Double doubleZero = 0.0;

    static long maxSupportedLengthImpl(Class<?> elementType) {
        if (elementType == null)
            throw new NullPointerException("Null elementType argument");
        if (elementType == boolean.class || elementType == byte.class)
            return Long.MAX_VALUE;
        //[[Repeat() char ==> short,,int,,long,,float,,double;;
        //           CHAR ==> SHORT,,INT,,LONG,,FLOAT,,DOUBLE]]
        if (elementType == char.class) {
            return Long.MAX_VALUE >> BYTES_PER_CHAR_LOG;
        } else //[[Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! ]]
        if (elementType == short.class) {
            return Long.MAX_VALUE >> BYTES_PER_SHORT_LOG;
        } else
        if (elementType == int.class) {
            return Long.MAX_VALUE >> BYTES_PER_INT_LOG;
        } else
        if (elementType == long.class) {
            return Long.MAX_VALUE >> BYTES_PER_LONG_LOG;
        } else
        if (elementType == float.class) {
            return Long.MAX_VALUE >> BYTES_PER_FLOAT_LOG;
        } else
        if (elementType == double.class) {
            return Long.MAX_VALUE >> BYTES_PER_DOUBLE_LOG;
        } else //[[Repeat.AutoGeneratedEnd]]
        {
            return -1;
        }
    }

    static void freeAllResources() {
        Set<DataStorage> all;
        synchronized(MappedDataStorages.allNonFinalizedMappedStorages) {
            all = new HashSet<DataStorage>(MappedDataStorages.allNonFinalizedMappedStorages);
        }
        for (DataStorage storage : all) {
            storage.freeResources(null, false); // implementations here do not use the first argument
        }
    }



    /**
     * Returns an instance of {@link LargeMemoryModel} that will create storages
     * with characteristics identical to this one (for any element types).
     *
     * @return an instance of {@link LargeMemoryModel} compatible with this storage.
     */
    abstract MemoryModel newCompatibleMemoryModel();

    /**
     * Creates new empty storage with characteristics identical to this one
     * (in particular, with the same element type).
     *
     * @param unresizable <tt>true</tt> if this storage will be used for unresizable array.
     * @return            new compatible empty storage.
     */
    abstract DataStorage newCompatibleEmptyStorage(boolean unresizable);

    /**
     * Returns the binary logarithm of the number of bytes per one <tt>Buffer</tt> element
     * used by this storage. For bit storages, returns 3, as for <tt>long</tt> values.
     *
     * @return the binary logarithm of the number of bytes per one <tt>Buffer</tt> element.
     */
    abstract int bytesPerBufferElementLog();

    /**
     * Returns the byte order used by this storage.
     *
     * @return the byte order used by this storage.
     */
    abstract ByteOrder byteOrder();

    /**
     * Creates new <tt>a</tt> zero-filled array, currently stored in this storage.
     * The only usage of <tt>a</tt> argument should
     * be correction of information about it that may be stored here.
     *
     * @param capacity    new array capacity.
     * @param unresizable if <tt>true</tt>, the {@link #changeCapacity(long, long, long)} method
     * should never be called.
     */
    abstract void allocate(long capacity, boolean unresizable);

    /**
     * Changes the capacity of <tt>a</tt> array, currently stored in this storage
     * starting from <tt>offset</tt> position,
     * to <tt>newCapacity</tt>, copies elements <tt>offset..offset+length-1</tt>
     * to new allocated array, and returns the resulting storage.
     * Result may be equal to this one or may be a new instance,
     * if all data were really copied into new created storage.
     *
     * <p>If the capacity is increased, all new elements
     * are zero. The only usage of <tt>a</tt> argument should
     * be correction of information about it that may be stored here.
     *
     * @param newCapacity new array capacity.
     * @param offset      start position of the array which should be copied to new array.
     * @param length      number of elements which should be copied to new array.
     * @return            this instance or new created storage.
     */
    abstract DataStorage changeCapacity(long newCapacity, long offset, long length);

    /*Repeat() boolean|bit ==> char,,byte,,short,,int,,long,,float,,double;;
               Bit         ==> Char,,Byte,,Short,,Int,,Long,,Float,,Double
     */
    /**
     * Returns the bit #<tt>index</tt> if it is a bit storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the bit at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a bit storage.
     */
    boolean getBit(long index) {
        throw new UnsupportedOperationException("It is not a bit storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a bit storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the bit to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a bit storage.
     */
    void setBit(long index, boolean value) {
        throw new UnsupportedOperationException("It is not a bit storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getBit(long) getBit}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a bit storage.
     */
    long indexOfBit(long lowIndex, long highIndex, boolean value) {
        throw new UnsupportedOperationException("It is not a bit storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getBit(long) getBit}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this bit in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this bit does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfBit(long lowIndex, long highIndex, boolean value) {
        throw new UnsupportedOperationException("It is not a bit storage");
    }

    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */
    /**
     * Returns the char #<tt>index</tt> if it is a char storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the char at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a char storage.
     */
    char getChar(long index) {
        throw new UnsupportedOperationException("It is not a char storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a char storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the char to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a char storage.
     */
    void setChar(long index, char value) {
        throw new UnsupportedOperationException("It is not a char storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getChar(long) getChar}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a char storage.
     */
    long indexOfChar(long lowIndex, long highIndex, char value) {
        throw new UnsupportedOperationException("It is not a char storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getChar(long) getChar}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this char in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this char does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfChar(long lowIndex, long highIndex, char value) {
        throw new UnsupportedOperationException("It is not a char storage");
    }


    /**
     * Returns the byte #<tt>index</tt> if it is a byte storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the byte at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a byte storage.
     */
    byte getByte(long index) {
        throw new UnsupportedOperationException("It is not a byte storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a byte storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the byte to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a byte storage.
     */
    void setByte(long index, byte value) {
        throw new UnsupportedOperationException("It is not a byte storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getByte(long) getByte}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a byte storage.
     */
    long indexOfByte(long lowIndex, long highIndex, byte value) {
        throw new UnsupportedOperationException("It is not a byte storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getByte(long) getByte}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this byte in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this byte does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfByte(long lowIndex, long highIndex, byte value) {
        throw new UnsupportedOperationException("It is not a byte storage");
    }


    /**
     * Returns the short #<tt>index</tt> if it is a short storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the short at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a short storage.
     */
    short getShort(long index) {
        throw new UnsupportedOperationException("It is not a short storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a short storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the short to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a short storage.
     */
    void setShort(long index, short value) {
        throw new UnsupportedOperationException("It is not a short storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getShort(long) getShort}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a short storage.
     */
    long indexOfShort(long lowIndex, long highIndex, short value) {
        throw new UnsupportedOperationException("It is not a short storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getShort(long) getShort}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this short in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this short does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfShort(long lowIndex, long highIndex, short value) {
        throw new UnsupportedOperationException("It is not a short storage");
    }


    /**
     * Returns the int #<tt>index</tt> if it is a int storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the int at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a int storage.
     */
    int getInt(long index) {
        throw new UnsupportedOperationException("It is not a int storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a int storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the int to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a int storage.
     */
    void setInt(long index, int value) {
        throw new UnsupportedOperationException("It is not a int storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getInt(long) getInt}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a int storage.
     */
    long indexOfInt(long lowIndex, long highIndex, int value) {
        throw new UnsupportedOperationException("It is not a int storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getInt(long) getInt}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this int in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this int does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfInt(long lowIndex, long highIndex, int value) {
        throw new UnsupportedOperationException("It is not a int storage");
    }


    /**
     * Returns the long #<tt>index</tt> if it is a long storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the long at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a long storage.
     */
    long getLong(long index) {
        throw new UnsupportedOperationException("It is not a long storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a long storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the long to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a long storage.
     */
    void setLong(long index, long value) {
        throw new UnsupportedOperationException("It is not a long storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getLong(long) getLong}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a long storage.
     */
    long indexOfLong(long lowIndex, long highIndex, long value) {
        throw new UnsupportedOperationException("It is not a long storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getLong(long) getLong}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this long in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this long does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfLong(long lowIndex, long highIndex, long value) {
        throw new UnsupportedOperationException("It is not a long storage");
    }


    /**
     * Returns the float #<tt>index</tt> if it is a float storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the float at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a float storage.
     */
    float getFloat(long index) {
        throw new UnsupportedOperationException("It is not a float storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a float storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the float to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a float storage.
     */
    void setFloat(long index, float value) {
        throw new UnsupportedOperationException("It is not a float storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getFloat(long) getFloat}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a float storage.
     */
    long indexOfFloat(long lowIndex, long highIndex, float value) {
        throw new UnsupportedOperationException("It is not a float storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getFloat(long) getFloat}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this float in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this float does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfFloat(long lowIndex, long highIndex, float value) {
        throw new UnsupportedOperationException("It is not a float storage");
    }


    /**
     * Returns the double #<tt>index</tt> if it is a double storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @return      the double at the specified position in the source array.
     * @throws UnsupportedOperationException if it is not a double storage.
     */
    double getDouble(long index) {
        throw new UnsupportedOperationException("It is not a double storage");
    }

    /**
     * Sets the element #<tt>index</tt> to specified <tt>value</tt> if it is a double storage.
     *
     * @param index the index of the data element in the source array (not sub-array).
     * @param value the double to be stored at the specified position.
     * @throws UnsupportedOperationException if it is not a double storage.
     */
    void setDouble(long index, double value) {
        throw new UnsupportedOperationException("It is not a double storage");
    }

    /**
     * Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
     * and <tt>{@link #getDouble(long) getDouble}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index for search (inclusive).
     * @param highIndex the high index for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the first occurrence of this element in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this element does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     * @throws UnsupportedOperationException if it is not a double storage.
     */
    long indexOfDouble(long lowIndex, long highIndex, double value) {
        throw new UnsupportedOperationException("It is not a double storage");
    }

    /**
     * Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
     * and <tt>{@link #getDouble(long) getDouble}(k)==value</tt>,
     * or <tt>-1</tt> if there is no such element.
     *
     * <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.
     *
     * @param lowIndex  the low index in the array for search (inclusive);
     *                  pass <tt>0</tt> to search all remaining elements.
     * @param highIndex the high index in the array for search (exclusive).
     * @param value     the value of element to be found.
     * @return          the index of the last occurrence of this double in range <tt>lowIndex..highIndex-1</tt>,
     *                  or <tt>-1</tt> if this double does not occur
     *                  or if <tt>lowIndex&gt;=highIndex</tt>.
     */
    long lastIndexOfDouble(long lowIndex, long highIndex, double value) {
        throw new UnsupportedOperationException("It is not a double storage");
    }

    /*Repeat.AutoGeneratedEnd*/

    /**
     * Copies element #<tt>srcIndex</tt> to position #<tt>destIndex</tt> inside
     * the stored array (not sub-array).
     *
     * @param destIndex index of element to replace.
     * @param srcIndex  index of element to be copied.
     */
    abstract void copy(long destIndex, long srcIndex);

    /**
     * Swaps elements at positions #<tt>firstIndex</tt> and #<tt>secondIndex</tt> inside
     * the stored array (not sub-array).
     *
     * @param firstIndex  first index of element to exchange.
     * @param secondIndex second index of element to exchange.
     */
    abstract void swap(long firstIndex, long secondIndex);

    /**
     * Copies <tt>count</tt> elements of this storage, starting from <tt>pos</tt> index,
     * into the specified Java array of corresponding type, starting from <tt>destArrayOffset</tt> index.
     *
     * @param pos             starting position in the stored AlgART array (not sub-array).
     * @param destArray       the target Java array.
     * @param destArrayOffset starting position in the target Java array.
     * @param count           the number of elements to be copied.
     */
    abstract void getData(long pos, Object destArray, int destArrayOffset, int count);

    /**
     * Copies <tt>count</tt> elements from the specified Java array of corresponding type,
     * starting from <tt>srcArrayOffset</tt> index,
     * into this storage, starting from <tt>pos</tt> index.
     *
     * @param pos            starting position in the stored AlgART array (not sub-array).
     * @param srcArray       the source Java array.
     * @param srcArrayOffset starting position in the source Java array.
     * @param count          the number of elements to be copied.
     */
    abstract void setData(long pos, Object srcArray, int srcArrayOffset, int count);

    /**
     * Fills elements <tt>#pos..#pos+count-1</tt> of this storage
     * by the filler stored in <tt>fillerWrapper</tt>
     * (<tt>Boolean</tt>, <tt>Character</tt>, <tt>Byte</tt>, <tt>Short</tt>,
     * <tt>Integer</tt>, <tt>Long</tt>, <tt>Float</tt> or <tt>Double</tt>).
     *
     * @param pos           starting position in the stored AlgART array (not sub-array).
     * @param count         the number of elements to be copied.
     * @param fillerWrapper the wrapper of primitive type storing the filling value.
     */
    abstract void fillData(long pos, long count, Object fillerWrapper);

    /**
     * Fills elements <tt>#pos..#pos+count-1</tt> of this storage by zero.
     *
     * @param pos   starting position in the stored AlgART array (not sub-array).
     * @param count the number of elements to be filled.
     */
    abstract void clearData(long pos, long count);

    /**
     * Copies <tt>count</tt> elements of <tt>src</tt> storage, starting from <tt>srcPos</tt> index,
     * to this storage, starting from <tt>destPos</tt> index.
     *
     * <p>This operation may be not supported for some kind of the passed storage;
     * in this case, this method must return <tt>false</tt>.
     * In a case of success this method returns <tt>true</tt>.
     * Always returns <tt>true</tt> is <tt>src==this</tt> or if <tt>src</tt>
     * was created via <tt>this.{@link #newCompatibleEmptyStorage(boolean)}</tt>.
     *
     * <p><i>This method works correctly even if the copied areas overlap</i>,
     * i.e. if <tt>src</tt> is this storage and <tt>Math.abs(destPos - srcPos) &lt; count</tt>.
     * More precisely, in this case the copying is performed as if the
     * elements at positions <tt>srcPos..srcPos+count-1</tt>
     * were first copied to a temporary array with <tt>count</tt> elements
     * and then the contents of the temporary array were copied into positions
     * <tt>destPos..destPos+count-1</tt> of this array.
     *
     * @param src     the source storage.
     * @param srcPos  starting position in the source storage.
     * @param destPos starting position in this storage.
     * @param count   the number of elements to be copied.
     * @return        <tt>true</tt> if elements were copied, <tt>false</tt> if this method did nothing.
     */
    abstract boolean copy(DataStorage src, long srcPos, long destPos, long count);

    /**
     * Swaps <tt>count</tt> elements of <tt>another</tt> storage, starting from <tt>anotherPos</tt> index,
     * and the same number of elements of this storage, starting from <tt>thisPos</tt> index.
     *
     * <p>This operation may be not supported for some kind of the passed storage;
     * in this case, this method must return <tt>false</tt>.
     * In a case of success this method returns <tt>true</tt>.
     * Always returns <tt>true</tt> is <tt>another==this</tt>.
     *
     * <p>Some elements may be swapped incorrectly if this storage and <tt>another</tt> is the same object
     * and the swapped areas overlap (<tt>Math.abs(anotherPos - thisPos) &lt; count</tt>).
     *
     * @param another    another storage.
     * @param anotherPos starting position in another storage.
     * @param thisPos    starting position in this storage.
     * @param count      the number of elements to be exchanged.
     * @return        <tt>true</tt> if elements were copied, <tt>false</tt> if this method did nothing.
     */
    abstract boolean swap(DataStorage another, long anotherPos, long thisPos, long count);

    /**
     * Replaces <tt>count</tt> elements of Java array <tt>destArray</tt> of corresponding type,
     * starting from <tt>destArrayOffset</tt> index,
     * with the minimum of them and corresponding <tt>count</tt>
     * elements of this storage, starting from <tt>pos</tt> index.
     * Must not be called for bit storages.
     *
     * @param pos             starting position in the stored AlgART array (not sub-array).
     * @param destArray       the target Java array.
     * @param destArrayOffset starting position in the target Java array.
     * @param count           the number of elements to be replaced.
     */
    abstract void minData(long pos, Object destArray, int destArrayOffset, int count);

    /**
     * Replaces <tt>count</tt> elements of Java array <tt>destArray</tt> of corresponding type,
     * starting from <tt>destArrayOffset</tt> index,
     * with the maximum of them and corresponding <tt>count</tt>
     * elements of this storage, starting from <tt>pos</tt> index.
     * Must not be called for bit storages.
     *
     * @param pos             starting position in the stored AlgART array (not sub-array).
     * @param destArray       the target Java array.
     * @param destArrayOffset starting position in the target Java array.
     * @param count           the number of elements to be replaced.
     */
    abstract void maxData(long pos, Object destArray, int destArrayOffset, int count);

    /**
     * Replaces <tt>count</tt> elements of Java array <tt>destArray</tt>,
     * starting from <tt>destArrayOffset</tt> index,
     * with the sum of them and corresponding <tt>count</tt>
     * elements of this storage, starting from <tt>pos</tt> index.
     * Must not be called for bit storages.
     *
     * @param pos             starting position in the stored AlgART array (not sub-array).
     * @param destArray       the target Java array.
     * @param destArrayOffset starting position in the target Java array.
     * @param count           the number of elements to be replaced.
     */
    abstract void addData(long pos, int[] destArray, int destArrayOffset, int count);

    /**
     * Replaces <tt>count</tt> elements of Java array <tt>destArray</tt>,
     * starting from <tt>destArrayOffset</tt> index,
     * with the sum of them and corresponding <tt>count</tt>
     * elements of this storage, multiplied by <tt>mult</tt> argument,
     * starting from <tt>pos</tt> index.
     * Must not be called for bit storages.
     *
     * @param pos             starting position in the stored AlgART array (not sub-array).
     * @param destArray       the target Java array.
     * @param destArrayOffset starting position in the target Java array.
     * @param count           the number of elements to be replaced.
     * @param mult            the elements from this storage are multiplied by this value before adding.
     */
    abstract void addData(long pos, double[] destArray, int destArrayOffset, int count, double mult);

    /**
     * Replaces <tt>count</tt> elements of Java array <tt>destArray</tt> of corresponding type,
     * starting from <tt>destArrayOffset</tt> index,
     * with the difference of them and corresponding <tt>count</tt>
     * elements of this storage, starting from <tt>pos</tt> index.
     * If <tt>truncateOverflows</tt> argument is <tt>true</tt>,
     * and the element type is <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>char</tt>,
     * then the difference is truncated
     * to <tt>0..0xFF</tt>, <tt>0..0xFFFF</tt>, <tt>Integer.MIN_VALUE..Integer.MAX_VALUE</tt>, <tt>0..0xFFFF</tt>
     * range before assigning to <tt>dest</tt> elements.
     * The byte / short elements are considered to be unsigned.
     * Must not be called for bit storages.
     *
     * @param pos               starting position in the stored AlgART array (not sub-array).
     * @param destArray         the target Java array.
     * @param destArrayOffset   starting position in the target Java array.
     * @param count             the number of elements to be replaced.
     * @param truncateOverflows whether the results should be truncated in a case of overflow.
     */
    abstract void subtractData(long pos, Object destArray, int destArrayOffset, int count,
        boolean truncateOverflows);

    /**
     * Replaces <tt>count</tt> elements of Java array <tt>destArray</tt> of corresponding type,
     * starting from <tt>destArrayOffset</tt> index,
     * with the absolute value of the difference of them
     * and corresponding <tt>count</tt>
     * elements of this storage, starting from <tt>pos</tt> index.
     * If <tt>truncateOverflows</tt> argument is <tt>true</tt>,
     * and the element type is <tt>int</tt>,
     * then the difference is truncated
     * to <tt>Integer.MIN_VALUE..Integer.MAX_VALUE</tt>
     * range before assigning to <tt>dest</tt> elements.
     * The byte / short elements are considered to be unsigned.
     * Must not be called for bit storages.
     *
     * @param pos               starting position in the stored AlgART array (not sub-array).
     * @param destArray         the target Java array.
     * @param destArrayOffset   starting position in the target Java array.
     * @param count             the number of elements to be replaced.
     * @param truncateOverflows whether the results should be truncated in a case of overflow.
     */
    abstract void absDiffData(long pos, Object destArray, int destArrayOffset, int count,
        boolean truncateOverflows);

    /**
     * This method is always called at least once before first using this object.
     * The method must not store any direct or soft references to the passed array,
     * but may store some weak reference.
     *
     * @param a the new array using this storage.
     */
    void attachArray(Array a) {}

    /**
     * If overridden, must forget any information the AlgART array
     * and, if it is the last stored array, dispose all data.
     * The argument must be the result of <tt>System.identityHashCode(a)</tt>
     * for the AlgART array using this storage.
     * Called only while AlgART array finalization and copying-on-next-write.
     *
     * @param arrayIdentityHashCode the array that is currently using this object.
     */
    void forgetArray(int arrayIdentityHashCode) {}

    /**
     * If overridden, should actualize elements <tt>#fromIndex..#toIndex-1</tt>.
     * Some forms of data storages do not initialize some elements immediately after creating the storage,
     * but the first access fills them by some standard value (usually by zero).
     * This method guarantees that all elements <tt>#fromIndex..#toIndex-1</tt> will be really initialized,
     * if it is necessary.
     *
     * @param context the context of calculations; if not <tt>null</tt>, used for showing progress and interruption.
     * @param fromIndex start index (inclusive) in the stored AlgART array (not sub-array).
     * @param toIndex   end index (exclusive) in the stored AlgART array (not sub-array).
     */
    void actualizeLazyFilling(ArrayContext context, long fromIndex, long toIndex) {}

    /**
     * If overridden, should try to preload the resources connected with the specified region
     * of this storage into RAM. It is possible that not all resources will be preloaded.
     *
     * @param fromIndex start index (inclusive) in the stored AlgART array (not sub-array).
     * @param toIndex   end index (exclusive) in the stored AlgART array (not sub-array).
     */
    void loadResources(long fromIndex, long toIndex) {}

    /**
     * If overridden, should flush to disk all resources, corresponding to the specified region on this storage.
     * Maybe, flushs some additional resources.
     * Maybe, does not fill the rest of array by zeroes; to do this, you need to call
     * {@link #actualizeLazyFilling(ArrayContext, long, long)} method before.
     *
     * @param fromIndex            start index (inclusive) in the stored AlgART array (not sub-array).
     * @param toIndex              end index (exclusive) in the stored AlgART array (not sub-array).
     * @param forcePhysicalWriting is it necessary to try forcing physical writing all associated resources
     *                             to the external device.
     */
    void flushResources(long fromIndex, long toIndex, boolean forcePhysicalWriting) {}

    /**
     * If overridden, should free the resources connected with <tt>a</tt>.
     * In current implementation, ignores <tt>a</tt> and always frees all resources.
     *
     * @param a the array that is currently using this object.
     * @param forcePhysicalWriting is it necessary to try forcing physical writing all associated resources
     *                             to the external device.
     */
    void freeResources(Array a, boolean forcePhysicalWriting) {}

    /**
     * If overridden, must try to dispose all data.
     * Current implementation of {@link LargeMemoryModel} does not use this method.
     */
    void dispose() {}
}
