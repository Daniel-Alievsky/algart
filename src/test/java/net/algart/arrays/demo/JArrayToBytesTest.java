/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2007-2024 Daniel Alievsky, AlgART Laboratory (http://algart.net)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.algart.arrays.demo;

import net.algart.arrays.JArrays;

import java.nio.ByteOrder;
import java.util.Random;

/**
 * <p>Basic test for {@link JArrays#charArrayToBytes(byte[], char[], int, ByteOrder)} and similar methods.</p>
 *
 * @author Daniel Alievsky
 */
public class JArrayToBytesTest {
    /*Repeat() char ==> short,,int,,long,,float,,double;;
               Char ==> Short,,Int,,Long,,Float,,Double;;
               2(\s*\*) ==> 2$1,,4$1,,8$1,,4$1,,8$1;;
               (\/\s*)2 ==> / 2,,/ 4,,/ 8,,/ 4,,/ 8
     */
    private static void testCharArray(Random rnd, int arrayLength) {
        final int len = rnd.nextInt(arrayLength);
        byte[] bytes = new byte[len];
        for (int k = 0; k < bytes.length; k++) {
            bytes[k] = (byte) rnd.nextInt();
        }
        int count = rnd.nextInt(len / 2 + 1);
        char[] chars = rnd.nextBoolean() ? new char[count + 2] : null;
        ByteOrder order = rnd.nextBoolean() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
        chars = JArrays.bytesToCharArray(chars, bytes, count, order);
        byte[] back = rnd.nextBoolean() ? new byte[2 * count + 2] : null;
        back = JArrays.charArrayToBytes(back, chars, count, order);
        if (!JArrays.arrayEquals(back, 0, bytes, 0, count)) {
            throw new AssertionError("Bug in byteToCharArray/charToByteArray");
        }
    }

    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */
    private static void testShortArray(Random rnd, int arrayLength) {
        final int len = rnd.nextInt(arrayLength);
        byte[] bytes = new byte[len];
        for (int k = 0; k < bytes.length; k++) {
            bytes[k] = (byte) rnd.nextInt();
        }
        int count = rnd.nextInt(len / 2 + 1);
        short[] shorts = rnd.nextBoolean() ? new short[count + 2] : null;
        ByteOrder order = rnd.nextBoolean() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
        shorts = JArrays.bytesToShortArray(shorts, bytes, count, order);
        byte[] back = rnd.nextBoolean() ? new byte[2 * count + 2] : null;
        back = JArrays.shortArrayToBytes(back, shorts, count, order);
        if (!JArrays.arrayEquals(back, 0, bytes, 0, count)) {
            throw new AssertionError("Bug in byteToShortArray/shortToByteArray");
        }
    }
    private static void testIntArray(Random rnd, int arrayLength) {
        final int len = rnd.nextInt(arrayLength);
        byte[] bytes = new byte[len];
        for (int k = 0; k < bytes.length; k++) {
            bytes[k] = (byte) rnd.nextInt();
        }
        int count = rnd.nextInt(len / 4 + 1);
        int[] ints = rnd.nextBoolean() ? new int[count + 2] : null;
        ByteOrder order = rnd.nextBoolean() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
        ints = JArrays.bytesToIntArray(ints, bytes, count, order);
        byte[] back = rnd.nextBoolean() ? new byte[4 * count + 2] : null;
        back = JArrays.intArrayToBytes(back, ints, count, order);
        if (!JArrays.arrayEquals(back, 0, bytes, 0, count)) {
            throw new AssertionError("Bug in byteToIntArray/intToByteArray");
        }
    }
    private static void testLongArray(Random rnd, int arrayLength) {
        final int len = rnd.nextInt(arrayLength);
        byte[] bytes = new byte[len];
        for (int k = 0; k < bytes.length; k++) {
            bytes[k] = (byte) rnd.nextInt();
        }
        int count = rnd.nextInt(len / 8 + 1);
        long[] longs = rnd.nextBoolean() ? new long[count + 2] : null;
        ByteOrder order = rnd.nextBoolean() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
        longs = JArrays.bytesToLongArray(longs, bytes, count, order);
        byte[] back = rnd.nextBoolean() ? new byte[8 * count + 2] : null;
        back = JArrays.longArrayToBytes(back, longs, count, order);
        if (!JArrays.arrayEquals(back, 0, bytes, 0, count)) {
            throw new AssertionError("Bug in byteToLongArray/longToByteArray");
        }
    }
    private static void testFloatArray(Random rnd, int arrayLength) {
        final int len = rnd.nextInt(arrayLength);
        byte[] bytes = new byte[len];
        for (int k = 0; k < bytes.length; k++) {
            bytes[k] = (byte) rnd.nextInt();
        }
        int count = rnd.nextInt(len / 4 + 1);
        float[] floats = rnd.nextBoolean() ? new float[count + 2] : null;
        ByteOrder order = rnd.nextBoolean() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
        floats = JArrays.bytesToFloatArray(floats, bytes, count, order);
        byte[] back = rnd.nextBoolean() ? new byte[4 * count + 2] : null;
        back = JArrays.floatArrayToBytes(back, floats, count, order);
        if (!JArrays.arrayEquals(back, 0, bytes, 0, count)) {
            throw new AssertionError("Bug in byteToFloatArray/floatToByteArray");
        }
    }
    private static void testDoubleArray(Random rnd, int arrayLength) {
        final int len = rnd.nextInt(arrayLength);
        byte[] bytes = new byte[len];
        for (int k = 0; k < bytes.length; k++) {
            bytes[k] = (byte) rnd.nextInt();
        }
        int count = rnd.nextInt(len / 8 + 1);
        double[] doubles = rnd.nextBoolean() ? new double[count + 2] : null;
        ByteOrder order = rnd.nextBoolean() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
        doubles = JArrays.bytesToDoubleArray(doubles, bytes, count, order);
        byte[] back = rnd.nextBoolean() ? new byte[8 * count + 2] : null;
        back = JArrays.doubleArrayToBytes(back, doubles, count, order);
        if (!JArrays.arrayEquals(back, 0, bytes, 0, count)) {
            throw new AssertionError("Bug in byteToDoubleArray/doubleToByteArray");
        }
    }

    /*Repeat.AutoGeneratedEnd*/

    public static void main(String[] args) {
        final boolean superLarge = false;
        if (args.length < 2) {
            System.out.println("Usage: " + JArrayToBytesTest.class.getName()
                    + " arrayLength numberOfTests [randSeed]");
            return;
        }

        int arrayLength = Integer.parseInt(args[0]);
        int numberOfTests = Integer.parseInt(args[1]);
        if (arrayLength > Integer.MAX_VALUE / 10) {
            throw new IllegalArgumentException("Too large arrayLength = " + arrayLength);
        }
        long seed;
        if (args.length < 3) {
            seed = new Random().nextLong();
        } else {
            seed = Long.parseLong(args[2]);
        }

        Random rnd = new Random(seed);
        System.out.println("Testing " + arrayLength + " elements with start random seed " + seed);

        for (int testIndex = 0; testIndex < numberOfTests; testIndex++) {
            testCharArray(rnd, arrayLength);
            testShortArray(rnd, arrayLength);
            testIntArray(rnd, arrayLength);
            testLongArray(rnd, arrayLength);
            testFloatArray(rnd, arrayLength);
            testDoubleArray(rnd, arrayLength);
            PackedBitArraysTest.showProgress(testIndex);
        }
        System.out.println("           ");
        System.out.println("All O'k: testing time "
                + (System.currentTimeMillis() - PackedBitArraysTest.tStart) + " ms");
    }
}
