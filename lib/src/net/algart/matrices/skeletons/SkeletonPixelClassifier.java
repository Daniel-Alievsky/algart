package net.algart.matrices.skeletons;

import net.algart.arrays.*;

/**
 * <p>Classifier of pixels of skeletons (bit matrices, generated by skeletonization algorithms),
 * separating them into "nodes", "branch pixels" and other groups.
 * This class can be used together with {@link SkeletonScanner} class,
 * providing a full solution of analysing the structure of a skeleton.</p>
 *
 * <p>Note, that every type of skeletonization algorithm, generally speaking, requires a specific
 * pixel classifier, which "knows" all pixel configuration, that can appear in the results of that algorithm.
 * The class {@link BasicSkeletonPixelClassifier2D} offers ready pixel classifiers for
 * {@link OctupleThinningSkeleton2D}, {@link Quadruple3x5ThinningSkeleton2D} and
 * {@link StrongQuadruple3x5ThinningSkeleton2D} algorithms.</p>
 *
 * <h4>Pixel types</h4>
 *
 * <p>The main purpose of this class is detecting the <i>type</i> of each skeleton pixel:
 * is it a node, a branch pixel, an isolated pixel, or, maybe,
 * an "illegal" pixel which cannot appear in a correct skeleton.
 * More precisely:</p>
 *
 * <ol>
 * <li>we call a pixel (a unit element of the skeleton matrix)
 * <i>{@link #TYPE_USUAL_BRANCH usual branch pixel}</i>, if this element
 * of the skeleton has strictly 2 unit neighbour elements;</li>
 * <li>we call a pixel <i>{@link #TYPE_FREE_BRANCH_END free branch end}</i>,
 * if this element of the skeleton has strictly 1 unit neighbour element;</li>
 * <li>we call a pixel <i>{@link #TYPE_ISOLATED isolated}</i>, if this element
 * of the skeleton has no neighbour elements;</li>
 * <li>we call a pixel "<i>{@link #TYPE_ILLEGAL illegal}</i>", if analysis of some close neighbourhood of this pixel
 * (usually 3x3 or 5x5) allows to conclude, that this pixel cannot belong to a skeleton of the concrete
 * analysed kind;</li>
 * <li><a name="groupAttachable"></a>in other cases, i.e. if a unit pixel has <i>k</i>&ge;3 neighbours
 * and is not "illegal", we call it either <i>{@link #TYPE_USUAL_NODE node}</i>, or an
 * <i>{@link #isAttachableBranchEndPixelType(int) attachable branch end}</i>.
 * The concrete implementation of this abstract class defines, which of such pixels are considered to be nodes,
 * and which are considered to be attachable branch ends. For each attachable branch end <i>E</i>,
 * this class also detects two from its <i>k</i> neighbours with special roles:
 *     <ol type="A">
 *     <li>the 1st of them, <i>A</i>, is always {@link #TYPE_USUAL_NODE node} and is called "<i>attached node</i>"
 *     (so there is a guarantee that an attachable branch end is always have a node among neighbours),</li>
 *     <li>the 2nd, <i>B</i>, is called "an element of <i>attaching branch</i>" and it is:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;&mdash; either really a branch pixel: {@link #TYPE_USUAL_BRANCH usual},
 *     {@link #TYPE_FREE_BRANCH_END free end} or {@link #isAttachableBranchEndPixelType(int) attachable}
 *     (that means: this branch is "extended" with this attachable pixel <i>E</i> to achieve the node <i>A</i>),<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;&mdash; or another {@link #TYPE_USUAL_NODE node} (that means:
 *     we have 1-pixel branch <i>A</i>&ndash;<i>E</i>&ndash;<i>B</i>, connecting nodes <i>A</i> and <i>B</i>).</li>
 *     </ol>
 * (Note that if the skeleton contains "illegal" pixels, they also may be detected as "attached node"
 * and "an element of attaching branch");</li>
 * <li>the last possible case is trivial: <i>{@link #TYPE_ZERO zero}</i> element of the skeleton matrix.
 * </ol>
 *
 * <h4>Nodes, branches, degenerated branches</h4>
 *
 * <p>As a result of detecting pixel types, this class separates all unit pixels of the correct skeleton,
 * generated by some skeletonization algorithm (and, so, not containing "{@link #TYPE_ILLEGAL illegal}" pixels),
 * into the following categories:</p>
 *
 * <ul>
 * <li><i>{@link #TYPE_USUAL_NODE nodes}</i>, detected in the 5th group above,</li>
 * <li><i>branches</i>, consisting of {@link #TYPE_USUAL_BRANCH usual branch pixels},
 * {@link #TYPE_FREE_BRANCH_END free branch ends} and
 * {@link #isAttachableBranchEndPixelType(int) attachable branch ends},</li>
 * <li>and also {@link #TYPE_ISOLATED isolated pixels}: a special case,
 * that can be considered as a special kind of nodes without incident branches.</li>
 * </ul>
 *
 * <p>If two {@link #TYPE_USUAL_NODE nodes} or {@link #TYPE_FREE_BRANCH_END free branch ends} are neighbours
 * (in straight-and-diagonal connectivity terms, see <a href="#connectivity">below</a>),
 * then they may be considered to be connected with a <i>degenerated branch</i>, consisting of 0 pixels.
 * If at least one of them is a {@link #TYPE_FREE_BRANCH_END free branch end},
 * then we always consider them to be connected with a degenerated branch.
 * If both are {@link #TYPE_USUAL_NODE nodes}, then the decision, whether these neighbouring nodes
 * are connected with a degenerated branch, is made by
 * {@link #markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])} method;
 * it is used in {@link SkeletonScanner#adjacentBranches()} method.</p>
 *
 * <h4>About the nonoriented graph, formed by the skeleton</h4>
 *
 * <p>This class guarantees that if the skeleton is correct (contains no "illegal" pixels),
 * then the nodes and branches form a <i>correct skeleton nonoriented graph</i>,
 * with skeleton {@link #TYPE_USUAL_NODE nodes}, {@link #TYPE_FREE_BRANCH_END free branch ends} and
 * {@link #TYPE_ISOLATED isolated pixels} in a role of graph nodes,
 * and skeleton branches (excluding free branch ends) in a role of graph edges.
 * "Correct" graph means that:</p>
 *
 * <ol type="I">
 * <li>each connected component of the skeleton (bit matrix) corresponds to a connected component of this graph;</li>
 * <li>any branch is a connected series of 0, 1 or more unit pixels, connecting strictly 2 different
 * {@link #TYPE_USUAL_NODE nodes} or {@link #TYPE_FREE_BRANCH_END free branch ends} (playing the role
 * of graph nodes: ends of the corresponding graph edge).
 * For nondegenerate branches (containing at least 1 pixel between ending nodes or
 * free branch ends), all their pixels belong to "{@link #TYPE_USUAL_BRANCH usual branch pixels}" type
 * (strictly 2 unit neighbours) or "{@link #isAttachableBranchEndPixelType(int) attachable branch end}" type
 * (having 3 or more unit neighbours), and only the first and the last among them can be attachable ends.
 * If the first or the last pixel, really, is an attachable end,
 * then it is considered that the <i>attached node A</i>, defined above in the
 * <a href="#groupAttachable">description of group 5</a> of pixel types,
 * plays the role of the corresponding graph node, incident with the given branch/edge.
 * The pixel <i>B</i> (see the <a href="#groupAttachable">description of group 5</a>) plays the role of
 * the second graph node, incident with the given branch/edge, if it is a {@link #TYPE_USUAL_NODE node} or
 * a {@link #TYPE_FREE_BRANCH_END free branch end}: it means that we have 1-pixel branch;</li>
 * <li>there is the only possible exception from the rules I and II: if a skeleton contains <i>cyclic branches</i>,
 * i.e. connected components consisting of usual branch pixels only (thin 1-pixel closed lines, where every pixel
 * has strictly 2 unit neighbours), then such branches do not connect any nodes and
 * do not form any elements of the graph ({@link SkeletonScanner} class recognizes
 * such branches separately);</li>
 * <li>nodes of the graph have 0, 1 or &ge;3 incident edges, but never have 2 incident edges.</li>
 * </ol>
 *
 * <p>See more detailed and formal definition of the nonoriented graph, formed by the skeleton, in the comments
 * to {@link SkeletonScanner} class.</p>
 *
 * <h4>Base functions of this class</h4>
 *
 * <p>One instance of this class can process different skeletons (bit matrices), but all they
 * must have the fixed number of dimensions, returned by {@link #dimCount()} method.</p>
 *
 * <p>The main method of this class is</p>
 * <blockquote>{@link #asPixelTypes(Matrix, SkeletonPixelClassifier.AttachmentInformation)},
 * </blockquote>
 * <p>which performs classification of pixels of the given skeleton matrix. The second important method of
 * this class is</p>
 * <blockquote>{@link #markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])},
 * </blockquote>
 * <p>which allows to decide, whether two neighbouring nodes should be considered as connected with a degenerated
 * 0-pixel branch. (It is the only situation, when the results of {@link #asPixelTypes asPixelTypes} are
 * not enough to recognize, whether two nodes of skeleton nonoriented graph should be connected with an edge.)
 * This class also provides {@link #neighbourOffset(int)} method, which specifies
 * some order of the <nobr>3<sup><i>n</i></sup>&minus;1</nobr> neighbours, <i>n</i>={@link #dimCount()},
 * of each matrix element and is necessary for interpretation of non-negative values, returned by
 * {@link #asPixelTypes asPixelTypes} method.</p>
 *
 * <h4><a name="connectivity"></a>Connectivity model (straight-and-diagonal) and "neighbour" term</h4>
 *
 * <p>Note that this class, as well as {@link SkeletonScanner}, supposes
 * the <i>straight-and-diagonal</i> connectivity kind: see
 * {@link net.algart.matrices.scanning.ConnectivityType#STRAIGHT_AND_DIAGONAL}. It means, that all skeletons
 * are supposed to be connected in terms of this connectivity: every connected component of the skeleton matrix
 * is a "carcass" or "skeleton" of some connected component of the original matrix, for which this skeleton
 * was built.</p>
 *
 * <p>So, the term "<b><i>neighbour</i></b>" of some pixel (matrix element) in this class
 * and in {@link SkeletonScanner} always means another pixel (matrix element), so that</p>
 *
 * <blockquote>max&nbsp;(|<i>i</i><sub><i>k</i></sub>&minus;<i>j</i><sub><i>k</i></sub>|)=1</blockquote>
 *
 * <p>where <nobr><i>i</i><sub>0</sub>, <i>i</i><sub>1</sub>, ..., <i>i</i><sub><i>n</i>-1</sub></nobr>
 * are coordinates of the first pixel and
 * <nobr><i>j</i><sub>0</sub>, <i>j</i><sub>1</sub>, ..., <i>j</i><sub><i>n</i>-1</sub></nobr>
 * are coordinates of the second pixel (a neighbour of the first one). In 2-dimensional case,
 * such connectivity kind is also called <i>8-connectivity</i>.</p>
 *
 * <h4>Example of results</h4>
 *
 * <p>Below is a simple example of 2-dimensional skeleton, the pixels of which are classified by this class
 * into nodes (<tt>N</tt>), usual branch pixels (<tt>b</tt>), free branch ends (<tt>E</tt>),
 * attachable branch ends (<tt>a</tt>) and isolated pixels (<tt>I</tt>):</p>
 *
 * <pre>
 * . . . . . . . . . . . . . . . . .
 * . . . . . . <b>E</b> . . . . . . . . . .
 * . . <b>E</b> . . . b . . <b>E</b> . . <b>I</b> . <b>E</b> <b>E</b> .
 * . . . b a <b>N</b> . . b . . . . . . . .
 * . . . . . a . . a . b <b>E</b> . . . <b>I</b> .
 * . . . . . . b a <b>N</b> <b>N</b> . . . . . . .
 * . . . . . . . . a . . . . <b>E</b> . . .
 * . . b b . . . . b . . . . b . . .
 * . b . . b . . <b>E</b> . . . . . <b>E</b> . . .
 * . b . . . b . . . . . . . . . <b>E</b> .
 * . b . . . b . . . . . . . b b . .
 * . . b b b . . . . <b>E</b> b b b . . . .
 * . . . . . . . . . . . . . . . . .</pre>
 *
 * <p>In the left bottom part you can see an example of a cyclic branch, consisting only of usual branch pixels
 * (<tt>b</tt>).</p>
 *
 * <h4>Creating instances of this class</h4>
 *
 * <p>This class is designed for a case of any number of dimensions, though, of course, the most popular
 * case is 2-dimensional. This package provides the following 2-dimensional full implementation of this class:</p>
 *
 * <ul>
 * <li>{@link BasicSkeletonPixelClassifier2D}</li>
 * </ul>
 *
 * <p>You can also extend the skeletal implementation of this class:
 * {@link ApertureBasedSkeletonPixelClassifier}.</p>
 *
 * <h4>Pseudo-cyclic continuation</h4>
 *
 * <p>This class supposes that the processed matrix is infinitely pseudo-cyclically continued, as well
 * {@link net.algart.arrays.Matrices#asShifted Matrices.asShifted} method supposes it.
 * You can change this behavior by appending the source matrix with zero elements
 * by calling <nobr>{@link Matrix#subMatrix(long[], long[], Matrix.ContinuationMode)}</nobr> method,
 * where the dimensions of the "submatrix" are greater than dimensions of the source one by 1
 * and the <tt>continuationMode</tt> argument is {@link net.algart.arrays.Matrix.ContinuationMode#ZERO_CONSTANT}.</p>
 *
 * <h4>Multithread compatibility</h4>
 *
 * <p>This class and its inheritors from this package are <b>immutable</b> and <b>thread-safe</b>:
 * there are no ways to modify settings of the created instance.</p>
 *
 * <p>AlgART Laboratory 2007-2013</p>
 *
 * @author Daniel Alievsky
 * @version 1.2
 * @since JDK 1.5
 * @see SkeletonScanner
 */
public abstract class SkeletonPixelClassifier {
    /**
     * <p>Style of interpretation of non-negative results while detecting pixel types of the skeleton.
     * See comments to {@link SkeletonPixelClassifier#asPixelTypes(Matrix,
     * SkeletonPixelClassifier.AttachmentInformation)} method.</p>
     *
     * <p>This class is <b>immutable</b> and <b>thread-safe</b>:
     * there are no ways to modify settings of the created instance.</p>
     */
    public static enum AttachmentInformation {
        /**
         * Indicates that {@link SkeletonPixelClassifier#asPixelTypes asPixelTypes} method must return,
         * for attachable branch ends, the direction (neighbour index) towards the branch,
         * to which this pixel should be attached.
         */
        NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH,

        /**
         * Indicates that {@link SkeletonPixelClassifier#asPixelTypes asPixelTypes} method must return,
         * for attachable branch ends, the direction (neighbour index) towards the node,
         * which is one of the ends of the branch.
         */
        NEIGHBOUR_INDEX_OF_ATTACHED_NODE
    }

    /**
     * <i>Node</i> pixel type for a skeleton matrix.
     * (This value can appear in the result of {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Such matrix element is always unit and also has &ge;3 unit neighbours,
     * but these conditions are not enough: unit element with &ge;3 unit neighbours may be not only a node,
     * but also an {@link #isAttachableBranchEndPixelType(int) attachable branch end}.
     * Strict definition of node pixels may depend on the implementation of {@link #asPixelTypes asPixelTypes} method,
     * &mdash; but it is chosen in such a way, that the nodes and branches form a correct skeleton nonoriented graph,
     * as written in the {@link SkeletonPixelClassifier comments to this class}.
     * Informally, this pixel type indicates the situation
     * when 3 or more thin connected 1-pixel branches meet.
     *
     * <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as a node of the graph,
     * where 3 or more edges meet.
     *
     * <p>Below are typical examples for 2D case:
     * <pre>
     * . . . . 1      . . 1 . .
     * 1 1 . 1 .      . . 1 . .
     * . . <b>1</b> . .  or  1 1 <b>1</b> 1 1
     * . . 1 . .      . . 1 . .
     * . . 1 . .      . . 1 . .</pre>
     *
     * <p>This constant is {@value}.
     */
    public static final int TYPE_USUAL_NODE = -1;

    /**
     * <i>Isolated</i> pixel type for a skeleton matrix.
     * (This value can appear in the result of {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Formal definition: a matrix element is an isolated pixel
     * if and only if this element is unit and has no unit neighbours.
     *
     * <p>In the nonoriented graph, formed by the skeleton, such pixel
     * is treated as a special degenerated case of a node.
     *
     * <p>This situation is shown below for 2D case:
     * <pre>
     * . . . . .
     * . . . . .
     * . . <b>1</b> . .
     * . . . . .
     * . . . . .</pre>
     *
     * <p>This constant is {@value}.
     */
    public static final int TYPE_ISOLATED = -2;

    /**
     * <i>Free branch end</i> pixel type for a skeleton matrix.
     * (This value can appear in the result of {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Formal definition: a matrix element is a free branch end
     * if and only if this element is unit and has exactly 1 unit neighbour.
     *
     * <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as a node of the graph,
     * having 1 incident edge.
     *
     * <p>Below is a typical example for 2D case:
     * <pre>
     * . . . . .
     * 1 1 . . .
     * . . <b>1</b> . .
     * . . . . .
     * . . . . .</pre>
     *
     * <p>This constant is {@value}.
     */
    public static final int TYPE_FREE_BRANCH_END = -3;

    /**
     * <i>Usual branch</i> pixel type for a skeleton matrix.
     * (This value can appear in the result of {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Formal definition: a matrix element is a usual branch pixel
     * if and only if this element is unit and has exactly 2 unit neighbours.
     *
     * <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as an internal pixel
     * of an edge of the graph.
     *
     * <p>Below is a typical example for 2D case:
     * <pre>
     * . . . . .
     * 1 1 . . .
     * . . <b>1</b> 1 .
     * . . . . 1
     * . . . . .</pre>
     *
     * <p>This constant is {@value}.
     */
    public static final int TYPE_USUAL_BRANCH = -4;

    /**
     * <i>"Illegal"</i> pixel type for a skeleton matrix.
     * (This value can appear in the result of {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Strict definition of "illegal" pixels may depend on the implementation
     * of {@link #asPixelTypes asPixelTypes} method,
     * &mdash; but it is chosen in such a way, that the unit elements of a correct skeleton,
     * built by the corresponding skeletonization algorithm (on which this implementation
     * of this class is oriented), cannot be "illegal".
     * Informally, this pixel type indicates an impossible configuration
     * for a correct result of the given skeletonization algorithm,
     * where it is impossible to decide, is it a node or an element of a branch.
     *
     * <p>Below is a possible example for 2D case:
     * <pre>
     * 1 1 1 1 1
     * 1 1 1 1 1
     * 1 1 <b>1</b> 1 1
     * . . . . .
     * . . . . .</pre>
     * <p>(in most skeletonization algorithms, the bottom row of unit pixels should be removed here).
     *
     * <p>This value is negative; the concrete value is undocumented and can be changed in future versions.
     */
    public static final int TYPE_ILLEGAL = -5;

    /**
     * <i>Zero</i> element type for a skeleton matrix.
     * (This value can appear in the result of {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Formal definition: any zero matrix element.
     *
     * <p>Obviously, such pixels are not used while forming the skeleton nonoriented graph.
     *
     * <p>This value is negative; the concrete value is undocumented and can be changed in future versions.
     */
    public static final int TYPE_ZERO = -6;

    /**
     * Minimal from 3 adjacent values {@link #TYPE_USUAL_NODE}, {@link #TYPE_ISOLATED} and {@link #TYPE_FREE_BRANCH_END}.
     * This constant is {@value}.
     */
    public static final int TYPE_NODE_OR_BRANCH_END_MIN = TYPE_FREE_BRANCH_END;

    /**
     * Maximal from 3 adjacent values {@link #TYPE_USUAL_NODE}, {@link #TYPE_ISOLATED} and {@link #TYPE_FREE_BRANCH_END}.
     * This constant is {@value}.
     */
    public static final int TYPE_NODE_OR_BRANCH_END_MAX = TYPE_USUAL_NODE;

    /**
     * Minimal from 2 adjacent values
     * {@link #TYPE_FREE_BRANCH_END}, {@link #TYPE_USUAL_BRANCH}.
     * This constant is {@value}.
     */
    public static final int TYPE_BRANCH_MIN = TYPE_USUAL_BRANCH;

    /**
     * Maximal from 2 adjacent values
     * {@link #TYPE_FREE_BRANCH_END}, {@link #TYPE_USUAL_BRANCH}.
     * This constant is {@value}.
     */
    public static final int TYPE_BRANCH_MAX = TYPE_FREE_BRANCH_END;

    /**
     * The number of dimensions, returned by {@link #dimCount()} method.
     */
    protected final int dimCount;

    /**
     * The number of neighbours of each matrix element, returned by {@link #numberOfNeighbours()} method.
     * Equal to 3<sup><i>n</i></sup>&minus;1, <i>n</i>={@link #dimCount}
     * (the number of elements of 3x3x...x3 hypercube without the central element).
     */
    protected final int numberOfNeighbours;

    /**
     * Creates new instance of this class, allowing to process skeletons with the given number of dimensions.
     * The number of dimensions must not be greater than
     * <nobr><tt>(int)</tt>log<sub>3</sub>(2<sup>31</sup>&minus;1)=19</nobr>:
     * this condition provides a guarantee that the number of neighbours, returned by
     * {@link #numberOfNeighbours()} method, can be represented by <tt>int</tt> Java type.
     *
     * @param dimCount the number of dimensions, which will be returned by {@link #dimCount()} method.
     * @throws IllegalArgumentException if <tt>dimCount &le; 0</tt> or
     *                                  if 3<sup><tt>dimCount</tt></sup> &gt;
     *                                  <tt>Integer.MAX_VALUE</tt>=2<sup>31</sup>&minus;1.
     */
    protected SkeletonPixelClassifier(int dimCount) {
        if (dimCount <= 0)
            throw new IllegalArgumentException("Zero or negative dimCount");
        long m = 1;
        for (int k = 0; k < dimCount; k++) {
            m *= 3;
            if (m > Integer.MAX_VALUE)
                throw new IllegalArgumentException("Too large number of dimensions " + dimCount
                    + " of the skeleton matrix: 3x3x3x... aperture contains more than 2^31-1=" + Integer.MAX_VALUE
                    + " elements");
        }
        this.dimCount = dimCount;
        this.numberOfNeighbours = (int)(m - 1);
    }

    /**
     * Returns <tt>true</tt> if this pixel type is indicates a node, i&#46;e&#46; a unit element
     * where 3 or more thin connected 1-pixel branches meet or, as a degenerated case, an isolated pixel:
     * a unit element having no unit neighbours.
     * Equivalent to
     * <nobr><tt>pixelType == {@link #TYPE_USUAL_NODE} || pixelType == {@link #TYPE_ISOLATED}</tt></nobr>.
     *
     * <p>Note that all unit pixels in the skeleton, excepting {@link #isIllegalPixelType(int) "illegal"},
     * are separated into 2 groups:
     * nodes (including isolated pixels as a degenerated case),
     * for which this method returns <tt>true</tt>,
     * and branch pixels, for which {@link #isBranchPixelType(int)} returns <tt>true</tt>.
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates a node,
     *                  including the degenerated case of an isolated pixel.
     */
    public static boolean isNodePixelType(int pixelType) {
        return pixelType == TYPE_USUAL_NODE || pixelType == TYPE_ISOLATED;
    }

    /**
     * Returns <tt>true</tt> if this pixel type indicates a usual branch pixel,
     * i&#46;e&#46; a unit pixel having exactly 2 unit neighbours.
     * Equivalent to
     * <nobr><tt>pixelType == {@link #TYPE_USUAL_BRANCH}</tt></nobr>.
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates a usual (non-ending) branch pixel.
     */
    public static boolean isUsualBranchPixelType(int pixelType) {
        return pixelType == TYPE_USUAL_BRANCH;
    }

    /**
     * Returns <tt>true</tt> if this pixel type indicates a free branch end,
     * i&#46;e&#46; a unit pixel having exactly 1 unit neighbour.
     * Equivalent to
     * <nobr><tt>pixelType == {@link #TYPE_FREE_BRANCH_END}</tt></nobr>.
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates a free branch end.
     */
    public static boolean isFreeBranchEndPixelType(int pixelType) {
        return pixelType == TYPE_FREE_BRANCH_END;
    }

    /**
     * Returns <tt>true</tt> if this pixel type indicates an <i>attachable branch end</i>,
     * i&#46;e&#46; a unit pixel having 3 or more unit neighbours,
     * which this class considers to be not a node, but an ending pixel of some branch.
     * Equivalent to
     * <nobr><tt>pixelType >= 0</tt></nobr>.
     * (The value of <tt>pixelType</tt> argument can appear in the result of
     * {@link #asPixelTypes asPixelTypes} method.)
     *
     * <p>Such matrix element is always unit and also has &ge;3 unit neighbours, as {@link #TYPE_USUAL_NODE nodes},
     * but it is not considered to be a node.
     * Strict definition of attachable branch ends may depend on the implementation of
     * {@link #asPixelTypes asPixelTypes} method,
     * &mdash; but it is chosen in such a way, that the nodes and branches form a correct skeleton nonoriented graph,
     * as written in the {@link SkeletonPixelClassifier comments to this class}.
     * Informally, this pixel type indicates an ending pixel of
     * a thin connected 1-pixel branch, which approaches a node,
     * when the number of neighbours of this pixel is greater than 2.
     *
     * <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as an internal pixel
     * of an edge of the graph, as well as {@link #TYPE_USUAL_BRANCH usual branch pixels}.
     *
     * <p>Below is a typical example for 2D case:
     * <pre>
     * . . 1 . .
     * . . <b>1</b> . .
     * 1 <b>1</b> <i>1</i> <b>1</b> 1
     * . . <b>1</b> . .
     * . . 1 . .</pre>
     *
     * <p>4 unit pixels near the center can be considered as attachable branch ends.
     * All they have 4 unit neighbours, but it is clear that there is no sense
     * to consider them as nodes &mdash; unlike the center, which also has 4 unit neighbours and is an obvious node.
     *
     * <p>Another example:
     * <pre>
     * 1 1 . . . 1 1
     * . . 1 . <b>1</b> . .
     * . . . <b>1</b> <i>1</i> . .
     * . . . . . 1 .
     * . . . . . . 1</pre>
     * <p>The central unit pixel and its right diagonal neighbour (marked out by bold font)
     * can be considered as attachable branch ends. They have 3 unit neighbours,
     * but it is clear that they may be treated as end elements of the corresponding branches &mdash;
     * unlike the true node to the right from the center (marked out by italic font).
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates an attachable branch end,
     *                  i.e. if it is non-negative.
     */
    public static boolean isAttachableBranchEndPixelType(int pixelType) {
        return pixelType >= 0;
    }

    /**
     * Returns <tt>true</tt> if this pixel type is indicates a node
     * (<tt>{@link #isNodePixelType(int) isNodePixelType}(pixelType)</tt> returns <tt>true</tt>)
     * or a free branch end
     * (<tt>{@link #isFreeBranchEndPixelType(int) isFreeBranchEndPixelType}(pixelType)</tt> returns <tt>true</tt>).
     * Equivalent to<br>
     * <nobr><tt>pixelType &gt;= {@link #TYPE_NODE_OR_BRANCH_END_MIN} &&
     * pixelType &lt;= {@link #TYPE_NODE_OR_BRANCH_END_MAX}</tt></nobr>.
     *
     * <p>Note that all such pixels (nodes and free branch ends) corresponds to
     * nodes of a graph, describing the geometric structure of the skeleton
     * (branches correspond to edges in that graph).
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates a node or a free branch end.
     */
    public static boolean isNodeOrFreeBranchEndPixelType(int pixelType) {
        return pixelType >= TYPE_NODE_OR_BRANCH_END_MIN && pixelType <= TYPE_NODE_OR_BRANCH_END_MAX;
    }

    /**
     * Returns <tt>true</tt> if this pixel type is indicates a branch element: usual
     * (where <tt>{@link #isUsualBranchPixelType(int) isUsualBranchPixelType}(pixelType)</tt>
     * returns <tt>true</tt>), free branch end
     * (where <tt>{@link #isFreeBranchEndPixelType(int) isFreeBranchEndPixelType}(pixelType)</tt>
     * returns <tt>true</tt>) or attachable branch end
     * (where <tt>{@link #isAttachableBranchEndPixelType(int) isAttachablePixelType}(pixelType)</tt>
     * returns <tt>true</tt>).
     * Equivalent to<br>
     * <nobr><tt>pixelType &gt;= 0 ||
     * (pixelType &gt;= {@link #TYPE_BRANCH_MIN} && pixelType &lt;= {@link #TYPE_BRANCH_MAX})</tt></nobr>.
     *
     * <p>Note that all unit pixels in the skeleton, excepting {@link #isIllegalPixelType(int) "illegal"},
     * are separated into 2 groups:
     * nodes (including isolated pixels as a degenerated case),
     * for which {@link #isNodePixelType(int)} returns <tt>true</tt>,
     * and branch pixels, for which this method returns <tt>true</tt>.
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates some element of a branch.
     */
    public static boolean isBranchPixelType(int pixelType) {
        return pixelType >= 0 || (pixelType >= TYPE_BRANCH_MIN && pixelType <= TYPE_BRANCH_MAX);
    }

    /**
     * Returns <tt>true</tt> if this pixel type indicates that the pixel is a center of an impossible configuration
     * for a correct result of the given skeletonization algorithm.
     * Equivalent to
     * <nobr><tt>pixelType == {@link #TYPE_ILLEGAL}</tt></nobr>.
     *
     * @param pixelType pixel type: possible element of the result of {@link #asPixelTypes asPixelTypes} method.
     * @return          <tt>true</tt> if this type indicates an incorrect configuration of the pixel's neighbours.
     */
    public static boolean isIllegalPixelType(int pixelType) {
        return pixelType == TYPE_ILLEGAL;
    }
    /**
     * Returns the number of dimensions of the matrices, which can be processed by this object.
     * In {@link SkeletonScanner}, equivalent to
     * <nobr><tt>{@link SkeletonScanner#skeleton() skeleton()}.{@link Matrix#dimCount() dimCount()}</tt></nobr>.
     *
     * @return the number of dimensions of the matrices, which can be processed by this object.
     */
    public final int dimCount() {
        return this.dimCount;
    }

    /**
     * Returns the number of neighbours of each element of a skeleton matrix, in terms
     * of straight-and-diagonal connectivity kind.
     * Equal to 3<sup><i>n</i></sup>&minus;1, <i>n</i>={@link #dimCount()}
     * (the number of elements of 3x3x...x3 hypercube without the central element).
     * In particular, in 2-dimensional case this method returns 3<sup>2</sup>-1=8,
     * and in 3-dimensional case this method returns 3<sup>3</sup>-1=26.
     *
     * @return the number of neighbours of every element.
     */
    public final int numberOfNeighbours() {
        return this.numberOfNeighbours;
    }

    /**
     * Returns the differences of all coordinates of the neighbour of some (central) element with the given index
     * and the coordinates of this central element.
     * In other words, if <nobr><i>i</i><sub>0</sub>, <i>i</i><sub>1</sub>, ..., <i>i</i><sub><i>n</i>-1</sub></nobr>
     * are coordinates of the some element of a skeleton matrix (<i>n</i>={@link #dimCount()}),
     * and we need to find the coordinates
     * <nobr><i>j</i><sub>0</sub>, <i>j</i><sub>1</sub>, ..., <i>j</i><sub><i>n</i>-1</sub></nobr>
     * of its neighbour #<i>k</i>, 0&le;<i>k</i>&lt;{@link #numberOfNeighbours() numberOfNeighbours()},
     * we should use the following formula:
     * <blockquote>
     * <i>j<sub>i</sub></i> = <i>i<sub>i</sub></i> + <tt>offset[</tt><i>i</i><tt>]</tt>,
     * </blockquote>
     * <p>where <tt>offset</tt> is the result of calling this method with <tt>neighbourIndex</tt>=<i>k</i>.
     *
     * <p>The returned array is always a newly allocated Java array.
     * Its length is always equal to {@link #dimCount()}.
     * Its elements will be always same while different calls of this method for the same object
     * (implementing this class) with the same <tt>neighbourIndex</tt> argument.
     * The elements of the returned array are always equal to <tt>-1</tt>, <tt>0</tt> or <tt>+1</tt>,
     * and all they cannot be <tt>0</tt> simultaneously.
     *
     * <p>This method defines some <i>order</i> of enumerating neighbours.
     * This order can be different in different implementations.
     * In {@link BasicSkeletonPixelClassifier2D} implementation,
     * the order of neighbours is described by the following diagram:
     * <pre>
     * 0 1 2
     * 7 <b><i>C</i></b> 3
     * 6 5 4</pre>
     * <p>(the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).
     * It means that the results of this method in {@link BasicSkeletonPixelClassifier2D} are the following:
     * for <tt>neighbourIndex=0</tt> it returns two-element array <tt><nobr>{-1,-1}</nobr></tt>,
     * for <tt>neighbourIndex=1</tt> it returns two-element array <tt><nobr>{0,-1}</nobr></tt>,
     * for <tt>neighbourIndex=2</tt> it returns two-element array <tt><nobr>{1,-1}</nobr></tt>,
     * for <tt>neighbourIndex=3</tt> it returns two-element array <tt><nobr>{1,0}</nobr></tt>,
     * for <tt>neighbourIndex=4</tt> it returns two-element array <tt><nobr>{1,1}</nobr></tt>,
     * for <tt>neighbourIndex=5</tt> it returns two-element array <tt><nobr>{0,1}</nobr></tt>,
     * for <tt>neighbourIndex=6</tt> it returns two-element array <tt><nobr>{-1,1}</nobr></tt>,
     * for <tt>neighbourIndex=7</tt> it returns two-element array <tt><nobr>{-1,0}</nobr></tt>.
     * In other words, {@link BasicSkeletonPixelClassifier2D} class enumerates
     * the neighbours along the perimeter of 3x3 square.
     *
     * <p>This method is completely implemented via {@link #neighbourOffset(long[], int)} method.
     *
     * @param neighbourIndex an index if the neighbour of some central element of a matrix.
     * @return               shifts along all coordinates from the central element to this neighbour.
     * @throws IndexOutOfBoundsException if <tt>neighbourIndex</tt> is out of range
     *                                   <tt>0..{@link #numberOfNeighbours() numberOfNeighbours()}-1</tt>.
     * @see SkeletonScanner#neighbourOffsetInArray(int)
     */
    public final long[] neighbourOffset(int neighbourIndex) {
        long[] coordinateIncrements = new long[dimCount];
        neighbourOffset(coordinateIncrements, neighbourIndex);
        return coordinateIncrements;
    }

    /**
     * More efficient version of {@link #neighbourOffset(int) neighbourOffset(int)} method,
     * which stores the results in the passed Java array instead of creating new Java array.
     * This method is equivalent to calling that method and copying its result into
     * <tt>coordinateIncrements</tt> argument, but does not allocate any arrays.
     * It is a better solution if we need to calculate neighbour offsets in a long loop,
     * because allows to avoid allocating a lot of short arrays.
     *
     * <p>The length of the passed array must be equal to {@link #dimCount() the number of dimensions}
     * of processed matrices.
     *
     * @param coordinateIncrements Java array for storing the differences of all coordinates of
     *                             the neighbour #<tt>neighbourIndex</tt> of some (central) element
     *                             and the coordinates of this central element.
     * @param neighbourIndex       an index if the neighbour of some central element of the matrix.
     * @throws NullPointerException     if <tt>coordinateIncrements</tt> argument is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>coordinateIncrements.length!={@link #dimCount()}</tt>.
     * @throws IndexOutOfBoundsException if <tt>neighbourIndex</tt> is out of range
     *                                   <tt>0..{@link #numberOfNeighbours() numberOfNeighbours()}-1</tt>.
     * @see SkeletonScanner#neighbourOffsetInArray(int)
     */
    public abstract void neighbourOffset(long[] coordinateIncrements, int neighbourIndex);

    /**
     * Returns an index of such neighbour <i>B</i> of some element <i>A</i> of a skeleton matrix,
     * so that the element <i>A</i> is the neighbour with the specified index <tt>neighbourIndex</tt>
     * of its neighbour <i>B</i>.
     * Both neighbour indexes are considered in terms of {@link #neighbourOffset(int) neighbourOffset(int)} method.
     * It means, that if <tt>k1</tt> is the argument of this method and <tt>k2</tt> is the result of this method,
     * <nobr><tt>offset1={@link #neighbourOffset(int) neighbourOffset}(k1)</tt></nobr> and
     * <nobr><tt>offset2={@link #neighbourOffset(int) neighbourOffset}(k2)</tt></nobr>,
     * then
     * <blockquote>
     * <tt>offset2[<i>i</i>] = -offset1[<i>i</i>]</tt> for all <i>i</i>.
     * </blockquote>
     *
     * <p>For example, in {@link BasicSkeletonPixelClassifier2D} class (which enumerates 8 neighbours along
     * the perimeter of 3x3 square) this method returns <tt>(neighbourIndex+4)%8</tt>.
     *
     * @param neighbourIndex an index of some neighbour <i>B</i> of some central element <i>A</i>.
     * @return               an index of the central element <i>A</i> as a neighbour of the element <i>B</i>.
     * @throws IndexOutOfBoundsException if <tt>neighbourIndex</tt> is out of range
     *                                   <tt>0..{@link #numberOfNeighbours() numberOfNeighbours()}-1</tt>.
     */
    public abstract int reverseNeighbourIndex(int neighbourIndex);

    /**
     * Returns an immutable view of the passed skeleton matrix, where each element is an integer,
     * specifying the type of the corresponding pixel of the skeleton. The number of dimensions of
     * the passed matrix must be equal to {@link #dimCount() dimCount()}.
     *
     * <p>More precisely, let's consider that <tt>skeleton</tt> matrix is the result of some skeletonization
     * algorithm (chosen while creating an instance of this class). The resulting matrix will
     * contain the following values:
     *
     * <ol>
     * <li>{@link #TYPE_ZERO}, if the corresponding element of the skeleton is zero (no pixel);</li>
     * <li>{@link #TYPE_ILLEGAL}, if here is an impossible configuration for a correct result of the given
     * skeletonization algorithm (probable case, if the passed matrix is really not a skeleton);</li>
     * <li>{@link #TYPE_USUAL_NODE}, if the corresponding element of the skeleton is a node, where 3 or more
     * branches meet;</li>
     * <li>{@link #TYPE_ISOLATED}, if the corresponding element of the skeleton is an isolated unit pixel,
     * having no unit neighbour elements;</li>
     * <li>{@link #TYPE_FREE_BRANCH_END}, if the corresponding element of the skeleton is an end of some branch,
     * having 1 unit neighbour elements;</li>
     * <li>{@link #TYPE_USUAL_BRANCH}, if the corresponding element of the skeleton has 2
     * unit neighbour elements;</li>
     * <li>some non-negative value in <tt>0..{@link #numberOfNeighbours() numberOfNeighbours()}-1</tt> range,
     * if the corresponding element of the skeleton has &ge;3 unit neighbour elements, but this class recommends
     * to consider this pixel not a node, but an additional {@link #isAttachableBranchEndPixelType(int)
     * "attached" element} of some branch. In this case, this value means the following:
     *     <ol type=A>
     *     <li>if <tt>attachmentInformation</tt> argument is
     *     {@link AttachmentInformation#NEIGHBOUR_INDEX_OF_ATTACHED_NODE},
     *     this value specifies the direction (neighbour index) towards the neighbouring node,
     *     which is one of the ends of this branch;
     *     there is a guarantee that this neighbour is either really {@link #TYPE_USUAL_NODE node} or, maybe,
     *     {@link #TYPE_ILLEGAL};</li>
     *     <li>if <tt>attachmentInformation</tt> argument is
     *     {@link AttachmentInformation#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH},
     *     this value specifies the direction (neighbour index) towards the branch,
     *     to which this pixel should be attached as its ending element;
     *     there is no guarantee that this neighbour is really a branch element, but it cannot be
     *     {@link #TYPE_ZERO zero} or {@link #TYPE_ISOLATED isolated}, and if it is a {@link #TYPE_USUAL_NODE node},
     *     it is supposed that we have a short branch to it, consisting of 1 pixel.</li>
     *     </ol>
     * See also the {@link SkeletonPixelClassifier comments to SkeletonPixelClassifier},
     * section "Pixel types", group 5.<br>
     * The direction is specified in terms of {@link #neighbourOffset(int) neighbourOffset(int)} method.
     * In {@link BasicSkeletonPixelClassifier2D}, it can be 0,1,2,3,4,5,6,7, corresponding to the following diagram:
     * <pre>
     * 0 1 2
     * 7 <b><i>C</i></b> 3
     * 6 5 4</pre>
     * <p>(the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).
     * Namely, if the current element has coordinates <nobr>(<i>x</i>,<i>y</i>)</nobr>,
     * then "0" value means attaching of the node with coordinates
     * <nobr>(<i>x</i>&minus;1,<i>y</i>&minus;1)</nobr> (the case A)
     * or attaching of the node to the branch containing the pixel
     * <nobr>(<i>x</i>&minus;1,<i>y</i>&minus;1)</nobr> (the case B),
     * "1" value means attaching of the node / to the branch <nobr>(<i>x</i>,<i>y</i>&minus;1)</nobr>,
     * "2" value means attaching of the node / to the branch <nobr>(<i>x</i>+1,<i>y</i>&minus;1)</nobr>,
     * "3" value means attaching of the node / to the branch  <nobr>(<i>x</i>+1,<i>y</i>)</nobr>,
     * "4" value means attaching of the node / to the branch  <nobr>(<i>x</i>+1,<i>y</i>+1)</nobr>,
     * "5" value means attaching of the node / to the branch  <nobr>(<i>x</i>,<i>y</i>+1)</nobr>,
     * "6" value means attaching of the node / to the branch  <nobr>(<i>x</i>&minus;1,<i>y</i>+1)</nobr>,
     * "7" value means attaching of the node / to the branch  <nobr>(<i>x</i>&minus;1,<i>y</i>)</nobr>.
     * </li>
     * </ol>
     *
     * <p>Note, that the situation, when some neighbouring elements are out of ranges of the matrix coordinates,
     * is processed according to the model of infinite pseudo-cyclical continuation &mdash;
     * see the end of the {@link SkeletonPixelClassifier comments to SkeletonPixelClassifier}.
     *
     * <p>Note, that all values, specified by constants of this class
     * (all cases 1-6 above, excepting the last case 7), are different negative integers.
     * Then, note that {@link #TYPE_USUAL_NODE}, {@link #TYPE_ISOLATED} and {@link #TYPE_FREE_BRANCH_END}
     * are adjacent integers {@value #TYPE_NODE_OR_BRANCH_END_MIN}..{@value #TYPE_NODE_OR_BRANCH_END_MAX}.
     * Then, note that two constants, corresponding to branches and their ends &mdash;
     * {@link #TYPE_FREE_BRANCH_END} and {@link #TYPE_USUAL_BRANCH} &mdash;
     * are also adjacent integers {@value #TYPE_BRANCH_MIN}..{@value #TYPE_BRANCH_MAX}.
     * Then, note that two constants, corresponding to nodes and isolated pixels &mdash;
     * {@link #TYPE_USUAL_NODE} and {@link #TYPE_ISOLATED} &mdash;
     * are also adjacent integers {@value #TYPE_ISOLATED}..{@value #TYPE_USUAL_NODE}.
     * This can be useful for extracting special kinds of skeleton pixels into bit matrices.</p>
     *
     * @param skeleton              the skeleton matrix that should be processed.
     * @param attachmentInformation what should this method return for attachable pixels.
     * @return                      the matrix of integer codes with the same sizes, describing the types
     *                              of all skeleton pixels.
     * @throws NullPointerException     if <tt>skeleton</tt> or <tt>attachmentInformation</tt> is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>skeleton.dimCount()!={@link #dimCount()}</tt>.
     */
    public abstract Matrix<? extends PIntegerArray> asPixelTypes(
        Matrix<? extends BitArray> skeleton,
        AttachmentInformation attachmentInformation);

    /**
     * Finds and marks, by assigning <tt>Integer.MIN_VALUE</tt> to corresponding elements of the passed Java array,
     * all neighbours of some {@link #TYPE_USUAL_NODE node}, which are also {@link #TYPE_USUAL_NODE nodes}
     * and are considered to be <i>not</i> connected with this node via a degenerated 0-pixel branch.
     * Neighbouring nodes, which are considered to be connected with the central node
     * via 0-pixel branch, stay unchanged.
     *
     * <p>More precisely, this method analyses the Java array <tt>pixelTypesOfAllNeighbours</tt>,
     * which contains the pixel types of all neighbours of some "central" pixel, which is supposed to be
     * a {@link #TYPE_USUAL_NODE node}, in the order, defined by
     * {@link #neighbourOffset(int) neighbourOffset(int)} method.
     * This method finds among them all values, equal to {@link #TYPE_USUAL_NODE}, and, if this class considers
     * that they should not be connected with the central node via degenerated branches, such values are
     * replaced with <tt>Integer.MIN_VALUE</tt> (which means "removing" these neighbours from candidates to
     * connection with the central node). So, if some elements of the passed array are
     * {@link #TYPE_USUAL_NODE} after calling this method as before,
     * it means that such neighbouring nodes should be considered as connected
     * with the central node via degenerated branches.
     *
     * <p>This method is used in {@link SkeletonScanner#adjacentBranches()} to correctly find all degenerated
     * branches, originating in the current node.
     *
     * <p>The passed array must contain at least {@link #numberOfNeighbours() numberOfNeighbours()} elements.
     * If it contains more elements, this method processes only first
     * {@link #numberOfNeighbours() numberOfNeighbours()} elements and ignores others.
     *
     * <p>In {@link ApertureBasedSkeletonPixelClassifier} for 2-dimensional case and,
     * in particular, in {@link BasicSkeletonPixelClassifier2D},
     * the neighbouring node <i>Q</i> of the central node <i>P</i>
     * is not marked for removing (not replaced with <tt>Integer.MIN_VALUE</tt>),
     * if the segment <i>PQ</i> is not diagonal (4-connected neighbour) or if it is diagonal,
     * but the two adjacent pixels, which are 4-connected neighbours
     * of both <i>P</i> and <i>Q</i>, are not {@link SkeletonPixelClassifier#TYPE_USUAL_NODE nodes}:
     * <pre>
     *     . . * . . .      . . . * . .
     *     . . * . . .      . . . * . .
     *     * * . * * *      . . . Q * *
     *     . . P Q . .  or  * * P . . .
     *     . . * . * .      . . * . . .
     *     . . * . . *      . . * . . .
     * </pre>
     * In other situations, a diagonal degenerated branch between <i>P</i> and <i>Q</i> would be extra, because
     * they are connected via two horizontal and vertical degenerated 0-pixel branches.
     * (In {@link ApertureBasedSkeletonPixelClassifier} class for the number of dimensions, other than 2,
     * the implementation of this method does nothing.)
     *
     * @param pixelTypesOfAllNeighbours an array of the pixel types of all neighbours of some given element,
     *                                  supposed to be a {@link #TYPE_USUAL_NODE node}; this method will replace
     *                                  some {@link #TYPE_USUAL_NODE} values in this array with
     *                                  <tt>Integer.MIN_VALUE</tt>.
     * @throws NullPointerException     if the argument is <tt>null</tt>.
     * @throws IllegalArgumentException if the length of the passed array is less than {@link #numberOfNeighbours()}.
     */
    public abstract void markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[] pixelTypesOfAllNeighbours);
}
