package net.algart.performance;

/**
 * <p><i>Memory</i>: an object for representation of amount of memory.
 * This object is immutable.</p>
 *
 * <p>It is guaranteed that this class allows to represent, with absolute precision (measured in bits),
 * any memory not greater than <tt>2<sup>50</sup>-1</tt> bytes.
 * For large amount of memory, this class will still work, but the precision may be less than usual.</p>
 *
 * <p>AlgART Laboratory 2007-2008</p>
 *
 * @author Daniel Alievsky
 * @version 1.0
 * @since JDK 1.0
 */
public final class Memory {
    private final double bits;
    private final long longBits;

    /**
     * Creates new <tt>Memory</tt> instance representing an the specified number of bits.
     *
     * @param bits the number of bits in the created memory amount.
     */
    private Memory(double bits) {
        this.bits = bits;
        this.longBits = Math.round(bits); // Long.MAX_VALUE or Long.MIN_VALUE if overflow
    }

    /**
     * Creates new <tt>Memory</tt> instance representing an the specified number of bits.
     *
     * @param bits the number of bits in the created memory amount.
     */
    private Memory(long bits) {
        this.bits = bits;
        this.longBits = bits;
    }

    /*Repeat() BIT   ==> CHAR,,BYTE,,SHORT,,INT,,LONG,,FLOAT,,DOUBLE ;;
               1\sbit ==> 1 <tt>char</tt> Java value,,
                          1 <tt>byte</tt> Java value,,
                          1 <tt>short</tt> Java value,,
                          1 <tt>int</tt> Java value,,
                          1 <tt>long</tt> Java value,,
                          1 <tt>float</tt> Java value,,
                          1 <tt>double</tt> Java value ;;
                   1L ==>  16L,,8L,,16L,,32L,,64L,,32L,,64L
     */
    /**
     * Amount of memory equal to 1 bit.
     */
    public static final Memory BIT = new Memory(1L);
    /*Repeat.AutoGeneratedStart !! Generated by Repeater: DO NOT EDIT !! */
    /**
     * Amount of memory equal to 1 <tt>char</tt> Java value.
     */
    public static final Memory CHAR = new Memory(16L);

    /**
     * Amount of memory equal to 1 <tt>byte</tt> Java value.
     */
    public static final Memory BYTE = new Memory(8L);

    /**
     * Amount of memory equal to 1 <tt>short</tt> Java value.
     */
    public static final Memory SHORT = new Memory(16L);

    /**
     * Amount of memory equal to 1 <tt>int</tt> Java value.
     */
    public static final Memory INT = new Memory(32L);

    /**
     * Amount of memory equal to 1 <tt>long</tt> Java value.
     */
    public static final Memory LONG = new Memory(64L);

    /**
     * Amount of memory equal to 1 <tt>float</tt> Java value.
     */
    public static final Memory FLOAT = new Memory(32L);

    /**
     * Amount of memory equal to 1 <tt>double</tt> Java value.
     */
    public static final Memory DOUBLE = new Memory(64L);
    /*Repeat.AutoGeneratedEnd*/

    /**
     * Creates new <tt>Memory</tt> instance representing estimated amount of
     * memory used in Java heap now.
     * Is is an analog of the following expression:
     * <tt>Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()</tt>.
     *
     * @return new <tt>Memory</tt> instance representing estimated amount of
     * memory used in Java heap now.
     */
    public static Memory currentMemory() {
        Runtime rt = Runtime.getRuntime();
        long totalMemory = rt.totalMemory();
        if (totalMemory >= 1L << 60) // almost impossible: a million of terabytes
            return new Memory(8.0 * (double)(totalMemory - rt.freeMemory()));
        else
            return new Memory((totalMemory - rt.freeMemory()) << 3);
    }

    /**
     * Creates new <tt>Memory</tt> instance representing total amount of memory
     * in the Java virtual machine.
     * Is is an analog of the following expression:
     * <tt>Runtime.getRuntime().totalMemory()</tt>.
     *
     * @return new <tt>Memory</tt> instance representing total amount of memory
     * in the Java virtual machine.
     */
    public static Memory totalMemory() {
        long totalMemory = Runtime.getRuntime().totalMemory();
        if (totalMemory >= 1L << 60) // almost impossible: a million of terabytes
            return new Memory(8.0 * (double)(totalMemory));
        else
            return new Memory(totalMemory << 3);
    }

    /**
     * Returns the difference between this and <tt>m</tt> amounts of memory.
     * For example:<pre>
     * Memory m1 = new Memory(); // moment #1
     * // ... the code being measured ...
     * Memory m2 = new Memory(); // moment #2
     * System.out.println(m2.sub(m1));
     * // prints the memory which was occupied between moments #1 and #2;
     * // result is negative if the occupied memory was reduced
     * </pre>
     *
     * @param m another amount of memory.
     * @return  the difference between this and <tt>m</tt> amounts of memory (may be negative).
     * @see #toString()
     */
    public Memory sub(Memory m) {
        return new Memory(bits - m.bits);
    }

    /**
     * Returns the sum of this and <tt>m</tt> amounts of memory.
     *
     * @param m another amount of memory.
     * @return  sum of this and <tt>m</tt> amounts of memory.
     */
    public Memory add(Memory m) {
        return new Memory(m.bits + bits);
    }

    /**
     * Multiplies this amount of memory by <tt>value</tt> and returns the result memory.
     *
     * @param value a multiplier.
     * @return      this amount of memory multiplied by <tt>value</tt>.
     */
    public Memory mul(double value) {
        return new Memory(bits * value);
    }

    /**
     * Divides this amount of memory by <tt>value</tt> and returns the result memory.
     * Typical example:<pre>
     * Memory m1 = new Memory(); // moment #1
     * int[] array = new int[n];
     * Memory m2 = new Memory(); // moment #2
     * System.out.println(m2.diff(m1).div(n).bytes(2));
     * // prints the amount of memory per 1 integer Java value, should be ~4
     * </pre>
     *
     * @param value a divisor.
     * @return      this amount of memory divided by <tt>value</tt>.
     */
    public Memory div(double value) {
        return new Memory(bits / value);
    }

    /**
     * Returns this amount of memory as a number of bits with maximal supported presicion.
     *
     * @return this amount of memory as a number of bits .
     */
    public double bits() {
        return bits;
    }

    /**
     * Returns this amount of memory as a number of bits, or
     * <tt>Long.MAX_VALUE</tt> / <tt>Long.MIN_VALUE</tt> if the absolute value
     * of this amount is equal ot greater than <tt>2<sup>60</sup>-1</tt> bytes (about a million of terabytes).
     * The result will be absolutely precise if this memory
     * is not greater than <tt>2<sup>50</sup>-1</tt> bytes.
     *
     * @return this amount of memory as a number of bits .
     */
    public long preciseBits() {
        return longBits;
    }

    /**
     * Returns the string decimal representation of this amount of memory in bits
     * with <tt>digitsInMantissa</tt> digits after the decimal point.
     * Special cases:<ul>
     * <li>if <tt>digitsInMantissa &lt; 0</tt>,
     * the method is equivalent to <tt>String.valueOf({@link #bits()})</tt> call;
     * <li>if <tt>digitsInMantissa == 0</tt>, the mantissa is not included in the result
     * (i.e. the method is equivalent to <tt>String.valueOf(Math.round({@link #bits()}))</tt>).
     * </ul>
     *
     * <p>As for <tt>String.valueOf(v)</tt> call, the result is
     * always written in american (scientific) standard, regardless
     * of the current regional settings.
     *
     * @param digitsInMantissa the number of digits after the decimal point.
     * @return                 the decimal representation of this amount of memory in bits.
     */
    public String bits(int digitsInMantissa) {
        return Time.toString(bits, digitsInMantissa);
    }

    /**
     * Returns this amount of memory as a number of bytes with maximal supported presicion.
     *
     * @return this amount of memory as a number of bytes.
     */
    public double bytes() {
        return bits / 8.0;
    }

    /**
     * Returns the string decimal representation of this amount of memory in bytes
     * with <tt>digitsInMantissa</tt> digits after the decimal point.
     *
     * @param digitsInMantissa the number of digits after the decimal point.
     * @return                 the decimal representation of this amount of memory in bytes.
     * @see #bits(int)
     */
    public String bytes(int digitsInMantissa) {
        return Time.toString(bits / 8.0, digitsInMantissa);
    }

    /**
     * Returns this amount of memory as a number of kilobytes with maximal supported presicion.
     *
     * @return this amount of memory as a number of kilobytes.
     */
    public double kb() {
        return bits / 8192.0;
    }

    /**
     * Returns the string decimal representation of this amount of memory in kilobytes
     * with <tt>digitsInMantissa</tt> digits after the decimal point.
     *
     * @param digitsInMantissa the number of digits after the decimal point.
     * @return                 the decimal representation of this amount of memory in kilobytes.
     * @see #bits(int)
     */
    public String kb(int digitsInMantissa) {
        return Time.toString(bits / 8192.0, digitsInMantissa);
    }

    /**
     * Returns this amount of memory as a number of megabytes with maximal supported presicion.
     *
     * @return this amount of memory as a number of megabytes.
     */
    public double mb() {
        return bits / 8388608.0;
    }

    /**
     * Returns the string decimal representation of this amount of memory in megabytes
     * with <tt>digitsInMantissa</tt> digits after the decimal point.
     *
     * @param digitsInMantissa the number of digits after the decimal point.
     * @return                 the decimal representation of this amount of memory in megabytes.
     * @see #bits(int)
     */
    public String mb(int digitsInMantissa) {
        return Time.toString(bits / 8388608.0, digitsInMantissa);
    }

    /**
     * Returns this amount of memory as a number of gigabytes with maximal supported presicion.
     *
     * @return this amount of memory as a number of gigabytes.
     */
    public double gb() {
        return bits / 8589934592.0;
    }

    /**
     * Returns the string decimal representation of this amount of memory in gigabytes
     * with <tt>digitsInMantissa</tt> digits after the decimal point.
     *
     * @param digitsInMantissa the number of digits after the decimal point.
     * @return                 the decimal representation of this amount of memory in gigabytes.
     * @see #bits(int)
     */
    public String gb(int digitsInMantissa) {
        return Time.toString(bits / 8589934592.0, digitsInMantissa);
    }

    /**
     * Returns the same result as <tt>{@link #bytes(int) ns}(0)</tt>.
     *
     * @return a string representation of this amount of memory in bytes.
     */
    public String toString() {
        return String.valueOf(bytes(0));
    }
}
