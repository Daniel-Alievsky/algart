<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
PackedBitArrays
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="PackedBitArrays";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/ObjectStack.html" title="interface in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/PackedBitBuffers.html" title="class in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/PackedBitArrays.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="PackedBitArrays.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.arrays</FONT>
<BR>
Class PackedBitArrays</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.arrays.PackedBitArrays</STRONG>
</PRE>
<HR>
<PRE>public class <STRONG>PackedBitArrays</STRONG>
extends java.lang.Object</PRE>

<P>
<p>Operations with bit arrays packed into <tt>long[]</tt> Java arrays.</p>

 <p>The maximal length of bit arrays supported by this class is <tt>2<sup>37</sup>-64</tt>.
 All indexes and lengths passed to methods of this class must not exceed this value.
 Moreover, all indexes and length, concerning usual (non-packed) Java array,
 must not exceed <tt>2<sup>31</sup>-1</tt>. In other case, the results are unspecified.
 ("Unspecified" means that any elements of the passed arrays can be read or changed,
 or that <tt>IndexOutOfBoundsException</tt> can be thrown.)</p>

 <p>In all methods of this class, it's supposed that the bit <tt>#k</tt> in a packed <tt>long[] array</tt>
 is the bit <tt>#(k%64)</tt> in the long element <tt>array[k/64]</tt>. In other words, the bit <tt>#k</tt>
 (<tt>false</tt> or <tt>true</tt> value) can be extracted by the following operator:</p>

 <pre>
 (array[k >>> 6] & (1L << (k & 63))) != 0L
 </pre>

 <p>and can be set or cleared by the following operators:</p>

 <pre>
 if (newValue) // we need to set bit #k to 1
 &#32;   array[k >>> 6] |= 1L << (k & 63);
 else          // we need to clear bit #k to 0
 &#32;   array[k >>> 6] &= ~(1L << (k & 63));
 </pre>

 <p>If any method of this class modifies some portion of an element of a packed <tt>long[]</tt> Java array,
 i.e. modifies less than all 64 its bits, then all accesses to this <tt>long</tt> element are performed
 <b>inside a single synchronized block</b>, using the following instruction:</p>

 <pre>
 synchronized (array) {
 &#32;   // accessing to some element array[k]
 }
 </pre>

 <p>(See an example in comments to <A HREF="../../../net/algart/arrays/PackedBitArrays.html#setBit(long[], long, boolean)"><CODE>setBit(long[], long, boolean)</CODE></A> method.)
 If all 64 bits of the element are written, or if the bits are read only, then no synchronization is performed.
 Such behavior allows to simultaneously work with non-overlapping fragments of a packed bit array
 from several threads (different fragments for different threads), as if it would be a usual Java array.</p>

 <p>This class cannot be instantiated.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.1</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#addBitsToInts(int[], int, long[], long, int)">addBitsToInts</A></STRONG>(int[]&nbsp;dest,
              int&nbsp;destPos,
              long[]&nbsp;src,
              long&nbsp;srcPos,
              int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and add them <tt>count</tt> elements of <tt>dest</tt> array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#andBits(long[], long, long[], long, long)">andBits</A></STRONG>(long[]&nbsp;dest,
        long&nbsp;destPos,
        long[]&nbsp;src,
        long&nbsp;srcPos,
        long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#andNotBits(long[], long, long[], long, long)">andNotBits</A></STRONG>(long[]&nbsp;dest,
           long&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#areBitsZero(long[], long, long)">areBitsZero</A></STRONG>(long[]&nbsp;array,
            long&nbsp;pos,
            long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the specified fragment of the given packed bit array
 is filled by zero bits (<tt>0</tt>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#bitEquals(long[], long, long[], long, long)">bitEquals</A></STRONG>(long[]&nbsp;array1,
          long&nbsp;pos1,
          long[]&nbsp;array2,
          long&nbsp;pos2,
          long&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the specified fragments of the given packed bit arrays are equals,
 or if both arguments are <tt>null</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#bitHashCode(long[], long, long)">bitHashCode</A></STRONG>(long[]&nbsp;array,
            long&nbsp;fromIndex,
            long&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hash code based on the contents of the specified fragment of the given packed bit array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#cardinality(long[], long, long)">cardinality</A></STRONG>(long[]&nbsp;src,
            long&nbsp;fromIndex,
            long&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of high bits (1) in the given fragment of the given packed bit array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#copyBits(long[], long, long[], long, long)">copyBits</A></STRONG>(long[]&nbsp;dest,
         long&nbsp;destPos,
         long[]&nbsp;src,
         long&nbsp;srcPos,
         long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#fillBits(long[], long, long, boolean)">fillBits</A></STRONG>(long[]&nbsp;dest,
         long&nbsp;destPos,
         long&nbsp;count,
         boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <tt>count</tt> bits in the packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 by the specified value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)">getBit</A></STRONG>(long[]&nbsp;src,
       long&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bit <tt>#index</tt> in the packed <tt>dest</tt> bit array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#indexOfBit(long[], long, long, boolean)">indexOfBit</A></STRONG>(long[]&nbsp;src,
           long&nbsp;lowIndex,
           long&nbsp;highIndex,
           boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit array is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#lastIndexOfBit(long[], long, long, boolean)">lastIndexOfBit</A></STRONG>(long[]&nbsp;src,
               long&nbsp;lowIndex,
               long&nbsp;highIndex,
               boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit array is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#notBits(long[], long, long[], long, long)">notBits</A></STRONG>(long[]&nbsp;dest,
        long&nbsp;destPos,
        long[]&nbsp;src,
        long&nbsp;srcPos,
        long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical NOT of corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#orBits(long[], long, long[], long, long)">orBits</A></STRONG>(long[]&nbsp;dest,
       long&nbsp;destPos,
       long[]&nbsp;src,
       long&nbsp;srcPos,
       long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#orNotBits(long[], long, long[], long, long)">orNotBits</A></STRONG>(long[]&nbsp;dest,
          long&nbsp;destPos,
          long[]&nbsp;src,
          long&nbsp;srcPos,
          long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBits(long[], long, boolean[], int, int)">packBits</A></STRONG>(long[]&nbsp;dest,
         long&nbsp;destPos,
         boolean[]&nbsp;src,
         int&nbsp;srcPos,
         int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, byte[], int, int, int)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                byte[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, char[], int, int, char)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                char[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                char&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, double[], int, int, double)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                double[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                double&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, float[], int, int, float)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                float[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                float&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, int[], int, int, int)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                int[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, long[], int, int, long)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                long[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                long&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreater(long[], long, short[], int, int, int)">packBitsGreater</A></STRONG>(long[]&nbsp;dest,
                long&nbsp;destPos,
                short[]&nbsp;src,
                int&nbsp;srcPos,
                int&nbsp;count,
                int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &gt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, byte[], int, int, int)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       byte[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, char[], int, int, char)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       char[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       char&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, double[], int, int, double)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       double[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       double&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, float[], int, int, float)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       float[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       float&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, int[], int, int, int)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       int[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, long[], int, int, long)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       long[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       long&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsGreaterOrEqual(long[], long, short[], int, int, int)">packBitsGreaterOrEqual</A></STRONG>(long[]&nbsp;dest,
                       long&nbsp;destPos,
                       short[]&nbsp;src,
                       int&nbsp;srcPos,
                       int&nbsp;count,
                       int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &gt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsInverted(long[], long, boolean[], int, int)">packBitsInverted</A></STRONG>(long[]&nbsp;dest,
                 long&nbsp;destPos,
                 boolean[]&nbsp;src,
                 int&nbsp;srcPos,
                 int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> <i>inverted</i> bits from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, byte[], int, int, int)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             byte[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, char[], int, int, char)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             char[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             char&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, double[], int, int, double)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             double[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             double&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, float[], int, int, float)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             float[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             float&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, int[], int, int, int)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             int[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, long[], int, int, long)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             long[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             long&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLess(long[], long, short[], int, int, int)">packBitsLess</A></STRONG>(long[]&nbsp;dest,
             long&nbsp;destPos,
             short[]&nbsp;src,
             int&nbsp;srcPos,
             int&nbsp;count,
             int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &lt; threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, byte[], int, int, int)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    byte[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, char[], int, int, char)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    char[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    char&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, double[], int, int, double)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    double[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    double&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, float[], int, int, float)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    float[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    float&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, int[], int, int, int)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    int[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, long[], int, int, long)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    long[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    long&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packBitsLessOrEqual(long[], long, short[], int, int, int)">packBitsLessOrEqual</A></STRONG>(long[]&nbsp;dest,
                    long&nbsp;destPos,
                    short[]&nbsp;src,
                    int&nbsp;srcPos,
                    int&nbsp;count,
                    int&nbsp;threshold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &lt;= threshold</tt></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#packedLength(long)">packedLength</A></STRONG>(long&nbsp;unpackedLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>(unpackedLength + 63) >>> 6</tt>: the minimal number of <tt>long</tt> values
 allowing to store <tt>unpackedLength</tt> bits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#reverseBitsOrder(long[], long, long[], long, long)">reverseBitsOrder</A></STRONG>(long[]&nbsp;dest,
                 long&nbsp;destPos,
                 long[]&nbsp;src,
                 long&nbsp;srcPos,
                 long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reverse order of <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and puts the result into <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#setBit(long[], long, boolean)">setBit</A></STRONG>(long[]&nbsp;dest,
       long&nbsp;index,
       boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the bit <tt>#index</tt> in the packed <tt>dest</tt> bit array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(boolean[], int, long[], long, int)">unpackBits</A></STRONG>(boolean[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> boolean array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(boolean[], int, long[], long, int, boolean, boolean)">unpackBits</A></STRONG>(boolean[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           boolean&nbsp;bit0Value,
           boolean&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> boolean array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(byte[], int, long[], long, int, byte, byte)">unpackBits</A></STRONG>(byte[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           byte&nbsp;bit0Value,
           byte&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> byte array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(char[], int, long[], long, int, char, char)">unpackBits</A></STRONG>(char[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           char&nbsp;bit0Value,
           char&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> char array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(double[], int, long[], long, int, double, double)">unpackBits</A></STRONG>(double[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           double&nbsp;bit0Value,
           double&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> double array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(float[], int, long[], long, int, float, float)">unpackBits</A></STRONG>(float[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           float&nbsp;bit0Value,
           float&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> float array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(int[], int, long[], long, int, int, int)">unpackBits</A></STRONG>(int[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           int&nbsp;bit0Value,
           int&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> int array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(long[], int, long[], long, int, long, long)">unpackBits</A></STRONG>(long[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           long&nbsp;bit0Value,
           long&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> long array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(java.lang.Object[], int, long[], long, int, java.lang.Object, java.lang.Object)">unpackBits</A></STRONG>(java.lang.Object[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           java.lang.Object&nbsp;bit0Value,
           java.lang.Object&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> Object array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackBits(short[], int, long[], long, int, short, short)">unpackBits</A></STRONG>(short[]&nbsp;dest,
           int&nbsp;destPos,
           long[]&nbsp;src,
           long&nbsp;srcPos,
           int&nbsp;count,
           short&nbsp;bit0Value,
           short&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> short array, starting from the element <tt>#destPos</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(boolean[], int, long[], long, int, boolean)">unpackUnitBits</A></STRONG>(boolean[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               boolean&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> boolean array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(byte[], int, long[], long, int, byte)">unpackUnitBits</A></STRONG>(byte[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               byte&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> byte array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(char[], int, long[], long, int, char)">unpackUnitBits</A></STRONG>(char[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               char&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> char array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(double[], int, long[], long, int, double)">unpackUnitBits</A></STRONG>(double[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               double&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> double array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(float[], int, long[], long, int, float)">unpackUnitBits</A></STRONG>(float[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               float&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> float array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(int[], int, long[], long, int, int)">unpackUnitBits</A></STRONG>(int[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               int&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> int array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(long[], int, long[], long, int, long)">unpackUnitBits</A></STRONG>(long[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               long&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> long array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(java.lang.Object[], int, long[], long, int, java.lang.Object)">unpackUnitBits</A></STRONG>(java.lang.Object[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               java.lang.Object&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> Object array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackUnitBits(short[], int, long[], long, int, short)">unpackUnitBits</A></STRONG>(short[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               short&nbsp;bit1Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> short array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(boolean[], int, long[], long, int, boolean)">unpackZeroBits</A></STRONG>(boolean[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               boolean&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> boolean array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(byte[], int, long[], long, int, byte)">unpackZeroBits</A></STRONG>(byte[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               byte&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> byte array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(char[], int, long[], long, int, char)">unpackZeroBits</A></STRONG>(char[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               char&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> char array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(double[], int, long[], long, int, double)">unpackZeroBits</A></STRONG>(double[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               double&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> double array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(float[], int, long[], long, int, float)">unpackZeroBits</A></STRONG>(float[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               float&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> float array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(int[], int, long[], long, int, int)">unpackZeroBits</A></STRONG>(int[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               int&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> int array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(long[], int, long[], long, int, long)">unpackZeroBits</A></STRONG>(long[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               long&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> long array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(java.lang.Object[], int, long[], long, int, java.lang.Object)">unpackZeroBits</A></STRONG>(java.lang.Object[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               java.lang.Object&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> Object array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#unpackZeroBits(short[], int, long[], long, int, short)">unpackZeroBits</A></STRONG>(short[]&nbsp;dest,
               int&nbsp;destPos,
               long[]&nbsp;src,
               long&nbsp;srcPos,
               int&nbsp;count,
               short&nbsp;bit0Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> short array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#updateBitHashCode(long[], long, long, java.util.zip.Checksum)">updateBitHashCode</A></STRONG>(long[]&nbsp;array,
                  long&nbsp;fromIndex,
                  long&nbsp;toIndex,
                  java.util.zip.Checksum&nbsp;hash)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates hash code (<tt>hash</tt> argument) on the base of the contents
 of the specified fragment of the given packed bit array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/PackedBitArrays.html#xorBits(long[], long, long[], long, long)">xorBits</A></STRONG>(long[]&nbsp;dest,
        long&nbsp;destPos,
        long[]&nbsp;src,
        long&nbsp;srcPos,
        long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical XOR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="packedLength(long)"><!-- --></A><H3>
packedLength</H3>
<PRE>
public static long <STRONG>packedLength</STRONG>(long&nbsp;unpackedLength)</PRE>
<DL>
<DD>Returns <tt>(unpackedLength + 63) >>> 6</tt>: the minimal number of <tt>long</tt> values
 allowing to store <tt>unpackedLength</tt> bits.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>unpackedLength</CODE> - the number of bits (the length of bit array).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>(unpackedLength + 63) >>> 6</tt> (the length of corresponding <tt>long[]</tt> array).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getBit(long[], long)"><!-- --></A><H3>
getBit</H3>
<PRE>
public static boolean <STRONG>getBit</STRONG>(long[]&nbsp;src,
                             long&nbsp;index)</PRE>
<DL>
<DD>Returns the bit <tt>#index</tt> in the packed <tt>dest</tt> bit array.
 Equivalent to the following expression:<pre>
 (src[(int)(index >>> 6)] & (1L << (index & 63))) != 0L;
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>index</CODE> - index of the returned bit.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the bit at the specified index.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>src</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if this method cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="setBit(long[], long, boolean)"><!-- --></A><H3>
setBit</H3>
<PRE>
public static void <STRONG>setBit</STRONG>(long[]&nbsp;dest,
                          long&nbsp;index,
                          boolean&nbsp;value)</PRE>
<DL>
<DD>Sets the bit <tt>#index</tt> in the packed <tt>dest</tt> bit array.
 Equivalent to the following operators:<pre>
 synchronized (dest) {
 &#32;   if (value)
 &#32;       dest[(int)(index >>> 6)] |= 1L << (index & 63);
 &#32;   else
 &#32;       dest[(int)(index >>> 6)] &= ~(1L << (index & 63));
 }
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>index</CODE> - index of the written bit.</DD><DD><CODE>value</CODE> - new bit value.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if this method cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="bitHashCode(long[], long, long)"><!-- --></A><H3>
bitHashCode</H3>
<PRE>
public static int <STRONG>bitHashCode</STRONG>(long[]&nbsp;array,
                              long&nbsp;fromIndex,
                              long&nbsp;toIndex)</PRE>
<DL>
<DD>Returns a hash code based on the contents of the specified fragment of the given packed bit array.
 If the passed array is <tt>null</tt> or <tt>fromIndex==toIndex</tt>, returns 0.

 <p>The returned hash code depends only on the sequence of packed bits, but does not depend
 on the position of this sequence in the passed <tt>long[]</tt> array.

 <p>For any two packed bit arrays <tt>a1</tt> and <tt>a2</tt> such that
 <tt>PackedBitArrays.bitEquals(a1, pos1, a2, pos2, count)</tt>, it is also the case that
 <tt>PackedBitArrays.bitHashCode(a1, pos1, pos1 + count) ==
 PackedBitArrays.bitHashCode(a2, pos2, pos2 + count)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>array</CODE> - the packed bit array whose content-based hash code to compute.</DD><DD><CODE>fromIndex</CODE> - the initial index of the checked fragment, inclusive.</DD><DD><CODE>toIndex</CODE> - the end index of the checked fragment, exclusive.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a content-based hash code for the specified fragment in <tt>array</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <tt>array</tt> argument is not a Java array.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>fromIndex</tt> or <tt>toIndex</tt> are negative,
          if <tt>toIndex</tt> is greater than <tt>array.length*64</tt> (0 if <tt>array==null</tt>),
          or if <tt>fromIndex</tt> is greater than <tt>startIndex</tt>,
          or if <tt>array==null</tt> and not <tt>fromIndex==toIndex==0</tt></DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/PackedBitArrays.html#bitEquals(long[], long, long[], long, long)"><CODE>bitEquals(long[], long, long[], long, long)</CODE></A>, 
<A HREF="../../../net/algart/arrays/JArrays.html#arrayHashCode(java.lang.Object, int, int)"><CODE>JArrays.arrayHashCode(Object, int, int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="updateBitHashCode(long[], long, long, java.util.zip.Checksum)"><!-- --></A><H3>
updateBitHashCode</H3>
<PRE>
public static void <STRONG>updateBitHashCode</STRONG>(long[]&nbsp;array,
                                     long&nbsp;fromIndex,
                                     long&nbsp;toIndex,
                                     java.util.zip.Checksum&nbsp;hash)</PRE>
<DL>
<DD>Updates hash code (<tt>hash</tt> argument) on the base of the contents
 of the specified fragment of the given packed bit array.
 If the passed array is <tt>null</tt> or <tt>fromIndex==toIndex</tt>, does nothing.

 <p>This method is used by <A HREF="../../../net/algart/arrays/PackedBitArrays.html#bitHashCode(long[], long, long)"><CODE>bitHashCode(long[] array, long fromIndex, long toIndex)</CODE></A>.
 More precisely, that method is equivalent to:<pre>
 Checksum sum = new CRC32();
 updateBitHashCode(array, fromIndex, toIndex, sum);
 return fromIndex == toIndex ? 0 : (int)sum.getValue();
 </pre>

 <p>The following 2 code fragment always produce the same results in <tt>hash</tt>argument:<pre>
 updateBitHashCode(arr, fromIndex, toIndex, hash);
 </pre>and<pre>
 updateBitHashCode(arr, fromIndex, k1, hash);
 updateBitHashCode(arr, k1, k2, hash);
 ...
 updateBitHashCode(arr, kN, toIndex, hash);
 </pre>
 where <tt>fromIndex &lt;= k1 &lt;= k2 &lt;= ... &lt;= kN &lt;= toIndex</tt>.
 So, unlike <tt>bitHashCode</tt>, this method allows to calculate correct hash code
 of a long array when we cannot get all its element at the same time,
 but can get sequent portions ot it.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>array</CODE> - the packed bit array whose content-based hash code to compute.</DD><DD><CODE>fromIndex</CODE> - the initial index of the checked fragment, inclusive.</DD><DD><CODE>toIndex</CODE> - the end index of the checked fragment, exclusive.</DD><DD><CODE>hash</CODE> - updated hash code.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>array</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>fromIndex</tt> or <tt>toIndex</tt> are negative,
          if <tt>toIndex</tt> is greater than <tt>array.length</tt> (0 if <tt>array==null</tt>),
          or if <tt>fromIndex</tt> is greater than <tt>startIndex</tt>,
          or if <tt>array==null</tt> and not <tt>fromIndex==toIndex==0</tt></DD></DL>
</DD>
</DL>
<HR>

<A NAME="bitEquals(long[], long, long[], long, long)"><!-- --></A><H3>
bitEquals</H3>
<PRE>
public static boolean <STRONG>bitEquals</STRONG>(long[]&nbsp;array1,
                                long&nbsp;pos1,
                                long[]&nbsp;array2,
                                long&nbsp;pos2,
                                long&nbsp;length)</PRE>
<DL>
<DD>Returns <tt>true</tt> if the specified fragments of the given packed bit arrays are equals,
 or if both arguments are <tt>null</tt>.
 Returns <tt>false</tt> if one of the arguments is <tt>null</tt>, but the other is not <tt>null</tt>.

 <p>The two packed bit arrays are considered equal if all corresponding pairs of bits
 in the two arrays are equal.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>array1</CODE> - one array to be tested for equality.</DD><DD><CODE>pos1</CODE> - the initial index of the checked fragment in the first array.</DD><DD><CODE>array2</CODE> - the other array to be tested for equality.</DD><DD><CODE>pos2</CODE> - the initial index of the checked fragment in the second array.</DD><DD><CODE>length</CODE> - the number of compared elements.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified fragments of two arrays are equal.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <tt>array1</tt> or <tt>array2</tt> argument is not a Java array.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>pos1</tt>, <tt>pos2</tt> or <tt>length</tt> are negative,
          if <tt>pos1 + length</tt> is greater than <tt>array1.length*64</tt> (0 if <tt>array1==null</tt>),
          or if <tt>pos2 + length</tt> is greater than <tt>array2.length*64</tt> (0 if <tt>array2==null</tt>).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="copyBits(long[], long, long[], long, long)"><!-- --></A><H3>
copyBits</H3>
<PRE>
public static void <STRONG>copyBits</STRONG>(long[]&nbsp;dest,
                            long&nbsp;destPos,
                            long[]&nbsp;src,
                            long&nbsp;srcPos,
                            long&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.

 <p><i>This method works correctly even if <tt>src == dest</tt>
 and the copied areas overlap</i>,
 i.e. if <tt>Math.abs(destPos - srcPos) &lt; count</tt>.
 More precisely, in this case the copying is performed as if the
 bits at positions <tt>srcPos..srcPos+count-1</tt>
 were first unpacked to a temporary <tt>boolean[]</tt> array with <tt>count</tt> elements
 and then the contents of the temporary array were packed into positions
 <tt>destPos..destPos+count-1</code>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be copied (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBits(long[], long, boolean[], int, int)"><!-- --></A><H3>
packBits</H3>
<PRE>
public static void <STRONG>packBits</STRONG>(long[]&nbsp;dest,
                            long&nbsp;destPos,
                            boolean[]&nbsp;src,
                            int&nbsp;srcPos,
                            int&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsInverted(long[], long, boolean[], int, int)"><!-- --></A><H3>
packBitsInverted</H3>
<PRE>
public static void <STRONG>packBitsInverted</STRONG>(long[]&nbsp;dest,
                                    long&nbsp;destPos,
                                    boolean[]&nbsp;src,
                                    int&nbsp;srcPos,
                                    int&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> <i>inverted</i> bits from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked inverted <tt>boolean</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, char[], int, int, char)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   char[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   char&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>char</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, char[], int, int, char)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                char[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                char&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>char</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, char[], int, int, char)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          char[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          char&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>char</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, char[], int, int, char)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       char[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       char&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>char</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, byte[], int, int, int)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   byte[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>byte</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, byte[], int, int, int)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                byte[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>byte</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, byte[], int, int, int)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          byte[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>byte</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, byte[], int, int, int)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       byte[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFF) &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>byte</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, short[], int, int, int)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   short[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>short</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, short[], int, int, int)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                short[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>short</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, short[], int, int, int)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          short[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>short</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, short[], int, int, int)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       short[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>(src[k] & 0xFFFF) &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>short</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, int[], int, int, int)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   int[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>int</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, int[], int, int, int)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                int[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>int</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, int[], int, int, int)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          int[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>int</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, int[], int, int, int)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       int[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       int&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>int</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, long[], int, int, long)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   long[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   long&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, long[], int, int, long)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                long[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                long&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, long[], int, int, long)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          long[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          long&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, long[], int, int, long)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       long[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       long&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, float[], int, int, float)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   float[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   float&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>float</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, float[], int, int, float)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                float[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                float&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>float</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, float[], int, int, float)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          float[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          float&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>float</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, float[], int, int, float)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       float[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       float&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>float</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreater(long[], long, double[], int, int, double)"><!-- --></A><H3>
packBitsGreater</H3>
<PRE>
public static void <STRONG>packBitsGreater</STRONG>(long[]&nbsp;dest,
                                   long&nbsp;destPos,
                                   double[]&nbsp;src,
                                   int&nbsp;srcPos,
                                   int&nbsp;count,
                                   double&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>double</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than this value are packed to unit bits (1),
                  the source elements less than or equal to this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLess(long[], long, double[], int, int, double)"><!-- --></A><H3>
packBitsLess</H3>
<PRE>
public static void <STRONG>packBitsLess</STRONG>(long[]&nbsp;dest,
                                long&nbsp;destPos,
                                double[]&nbsp;src,
                                int&nbsp;srcPos,
                                int&nbsp;count,
                                double&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt; threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>double</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than to this value are packed to unit bits (1),
                  the source elements greater than or equal this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsGreaterOrEqual(long[], long, double[], int, int, double)"><!-- --></A><H3>
packBitsGreaterOrEqual</H3>
<PRE>
public static void <STRONG>packBitsGreaterOrEqual</STRONG>(long[]&nbsp;dest,
                                          long&nbsp;destPos,
                                          double[]&nbsp;src,
                                          int&nbsp;srcPos,
                                          int&nbsp;count,
                                          double&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &gt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>double</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are greater than or equal to this value are packed to unit bits (1),
                  the source elements less than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="packBitsLessOrEqual(long[], long, double[], int, int, double)"><!-- --></A><H3>
packBitsLessOrEqual</H3>
<PRE>
public static void <STRONG>packBitsLessOrEqual</STRONG>(long[]&nbsp;dest,
                                       long&nbsp;destPos,
                                       double[]&nbsp;src,
                                       int&nbsp;srcPos,
                                       int&nbsp;count,
                                       double&nbsp;threshold)</PRE>
<DL>
<DD>Packs <tt>count</tt> elements from <tt>src</tt> array, starting from the element <tt>#srcPos</tt>,
 to packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 so that every element <tt>src[k]</tt> is transformed to boolean (bit) value
 <nobr><tt>src[k] &lt;= threshold</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (unpacked <tt>double</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be packed (must be &gt;=0).</DD><DD><CODE>threshold</CODE> - the source elements that are less than or equal to this value are packed to unit bits (1),
                  the source elements greater than this threshold are packed to zero bits (0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(boolean[], int, long[], long, int)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(boolean[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> boolean array, starting from the element <tt>#destPos</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be unpacked (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(boolean[], int, long[], long, int, boolean, boolean)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(boolean[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              boolean&nbsp;bit0Value,
                              boolean&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> boolean array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(boolean[], int, long[], long, int, boolean)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(boolean[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  boolean&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> boolean array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(boolean[], int, long[], long, int, boolean)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(boolean[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  boolean&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> boolean array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>boolean</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(char[], int, long[], long, int, char, char)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(char[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              char&nbsp;bit0Value,
                              char&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> char array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>char</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(char[], int, long[], long, int, char)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(char[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  char&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> char array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>char</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(char[], int, long[], long, int, char)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(char[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  char&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> char array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>char</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(byte[], int, long[], long, int, byte, byte)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(byte[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              byte&nbsp;bit0Value,
                              byte&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> byte array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>byte</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(byte[], int, long[], long, int, byte)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(byte[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  byte&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> byte array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>byte</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(byte[], int, long[], long, int, byte)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(byte[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  byte&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> byte array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>byte</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(short[], int, long[], long, int, short, short)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(short[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              short&nbsp;bit0Value,
                              short&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> short array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>short</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(short[], int, long[], long, int, short)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(short[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  short&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> short array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>short</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(short[], int, long[], long, int, short)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(short[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  short&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> short array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>short</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(int[], int, long[], long, int, int, int)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(int[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              int&nbsp;bit0Value,
                              int&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> int array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>int</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(int[], int, long[], long, int, int)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(int[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  int&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> int array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>int</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(int[], int, long[], long, int, int)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(int[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  int&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> int array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>int</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(long[], int, long[], long, int, long, long)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(long[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              long&nbsp;bit0Value,
                              long&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> long array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(long[], int, long[], long, int, long)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(long[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  long&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> long array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(long[], int, long[], long, int, long)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(long[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  long&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> long array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(float[], int, long[], long, int, float, float)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(float[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              float&nbsp;bit0Value,
                              float&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> float array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>float</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(float[], int, long[], long, int, float)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(float[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  float&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> float array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>float</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(float[], int, long[], long, int, float)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(float[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  float&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> float array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>float</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(double[], int, long[], long, int, double, double)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(double[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              double&nbsp;bit0Value,
                              double&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> double array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>double</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(double[], int, long[], long, int, double)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(double[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  double&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> double array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>double</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(double[], int, long[], long, int, double)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(double[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  double&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> double array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>double</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackBits(java.lang.Object[], int, long[], long, int, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
unpackBits</H3>
<PRE>
public static void <STRONG>unpackBits</STRONG>(java.lang.Object[]&nbsp;dest,
                              int&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              int&nbsp;count,
                              java.lang.Object&nbsp;bit0Value,
                              java.lang.Object&nbsp;bit1Value)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 to <tt>dest</tt> Object array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>Object</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements in the destination array to which the bit 0 is translated.</DD><DD><CODE>bit1Value</CODE> - the value of elements in the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackUnitBits(java.lang.Object[], int, long[], long, int, java.lang.Object)"><!-- --></A><H3>
unpackUnitBits</H3>
<PRE>
public static void <STRONG>unpackUnitBits</STRONG>(java.lang.Object[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  java.lang.Object&nbsp;bit1Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 1 sets the corresponding element of <tt>dest</tt> Object array,
 starting from the element <tt>#destPos</tt>, to <tt>bit1Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to zero bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?bit1Value:dest[destPos+k]</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>Object</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit1Value</CODE> - the value of elements of the destination array to which the bit 1 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unpackZeroBits(java.lang.Object[], int, long[], long, int, java.lang.Object)"><!-- --></A><H3>
unpackZeroBits</H3>
<PRE>
public static void <STRONG>unpackZeroBits</STRONG>(java.lang.Object[]&nbsp;dest,
                                  int&nbsp;destPos,
                                  long[]&nbsp;src,
                                  long&nbsp;srcPos,
                                  int&nbsp;count,
                                  java.lang.Object&nbsp;bit0Value)</PRE>
<DL>
<DD>Tests <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and for every found bit 0 sets the corresponding element of <tt>dest</tt> Object array,
 starting from the element <tt>#destPos</tt>, to <tt>bit0Value</tt>.
 Elements of <tt>dest</tt> array, corresponding to unit bits of the source array, are not changed.
 In other words, every element <tt>dest[destPos+k]</tt> is assigned to new value
 <tt><A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?dest[destPos+k]:bit0Value</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (unpacked <tt>Object</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first element in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of elements to be unpacked (must be &gt;=0).</DD><DD><CODE>bit0Value</CODE> - the value of elements of the destination array to which the bit 0 is translated.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="addBitsToInts(int[], int, long[], long, int)"><!-- --></A><H3>
addBitsToInts</H3>
<PRE>
public static void <STRONG>addBitsToInts</STRONG>(int[]&nbsp;dest,
                                 int&nbsp;destPos,
                                 long[]&nbsp;src,
                                 long&nbsp;srcPos,
                                 int&nbsp;count)</PRE>
<DL>
<DD>Unpacks <tt>count</tt> bits, packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and add them <tt>count</tt> elements of <tt>dest</tt> array, starting from the element <tt>#destPos</tt>.
 It means that every element <tt>dest[destPos+k]</tt> is assigned to
 <tt>dest[destPos+k]+(<A HREF="../../../net/algart/arrays/PackedBitArrays.html#getBit(long[], long)"><CODE>getBit</CODE></A>(srcPos+k)?1:0)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>dest</CODE> - the destination array (unpacked <tt>int</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first increased element in the destination array.</DD><DD><CODE>count</CODE> - the number of bits to be added to <tt>dest</tt> elements (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="fillBits(long[], long, long, boolean)"><!-- --></A><H3>
fillBits</H3>
<PRE>
public static void <STRONG>fillBits</STRONG>(long[]&nbsp;dest,
                            long&nbsp;destPos,
                            long&nbsp;count,
                            boolean&nbsp;value)</PRE>
<DL>
<DD>Fills <tt>count</tt> bits in the packed <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 by the specified value. <i>Be careful:</i> the second <tt>int</tt> argument in this method
 is the number of filled element, but not the end filled index
 as in <tt>java.util.Arrays.fill</tt> methods.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>count</CODE> - the number of bits to be filled (must be &gt;=0).</DD><DD><CODE>value</CODE> - new value of all filled bits (<tt>false</tt> means the bit 0, <tt>true</tt> means the bit 1).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if filling would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="areBitsZero(long[], long, long)"><!-- --></A><H3>
areBitsZero</H3>
<PRE>
public static boolean <STRONG>areBitsZero</STRONG>(long[]&nbsp;array,
                                  long&nbsp;pos,
                                  long&nbsp;count)</PRE>
<DL>
<DD>Returns <tt>true</tt> if the specified fragment of the given packed bit array
 is filled by zero bits (<tt>0</tt>).
 Returns <tt>false</tt> if at least one of <tt>count</tt> bits of this array,
 starting from the bit <tt>#pos</tt>, is <tt>1</tt>.

 <p>If the <tt>count</tt> argument (number of elements) is 0, this method returns <tt>true</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>array</CODE> - the checked bit array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>pos</CODE> - the initial index of the checked fragment in the array.</DD><DD><CODE>count</CODE> - the number of checked bits.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if and only if all <tt>count</tt> bits, starting from the bit <tt>#pos</tt>,
              are zero, or if <tt>count==0</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <tt>array</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if checking would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="notBits(long[], long, long[], long, long)"><!-- --></A><H3>
notBits</H3>
<PRE>
public static void <STRONG>notBits</STRONG>(long[]&nbsp;dest,
                           long&nbsp;destPos,
                           long[]&nbsp;src,
                           long&nbsp;srcPos,
                           long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical NOT of corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.

 <p>This method works correctly even if <tt>src&nbsp;==&nbsp;dest</tt>
 and <tt>srcPos&nbsp;==&nbsp;destPos</tt>:
 in this case it just inverts the specified bits.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="andBits(long[], long, long[], long, long)"><!-- --></A><H3>
andBits</H3>
<PRE>
public static void <STRONG>andBits</STRONG>(long[]&nbsp;dest,
                           long&nbsp;destPos,
                           long[]&nbsp;src,
                           long&nbsp;srcPos,
                           long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.

 <p>This method works correctly even if <tt>src&nbsp;==&nbsp;dest</tt>
 and <tt>srcPos&nbsp;==&nbsp;destPos</tt>:
 in this case it does nothing (so there are no reasons for this call).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="orBits(long[], long, long[], long, long)"><!-- --></A><H3>
orBits</H3>
<PRE>
public static void <STRONG>orBits</STRONG>(long[]&nbsp;dest,
                          long&nbsp;destPos,
                          long[]&nbsp;src,
                          long&nbsp;srcPos,
                          long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.

 <p>This method works correctly even if <tt>src&nbsp;==&nbsp;dest</tt>
 and <tt>srcPos&nbsp;==&nbsp;destPos</tt>:
 in this case it does nothing (so there are no reasons for this call).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="xorBits(long[], long, long[], long, long)"><!-- --></A><H3>
xorBits</H3>
<PRE>
public static void <STRONG>xorBits</STRONG>(long[]&nbsp;dest,
                           long&nbsp;destPos,
                           long[]&nbsp;src,
                           long&nbsp;srcPos,
                           long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical XOR of them and corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.

 <p>This method works correctly even if <tt>src&nbsp;==&nbsp;dest</tt>
 and <tt>srcPos&nbsp;==&nbsp;destPos</tt>:
 in this case it clears all specified bits.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="andNotBits(long[], long, long[], long, long)"><!-- --></A><H3>
andNotBits</H3>
<PRE>
public static void <STRONG>andNotBits</STRONG>(long[]&nbsp;dest,
                              long&nbsp;destPos,
                              long[]&nbsp;src,
                              long&nbsp;srcPos,
                              long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical AND of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.

 <p>This method works correctly even if <tt>src&nbsp;==&nbsp;dest</tt>
 and <tt>srcPos&nbsp;==&nbsp;destPos</tt>:
 in this case it clears all specified bits.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="orNotBits(long[], long, long[], long, long)"><!-- --></A><H3>
orNotBits</H3>
<PRE>
public static void <STRONG>orNotBits</STRONG>(long[]&nbsp;dest,
                             long&nbsp;destPos,
                             long[]&nbsp;src,
                             long&nbsp;srcPos,
                             long&nbsp;count)</PRE>
<DL>
<DD>Replaces <tt>count</tt> bits,
 packed in <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>,
 with the logical OR of them and <i>inverted</i> corresponding <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>.

 <p>This method works correctly even if <tt>src&nbsp;==&nbsp;dest</tt>
 and <tt>srcPos&nbsp;==&nbsp;destPos</tt>:
 in this case it sets all specified bits to 1.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="reverseBitsOrder(long[], long, long[], long, long)"><!-- --></A><H3>
reverseBitsOrder</H3>
<PRE>
public static void <STRONG>reverseBitsOrder</STRONG>(long[]&nbsp;dest,
                                    long&nbsp;destPos,
                                    long[]&nbsp;src,
                                    long&nbsp;srcPos,
                                    long&nbsp;count)</PRE>
<DL>
<DD>Reverse order of <tt>count</tt> bits,
 packed in <tt>src</tt> array, starting from the bit <tt>#srcPos</tt>,
 and puts the result into <tt>dest</tt> array, starting from the bit <tt>#destPos</tt>.
 So, the bit <tt>#(destPos+k)</tt> in <tt>dest</tt> bit array will be equal to the bit
 <tt>#(srcPos+count-1-k)</tt> of the <tt>src</tt> bit array.

 <p>This method does not work correctly if <tt>src&nbsp;==&nbsp;dest</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the destination array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>destPos</CODE> - position of the first written bit in the destination array.</DD><DD><CODE>src</CODE> - the source array (bits are packed in <tt>long</tt> values).</DD><DD><CODE>srcPos</CODE> - position of the first read bit in the source array.</DD><DD><CODE>count</CODE> - the number of bits to be replaced (must be &gt;=0).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if either <tt>src</tt> or <tt>dest</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if accessing bits would cause access of data outside array bounds.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="indexOfBit(long[], long, long, boolean)"><!-- --></A><H3>
indexOfBit</H3>
<PRE>
public static long <STRONG>indexOfBit</STRONG>(long[]&nbsp;src,
                              long&nbsp;lowIndex,
                              long&nbsp;highIndex,
                              boolean&nbsp;value)</PRE>
<DL>
<DD>Returns the minimal index <tt>k</tt>, so that <tt>lowIndex&lt;=k&lt;highIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit array is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.

 <p>If <tt>lowIndex&gt;=highIndex</tt>, this method returns <tt>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the searched packed bit array.</DD><DD><CODE>lowIndex</CODE> - the low index for search (inclusive).</DD><DD><CODE>highIndex</CODE> - the high index for search (exclusive).</DD><DD><CODE>value</CODE> - the value of bit to be found.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the index of the first occurrence of this bit in range <tt>lowIndex..highIndex-1</tt>,
                  or <tt>-1</tt> if this bit does not occur
                  or if <tt>lowIndex&gt;=highIndex</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>array</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>lowIndex</tt> is negative or
                                   if <tt>highIndex</tt> is greater than <tt>src.length*64</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/PackedBitArrays.html#lastIndexOfBit(long[], long, long, boolean)"><CODE>lastIndexOfBit(long[], long, long, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOfBit(long[], long, long, boolean)"><!-- --></A><H3>
lastIndexOfBit</H3>
<PRE>
public static long <STRONG>lastIndexOfBit</STRONG>(long[]&nbsp;src,
                                  long&nbsp;lowIndex,
                                  long&nbsp;highIndex,
                                  boolean&nbsp;value)</PRE>
<DL>
<DD>Returns the maximal index <tt>k</tt>, so that <tt>highIndex&gt;k&gt;=lowIndex</tt>
 and the bit <tt>#k</tt> in the packed <tt>src</tt> bit array is equal to <tt>value</tt>,
 or <tt>-1</tt> if there is no such bits.

 <p>If <tt>highIndex&lt;=lowIndex</tt>, this method returns <tt>-1</tt>.

 <p>Note that <tt>lowIndex</tt> and <tt>highIndex</tt> arguments have the same sense as in
 <A HREF="../../../net/algart/arrays/PackedBitArrays.html#indexOfBit(long[], long, long, boolean)"><CODE>indexOfBit(long[], long, long, boolean)</CODE></A> method:
 they describes the search index range <tt>lowIndex&lt;=k&lt;highIndex</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the searched packed bit array.</DD><DD><CODE>lowIndex</CODE> - the low index in the array for search (inclusive);
                  pass <tt>0</tt> to search all remaining elements.</DD><DD><CODE>highIndex</CODE> - the high index in the array for search (exclusive).</DD><DD><CODE>value</CODE> - the value of bit to be found.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the index of the last occurrence of this bit in range <tt>lowIndex..highIndex-1</tt>,
                  or <tt>-1</tt> if this bit does not occur
                  or if <tt>lowIndex&gt;=highIndex</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>src</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>lowIndex</tt> is negative or
                                   if <tt>highIndex</tt> is greater than <tt>src.length*64</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/PackedBitArrays.html#indexOfBit(long[], long, long, boolean)"><CODE>indexOfBit(long[], long, long, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="cardinality(long[], long, long)"><!-- --></A><H3>
cardinality</H3>
<PRE>
public static long <STRONG>cardinality</STRONG>(long[]&nbsp;src,
                               long&nbsp;fromIndex,
                               long&nbsp;toIndex)</PRE>
<DL>
<DD>Returns the number of high bits (1) in the given fragment of the given packed bit array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source packed bit array.</DD><DD><CODE>fromIndex</CODE> - the initial checked bit index in <tt>array</tt>, inclusive.</DD><DD><CODE>toIndex</CODE> - the end checked bit index in <tt>array</tt>, exclusive.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of high bits (1) in the given fragment of the given packed bit array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <tt>src</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>fromIndex</tt> or <tt>toIndex</tt> are negative,
                                   if <tt>toIndex</tt> is greater than <tt>src.length*64</tt>,
                                   or if <tt>fromIndex</tt> is greater than <tt>startIndex</tt></DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/ObjectStack.html" title="interface in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/PackedBitBuffers.html" title="class in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/PackedBitArrays.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="PackedBitArrays.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
