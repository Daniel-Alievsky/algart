<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Array
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Array";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/AbstractUpdatableShortArray.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/ArrayComparator.html" title="interface in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/Array.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Array.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.arrays</FONT>
<BR>
Interface Array</H2>
<DL>
<DT><STRONG>All Known Subinterfaces:</STRONG></DT> <DD><A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>, <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays">ByteArray</A>, <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays">CharArray</A>, <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays">DoubleArray</A>, <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays">FloatArray</A>, <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays">IntArray</A>, <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays">LongArray</A>, <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays">MutableArray</A>, <A HREF="../../../net/algart/arrays/MutableBitArray.html" title="interface in net.algart.arrays">MutableBitArray</A>, <A HREF="../../../net/algart/arrays/MutableByteArray.html" title="interface in net.algart.arrays">MutableByteArray</A>, <A HREF="../../../net/algart/arrays/MutableCharArray.html" title="interface in net.algart.arrays">MutableCharArray</A>, <A HREF="../../../net/algart/arrays/MutableDoubleArray.html" title="interface in net.algart.arrays">MutableDoubleArray</A>, <A HREF="../../../net/algart/arrays/MutableFloatArray.html" title="interface in net.algart.arrays">MutableFloatArray</A>, <A HREF="../../../net/algart/arrays/MutableIntArray.html" title="interface in net.algart.arrays">MutableIntArray</A>, <A HREF="../../../net/algart/arrays/MutableLongArray.html" title="interface in net.algart.arrays">MutableLongArray</A>, <A HREF="../../../net/algart/arrays/MutableObjectArray.html" title="interface in net.algart.arrays">MutableObjectArray</A>&lt;E&gt;, <A HREF="../../../net/algart/arrays/MutableObjectInPlaceArray.html" title="interface in net.algart.arrays">MutableObjectInPlaceArray</A>&lt;E&gt;, <A HREF="../../../net/algart/arrays/MutablePArray.html" title="interface in net.algart.arrays">MutablePArray</A>, <A HREF="../../../net/algart/arrays/MutablePFixedArray.html" title="interface in net.algart.arrays">MutablePFixedArray</A>, <A HREF="../../../net/algart/arrays/MutablePFloatingArray.html" title="interface in net.algart.arrays">MutablePFloatingArray</A>, <A HREF="../../../net/algart/arrays/MutablePIntegerArray.html" title="interface in net.algart.arrays">MutablePIntegerArray</A>, <A HREF="../../../net/algart/arrays/MutablePNumberArray.html" title="interface in net.algart.arrays">MutablePNumberArray</A>, <A HREF="../../../net/algart/arrays/MutableShortArray.html" title="interface in net.algart.arrays">MutableShortArray</A>, <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays">ObjectArray</A>&lt;E&gt;, <A HREF="../../../net/algart/arrays/ObjectInPlaceArray.html" title="interface in net.algart.arrays">ObjectInPlaceArray</A>&lt;E&gt;, <A HREF="../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>, <A HREF="../../../net/algart/arrays/PFixedArray.html" title="interface in net.algart.arrays">PFixedArray</A>, <A HREF="../../../net/algart/arrays/PFloatingArray.html" title="interface in net.algart.arrays">PFloatingArray</A>, <A HREF="../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>, <A HREF="../../../net/algart/arrays/PNumberArray.html" title="interface in net.algart.arrays">PNumberArray</A>, <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays">ShortArray</A>, <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>, <A HREF="../../../net/algart/arrays/UpdatableBitArray.html" title="interface in net.algart.arrays">UpdatableBitArray</A>, <A HREF="../../../net/algart/arrays/UpdatableByteArray.html" title="interface in net.algart.arrays">UpdatableByteArray</A>, <A HREF="../../../net/algart/arrays/UpdatableCharArray.html" title="interface in net.algart.arrays">UpdatableCharArray</A>, <A HREF="../../../net/algart/arrays/UpdatableDoubleArray.html" title="interface in net.algart.arrays">UpdatableDoubleArray</A>, <A HREF="../../../net/algart/arrays/UpdatableFloatArray.html" title="interface in net.algart.arrays">UpdatableFloatArray</A>, <A HREF="../../../net/algart/arrays/UpdatableIntArray.html" title="interface in net.algart.arrays">UpdatableIntArray</A>, <A HREF="../../../net/algart/arrays/UpdatableLongArray.html" title="interface in net.algart.arrays">UpdatableLongArray</A>, <A HREF="../../../net/algart/arrays/UpdatableObjectArray.html" title="interface in net.algart.arrays">UpdatableObjectArray</A>&lt;E&gt;, <A HREF="../../../net/algart/arrays/UpdatableObjectInPlaceArray.html" title="interface in net.algart.arrays">UpdatableObjectInPlaceArray</A>&lt;E&gt;, <A HREF="../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>, <A HREF="../../../net/algart/arrays/UpdatablePFixedArray.html" title="interface in net.algart.arrays">UpdatablePFixedArray</A>, <A HREF="../../../net/algart/arrays/UpdatablePFloatingArray.html" title="interface in net.algart.arrays">UpdatablePFloatingArray</A>, <A HREF="../../../net/algart/arrays/UpdatablePIntegerArray.html" title="interface in net.algart.arrays">UpdatablePIntegerArray</A>, <A HREF="../../../net/algart/arrays/UpdatablePNumberArray.html" title="interface in net.algart.arrays">UpdatablePNumberArray</A>, <A HREF="../../../net/algart/arrays/UpdatableShortArray.html" title="interface in net.algart.arrays">UpdatableShortArray</A></DD>
</DL>
<DL>
<DT><STRONG>All Known Implementing Classes:</STRONG></DT> <DD><A HREF="../../../net/algart/arrays/AbstractArray.html" title="class in net.algart.arrays">AbstractArray</A>, <A HREF="../../../net/algart/arrays/AbstractBitArray.html" title="class in net.algart.arrays">AbstractBitArray</A>, <A HREF="../../../net/algart/arrays/AbstractByteArray.html" title="class in net.algart.arrays">AbstractByteArray</A>, <A HREF="../../../net/algart/arrays/AbstractCharArray.html" title="class in net.algart.arrays">AbstractCharArray</A>, <A HREF="../../../net/algart/arrays/AbstractDoubleArray.html" title="class in net.algart.arrays">AbstractDoubleArray</A>, <A HREF="../../../net/algart/arrays/AbstractFloatArray.html" title="class in net.algart.arrays">AbstractFloatArray</A>, <A HREF="../../../net/algart/arrays/AbstractIntArray.html" title="class in net.algart.arrays">AbstractIntArray</A>, <A HREF="../../../net/algart/arrays/AbstractLongArray.html" title="class in net.algart.arrays">AbstractLongArray</A>, <A HREF="../../../net/algart/arrays/AbstractObjectArray.html" title="class in net.algart.arrays">AbstractObjectArray</A>, <A HREF="../../../net/algart/arrays/AbstractShortArray.html" title="class in net.algart.arrays">AbstractShortArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableBitArray.html" title="class in net.algart.arrays">AbstractUpdatableBitArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableByteArray.html" title="class in net.algart.arrays">AbstractUpdatableByteArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableCharArray.html" title="class in net.algart.arrays">AbstractUpdatableCharArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableDoubleArray.html" title="class in net.algart.arrays">AbstractUpdatableDoubleArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableFloatArray.html" title="class in net.algart.arrays">AbstractUpdatableFloatArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableIntArray.html" title="class in net.algart.arrays">AbstractUpdatableIntArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableLongArray.html" title="class in net.algart.arrays">AbstractUpdatableLongArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableObjectArray.html" title="class in net.algart.arrays">AbstractUpdatableObjectArray</A>, <A HREF="../../../net/algart/arrays/AbstractUpdatableShortArray.html" title="class in net.algart.arrays">AbstractUpdatableShortArray</A></DD>
</DL>
<HR>
<PRE>public interface <STRONG>Array</STRONG></PRE>

<P>
<p>AlgART array of any elements, read-only access.</p>

 <p>It is the basic superinterface for <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A> and <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>.
 Unlike that interfaces, the methods of this interface
 does not allow to modify elements or a number of elements.
 The instances of this interface, which do not implement
 its inheritors <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> and <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A>,
 are usually returned by  <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A> method.</p>

 <p>If the elements of this array are primitive values (<tt>byte</tt>, <tt>short</tt>, etc.),
 the array <b>must</b> implement one of
 <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>, <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>, <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>, <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>, <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>
 subinterfaces.
 In other case, the array <b>must</b> implement <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A> subinterface.</p>

 <p><A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>Immutable</CODE></A> arrays, implementing this interface,
 are <b>thread-safe</b> and can be used simultaneously in several threads.
 All other kinds of arrays <b>are thread-compatible</b>
 and can be synchronized manually if multithread access is necessary.
 Please see more details in the
 <a href="package-summary.html#multithreading">package description</a>.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>, 
<A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A>, 
<A HREF="../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays"><CODE>Matrix</CODE></A></DD></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()">asCopyOnNextWrite</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <i>copy-on-next-write</i> view of this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#asImmutable()">asImmutable</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an <i>immutable</i> view of this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()">asTrustedImmutable</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <i>trusted immutable</i> view of this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#buffer()">buffer</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><CODE>buffer(suitableMode, someCapacity)</CODE></A>, where both <tt>suitableMode</tt> and <tt>someCapacity</tt>
 arguments are chosen automatically.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode)">buffer</A></STRONG>(<A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html" title="enum in net.algart.arrays">DataBuffer.AccessMode</A>&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><CODE>buffer(mode, someCapacity)</CODE></A>, where <tt>mode</tt> is the argument of this method
 and <tt>someCapacity</tt> is chosen automatically to provide good performance in typical situations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)">buffer</A></STRONG>(<A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html" title="enum in net.algart.arrays">DataBuffer.AccessMode</A>&nbsp;mode,
       long&nbsp;capacity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays"><CODE>data buffer</CODE></A> allowing block access to this array
 with the specified <A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html" title="enum in net.algart.arrays"><CODE>access mode</CODE></A> and buffer capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#buffer(long)">buffer</A></STRONG>(long&nbsp;capacity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><CODE>buffer(suitableMode, capacity)</CODE></A>, where <tt>capacity</tt> is the argument of this method
 and <tt>suitableMode</tt> is chosen automatically.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.nio.ByteOrder</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#byteOrder()">byteOrder</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the byte order used by this array for storing data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#capacity()">capacity</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the capacity of this array: the number of elements
 allocated for storing elements in this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#checkUnallowedMutation()">checkUnallowedMutation</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to check, whether some unallowed mutations of this <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>trusted immutable</CODE></A> array took place,
 and throw <A HREF="../../../net/algart/arrays/UnallowedMutationError.html" title="class in net.algart.arrays"><CODE>UnallowedMutationError</CODE></A> in this case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#elementType()">elementType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of array elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#equals(java.lang.Object)">equals</A></STRONG>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether some other array is equal to this one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)">flushResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)"><CODE>flushResources</CODE></A>(context, false)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)">flushResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
               boolean&nbsp;forcePhysicalWriting)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If there are some external resources, associated with this array, &mdash;
 files, streams, sockets, locks, etc&#46; &mdash;
 and some array data are not still reflected in that resources
 (for example, were not saved in the disk file yet),
 this method <i>flushs</i> all these data to the external devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)">freeResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext, boolean)"><CODE>freeResources</CODE></A>(context, false)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext, boolean)">freeResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
              boolean&nbsp;forcePhysicalWriting)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If there are some resources, associated with this array, which are not controlled
 by Java garbage collectors &mdash; files, streams, sockets, locks, etc&#46; &mdash;
 this method tries to release them (for example, to close any files).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#getData(long, java.lang.Object)">getData</A></STRONG>(long&nbsp;arrayPos,
        java.lang.Object&nbsp;destArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>min(this.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length() - arrayPos</CODE></A>, destArray.length})</tt>
 elements of this array, starting from <tt>arrayPos</tt> index,
 into the specified Java array of corresponding type, starting from <tt>0</tt> index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#getData(long, java.lang.Object, int, int)">getData</A></STRONG>(long&nbsp;arrayPos,
        java.lang.Object&nbsp;destArray,
        int&nbsp;destArrayOffset,
        int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies <tt>count</tt> elements of this array, starting from <tt>arrayPos</tt> index,
 into the specified Java array of corresponding type, starting from <tt>destArrayOffset</tt> index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#getElement(long)">getElement</A></STRONG>(long&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the element #<tt>index</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#hashCode()">hashCode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash code of this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()">isCopyOnNextWrite</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this array is copy-on-next-write.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#isImmutable()">isImmutable</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this instance is <i>immutable</i>, i&#46;e&#46; there are no ways to
 change its content or state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#isLazy()">isLazy</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this array instance is <i>lazy</i>, i&#46;e&#46;
 if an access to its element means some calculations for producing result or actual saving element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#isNew()">isNew</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this array instance is <i>new</i>, i&#46;e&#46; it was created
 by one of <A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays"><CODE>MemoryModel</CODE></A> methods, creating an array or a matrix (<tt>newXxx</tt>
 or <tt>valueOf</tt>), or by fully equivalent methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()">isNewReadOnlyView</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this array instance is <i>new-read-only-view</i>, i&#46;e&#46;
 a newly created <i>view</i> of some external data, providing <i>read-only</i> access to this data &mdash;
 like <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asArray(P, java.lang.Class, long, long, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asArray(Object, Class, long, long, java.nio.ByteOrder)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#isUnresizable()">isUnresizable</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this instance is unresizable, i&#46;e&#46; there are no ways to
 change its length or capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#length()">length</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the length: number of elements in this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#loadResources(net.algart.arrays.ArrayContext)">loadResources</A></STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If there are some external resources, associated with this array, &mdash;
 files, streams, sockets, locks, etc&#46; &mdash;
 this method makes an effort to ensure that, when it returns,
 the content of this array will be resident in physical memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays">MutableArray</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#mutableClone(net.algart.arrays.MemoryModel)">mutableClone</A></STRONG>(<A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays">MemoryModel</A>&nbsp;memoryModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a mutable resizable copy of this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays">MutableArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#mutableType()">mutableType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>canonical resizable AlgART type</i> of arrays with the same element types:
 the class of one of 9 basic interfaces,
 describing all kinds of resizable AlgART arrays for 8 primitive and any non-primitive element types.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#newJavaArray(int)">newJavaArray</A></STRONG>(int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns usual Java-array (zero-filled) with the specified length
 and element type returned by <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#shallowClone()">shallowClone</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a "shallow" clone of this object:
 another array consisting of the same elements,
 but with independent length, start offset, capacity, copy-on-next-write and
 possible other information about any array characteristics besides its elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#subArr(long, long)">subArr</A></STRONG>(long&nbsp;position,
       long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(position, position + count)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)">subArray</A></STRONG>(long&nbsp;fromIndex,
         long&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a view of the portion of this array between <tt>fromIndex</tt>,
 inclusive, and <tt>toIndex</tt>, exclusive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#toString()">toString</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a brief string description of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#type()">type</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>canonical AlgART type</i> of this array: the class of one of 9 basic interfaces,
 describing all kinds of AlgART arrays for 8 primitive and any non-primitive element types.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)">updatableClone</A></STRONG>(<A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays">MemoryModel</A>&nbsp;memoryModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an unresizable updatable copy of this array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../net/algart/arrays/Array.html#updatableType()">updatableType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>canonical updatable AlgART type</i> of arrays with the same element types:
 the class of one of 9 basic interfaces,
 describing all kinds of updatable AlgART arrays for 8 primitive and any non-primitive element types.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="elementType()"><!-- --></A><H3>
elementType</H3>
<PRE>
java.lang.Class&lt;?&gt; <STRONG>elementType</STRONG>()</PRE>
<DL>
<DD>Returns the type of array elements.
 For arrays of primitive types, returns:<ul>
 <li><tt>boolean.class</tt> for <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>,</li>
 <li><tt>char.class</tt> for <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,</li>
 <li><tt>byte.class</tt> for <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>,</li>
 <li><tt>short.class</tt> for <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,</li>
 <li><tt>int.class</tt> for <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>),</li>
 <li><tt>long.class</tt> for <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,</li>
 <li><tt>float.class</tt> for <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>,</li>
 <li><tt>double.class</tt> for <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>.</li>
 </ul>
 All elements of the array are values of this type or (for non-primitive types)
 some inheritor of this type.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of array elements.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Arrays.html#elementType(java.lang.Class)"><CODE>Arrays.elementType(Class)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="type()"><!-- --></A><H3>
type</H3>
<PRE>
java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A>&gt; <STRONG>type</STRONG>()</PRE>
<DL>
<DD>Returns the <i>canonical AlgART type</i> of this array: the class of one of 9 basic interfaces,
 describing all kinds of AlgART arrays for 8 primitive and any non-primitive element types.
 More precisely, returns:<ul>
 <li><tt><A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>.</li>
 </ul>

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant value).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>canonical AlgART type of this array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="updatableType()"><!-- --></A><H3>
updatableType</H3>
<PRE>
java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A>&gt; <STRONG>updatableType</STRONG>()</PRE>
<DL>
<DD>Returns the <i>canonical updatable AlgART type</i> of arrays with the same element types:
 the class of one of 9 basic interfaces,
 describing all kinds of updatable AlgART arrays for 8 primitive and any non-primitive element types.
 More precisely, returns:<ul>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableBitArray.html" title="interface in net.algart.arrays"><CODE>UpdatableBitArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableCharArray.html" title="interface in net.algart.arrays"><CODE>UpdatableCharArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableByteArray.html" title="interface in net.algart.arrays"><CODE>UpdatableByteArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableShortArray.html" title="interface in net.algart.arrays"><CODE>UpdatableShortArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableIntArray.html" title="interface in net.algart.arrays"><CODE>UpdatableIntArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableLongArray.html" title="interface in net.algart.arrays"><CODE>UpdatableLongArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableFloatArray.html" title="interface in net.algart.arrays"><CODE>UpdatableFloatArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableDoubleArray.html" title="interface in net.algart.arrays"><CODE>UpdatableDoubleArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/UpdatableObjectArray.html" title="interface in net.algart.arrays"><CODE>UpdatableObjectArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>.</li>
 </ul>

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant value).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>canonical AlgART type of an updatable array of the same kind.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="mutableType()"><!-- --></A><H3>
mutableType</H3>
<PRE>
java.lang.Class&lt;? extends <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays">MutableArray</A>&gt; <STRONG>mutableType</STRONG>()</PRE>
<DL>
<DD>Returns the <i>canonical resizable AlgART type</i> of arrays with the same element types:
 the class of one of 9 basic interfaces,
 describing all kinds of resizable AlgART arrays for 8 primitive and any non-primitive element types.
 More precisely, returns:<ul>
 <li><tt><A HREF="../../../net/algart/arrays/MutableBitArray.html" title="interface in net.algart.arrays"><CODE>MutableBitArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableCharArray.html" title="interface in net.algart.arrays"><CODE>MutableCharArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableByteArray.html" title="interface in net.algart.arrays"><CODE>MutableByteArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableShortArray.html" title="interface in net.algart.arrays"><CODE>MutableShortArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableIntArray.html" title="interface in net.algart.arrays"><CODE>MutableIntArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableLongArray.html" title="interface in net.algart.arrays"><CODE>MutableLongArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableFloatArray.html" title="interface in net.algart.arrays"><CODE>MutableFloatArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableDoubleArray.html" title="interface in net.algart.arrays"><CODE>MutableDoubleArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>,</li>
 <li><tt><A HREF="../../../net/algart/arrays/MutableObjectArray.html" title="interface in net.algart.arrays"><CODE>MutableObjectArray</CODE></A>.class</tt>, if this object is an instance of <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>.</li>
 </ul>

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant value).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>canonical AlgART type of a resizable array of the same kind.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="length()"><!-- --></A><H3>
length</H3>
<PRE>
long <STRONG>length</STRONG>()</PRE>
<DL>
<DD>Returns the length: number of elements in this array.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
 The result of this method is never negative.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the length: number of elements in this array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="capacity()"><!-- --></A><H3>
capacity</H3>
<PRE>
long <STRONG>capacity</STRONG>()</PRE>
<DL>
<DD>Returns the capacity of this array: the number of elements
 allocated for storing elements in this array.
 For resizable arrays (implementing <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A> interface),
 the internal storage will be reallocated after <A HREF="../../../net/algart/arrays/MutableArray.html#length(long)"><CODE>MutableArray.length(long)</CODE></A>
 call only if the new length is <i>greater</i> than the current capacity.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the capacity of this array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getElement(long)"><!-- --></A><H3>
getElement</H3>
<PRE>
java.lang.Object <STRONG>getElement</STRONG>(long&nbsp;index)</PRE>
<DL>
<DD>Returns the element #<tt>index</tt>.
 It this array contains elements of primitive types,
 the value is automatically wrapped in an object (<tt>Boolean</tt>,
 <tt>Byte</tt>, etc.).

 <p>It is a low-level method.
 For arrays of primitive elements, implementing one of corresponding interfaces
 <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>, <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>, <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>, <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>, <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>,
 we recommend to use more efficient equivalent method of that interfaces:
 <A HREF="../../../net/algart/arrays/BitArray.html#getBit(long)"><CODE>BitArray.getBit(long)</CODE></A>, <A HREF="../../../net/algart/arrays/CharArray.html#getChar(long)"><CODE>CharArray.getChar(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/ByteArray.html#getByte(long)"><CODE>ByteArray.getByte(long)</CODE></A>, <A HREF="../../../net/algart/arrays/ShortArray.html#getShort(long)"><CODE>ShortArray.getShort(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/IntArray.html#getInt(long)"><CODE>IntArray.getInt(long)</CODE></A>, <A HREF="../../../net/algart/arrays/LongArray.html#getLong(long)"><CODE>LongArray.getLong(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/FloatArray.html#getFloat(long)"><CODE>FloatArray.getFloat(long)</CODE></A>, <A HREF="../../../net/algart/arrays/DoubleArray.html#getDouble(long)"><CODE>DoubleArray.getDouble(long)</CODE></A>.
 For other arrays, implementing <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>,
 we recommend to use <A HREF="../../../net/algart/arrays/ObjectArray.html#get(long)"><CODE>ObjectArray.get(long)</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>index</CODE> - index of element to get.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the element at the specified position in this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>index</tt> is out of range <tt>0..length()-1</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getData(long, java.lang.Object, int, int)"><!-- --></A><H3>
getData</H3>
<PRE>
void <STRONG>getData</STRONG>(long&nbsp;arrayPos,
             java.lang.Object&nbsp;destArray,
             int&nbsp;destArrayOffset,
             int&nbsp;count)</PRE>
<DL>
<DD>Copies <tt>count</tt> elements of this array, starting from <tt>arrayPos</tt> index,
 into the specified Java array of corresponding type, starting from <tt>destArrayOffset</tt> index.

 <p>For non-primitive element type (<A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>, <A HREF="../../../net/algart/arrays/UpdatableObjectArray.html" title="interface in net.algart.arrays"><CODE>UpdatableObjectArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableObjectArray.html" title="interface in net.algart.arrays"><CODE>MutableObjectArray</CODE></A> subinterfaces), this method may allocate new instances
 for Java array elements <tt>destArray[destArrayOffset]..destArray[destArrayOffset+count-1]</tt>,
 but also may change the state of already existing non-null elements: it depends on implementation.
 In any case, you can be sure that if some of target elements <tt>destArray[k]==null</tt>,
 this method always allocate new element.

 <p>Note: if <tt>IndexOutOfBoundsException</tt> occurs due to attempt to write data outside the passed
 Java array, the target Java array can be partially filled.
 In other words, this method <b>can be non-atomic regarding this failure</b>.
 All other possible exceptions are checked in the very beginning of this method
 before any other actions (the standard way for checking exceptions).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arrayPos</CODE> - starting position in this AlgART array.</DD><DD><CODE>destArray</CODE> - the target Java array.</DD><DD><CODE>destArrayOffset</CODE> - starting position in the target Java array.</DD><DD><CODE>count</CODE> - the number of elements to be copied.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>destArray</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>destArray</tt> argument is not an array.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if copying would cause access of data outside this array or target Java array.</DD>
<DD><CODE>java.lang.ArrayStoreException</CODE> - if <tt>destArray</tt> element type mismatches with this array
                                   <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>destArray</tt> element type mismatches with this array
                                   <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A>
                                   (both this and <tt>ArrayStoreException</tt> are possible,
                                   depending on implementation).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>, 
<A HREF="../../../net/algart/arrays/UpdatableArray.html#setData(long, java.lang.Object, int, int)"><CODE>UpdatableArray.setData(long, Object, int, int)</CODE></A>, 
<A HREF="../../../net/algart/arrays/BitArray.html#getBits(long, long[], long, long)"><CODE>BitArray.getBits(long, long[], long, long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="getData(long, java.lang.Object)"><!-- --></A><H3>
getData</H3>
<PRE>
void <STRONG>getData</STRONG>(long&nbsp;arrayPos,
             java.lang.Object&nbsp;destArray)</PRE>
<DL>
<DD>Copies <tt>min(this.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length() - arrayPos</CODE></A>, destArray.length})</tt>
 elements of this array, starting from <tt>arrayPos</tt> index,
 into the specified Java array of corresponding type, starting from <tt>0</tt> index.

 <p>For non-primitive element type (<A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>, <A HREF="../../../net/algart/arrays/UpdatableObjectArray.html" title="interface in net.algart.arrays"><CODE>UpdatableObjectArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableObjectArray.html" title="interface in net.algart.arrays"><CODE>MutableObjectArray</CODE></A> subinterfaces), this method may allocate new instances
 for Java array elements <tt>destArray[0]..destArray[count-1]</tt>,
 but also may change the state of already existing non-null elements: it depends on implementation.
 In any case, you can be sure that if some of target elements <tt>destArray[k]==null</tt>,
 this method always allocate new element.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>arrayPos</CODE> - starting position in this AlgART array.</DD><DD><CODE>destArray</CODE> - the target Java array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>destArray</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>destArray</tt> argument is not an array.</DD>
<DD><CODE>java.lang.ArrayStoreException</CODE> - if <tt>destArray</tt> element type mismatches with this array
                                   <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A>.</DD>
<DD><CODE>java.lang.ClassCastException</CODE> - if <tt>destArray</tt> element type mismatches with this array
                                   <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A>
                                   (both this and <tt>ArrayStoreException</tt> are possible,
                                   depending on implementation).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#getData(long, java.lang.Object, int, int)"><CODE>getData(long, Object, int, int)</CODE></A>, 
<A HREF="../../../net/algart/arrays/UpdatableArray.html#setData(long, java.lang.Object)"><CODE>UpdatableArray.setData(long, Object)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="newJavaArray(int)"><!-- --></A><H3>
newJavaArray</H3>
<PRE>
java.lang.Object <STRONG>newJavaArray</STRONG>(int&nbsp;length)</PRE>
<DL>
<DD>Returns usual Java-array (zero-filled) with the specified length
 and element type returned by <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A> method.

 <p>This method is equivalent to the following call:
 <tt>java.lang.reflect.Array.newInstance(elementType(),&nbsp;length)</tt>.

 <p>This method can be helpful while using together with
 <A HREF="../../../net/algart/arrays/Array.html#getData(long, java.lang.Object, int, int)"><CODE>getData</CODE></A> /
 <A HREF="../../../net/algart/arrays/UpdatableArray.html#setData(long, java.lang.Object, int, int)"><CODE>setData</CODE></A> methods.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>length</CODE> - the length of created Java-array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>Java-array with the specified length and the same type of elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NegativeArraySizeException</CODE> - if the specified <tt>length</tt> is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="subArray(long, long)"><!-- --></A><H3>
subArray</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A> <STRONG>subArray</STRONG>(long&nbsp;fromIndex,
               long&nbsp;toIndex)</PRE>
<DL>
<DD>Returns a view of the portion of this array between <tt>fromIndex</tt>,
 inclusive, and <tt>toIndex</tt>, exclusive.
 <ul>
 <li>If <tt>fromIndex</tt> and <tt>toIndex</tt> are equal, the returned array is empty.
 <li>The returned array is backed by this array, so &mdash; if this array is not immutable
 &mdash; any changes of the elements of the returned array are reflected in this array, and vice-versa.
 <li>The capacity of returned array (returned by <A HREF="../../../net/algart/arrays/Array.html#capacity()"><CODE>capacity()</CODE></A> method) will be
 equal to the its length (returned by <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>, that is <tt>toIndex-fromIndex</tt>.
 <li>The <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>type of elements</CODE></A> of the returned array is the same
 as the type of elements of this array.</li>
 <li>The returned array is <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable</CODE></A>,
 <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>trusted immutable</CODE></A> or
 <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A>, if, and only if,
 this array is immutable, trusted immutable or copy-on-next-write correspondingly.</li>
 <li>If (and only if) this array implements <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface,
 then the returned array also implements it.
 If (and only if) this array implements <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A> interface,
 then the returned array also implements it.
 The returned array <i>never</i> implements <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A> interface;
 it is always <i>unresizable</i>.</li>
 </ul>

 <p>Like <tt>List.subList</tt> method, this method eliminates the need
 for explicit range operations.
 For example, you may use <A HREF="../../../net/algart/arrays/Arrays.html#sort(net.algart.arrays.UpdatableArray, net.algart.arrays.ArrayComparator)"><CODE>Arrays.sort(UpdatableArray, ArrayComparator)</CODE></A>
 method for sorting a fragment of the array.

 <p>Unlike <tt>List.subList</tt>, the semantics of the array returned
 by this method is well-defined in any case, even in case of
 resizing of the source array.
 Namely, if the internal storage of this or returned array is reallocated,
 then the returned array will cease to be a view of this array.
 The only possible reasons for reallocation are the following:
 calling <A HREF="../../../net/algart/arrays/MutableArray.html#length(long)"><CODE>MutableArray.length(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableArray.html#ensureCapacity(long)"><CODE>MutableArray.ensureCapacity(long)</CODE></A> or <A HREF="../../../net/algart/arrays/MutableArray.html#trim()"><CODE>MutableArray.trim()</CODE></A> methods
 for this array, or any modification of this or returned array in a case when
 this array is <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A>.
 Also, if the length of this array will be reduced,
 it can lead to clearing some elements in returned array:
 see comments to <A HREF="../../../net/algart/arrays/MutableArray.html#length(long)"><CODE>MutableArray.length(long)</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>fromIndex</CODE> - low endpoint (inclusive) of the subarray.</DD><DD><CODE>toIndex</CODE> - high endpoint (exclusive) of the subarray.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified range within this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - for illegal <tt>fromIndex</tt> and <tt>toIndex</tt>
                                   (<tt>fromIndex &lt; 0 || toIndex &gt; <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>
                                   || fromIndex &gt; toIndex</tt>).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#subArr(long, long)"><CODE>subArr(long, long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="subArr(long, long)"><!-- --></A><H3>
subArr</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A> <STRONG>subArr</STRONG>(long&nbsp;position,
             long&nbsp;count)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(position, position + count)</CODE></A>.
 The only possible difference is other exception messages.
 If <tt>position+count&gt;Long.MAX_VALUE</tt> (overflow),
 an exception message is allowed to be not fully correct
 (maximal speed is more important than absolutely correct exception messages for such exotic situations).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>position</CODE> - start position (inclusive) of the subarray.</DD><DD><CODE>count</CODE> - number of elements in the subarray.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a view of the specified range within this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - for illegal <tt>position</tt> and <tt>count</tt>
                                   (<tt>position &lt; 0 || count &lt; 0
                                   || position + count &gt; <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A></tt>).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(long, long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><!-- --></A><H3>
buffer</H3>
<PRE>
<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A> <STRONG>buffer</STRONG>(<A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html" title="enum in net.algart.arrays">DataBuffer.AccessMode</A>&nbsp;mode,
                  long&nbsp;capacity)</PRE>
<DL>
<DD>Returns a <A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays"><CODE>data buffer</CODE></A> allowing block access to this array
 with the specified <A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html" title="enum in net.algart.arrays"><CODE>access mode</CODE></A> and buffer capacity.

 <p>If this array does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface
 (so, it is probably <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable</CODE></A> or <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>trusted immutable</CODE></A>), the <tt>mode</tt> argument must be <A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html#READ"><CODE>DataBuffer.AccessMode.READ</CODE></A>.

 <p>The <tt>capacity</tt> argument must be in range <tt>0..2<sup>37</sup>-1</tt>
 for <A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>bit arrays</CODE></A> or <tt>0..2<sup>31</sup>-1</tt> for all other element types.

 <p>If the <tt>capacity</tt> argument is greater than this array <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>,
 it is truncated to this length.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>mode</CODE> - the access mode for new buffer.</DD><DD><CODE>capacity</CODE> - the capacity of the buffer.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new data buffer for accessing this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>mode</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <tt>mode</tt> is not the <A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html#READ"><CODE>DataBuffer.AccessMode.READ</CODE></A>,
                                  but this arrays does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface,
                                  or if the specified <tt>capacity</tt> is negative or too high
                                  (&gt;=0..2<sup>37</sup> for bits or &gt;=0..2<sup>31</sup> for
                                  other element types).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode)"><CODE>buffer(net.algart.arrays.DataBuffer.AccessMode)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#buffer(long)"><CODE>buffer(long)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#buffer()"><CODE>buffer()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(net.algart.arrays.DataBuffer.AccessMode)"><!-- --></A><H3>
buffer</H3>
<PRE>
<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A> <STRONG>buffer</STRONG>(<A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html" title="enum in net.algart.arrays">DataBuffer.AccessMode</A>&nbsp;mode)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><CODE>buffer(mode, someCapacity)</CODE></A>, where <tt>mode</tt> is the argument of this method
 and <tt>someCapacity</tt> is chosen automatically to provide good performance in typical situations.
 Usually, the capacity is chosen to get a buffer occupying several kilobytes,
 that can fit in an internal cache of most processors.

 <p>In any case, you can be sure that the chosen capacity will not be greater than <tt>Integer.MAX_VALUE-64</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>mode</CODE> - the access mode for new buffer.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new data buffer for accessing this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>mode</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <tt>mode</tt> is not the <A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html#READ"><CODE>DataBuffer.AccessMode.READ</CODE></A>,
                                  but this arrays does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="buffer(long)"><!-- --></A><H3>
buffer</H3>
<PRE>
<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A> <STRONG>buffer</STRONG>(long&nbsp;capacity)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><CODE>buffer(suitableMode, capacity)</CODE></A>, where <tt>capacity</tt> is the argument of this method
 and <tt>suitableMode</tt> is chosen automatically. Namely, <tt>suitableMode</tt> is:<ul>
 <li><A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html#READ_WRITE"><CODE>DataBuffer.AccessMode.READ_WRITE</CODE></A> if this array implements <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface
 (i.e., is modifiable and, maybe, resizable);</li>
 <li><A HREF="../../../net/algart/arrays/DataBuffer.AccessMode.html#READ"><CODE>DataBuffer.AccessMode.READ</CODE></A> if this array does not implements this interface
 (i.e., probably, immutable or <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>trusted immutable</CODE></A>).</li>
 </ul>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>capacity</CODE> - the capacity of the buffer.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new data buffer for accessing this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the specified <tt>capacity</tt> is negative or too high
                                  (&gt;=0..2<sup>37</sup> for bits or &gt;=0..2<sup>31</sup> for
                                  other element types).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="buffer()"><!-- --></A><H3>
buffer</H3>
<PRE>
<A HREF="../../../net/algart/arrays/DataBuffer.html" title="interface in net.algart.arrays">DataBuffer</A> <STRONG>buffer</STRONG>()</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode, long)"><CODE>buffer(suitableMode, someCapacity)</CODE></A>, where both <tt>suitableMode</tt> and <tt>someCapacity</tt>
 arguments are chosen automatically. The algorithm of choosing these arguments is the same
 as for <A HREF="../../../net/algart/arrays/Array.html#buffer(net.algart.arrays.DataBuffer.AccessMode)"><CODE>buffer(net.algart.arrays.DataBuffer.AccessMode)</CODE></A> and <A HREF="../../../net/algart/arrays/Array.html#buffer(long)"><CODE>buffer(long)</CODE></A> methods.

 <p>In any case, you can be sure that the chosen capacity will not be greater than <tt>Integer.MAX_VALUE-64</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>new data buffer for accessing this array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="asImmutable()"><!-- --></A><H3>
asImmutable</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A> <STRONG>asImmutable</STRONG>()</PRE>
<DL>
<DD>Returns an <i>immutable</i> view of this array.
 If this array is already immutable (i.e. <A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A> is <tt>true</tt>),
 returns a reference to this object.

 <p>A array is considered to be <i>immutable</i>,
 if there are no ways to modify its content or state with help of this instance.
 In particular, immutable arrays never
 implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> or <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A> interfaces.
 Moreover, any third-party implementation of <tt>Array</tt> interface
 <i>must</i> return an instance of a class, which has no public methods or fields
 allowing to change this instance.

 <p>Query operations on the returned array "read through"
 to this array. The returned view is also unresizable
 (see <A HREF="../../../net/algart/arrays/UpdatableArray.html#asUnresizable()"><CODE>UpdatableArray.asUnresizable()</CODE></A>).

 <p>The returned view (when it is not a reference to this object) contains the same elements
 as this array, but independent length, start offset, capacity, copy-on-next-write and
 possible other information about array characteristics besides its elements,
 as for <A HREF="../../../net/algart/arrays/Array.html#shallowClone()"><CODE>shallowClone()</CODE></A> method.
 If modifications of this array characteristics lead to reallocation
 of the internal storage, then the returned array ceases to be a view of this array.
 The only possible reasons for reallocation are the following:
 calling <A HREF="../../../net/algart/arrays/MutableArray.html#length(long)"><CODE>MutableArray.length(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableArray.html#ensureCapacity(long)"><CODE>MutableArray.ensureCapacity(long)</CODE></A> or <A HREF="../../../net/algart/arrays/MutableArray.html#trim()"><CODE>MutableArray.trim()</CODE></A> methods
 for this array, or any modification of this or returned array in a case when
 this array is <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A>.

 <p>By default, the array factories (<A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays"><CODE>memory models</CODE></A>) create mutable arrays,
 but they can be converted to immutable by this method.

 <p>Note: <A HREF="../../../net/algart/arrays/Array.html#isNew()"><CODE>isNew()</CODE></A> method, called for the result of this method, always returns <tt>false</tt>
 &mdash; because it does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>.

 <p>Also note: <A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A> method, called for the result of this method, always returns
 the same value as <A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A> for this object.
 Really,
 <ul>
 <li>it this object is immutable (<tt><A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A>==true</tt>),
 then it is obvious (this method just returns a reference to this array);</li>
 <li>it this object is not immutable (<tt><A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A>==false</tt>),
 then, according to the contract to <A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A> method,
 <A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A> must return <tt>false</tt> for this array
 (in other case <A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A> would return <tt>true</tt>) and
 it also must return <tt>false</tt> for the returned array
 (because it is a view of another array and not an original view of external data &mdash;
 see the beginning of the comment to <A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A>).
 </li>
 </ul>
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an immutable view of this array (or a reference to this array if it is already immutable).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>asTrustedImmutable()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#mutableClone(net.algart.arrays.MemoryModel)"><CODE>mutableClone(MemoryModel)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)"><CODE>updatableClone(MemoryModel)</CODE></A>, 
<A HREF="../../../net/algart/arrays/UpdatableArray.html#asUnresizable()"><CODE>UpdatableArray.asUnresizable()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isImmutable()"><!-- --></A><H3>
isImmutable</H3>
<PRE>
boolean <STRONG>isImmutable</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this instance is <i>immutable</i>, i&#46;e&#46; there are no ways to
 change its content or state. (See <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A> method for more details.)

 <p>It is possible that array is immutable in fact, but this method returns <tt>false</tt>:
 for example, if the array is mapped to read-only file. However, it is guaranteed:
 <i>if the array was created via <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A> method, this method
 returns <tt>true</tt></i>.

 <p>Typically, this method returns <tt>true</tt> if the array:
 <ol>
 <li>does not implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface;</li>
 <li>does not implement <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A> interface, or implements it,
 but <A HREF="../../../net/algart/arrays/DirectAccessible.html#hasJavaArray()"><CODE>DirectAccessible.hasJavaArray()</CODE></A> method returns <tt>false</tt>.</li>
 </ol>

 <p>But you should not use these conditions to check whether an array is immutable;
 please use this method instead.
 In principle, it is possible that both these conditions are satisfied, but the array
 is though mutable. Maybe, some class from another package (or from future versions
 of this package), implementing <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays"><CODE>Array</CODE></A> interface, does not implement
 neither <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>, nor <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>, but offers another methods
 allowing to change its state or content.

 <p>Note: if this method returns <tt>true</tt>, it does not mean that its content cannot
 be modified at all. Quite the contrary, usually an immutable array <b>a</b>
 is just an immutable view of another mutable array <b>b</b>
 (created via <b>a</b>=<b>b.</b><A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A> call),
 and the original array <b>b</b> does allow to change the content of the immutable array <b>a</b>.
 Immutability means only that there are no ways to modify the content or state of the object <b>a</b>,
 <i>if this object</i> <b>a</b> <i>is the only reference to its content, which you have</i>.
 The same note is true for immutable collections, created by the standard
 <tt>Collections.unmodifiableList</tt> and analogous methods.
 Please compare this with the behaviour of another method <A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A>.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this instance is immutable.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asTrustedImmutable()"><!-- --></A><H3>
asTrustedImmutable</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A> <STRONG>asTrustedImmutable</STRONG>()</PRE>
<DL>
<DD>Returns a <i>trusted immutable</i> view of this array.
 If this array is already <i>trusted immutable</i>, returns a reference to this object.

 <p>A array is considered to be <i>"trusted" immutable</i>,
 if it <b>potentially can</b> change its elements,
 but the Java code working with this array <b>promises</b> that it will not change them.
 The returned instance <b>never</b> implements <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>,
 but <b>may</b> implement <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>, that allow quick access to its elements.
 As for <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>usual immutable view</CODE></A>,
 query operations on the returned array "read through"
 to this array.

 <p>The only standard way allowing to change elements of returned array
 is using <A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArray()"><CODE>DirectAccessible.javaArray()</CODE></A> method, in a case when the array is backed
 by an accessible array.
 But the Java code, processing the trusted immutable array,
 must use this method <i>only for quick reading</i> elements and <i>not try to change</i> them.
 If, despite the promise, the elements of the trusted immutable array will be changed,
 the <A HREF="../../../net/algart/arrays/UnallowedMutationError.html" title="class in net.algart.arrays"><CODE>UnallowedMutationError</CODE></A> may be thrown by the call of
 <A HREF="../../../net/algart/arrays/Array.html#checkUnallowedMutation()"><CODE>checkUnallowedMutation()</CODE></A> method.

 <p>In some implementations &mdash; for example, if <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A>
 interface is not supported by this array
 &mdash; this method may return the same result as <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A>.

 <p>The returned view is always unresizable.

 <p>The returned view (when it is not a reference to this object) contains the same elements
 as this array, but independent length, start offset, capacity, copy-on-next-write and
 possible other information about array characteristics besides its elements,
 as for <A HREF="../../../net/algart/arrays/Array.html#shallowClone()"><CODE>shallowClone()</CODE></A> method.
 If modifications of this array characteristics lead to reallocation
 of the internal storage, then the returned array ceases to be a view of this array.
 The only possible reasons for reallocation are the following:
 calling <A HREF="../../../net/algart/arrays/MutableArray.html#length(long)"><CODE>MutableArray.length(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableArray.html#ensureCapacity(long)"><CODE>MutableArray.ensureCapacity(long)</CODE></A> or <A HREF="../../../net/algart/arrays/MutableArray.html#trim()"><CODE>MutableArray.trim()</CODE></A> methods
 for this array, or any modification of this or returned array in a case when
 this array is <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A>.

 <p>Trusted immutable view is a compromise between absolute safety, provided by
 <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>usual immutable view</CODE></A>, and maximal efficiency,
 achieved while using the original non-protected array.
 Please see the <a href="package-summary.html#protectionAgainstUnallowedChanges">package description</a>
 to learn more about possible usage of this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a trusted immutable view of this array (or a reference to this array if it is already
         trusted immutable).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#checkUnallowedMutation()"><CODE>checkUnallowedMutation()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="checkUnallowedMutation()"><!-- --></A><H3>
checkUnallowedMutation</H3>
<PRE>
void <STRONG>checkUnallowedMutation</STRONG>()
                            throws <A HREF="../../../net/algart/arrays/UnallowedMutationError.html" title="class in net.algart.arrays">UnallowedMutationError</A></PRE>
<DL>
<DD>Tries to check, whether some unallowed mutations of this <A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>trusted immutable</CODE></A> array took place,
 and throw <A HREF="../../../net/algart/arrays/UnallowedMutationError.html" title="class in net.algart.arrays"><CODE>UnallowedMutationError</CODE></A> in this case.
 Does nothing if this array implement <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface
 or if it is truly immutable.

 <p>Implementation of this method usually checks whether the hash code was changed since array creation.

 <p>We recommend to call this method in <tt>finally</tt>
 sections after using the trusted immutable array.
 If it is impossible to create necessary <tt>finally</tt> section,
 you may use <A HREF="../../../net/algart/finalizing/Finalizer.html" title="class in net.algart.finalizing"><CODE>Finalizer</CODE></A> class (or an equivalent tool)
 to schedule call of this method for the <A HREF="../../../net/algart/arrays/Array.html#shallowClone()"><CODE>shallow clone</CODE></A> of this array
 on deallocation of this array:<pre>
 Finalizer fin = ...(some global application finalizer);
 final Array dup = thisArray.shallowClone();
 // - must be here, not inside the following inner class, to allow deallocation of thisArray
 fin.invokeOnDeallocation(thisArray, new Runnable() {
 &#32;   public void run() {
 &#32;       try {
 &#32;           dup.checkUnallowedMutation();
 &#32;       } catch (UnallowedMutationError ex) {
 &#32;           myLogger.severe(ex.toString());
 &#32;       }
 &#32;   }
 });
 </pre>
 Important: while using this finalization scheme, this array <i>must not be
 <A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A></i>!
 Illegal modifications of copy-on-next-write array will not change
 it's shallow clone and will not be detected.
<P>
</DD>
<DD><DL>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../net/algart/arrays/UnallowedMutationError.html" title="class in net.algart.arrays">UnallowedMutationError</A></CODE> - if some unallowed mutations of this array took place.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#asTrustedImmutable()"><CODE>asTrustedImmutable()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asCopyOnNextWrite()"><!-- --></A><H3>
asCopyOnNextWrite</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A> <STRONG>asCopyOnNextWrite</STRONG>()</PRE>
<DL>
<DD>Returns a <i>copy-on-next-write</i> view of this array.
 If this array is immutable (and only in this case), returns a reference to this object.
 If (and only if) this array implements <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A> interface,
 then the returned array also implements it.
 If (and only if) this array implements <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A> interface,
 then the returned array also implements it.

 <p><i>Copy-on-next-write</i> array is a array with the following special feature:
 the next attempt (but not further!) to modify this array,
 or any other access that can lead to its modification (like <A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArray()"><CODE>DirectAccessible.javaArray()</CODE></A>
 method), will lead to reallocation of the underlying storage, used for array elements,
 before performing the operation. In other words,
 you have a guarantee: if this array is a view of some another array or data
 (for example, a <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarray</CODE></A> or
 a <A HREF="../../../net/algart/arrays/SimpleMemoryModel.html#asUpdatableArray(java.lang.Object)"><CODE>view of Java array</CODE></A>,
 that there are no ways to change that data
 via accessing the returned array. Any changes, it they will occur,
 will be performed with the newly allocated storage only.

 <p>Moreover, there are <i>no guarantees</i> that the returned array will be a view of this one,
 even immediately after creation.
 Some implementations of updatable arrays may just return the full (deep) copy of this object,
 alike <A HREF="../../../net/algart/arrays/Array.html#mutableClone(net.algart.arrays.MemoryModel)"><CODE>mutableClone(MemoryModel)</CODE></A> method, and in this case
 <A HREF="../../../net/algart/arrays/TooLargeArrayException.html" title="class in net.algart.arrays"><CODE>TooLargeArrayException</CODE></A> is possible.
 All implementations from this package, excepting <tt>AbstractUpdatableXxxArray</tt> classes,
 returns a view;
 but in <tt>AbstractUpdatableXxxArray</tt> classes this method is equivalent to
 <tt><A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)"><CODE>updatableClone</CODE></A>(<A HREF="../../../net/algart/arrays/Arrays.html#SMM"><CODE>Arrays.SMM</CODE></A>).</tt>

 <p>Please note that <b>copy-on-next-write arrays are not traditional copy-on-write objects like
 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/CopyOnWriteArrayList.html"
 >CopyOnWriteArrayList</a>!</b> In particular, copy-on-next-write arrays
 are not thread-safe.

 <p>The main purpose of using copy-on-next-write arrays is more efficient alternative
 to <A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)"><CODE>cloning</CODE></A> and creating <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>quite immutable views</CODE></A>,
 when we need to be sure that original data will not be corrupted.
 Please see the <a href="package-summary.html#protectionAgainstUnallowedChanges">package description</a>
 to learn more about possible usage of this technique.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a copy-on-next-write view of this array (or a reference to this array if it is immutable).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../net/algart/arrays/TooLargeArrayException.html" title="class in net.algart.arrays">TooLargeArrayException</A></CODE> - if this method actually creates a copy of this array, but
                                the <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length</CODE></A> of this array is too large
                                for the memory model, used for allocating a copy.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A>, 
<A HREF="../../../net/algart/arrays/MemoryModel.html#newLazyCopy(net.algart.arrays.Array)"><CODE>MemoryModel.newLazyCopy(Array)</CODE></A>, 
<A HREF="../../../net/algart/arrays/MemoryModel.html#newUnresizableLazyCopy(net.algart.arrays.Array)"><CODE>MemoryModel.newUnresizableLazyCopy(Array)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isCopyOnNextWrite()"><!-- --></A><H3>
isCopyOnNextWrite</H3>
<PRE>
boolean <STRONG>isCopyOnNextWrite</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this array is copy-on-next-write.
 In other words, if this method returns <tt>true</tt>, it means that the next
 attempt (but not further) to modify this array, or any other access that can lead to
 its modification (like <A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArray()"><CODE>DirectAccessible.javaArray()</CODE></A> method), will lead to
 reallocation of the underlying storage. After reallocation,
 the array will cease to be copy-on-next-write: further calls of
 this method will return <tt>false</tt>.

 <p>This method can be useful if it's possible to select another,
 more optimal algorithm branch, allowing to avoid reallocation
 for copy-on-next-write arrays. The typical example is usage of
 <A HREF="../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A> interface. That interface, providing direct access to
 the internal Java array (which is a storage of the array elements), can optimize
 most of algorithms processing a array. However, reallocation of
 the Java array, that will be a result of calling <A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArray()"><CODE>DirectAccessible.javaArray()</CODE></A> for
 copy-on-next-write array, can make such "optimization" very unwanted.

 <p>The only standard way to make copy-on-next-write is calling
 <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>asCopyOnNextWrite()</CODE></A> method.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this array is copy-on-next-write.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>asCopyOnNextWrite()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isUnresizable()"><!-- --></A><H3>
isUnresizable</H3>
<PRE>
boolean <STRONG>isUnresizable</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this instance is unresizable, i&#46;e&#46; there are no ways to
 change its length or capacity.

 <p>It is guaranteed that if the array was created via <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A> method, this method
 returns <tt>true</tt>.

 <p>Typically, this method returns <tt>true</tt> if the array does not implement
 <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A>.
 But you should not use this condition to check whether a array is unresizable;
 please use this method instead.
 Maybe, some class from another package (or from future versions
 of this package), implementing this <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays"><CODE>Array</CODE></A> interface, does not implement
 <A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays"><CODE>MutableArray</CODE></A>, but offer another methods allowing to change its state or content.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this instance is unresizable.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/UpdatableArray.html#asUnresizable()"><CODE>UpdatableArray.asUnresizable()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isNew()"><!-- --></A><H3>
isNew</H3>
<PRE>
boolean <STRONG>isNew</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this array instance is <i>new</i>, i&#46;e&#46; it was created
 by one of <A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays"><CODE>MemoryModel</CODE></A> methods, creating an array or a matrix (<tt>newXxx</tt>
 or <tt>valueOf</tt>), or by fully equivalent methods.
 All other ways of creating AlgART array instance (<A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A>,
 <A HREF="../../../net/algart/arrays/Array.html#shallowClone()"><CODE>shallowClone()</CODE></A>, <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(long, long)</CODE></A>, <A HREF="../../../net/algart/arrays/SimpleMemoryModel.html#asUpdatableArray(java.lang.Object)"><CODE>SimpleMemoryModel.asUpdatableArray(Object)</CODE></A>
 etc.) create <i>non-new</i> arrays.

 <p>In updatable arrays the "new status", returned by this method, can be cleared manually by
 <A HREF="../../../net/algart/arrays/UpdatableArray.html#setNonNew()"><CODE>UpdatableArray.setNonNew()</CODE></A> method. Note that immutable arrays, not implementing <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>
 interface, are never <i>new</i> (this method returns <tt>false</tt>).

 <p>If the array is <i>new</i>, you can be sure that it is an original object, storing the data,
 but not a view of some other array (<A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable view</CODE></A>,
 <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarray</CODE></A>, etc.) or of another kind of data (Java array, file, etc.)
 This can be important for managing data, associated with AlgART arrays.

 <p>For example, let we have some source (factory), generating AlgART arrays
 (like a library of installable Java plugins), and we need to safely store the content
 of these arrays in some permanent storage.
 Of course, we can store a full clone of each array with help of <A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)"><CODE>updatableClone(MemoryModel)</CODE></A>
 or <A HREF="../../../net/algart/arrays/Array.html#mutableClone(net.algart.arrays.MemoryModel)"><CODE>mutableClone(MemoryModel)</CODE></A> method, but it can be inefficient for very large arrays (many gigabytes).
 On the other hand, we usually cannot just store a reference to an AlgART array
 or to its internal data: it is very possible, that one array, received from the factory, is a view of another
 one (<A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable view</CODE></A>, <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarray</CODE></A>, etc.), and storing
 both references in our storage will lead to incorrect behaviour &mdash; possible future changing
 of one element of the storage will be reflected in other elements.

 <p><i>New</i> status of the array, provided by this method, allows to correctly resolve this problem.
 We should store in the storage the full content (clone) of an array, if this method returns <tt>false</tt>,
 or the reference to an array or to its internal data (as  <A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArray()"><CODE>DirectAccessible.javaArray()</CODE></A>),
 if it returns <tt>true</tt>. In the second case, we must additionally clear the status of the original
 array object, received from the factory, by <A HREF="../../../net/algart/arrays/UpdatableArray.html#setNonNew()"><CODE>UpdatableArray.setNonNew()</CODE></A> method &mdash;
 it guarantees that we shall store only 1 reference to each really new array.

 <p>Additional important feature, provided by this method: if you know the memory model, which has created this
 instance, then you can be absolutely sure in all details of the algorithm of internal storing
 the array data (if it is documented in the corresponding memory model). It is important,
 for example, for <A HREF="../../../net/algart/arrays/LargeMemoryModel.html" title="class in net.algart.arrays"><CODE>LargeMemoryModel</CODE></A>: if this method returns <tt>true</tt>, then the content
 of this array corresponds to the content of an external file according to a known, fully documented scheme.
 Unlike this, another forms of AlgART arrays &mdash; like <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarrays</CODE></A> &mdash;
 have no documented correspondence with the content of an external data, even when we can retrieve
 some information about such data (as a name of the disk file <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#getDataFilePath(net.algart.arrays.Array)"><CODE>LargeMemoryModel.getDataFilePath(Array)</CODE></A>).

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this array instance is <i>new</i>: a new object, allocated by some <A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays"><CODE>MemoryModel</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#isNewReadOnlyView()"><CODE>isNewReadOnlyView()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isNewReadOnlyView()"><!-- --></A><H3>
isNewReadOnlyView</H3>
<PRE>
boolean <STRONG>isNewReadOnlyView</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this array instance is <i>new-read-only-view</i>, i&#46;e&#46;
 a newly created <i>view</i> of some external data, providing <i>read-only</i> access to this data &mdash;
 like <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asArray(P, java.lang.Class, long, long, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asArray(Object, Class, long, long, java.nio.ByteOrder)</CODE></A> method.
 All other ways of creating AlgART array instance (methods of <A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays"><CODE>MemoryModel</CODE></A> class,
 <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A>, <A HREF="../../../net/algart/arrays/Array.html#shallowClone()"><CODE>shallowClone()</CODE></A>, <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(long, long)</CODE></A>}
 etc.) create arrays, in which this method returns <tt>false</tt>.
 In the current version of this package, the only ways to create <i>new-read-only-view</i> AlgART array
 are the following:
 <ul>
 <li>the method
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asArray(P, java.lang.Class, long, long, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asArray(Object, Class, long filePosition, long fileAreaSize, ByteOrder byteOrder)</CODE></A>,
 when its <tt>filePosition</tt> argument is zero (<tt>filePosition==0</tt>);
 </li>
 <li>the versions of this method for concrete element types
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asBitArray(P, long, long, java.nio.ByteOrder)"><CODE>asBitArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asCharArray(P, long, long, java.nio.ByteOrder)"><CODE>asCharArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asByteArray(P, long, long, java.nio.ByteOrder)"><CODE>asByteArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asShortArray(P, long, long, java.nio.ByteOrder)"><CODE>asShortArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asIntArray(P, long, long, java.nio.ByteOrder)"><CODE>asIntArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asLongArray(P, long, long, java.nio.ByteOrder)"><CODE>asLongArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asFloatArray(P, long, long, java.nio.ByteOrder)"><CODE>asFloatArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asDoubleArray(P, long, long, java.nio.ByteOrder)"><CODE>asDoubleArray</CODE></A>
 in a case of the same condition: their <tt>filePosition</tt> argument is zero;
 </li>
 <li><A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asMatrix(P, net.algart.arrays.MatrixInfo)"><CODE>LargeMemoryModel.asMatrix(Object filePath, MatrixInfo matrixInfo)</CODE></A> method
 in a case when the <A HREF="../../../net/algart/arrays/MatrixInfo.html#dataOffset()"><CODE>data offset</CODE></A>, stored in its <A HREF="../../../net/algart/arrays/MatrixInfo.html" title="class in net.algart.arrays"><CODE>MatrixInfo</CODE></A> argument,
 is zero &mdash; then the array, extracted from such a matrix by
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#getRawArrayForSavingInFile(net.algart.arrays.Matrix)"><CODE>LargeMemoryModel.getRawArrayForSavingInFile(Matrix)</CODE></A> method, will be
 <i>new-read-only-view</i>.</li>
 </ul>

 <p><i>New-read-only-view</i> status, returned by this method,
 is final and cannot be changed after instantiation of the instance.
 (More precisely, there are no public methods, allowing to change it after finishing
 the method, which has created a new array instance.)
 Note that in updatable arrays, implementing <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>UpdatableArray</CODE></A>
 interface, this method returns <tt>false</tt> always.
 Moreover, if this method returns <tt>true</tt>, then there is a guarantee that
 <A HREF="../../../net/algart/arrays/Array.html#isImmutable()"><CODE>isImmutable()</CODE></A> method also returns <tt>true</tt>.

 <p>If this method returns <tt>true</tt>, you can be sure that it is an original object,
 associated with external data with read-only access rights,
 but not a view of some other array (<A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable view</CODE></A>,
 <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarray</CODE></A>, etc.) and not an updatable view of some external data,
 allowing to change them.
 This can improve efficiency of managing data, associated with AlgART arrays, in addition to
 <A HREF="../../../net/algart/arrays/Array.html#isNew()"><CODE>isNew()</CODE></A> method.

 <p>Please read again the possible scheme of storing array data in some storage, listed in the comments
 to <A HREF="../../../net/algart/arrays/Array.html#isNew()"><CODE>isNew()</CODE></A>. Sometimes we need to store some number of absolutely identical AlgART
 arrays, corresponding to the same data, maybe very large (many gigabytes).
 The listed scheme permits storing only 1 reference to each array
 (or its data), because we should avoid ability of changes in one stored array,
 reflecting in another stored array. It is a good and safe strategy, but it does not provide
 maximal performance in a case, when <i>we know that all data are immutable (read-only) and we shall never
 change them</i>. In the last case, there is no problem to create any number of references to the same
 data, as well as there is no problem to create a lot of references to the same
 immutable Java object like <tt>String</tt>.

 <p>This method allows to improve the described behaviour. Namely, if this method returns <tt>true</tt>,
 you still <i>may</i> store the reference to an AlgART array or to its internal data in your storage,
 though <A HREF="../../../net/algart/arrays/Array.html#isNew()"><CODE>isNew()</CODE></A> returns <tt>false</tt>.
 Yes, you can so create several references to the same array data,
 but it does not lead to incorrect behaviour &mdash; this data will always remain unchanged.

 <p>But here is an important <i>warning</i>: while using this technique, you should never try
 to increase the access rights to the external data, corresponding to the AlgART array, stored in your storage.
 More precisely, you should not try to provide write access to this data &mdash; even if the API allows
 to do this. In a case of <A HREF="../../../net/algart/arrays/LargeMemoryModel.html" title="class in net.algart.arrays"><CODE>LargeMemoryModel</CODE></A>, it means that you should not access to the disk file,
 retrieved from an array by <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#getDataFilePath(net.algart.arrays.Array)"><CODE>LargeMemoryModel.getDataFilePath(Array)</CODE></A> method,
 via <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asUpdatableArray(P, java.lang.Class, long, long, boolean, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asUpdatableArray</CODE></A> method &mdash; please use the original reference
 to AlgART array (where this method returns <tt>true</tt>) or new instances,
 created by <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asArray(P, java.lang.Class, long, long, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asArray</CODE></A> method.
 Maybe, future versions of <A HREF="../../../net/algart/arrays/LargeMemoryModel.html" title="class in net.algart.arrays"><CODE>LargeMemoryModel</CODE></A> class will contain API,
 which will allow to provide OS-level protection against any attempts to write into files,
 containing the data, stored in your storage of AlgART arrays.

 <p>In addition, this method provides the same feature as <A HREF="../../../net/algart/arrays/Array.html#isNew()"><CODE>isNew()</CODE></A> method:
 if you know the memory model, which has created this instance,
 then you can be absolutely sure in all details of the algorithm of internal storing
 the array data (if it is documented in the corresponding memory model). It is important
 for <A HREF="../../../net/algart/arrays/LargeMemoryModel.html" title="class in net.algart.arrays"><CODE>LargeMemoryModel</CODE></A>: if this method returns <tt>true</tt>, then the content
 of this array corresponds to the content of an external file according to a known, fully documented scheme.
 Unlike this, another forms of AlgART arrays &mdash; like <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarrays</CODE></A> &mdash;
 have no documented correspondence with the content of an external data, even when we can retrieve
 some information about such data (as a name of the disk file <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#getDataFilePath(net.algart.arrays.Array)"><CODE>LargeMemoryModel.getDataFilePath(Array)</CODE></A>).

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this array instance is a newly created <i>view</i> of some
         external data, providing <i>read-only</i> access to this data.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isLazy()"><!-- --></A><H3>
isLazy</H3>
<PRE>
boolean <STRONG>isLazy</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this array instance is <i>lazy</i>, i&#46;e&#46;
 if an access to its element means some calculations for producing result or actual saving element.
 Examples of <i>lazy</i> arrays are results of
 <A HREF="../../../net/algart/arrays/Arrays.html#asFuncArray(net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(net.algart.math.functions.Func, Class, PArray...)</CODE></A>
 and analogous methods.

 <p>If this method returns <tt>false</tt>, it means that reading elements
 (and writing for <A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays"><CODE>updatable arrays</CODE></A>) is performed as quickly as possible:
 it is just copying data from one memory (maybe a disk) to another.
 In particular, this method returns <tt>false</tt> for <A HREF="../../../net/algart/arrays/Array.html#isNew()"><CODE>new</CODE></A> arrays,
 their <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable views</CODE></A>, <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarrays</CODE></A>, etc.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this array instance if <i>lazy</i>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="byteOrder()"><!-- --></A><H3>
byteOrder</H3>
<PRE>
java.nio.ByteOrder <STRONG>byteOrder</STRONG>()</PRE>
<DL>
<DD>Returns the byte order used by this array for storing data.

 <p>This value does not important for using AlgART arrays.
 The only case when it can be interesting is when the array is stored in some external resources,
 for example, in a disk file.

 <p>For all array instances created by this package the byte order is native
 (<tt>ByteOrder.nativeOrder()</tt>), with the only exception:
 arrays, created by <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asArray(P, java.lang.Class, long, long, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asArray(Object, Class, long, long, ByteOrder)</CODE></A>,
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#asUpdatableArray(P, java.lang.Class, long, long, boolean, java.nio.ByteOrder)"><CODE>LargeMemoryModel.asUpdatableArray(Object, Class, long, long, boolean, ByteOrder)</CODE></A> methods
 and their versions for concrete element types, will have byte order
 specified by the argument of these methods.

 <p>Please note: in the combined arrays, created via <A HREF="../../../net/algart/arrays/CombinedMemoryModel.html" title="class in net.algart.arrays"><CODE>CombinedMemoryModel</CODE></A>,
 this method returns <tt>ByteOrder.nativeOrder()</tt>, though the byte order in the
 underlying storage arrays may be another.

 <p>There is a guarantee that this method works very quickly
 (usually it just returns a constant or a value of some private field).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the byte order used by this array for storing data.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shallowClone()"><!-- --></A><H3>
shallowClone</H3>
<PRE>
<A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays">Array</A> <STRONG>shallowClone</STRONG>()</PRE>
<DL>
<DD>Returns a "shallow" clone of this object:
 another array consisting of the same elements,
 but with independent length, start offset, capacity, copy-on-next-write and
 possible other information about any array characteristics besides its elements.
 In other words, any changes in the <i>elements</i> of the returned array
 are usually reflected in this array, and vice-versa; but changes of any other
 characteristics of the original or returned array, including the length,
 capacity, etc., will not be reflected in another array.

 <p>Please note: this method <i>never</i> returns a reference to this object,
 even if this array is immutable!
 Moreover, the returned object does not store any references to this instance in any internal fields.
 It can be important while using weak references and reference queues:
 this object and its shallow copy are deallocated by the garbage collector separately.

 <p>There are <i>no guarantees</i> that the returned array will share the elements with this one.
 Some implementations may return the full (deep) copy of this object, alike
 <A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)"><CODE>updatableClone(MemoryModel)</CODE></A> or <A HREF="../../../net/algart/arrays/Array.html#mutableClone(net.algart.arrays.MemoryModel)"><CODE>mutableClone(MemoryModel)</CODE></A> methods.
 All implementations from this package returns a shallow (non-deep) copy.

 <p>If modifications of this or returned array characteristics lead to reallocation
 of the internal storage, then the returned array ceases to be a view of this array.
 The only possible reasons for reallocation are the following:
 calling <A HREF="../../../net/algart/arrays/MutableArray.html#length(long)"><CODE>MutableArray.length(long)</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableArray.html#ensureCapacity(long)"><CODE>MutableArray.ensureCapacity(long)</CODE></A> or <A HREF="../../../net/algart/arrays/MutableArray.html#trim()"><CODE>MutableArray.trim()</CODE></A> methods
 for this array, or any modification of this or returned array in a case when
 this array is <A HREF="../../../net/algart/arrays/Array.html#asCopyOnNextWrite()"><CODE>copy-on-next-write</CODE></A>.

 <p>The values of <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>, <A HREF="../../../net/algart/arrays/Array.html#capacity()"><CODE>capacity()</CODE></A>, <A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArrayOffset()"><CODE>DirectAccessible.javaArrayOffset()</CODE></A>,
 <A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A> in the result will be the same as in this array.
 The returned instance implements the same set of interfaces as this array.

 <p>This method is an analog of the standard Java NIO
 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/nio/ByteBuffer.html#duplicate()"
 ><tt>ByteBuffer.duplicate()</tt></a> method. However, unlike <tt>ByteBuffer.duplicate()</tt>,
 <i>this method is necessary very rarely</i>. Usually, you need another forms
 of array views: <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>asImmutable()</CODE></A>, <A HREF="../../../net/algart/arrays/UpdatableArray.html#asUnresizable()"><CODE>UpdatableArray.asUnresizable()</CODE></A>, etc.
 The most often usage of this method is finalization
 via <A HREF="../../../net/algart/finalizing/Finalizer.html" title="class in net.algart.finalizing"><CODE>Finalizer</CODE></A> class:
 see example in comments to <A HREF="../../../net/algart/arrays/Array.html#checkUnallowedMutation()"><CODE>checkUnallowedMutation()</CODE></A> method. Also this method
 can be useful if you need to pass a array with the same content
 into some another class, but must be sure that further resizing
 of the source array will not affect to correct work of that class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a shallow copy of this object.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#capacity()"><CODE>capacity()</CODE></A>, 
<A HREF="../../../net/algart/arrays/DirectAccessible.html#javaArrayOffset()"><CODE>DirectAccessible.javaArrayOffset()</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#isCopyOnNextWrite()"><CODE>isCopyOnNextWrite()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="mutableClone(net.algart.arrays.MemoryModel)"><!-- --></A><H3>
mutableClone</H3>
<PRE>
<A HREF="../../../net/algart/arrays/MutableArray.html" title="interface in net.algart.arrays">MutableArray</A> <STRONG>mutableClone</STRONG>(<A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays">MemoryModel</A>&nbsp;memoryModel)</PRE>
<DL>
<DD>Returns a mutable resizable copy of this array.

 This method is equivalent to the following code:

 <pre>
 memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newArray(net.algart.arrays.Array)"><CODE>newArray</CODE></A>(thisArray).<A HREF="../../../net/algart/arrays/UpdatableArray.html#copy(net.algart.arrays.Array)"><CODE>copy</CODE></A>(thisArray);
 </pre>

 <p>Please note: this method is a good choice for cloning little arrays (thousands,
 maybe millions elements). If you clone large arrays by this method,
 the user, in particular, has no ways to view the progress of copying or to interrupt copying.
 To clone large arrays, we recommend the following code:

 <pre>
 MutableArray clone = memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newArray(net.algart.arrays.Array)"><CODE>newArray</CODE></A>(thisArray);
 <A HREF="../../../net/algart/arrays/Arrays.html#copy(net.algart.arrays.ArrayContext, net.algart.arrays.UpdatableArray, net.algart.arrays.Array)"><CODE>Arrays.copy</CODE></A>(someContext, clone, a);
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>memoryModel</CODE> - the memory model, used for allocation a new copy of this array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a mutable copy of this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../net/algart/arrays/UnsupportedElementTypeException.html" title="class in net.algart.arrays">UnsupportedElementTypeException</A></CODE> - if <tt>thisArray.<A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A></tt> is not supported
                                by the specified memory model.</DD>
<DD><CODE><A HREF="../../../net/algart/arrays/TooLargeArrayException.html" title="class in net.algart.arrays">TooLargeArrayException</A></CODE> - if the <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length</CODE></A> of this array is too large
                                for this the specified memory model.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#updatableClone(net.algart.arrays.MemoryModel)"><CODE>updatableClone(MemoryModel)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="updatableClone(net.algart.arrays.MemoryModel)"><!-- --></A><H3>
updatableClone</H3>
<PRE>
<A HREF="../../../net/algart/arrays/UpdatableArray.html" title="interface in net.algart.arrays">UpdatableArray</A> <STRONG>updatableClone</STRONG>(<A HREF="../../../net/algart/arrays/MemoryModel.html" title="interface in net.algart.arrays">MemoryModel</A>&nbsp;memoryModel)</PRE>
<DL>
<DD>Returns an unresizable updatable copy of this array.
 This method is equivalent to the following code:

 <pre>
 memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newUnresizableArray(net.algart.arrays.Array)"><CODE>newUnresizableArray</CODE></A>(thisArray).<A HREF="../../../net/algart/arrays/UpdatableArray.html#copy(net.algart.arrays.Array)"><CODE>copy</CODE></A>(thisArray);
 </pre>

 <p>Please note: this method is a good choice for cloning little arrays (thousands,
 maybe millions elements). If you clone large arrays by this method,
 the user, in particular, has no ways to view the progress of copying or to interrupt copying.
 To clone large arrays, we recommend the following code:

 <pre>
 UpdatableArray clone = memoryModel.<A HREF="../../../net/algart/arrays/MemoryModel.html#newUnresizableArray(net.algart.arrays.Array)"><CODE>newUnresizableArray</CODE></A>(thisArray);
 <A HREF="../../../net/algart/arrays/Arrays.html#copy(net.algart.arrays.ArrayContext, net.algart.arrays.UpdatableArray, net.algart.arrays.Array)"><CODE>Arrays.copy</CODE></A>(someContext, clone, a);
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>memoryModel</CODE> - the memory model, used for allocation a new copy of this array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>an updatable copy of this array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../net/algart/arrays/UnsupportedElementTypeException.html" title="class in net.algart.arrays">UnsupportedElementTypeException</A></CODE> - if <tt>thisArray.<A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A></tt> is not supported
                                by the specified memory model.</DD>
<DD><CODE><A HREF="../../../net/algart/arrays/TooLargeArrayException.html" title="class in net.algart.arrays">TooLargeArrayException</A></CODE> - if the <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length</CODE></A> of this array is too large
                                for this the specified memory model.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#mutableClone(net.algart.arrays.MemoryModel)"><CODE>mutableClone(MemoryModel)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="loadResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
loadResources</H3>
<PRE>
void <STRONG>loadResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>If there are some external resources, associated with this array, &mdash;
 files, streams, sockets, locks, etc&#46; &mdash;
 this method makes an effort to ensure that, when it returns,
 the content of this array will be resident in physical memory.
 In other words, this method tries to preload the content of this array into RAM
 to provide fastest access to its elements in the nearest future.

 <p>There are no any guarantees that <i>all</i> elements of this array will be really preloaded into RAM.
 This method usually avoids loading too large amount of data, comparable with the whole amount of RAM.
 For example, if the size of this array is 10 GB, it is possible only first several megabytes
 or tens of megabytes will be preloaded.
 If you work with a large array, we recommend to call this method
 for its not too large <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarray</CODE></A>, which really should be processed now, for example:

 <pre>
 final int blockSize = 1048576;
 for (long pos = 0, n = array.<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>; pos < n; pos += blockSize) {
 &#32;   int len = (int)Math.min(blockSize, n - pos);
 &#32;   Array region = array.<A HREF="../../../net/algart/arrays/Array.html#subArr(long, long)"><CODE>subArr</CODE></A>(pos, len);
 &#32;   region.loadResources(someContext)};
 &#32;   // some algorithm processing len elements of this region
 }
 </pre>

 <p>If the resources, associated with this array, are shared with some another arrays
 (usually when one array is a view of another one), this method
 tries to preload the content of that arrays, though it is not guaranteed.
 This method usually does nothing if the <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length</CODE></A> of this array is zero.

 <p>The <tt>context</tt> argument is necessary to allow user to interrupt this method and to view
 the execution progress. Namely, if this argument is not <tt>null</tt>, this method probably calls
 <tt>context.<A HREF="../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption</CODE></A></tt> and
 <tt>context.<A HREF="../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress</CODE></A></tt> methods from time to time.
 It may be useful if preloading data can require long time, for example, the content should be
 loaded from Internet.
 You always may pass <tt>null</tt> as this argument; then all will work correctly,
 but, maybe, the user will be bored for some time.
 For all arrays, created by this package, this method works quickly enough
 and doesn't require non-null context.

 <p>This method does nothing for arrays created by the <A HREF="../../../net/algart/arrays/SimpleMemoryModel.html" title="class in net.algart.arrays"><CODE>simple memory model</CODE></A>
 and the <A HREF="../../../net/algart/arrays/BufferMemoryModel.html" title="class in net.algart.arrays"><CODE>buffer memory model</CODE></A>, and also for constant arrays
 created by <A HREF="../../../net/algart/arrays/Arrays.html#nByteCopies(long, byte)"><CODE>Arrays.nByteCopies(long, byte)</CODE></A>, <A HREF="../../../net/algart/arrays/Arrays.html#nCharCopies(long, char)"><CODE>Arrays.nCharCopies(long, char)</CODE></A>, etc.:
 these arrays have no associated resources.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)"><CODE>flushResources(ArrayContext, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="flushResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
flushResources</H3>
<PRE>
void <STRONG>flushResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)"><CODE>flushResources</CODE></A>(context, false)</tt>.
 It is the most typical case of flushing resources.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#loadResources(net.algart.arrays.ArrayContext)"><CODE>loadResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(ArrayContext)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="flushResources(net.algart.arrays.ArrayContext, boolean)"><!-- --></A><H3>
flushResources</H3>
<PRE>
void <STRONG>flushResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                    boolean&nbsp;forcePhysicalWriting)</PRE>
<DL>
<DD>If there are some external resources, associated with this array, &mdash;
 files, streams, sockets, locks, etc&#46; &mdash;
 and some array data are not still reflected in that resources
 (for example, were not saved in the disk file yet),
 this method <i>flushs</i> all these data to the external devices.

 <p>This method may not perform <i>immediate</i> writing data to the storage devices.
 But it guarantees that:<ol>

 <li>if some AlgART array will be created and associated with the same resources as this array
 &mdash; for example, will be mapped to the same external file &mdash; all data stored
 in this array will be "visible" in the new array;
 <br>&nbsp;</li>

 <li>if this array is a view of some external resource, that is not "temporary"
 (i.e. will not be automatically deleted after shutting down JVM),
 then all changes, made in this array, will be really stored in that resource
 and will be able to be loaded by another software, at least, after shutting down JVM.
 </li>
 </ol>

 <p>If <tt>forcePhysicalWriting</tt> argument is <tt>false</tt>, this method works as quick as possible.

 <p>If <tt>forcePhysicalWriting</tt> argument is <tt>true</tt>, this
 method tries to physically flush all unsaved elements of this array to the storage device.
 The precise actions, performed in this case, are not specified.
 The typical behaviour: all internal caches, if they are provided by Java imlementation of the AlgART array,
 are written to the external device via OS calls, and OS is requested to flush buffers or file-mapping
 to the physical disk.
 The mode <tt>forcePhysicalWriting=true</tt> increases chances that the data will be really flushed to
 external devices and, so, OS will release physical memory, which was probably used for disk or another cache.
 This mode also increases chances that all changes, made in this array until this moment,
 will be immediately "visible" in another software (another OS process) as changes in the corresponding
 external resources (for example, in the disk file).

 <p>If the resources, associated with this array, are shared with some another arrays
 (usually when one array is a view of another one), this method still
 <i>does flush these resource</i>.

 <p>You may use <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(long, long)</CODE></A> / <A HREF="../../../net/algart/arrays/Array.html#subArr(long, long)"><CODE>subArr(long, long)</CODE></A> methods
 to flush any portion of this array, for example:<pre>
     array.subArr(destPos, count).flushResources(context, false);</pre>
 <p>But there is no guarantee that flushing a subarray will not lead to flushing some other
 parts of the source array.

 <p>In particular, please note: this method may do something even for immutable arrays.
 If an array is an <A HREF="../../../net/algart/arrays/Array.html#asImmutable()"><CODE>immutable view</CODE></A> of another array <tt><b>a</b></tt>,
 flushing this view is equivalent to flushing the original array <tt><b>a</b></tt>.

 <p>The <tt>context</tt> argument is necessary to allow user to interrupt this method and to view
 the execution progress. Namely, if this argument is not <tt>null</tt>, this method probably calls
 <tt>context.<A HREF="../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption</CODE></A></tt> and
 <tt>context.<A HREF="../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress</CODE></A></tt> methods from time to time.
 It may be useful if this array is very large and writing non-flushed data to an external device
 requires long time. For example, it is possible for arrays, created by
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#newLazyCopy(net.algart.arrays.Array)"><CODE>LargeMemoryModel.newLazyCopy</CODE></A> method.
 You always may pass <tt>null</tt> as this argument; then all will work correctly,
 but, maybe, the user will be bored for some time.

 <p>This method does nothing for arrays created by the <A HREF="../../../net/algart/arrays/SimpleMemoryModel.html" title="class in net.algart.arrays"><CODE>simple memory model</CODE></A>
 and the <A HREF="../../../net/algart/arrays/BufferMemoryModel.html" title="class in net.algart.arrays"><CODE>buffer memory model</CODE></A>, and also for constant arrays
 created by <A HREF="../../../net/algart/arrays/Arrays.html#nByteCopies(long, byte)"><CODE>Arrays.nByteCopies(long, byte)</CODE></A>, <A HREF="../../../net/algart/arrays/Arrays.html#nCharCopies(long, char)"><CODE>Arrays.nCharCopies(long, char)</CODE></A>, etc.:
 these arrays have no associated resources.

 <p>All operations, performed by this method, are also performed by
 <A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext, boolean)"><CODE>freeResources(ArrayContext, boolean)</CODE></A> method with
 the same <tt>forcePhysicalWriting</tt> argument.

 <p><b>Performance note:</b> please avoid sequential calls of this method, like the following:<pre>
     array.flushResources(null, false);
     array.flushResources(null, false); // - unnecessary call
 </pre>
 <p>The second call here is not necessary, because all data are already flushed while the first call &mdash;
 however, it is still possible that the second call will spend time for writing data again t
 o an external device.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>forcePhysicalWriting</CODE> - is it necessary to try forcing physical writing all associated resources
                             to the external device.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#loadResources(net.algart.arrays.ArrayContext)"><CODE>loadResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext, boolean)"><CODE>freeResources(ArrayContext, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="freeResources(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
freeResources</H3>
<PRE>
void <STRONG>freeResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context)</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext, boolean)"><CODE>freeResources</CODE></A>(context, false)</tt>.
 It is the most typical case of freeing resources.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#loadResources(net.algart.arrays.ArrayContext)"><CODE>loadResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext)"><CODE>flushResources(ArrayContext)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="freeResources(net.algart.arrays.ArrayContext, boolean)"><!-- --></A><H3>
freeResources</H3>
<PRE>
void <STRONG>freeResources</STRONG>(<A HREF="../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                   boolean&nbsp;forcePhysicalWriting)</PRE>
<DL>
<DD>If there are some resources, associated with this array, which are not controlled
 by Java garbage collectors &mdash; files, streams, sockets, locks, etc&#46; &mdash;
 this method tries to release them (for example, to close any files).
 However, the array stays alive: if the resources will be necessary for following array operations,
 they will be automatically re-acquired.

 <p>As a part of the work, this method always performs the same actions as
 <tt><A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)"><CODE>flushResources</CODE></A>(context, forcePhysicalWriting)</tt>
 call with the same <tt>forcePhysicalWriting</tt> argument. See comments to that method for more details
 about flushing external resources.

 <p>This method guarantees that any changes, made after its call in any external resources,
 associated with this array, will be "visible" in this array while any accesses to it
 after these changes. For example, if this array is a view of some disk file,
 you need to call this method to be sure that any changes, performed in the file
 by another application <i>after</i> this call and <i>before</i> the next access to this array,
 will be successfully reflected in this array.

 <p>If the resources, associated with this array, are shared with some another arrays
 (usually when one array is a view of another one), this method still
 <i>does release these resource</i>.
 It means that calling this method can slow down the next access not only to this array,
 but also to another ones, for example, to its <A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subarrays</CODE></A>.

 <p>The <tt>context</tt> argument is necessary to allow user to interrupt this method and to view
 the execution progress. Namely, if this argument is not <tt>null</tt>, this method probably calls
 <tt>context.<A HREF="../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption</CODE></A></tt> and
 <tt>context.<A HREF="../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress</CODE></A></tt> methods from time to time.
 It may be useful if this array is very large and writing non-flushed data to an external device
 requires long time. For example, it is possible for arrays, created by
 <A HREF="../../../net/algart/arrays/LargeMemoryModel.html#newLazyCopy(net.algart.arrays.Array)"><CODE>LargeMemoryModel.newLazyCopy</CODE></A> method.
 You always may pass <tt>null</tt> as this argument; then all will work correctly,
 but, maybe, the user will be bored for some time.

 <p>This method does nothing for arrays created by the <A HREF="../../../net/algart/arrays/SimpleMemoryModel.html" title="class in net.algart.arrays"><CODE>simple memory model</CODE></A>
 and the <A HREF="../../../net/algart/arrays/BufferMemoryModel.html" title="class in net.algart.arrays"><CODE>buffer memory model</CODE></A>, and also for constant arrays
 created by <A HREF="../../../net/algart/arrays/Arrays.html#nByteCopies(long, byte)"><CODE>Arrays.nByteCopies</CODE></A>, <A HREF="../../../net/algart/arrays/Arrays.html#nCharCopies(long, char)"><CODE>Arrays.nCharCopies</CODE></A>, etc.:
 these arrays have no associated resources.

 <p><b>Performance note 1:</b> you may use the call<pre>
     array.<A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(0,0)</CODE></A>.freeResources(null, false)
 </pre>
 to release all resources, associated with the original <tt>array</tt>.
 It may work <i>faster</i> than simple
 "<tt>array.freeResources(null,false)</tt>",
 because there is no necessity to <i>flush all array elements</i>:
 releasing a subarray requires flushing only the subarray elements,
 i.e. no elements in a case of the zero-length subarray.
 This speeding-up is guaranteed for arrays, created by <A HREF="../../../net/algart/arrays/LargeMemoryModel.html" title="class in net.algart.arrays"><CODE>large memory model</CODE></A>,
 but is not guaranteed for other arrays: it is still possible that
 "<tt>array.<A HREF="../../../net/algart/arrays/Array.html#subArray(long, long)"><CODE>subArray(0,0)</CODE></A>.freeResources(context,false)</tt>"
 call will flush <i>all</i> <tt>array</tt> data.

 <p><b>Performance note 2:</b> please avoid calling <A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)"><CODE>flushResources(ArrayContext, boolean)</CODE></A>
 together with this method:<pre>
     array.flushResources(null, false); // - unnecessary call
     array.freeResources(null, false);
 </pre>
 <p>or<pre>
     array.flushResources(null, true);
     array.freeResources(null);
     // - it's much better to use a single call "array.freeResources(null, true)"
 </pre>
 <p>It is very possible that the call of <tt>freeResources</tt> method will spend time for flushing data again,
 though they were already flushed by the previous <tt>flushResources</tt> method.
 If is much better to perform all the work in a single call of this method with the corresponding
 <tt>forcePhysicalWriting</tt> argument.

 <p>All resources allocated by this package are automatically released and &mdash;
 for temporary resources, i.e. garbage, &mdash;
 removed (as it is possible) by built-in cleanup procedures while JVM termination.
 However, we recommend to directly call
 <tt>freeResources(context)</tt> at the end of methods
 that create and process large AlgART arrays.
 The reason is that if there will be a lot of non-released large arrays, the automatic cleanup procedure
 may strongly reduce the speed of closing the application.

 <p><b>Important:</b> you <i>must</i> use this method if you are working with some collection
 (like <tt>java.util.List</tt> or a usual Java array) of large AlgART arrays
 (each per many megabytes or gigabytes) <i>and</i> if this collection contains many elements:
 more than several tens. If an AlgART array has some associated resources, for example,
 like arrays created by <A HREF="../../../net/algart/arrays/LargeMemoryModel.html" title="class in net.algart.arrays"><CODE>LargeMemoryModel</CODE></A> and mapped on a disk file, then every such instance
 usually occupies some RAM (and also, maybe, OS address space for mapping),
 usually up to several tens of megabytes (for large arrays) for caching and similar needs.
 This RAM cannot be automatically released by the garbage collector until you call this method.
 So, you <i>must</i> manually release all resources by calling this method every time,
 when this array is already not necessary, but should be stored in some collection for the future.
 In other case, thousands of inactive instances of AlgART arrays with non-released resources
 can exhaust all available RAM (or address space).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the context of execution; may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>forcePhysicalWriting</CODE> - is it necessary to try forcing physical writing all associated resources
                             to the external device.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../net/algart/arrays/Array.html#loadResources(net.algart.arrays.ArrayContext)"><CODE>loadResources(ArrayContext context)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#flushResources(net.algart.arrays.ArrayContext, boolean)"><CODE>flushResources(ArrayContext context, boolean forcePhysicalWriting)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Array.html#freeResources(net.algart.arrays.ArrayContext)"><CODE>freeResources(ArrayContext)</CODE></A>, 
<A HREF="../../../net/algart/arrays/Arrays.html#freeAllResources()"><CODE>Arrays.freeAllResources()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
java.lang.String <STRONG>toString</STRONG>()</PRE>
<DL>
<DD>Returns a brief string description of this object.

 <p>The result of this method may depend on implementation and usually contains
 a short description of the array length, capacity, element type.

 <p>Note: for <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>character arrays</CODE></A>, unlike <tt>CharSequence.toString()</tt>,
 this method works as for all other array types.
 If you need to convert a character array to a string,
 containing all characters of the array, you may use
 <A HREF="../../../net/algart/arrays/Arrays.html#toString(net.algart.arrays.CharArray)"><CODE>Arrays.toString(CharArray)</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a brief string description of this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
int <STRONG>hashCode</STRONG>()</PRE>
<DL>
<DD>Returns the hash code of this array. The result depends on all elements of the array
 (from element <tt>#0</tt> to element <tt>#<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>-1</tt>).

 <p>For non-primitive element type (<A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>, <A HREF="../../../net/algart/arrays/UpdatableObjectArray.html" title="interface in net.algart.arrays"><CODE>UpdatableObjectArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/MutableObjectArray.html" title="interface in net.algart.arrays"><CODE>MutableObjectArray</CODE></A> subinterfaces), the result is always based on implementation
 of <tt>hashCode</tt> method in the class of elements (<A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>elementType()</CODE></A>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the hash code of this array.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
boolean <STRONG>equals</STRONG>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Indicates whether some other array is equal to this one.
 Returns <tt>true</tt> if and only if:<ol>
 <li>the specified object is a array (i.e. implements <A HREF="../../../net/algart/arrays/Array.html" title="interface in net.algart.arrays"><CODE>Array</CODE></A>),</li>
 <li>both arrays have the same <A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length</CODE></A>,</li>
 <li>for arrays of primitive elements
 (<A HREF="../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>, <A HREF="../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>, <A HREF="../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>, <A HREF="../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,
 <A HREF="../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>, <A HREF="../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>):
 both arrays have the same <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>element type</CODE></A>
 and all corresponding pairs of elements are equal
 (for <tt>float</tt> and <tt>double</tt> elements,
 unlike the <tt>==</tt> operator, this method considers
 <tt>NaN</tt> equals to itself, and 0.0 unequal to -0.0);</li>
 <li>for non-primitive arrays (when both arrays implement <A HREF="../../../net/algart/arrays/ObjectArray.html" title="interface in net.algart.arrays"><CODE>ObjectArray</CODE></A>),
 the method may check one from two following conditions
 (only 1st or only 2nd, depending on implementation):<ul>
 <li>both arrays have the same <A HREF="../../../net/algart/arrays/Array.html#elementType()"><CODE>element type</CODE></A>
 and all corresponding pairs of elements contain identical data
 (<tt>equals</tt> method of the class of elements
 is not used in this case: <A HREF="../../../net/algart/arrays/CombinedMemoryModel.html" title="class in net.algart.arrays"><CODE>combined arrays</CODE></A> are an example);</li>
 <li>for all corresponding pairs of elements <tt>e1</tt>, <tt>e2</tt>
 (<tt>e1</tt> is an element <tt>#i</tt> of this array,
 <tt>e2</tt> is an element <tt>#i</tt> of the <tt>obj</tt> argument,
 <tt>i=0,1,...,<A HREF="../../../net/algart/arrays/Array.html#length()"><CODE>length()</CODE></A>-1)</tt>, the following check returns <tt>true</tt>:
 <tt>(e1==null ? e2==null : e1.equals(e2))</tt>.</li>
 </ul></li>
 </ol>
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>obj</CODE> - the object to be compared for equality with this array.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified object is an array equal to this one.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/algart/arrays/AbstractUpdatableShortArray.html" title="class in net.algart.arrays"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../net/algart/arrays/ArrayComparator.html" title="interface in net.algart.arrays"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/algart/arrays/Array.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Array.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
