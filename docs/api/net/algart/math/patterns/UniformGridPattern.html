<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
UniformGridPattern
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="UniformGridPattern";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/UpperHalfEllipsoidOfRevolutionFunc.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/UniformGridPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="UniformGridPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.math.patterns</FONT>
<BR>
Interface UniformGridPattern</H2>
<DL>
<DT><STRONG>All Superinterfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></DD>
</DL>
<DL>
<DT><STRONG>All Known Subinterfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/DirectPointSetUniformGridPattern.html" title="interface in net.algart.math.patterns">DirectPointSetUniformGridPattern</A>, <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns">RectangularPattern</A></DD>
</DL>
<DL>
<DT><STRONG>All Known Implementing Classes:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns">AbstractUniformGridPattern</A></DD>
</DL>
<HR>
<PRE>public interface <STRONG>UniformGridPattern</STRONG>
extends <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></PRE>

<P>
<p>Interface, used by <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> implementations to indicate that
 they are <i>uniform-grid patterns</i>, i&#46;e&#46;
 subsets of the set of all mesh nodes of some uniform grids.
 See also the section "Uniform-grid patterns" in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface.</p>

 <p>More precisely, a pattern, implementing this interface, is some set of <i>N</i> points (<i>N</i>&gt;0)
 <nobr><b>x</b><sup>(<i>k</i>)</sup> = (<i>x</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 (<i>k</i>=0,1,...,<i>N</i>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>),
 produced by the following formulas:

 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>where <i>o</i><sub><i>j</i></sub> and <i>d</i><sub><i>j</i></sub>
 are some constants (<i>d</i><sub><i>j</i></sub>&gt;0)
 and <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup> are any integer numbers.
 The point
 <b>o</b>=(<i>o</i><sub>0</sub>,<i>o</i><sub>1</sub>,...,<i>o</i><sub><i>n</i>&minus;1</sub>),
 named <i>origin</i> of the grid, and the vector
 <b>d</b>=(<i>d</i><sub>0</sub>,<i>d</i><sub>1</sub>,...,<i>d</i><sub><i>n</i>&minus;1</sub>),
 named <i>steps</i> of the grid, are specified while creating the pattern.
 Moreover, these parameters about (<b>o</b> and <b>d</b>)
 <b>are stored inside the object and can be quickly read at any time
 by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>originOfGrid()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>stepsOfGrid()</CODE></A> methods</b>
 &mdash; this condition is a requirement for all implementations of this interface.</p>

 <p>The numbers <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup> are called <i>grid indexes</i>
 of the points of the pattern (or, briefly, <i>grid indexes</i> of the pattern).
 The integer points
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 (<i>k</i>=0,1,...,<i>N</i>&minus;1)
 form an integer pattern (see the section "Integer patterns" in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface),
 which is called <i>grid index pattern</i> and can be got at any time by
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>gridIndexPattern()</CODE></A> method. If the number of points is not extremely large, the grid indexes
 can be also retrieved directly as Java set of <b>i</b><sup>(<i>k</i>)</sup> points
 by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>gridIndexes()</CODE></A> method.</p>

 <p>Warning: not only patterns, implementing this interface, are actually such sets of points.
 Moreover, many patterns, created by this package, are really uniform grid
 (all their points really belong to set of mesh points of some uniform grid),
 but they do not implement this interface and are not considered to be "uniform-grid".
 The typical examples are Minkowski sums, created by
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(Collection)</CODE></A> method,
 and unions, created by <A HREF="../../../../net/algart/math/patterns/Patterns.html#newUnion(java.util.Collection)"><CODE>Patterns.newUnion(Collection)</CODE></A> method.
 It is obvious that a Minkowski sum or a union of several uniform-grid patterns, having
 zero origin <b>o</b>=(0,0,...,0) and the same steps <b>d</b>, are also uniform-grid patterns
 with the same origin and steps. However, it is very probably that the objects, returned by
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(Collection)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Patterns.html#newUnion(java.util.Collection)"><CODE>Patterns.newUnion(Collection)</CODE></A> methods,
 will not implement <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface even in this "good" case.</p>

 <h4>Grid index restrictions</h4>

 <p>There are the following guarantees for grid indexes <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup>
 of any uniform-grid pattern:</p>

 <ol>
 <li>if <b>p</b>=(<i>i</i><sub>0</sub>,<i>i</i><sub>1</sub>,...,<i>i</i><sub><i>n</i>&minus;1</sub>) is
 the grid index of some point of the pattern, then
 &minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>&le;<i>i</i><sub><i>j</i></sub>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>
 for all <i>j</i>;</li>
 <li>if <b>p</b>=(<i>i</i><sub>0</sub><sup>1</sup>,<i>i</i><sub>1</sub><sup>1</sup>,...,<i>i</i><sub
 ><i>n</i>&minus;1</sub><sup>1</sup>) and
 <b>q</b>=(<i>i</i><sub>0</sub><sup>2</sup>,<i>i</i><sub>1</sub><sup>2</sup>,...,<i>i</i><sub
 ><i>n</i>&minus;1</sub><sup>2</sup>)
 are the grid indexes of some two points of the pattern, then
 |<i>i</i><sub><i>j</i></sub><sup>1</sup>&minus;<i>i</i><sub><i>j</i></sub><sup>2</sup>|&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A> for all <i>j</i>.</li>
 </ol>

 <p>Each implementation of this interface <i>must</i> fulfil both restriction.
 Any attempt to create a uniform-grid pattern, the grid indexes of which do not satisfy these restrictions,
 leads to <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.</p>

 <p>These restrictions are guaranteed <i>together</i> with the coordinate restrictions,
 described in the section "Coordinate restrictions" in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface.
 These restrictions provide a guarantee that the method <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>gridIndexPattern()</CODE></A> always
 works successfully and creates a correct integer pattern.</p>

 <p>AlgART Laboratory 2007-2013</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.math.patterns.Pattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from interface net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE">MAX_COORDINATE</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#carcass()">carcass</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>carcass</i> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexArea()">gridIndexArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal <i>grid index</i> <i>i</i><sub><i>j</i></sub>
 among all points of this pattern
 for all coordinate axes <i>j</i>
 If <tt>a</tt> is the result of this method,
 then <tt>a.<A HREF="../../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A>==<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>
 and <tt>a.<A HREF="../../../../net/algart/math/IRectangularArea.html#range(int)"><CODE>range</CODE></A>(k)</tt>
 is equal to <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange</CODE></A>(k)</tt> for all <tt>k</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()">gridIndexes</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of all <i>grid indexes</i> <i>i</i><sub><i>j</i></sub> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMax()">gridIndexMax</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the point, each coordinate #<i>j</i> of which
 is equal to the maximal corresponding grid index <i>i</i><sub><i>j</i></sub>
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMin()">gridIndexMin</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the point, each coordinate #<i>j</i> of which
 is equal to the minimal corresponding grid index <i>i</i><sub><i>j</i></sub>
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()">gridIndexPattern</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()"><CODE>ordinary</CODE></A> integer pattern with the same set of <i>grid indexes</i>
 <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup> as this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)">gridIndexRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal <i>grid index</i> <i>i</i><sub><i>j</i></sub>
 among all points of this pattern
 for the specified coordinate index <i>j</i>==<tt>coordIndex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isActuallyRectangular()">isActuallyRectangular</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern is <i>n</i>-dimensional rectangular parallelepiped.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()">isOrdinary</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this uniform-grid pattern is an <i>ordinary integer pattern</i>,
 i&#46;e&#46; if the grid origin <b>o</b> is the origin of coordinates (0,0,...,0)
 and all grid steps <i>d</i><sub><i>j</i></sub> are 1.0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)">lowerSurface</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>lower boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the backward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)">maxBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>maximal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with greater coordinate <tt>#coordIndex</tt>
 and same other coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#minBound(int)">minBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>minimal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with less coordinate <tt>#coordIndex</tt>
 and same other coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#multiply(double)">multiply</A></STRONG>(double&nbsp;multiplier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multiplier along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()">originOfGrid</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the grid <i>origin</i> <b>o</b> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the projection of this pattern along the given axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#scale(double...)">scale</A></STRONG>(double...&nbsp;multipliers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multipliers along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shift(net.algart.math.Point)">shift</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, shifted by the argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shiftGridIndexes(net.algart.math.IPoint)">shiftGridIndexes</A></STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns another uniform-grid pattern, identical to this one with the only difference, that
 the grid index
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 for each point #<i>k</i> of the result is shifted by the argument of this method via the call
 <b>i</b><sup>(<i>k</i>)</sup><tt>.<A HREF="../../../../net/algart/math/IPoint.html#add(net.algart.math.IPoint)"><CODE>add</CODE></A>(shift)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)">stepOfGrid</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the grid <i>step</i> <i>d</i><sub><i>j</i></sub> along the coordinate #<i>j</i> of this pattern
 along the coordinate #<i>j</i>=<tt>coordIndex</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()">stepsOfGrid</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the array of grid <i>steps</i> <b>d</b> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)">stepsOfGridEqual</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates whether the other uniform-grid pattern has the same grid steps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#surface()">surface</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set-theoretical union of all patterns, returned by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>lowerSurface(int)</CODE></A>
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>upperSurface(int)</CODE></A> methods for all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#symmetric()">symmetric</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symmetric pattern: equivalent to <A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)">upperSurface</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>upper boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the forward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.algart.math.patterns.Pattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from interface net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)">allUnionDecompositions</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()">coordArea</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()">coordMax</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()">coordMin</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">coordRange</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()">dimCount</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()">isSurelyInteger</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">isSurelySinglePoint</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()">largePointCount</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">pointCount</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">points</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#round()">round</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()">roundedCoordArea</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)">roundedCoordRange</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()">roundedPoints</A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)">unionDecomposition</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="originOfGrid()"><!-- --></A><H3>
originOfGrid</H3>
<PRE>
<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>originOfGrid</STRONG>()</PRE>
<DL>
<DD>Returns the grid <i>origin</i> <b>o</b> of this pattern.
 See the <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A> for more details.

 <p>There is a guarantee, that this method always works very quickly
 (<i>O</i>(<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the origin <b>o</b> of the uniform grid of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepsOfGrid()"><!-- --></A><H3>
stepsOfGrid</H3>
<PRE>
double[] <STRONG>stepsOfGrid</STRONG>()</PRE>
<DL>
<DD>Returns the array of grid <i>steps</i> <b>d</b> of this pattern.
 The length of the returned array is equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>,
 and the element #<i>j</i> contains the grid step <i>d</i><sub><i>j</i></sub> along the coordinate #<i>j</i>.
 See the <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A> for more details.

 <p>The returned array is a clone of the internal array of the steps, stored in this object.
 The returned array is never empty (its length cannot be zero).
 The elements of the returned array are always positive (<tt>&lt;0.0</tt>).

 <p>There is a guarantee, that this method always works very quickly
 (<i>O</i>(<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an array containing all grid steps of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepOfGrid(int)"><!-- --></A><H3>
stepOfGrid</H3>
<PRE>
double <STRONG>stepOfGrid</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the grid <i>step</i> <i>d</i><sub><i>j</i></sub> along the coordinate #<i>j</i> of this pattern
 along the coordinate #<i>j</i>=<tt>coordIndex</tt>.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>stepsOfGrid()</CODE></A>[coordIndex]</tt>, but works faster.

 <p>There is a guarantee, that this method always works very quickly
 (maximally <i>O</i>(<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the grid step of this pattern along the specified coordinate axis.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or
                                   <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)"><!-- --></A><H3>
stepsOfGridEqual</H3>
<PRE>
boolean <STRONG>stepsOfGridEqual</STRONG>(<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Indicates whether the other uniform-grid pattern has the same grid steps.
 In other words, returns <tt>true</tt> if and only if
 both patterns have the same dimension count (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>)
 and the corresponding grid steps <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid((k)</CODE></A> are equal for every <tt>k</tt>.

 <p>Note: this method does not compare the origin of grid.

 <p>Equality of grid steps is important, for example, while calculation of a Minkowski sum
 of this and another patterns by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A> method.
 If two uniform-grid patterns have identical grid steps, then a Minkowski sum of them
 can be also represented by uniform-grid pattern (with same grid steps).
 In other case, it is usually impossible &mdash; the Minkowski sum, returned by
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A>, will not implement <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pattern</CODE> - another uniform-grid pattern,
                the grid steps of which should be compared with grid steps of this one.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the specified pattern has the same steps of grid.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexes()"><!-- --></A><H3>
gridIndexes</H3>
<PRE>
java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt; <STRONG>gridIndexes</STRONG>()</PRE>
<DL>
<DD>Returns a set of all <i>grid indexes</i> <i>i</i><sub><i>j</i></sub> of this pattern.
 Namely, the elements of the returned set contain grid indexes
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 of all points <nobr><b>x</b><sup>(<i>k</i>)</sup> = (<i>x</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 of this pattern:
 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface must be
 immutable).

 <p>The returned set is always non-empty,
 and the number of its elements is always equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.
 This method surely fails (throws one of these exception), if the total number of points
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&gt;Integer.MAX_VALUE</tt>, because Java <tt>Set</tt> object
 cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.

 <p>For example, implementations of the <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>
 allow to successfully define a very large 3D parallelepiped
 <nobr><i>n</i> x <i>n</i> x <i>n</i></nobr>.
 Fur such pattern, this method will require a lot of memory
 for <i>n</i>=1000 and will fail (probably with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>)
 for <i>n</i>=2000 (2000<sup>3</sup>&gt;<tt>Integer.MAX_VALUE</tt>).

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>Note: if you do not really need to get a Java collection of all grid indexes,
 you can use <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>gridIndexPattern()</CODE></A> method, which returns the same result in a form
 of another (integer) pattern. That method, unlike this one, never spends extreme amount of memory
 and time and has no risk to fail with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all grid indexes of this pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if the number of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>gridIndexPattern()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexRange(int)"><!-- --></A><H3>
gridIndexRange</H3>
<PRE>
<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A> <STRONG>gridIndexRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the minimal and maximal <i>grid index</i> <i>i</i><sub><i>j</i></sub>
 among all points of this pattern
 for the specified coordinate index <i>j</i>==<tt>coordIndex</tt>.
 The minimal grid index will be <tt>r.<A HREF="../../../../net/algart/math/IRange.html#min()"><CODE>min()</CODE></A></tt>,
 the maximal grid index will be <tt>r.<A HREF="../../../../net/algart/math/IRange.html#max()"><CODE>max()</CODE></A></tt>,
 where <tt>r</tt> is the result of this method.
 See the <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A> for more details.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>Moreover, all patterns, implemented in this package, have very quick implementations of this method
 (<i>O</i>(1) operations). Also, the implementations of this method in this package never throw exceptions.

 <p>It is theoretically possible, that in custom implementations of this interface
 (outside this package) this method will work slowly, up to <i>O</i>(<i>N</i>) operations,
 <i>N</i> is the number of points in this pattern.
 However, even in such implementations this method <i>must not</i> lead to
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>, like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index <i>j</i> of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal grid index <i>i</i><sub><i>j</i></sub>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or
                                   <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMin()"><CODE>gridIndexMin()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexMax()"><CODE>gridIndexMax()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexArea()"><CODE>gridIndexArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexArea()"><!-- --></A><H3>
gridIndexArea</H3>
<PRE>
<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A> <STRONG>gridIndexArea</STRONG>()</PRE>
<DL>
<DD>Returns the minimal and maximal <i>grid index</i> <i>i</i><sub><i>j</i></sub>
 among all points of this pattern
 for all coordinate axes <i>j</i>
 If <tt>a</tt> is the result of this method,
 then <tt>a.<A HREF="../../../../net/algart/math/IRectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A>==<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>
 and <tt>a.<A HREF="../../../../net/algart/math/IRectangularArea.html#range(int)"><CODE>range</CODE></A>(k)</tt>
 is equal to <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange</CODE></A>(k)</tt> for all <tt>k</tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal grid index for all space dimensions.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexMin()"><!-- --></A><H3>
gridIndexMin</H3>
<PRE>
<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A> <STRONG>gridIndexMin</STRONG>()</PRE>
<DL>
<DD>Returns the point, each coordinate #<i>j</i> of which
 is equal to the minimal corresponding grid index <i>i</i><sub><i>j</i></sub>
 among all points of this pattern.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexArea()"><CODE>gridIndexArea()</CODE></A>.<A HREF="../../../../net/algart/math/IRectangularArea.html#min()"><CODE>min()</CODE></A></tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>minimal grid index for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexMax()"><!-- --></A><H3>
gridIndexMax</H3>
<PRE>
<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A> <STRONG>gridIndexMax</STRONG>()</PRE>
<DL>
<DD>Returns the point, each coordinate #<i>j</i> of which
 is equal to the maximal corresponding grid index <i>i</i><sub><i>j</i></sub>
 among all points of this pattern.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexArea()"><CODE>gridIndexArea()</CODE></A>.<A HREF="../../../../net/algart/math/IRectangularArea.html#max()"><CODE>max()</CODE></A></tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>maximal grid index for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isOrdinary()"><!-- --></A><H3>
isOrdinary</H3>
<PRE>
boolean <STRONG>isOrdinary</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this uniform-grid pattern is an <i>ordinary integer pattern</i>,
 i&#46;e&#46; if the grid origin <b>o</b> is the origin of coordinates (0,0,...,0)
 and all grid steps <i>d</i><sub><i>j</i></sub> are 1.0.
 Equivalent to
 <tt><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>originOfGrid()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#isOrigin()"><CODE>isOrigin()</CODE></A>
 && <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange</CODE></A>(0)==1.0
 && <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange</CODE></A>(1)==1.0
 &&&nbsp;...</tt>
 Ordinary integer patterns are a simplest form of <i>integer</i> pattern:
 see comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface, section "Uniform-grid patterns".

 <p>There is a guarantee, that this method always works very quickly
 (maximally <i>O</i>(<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether the grid origin <b>o</b>=(0,0,...,0) and also all grid steps <i>d</i><sub><i>j</i></sub>=1.0.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isActuallyRectangular()"><!-- --></A><H3>
isActuallyRectangular</H3>
<PRE>
boolean <STRONG>isActuallyRectangular</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pattern is <i>n</i>-dimensional rectangular parallelepiped.
 (For 2D patterns it means a rectangle, for 1D pattern it means an interval.)
 In other words, it returns <tt>true</tt> if this pattern is the set of all points
 <nobr>(<i>o</i><sub>0</sub>+<i>i</i><sub>0</sub><i>d</i><sub>0</sub>,
 <i>o</i><sub>1</sub>+<i>i</i><sub>1</sub><i>d</i><sub>1</sub>, ...,
 <i>o</i><sub><i>n</i>&minus;1</sub>+<i>i</i><sub><i>n</i>&minus;1</sub><i>d</i><sub><i>n</i>&minus;1</sub>)</nobr>,
 where <i>o<sub>j</sub></i> are coordinates of the <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>origin of the grid</CODE></A>,
 <i>d<sub>j</sub></i> are <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>steps of the grid</CODE></A>
 and <i>i<sub>j</sub></i> are all integers in the ranges
 <nobr><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(<i>j</i>)</CODE></A>.<A HREF="../../../../net/algart/math/IRange.html#min()"><CODE>min()</CODE></A>&lt;=<i>i</i><sub><i>j</i></sub>&lt;=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexRange(int)"><CODE>gridIndexRange(<i>j</i>)</CODE></A>.<A HREF="../../../../net/algart/math/IRange.html#max()"><CODE>max()</CODE></A></nobr>, <nobr><i>j</i>=0,1,...,<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>&minus;1</nobr>.</p>

 <p>Note that this condition is the same as in the definition of rectangular patterns, represented by
 <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface. Really, if the object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>,
 this method always returns <tt>true</tt>. However, this method tries to investigate
 the actual point set for other types of patterns.

 <p>There are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern is
 <i>n</i>-dimensional rectangular parallelepiped. (In some complex situations, such analysis can
 be too difficult.) But there is this guarantee for all uniform-grid patterns, created by this package.
 And, of course, there is the reverse guarantee: if this method returns <tt>true</tt>, the pattern is
 really a rectangular parallelepiped.</p>

 <p>You may be also sure that this method always works quickly enough and without exceptions.
 In the worst case, it can require <i>O</i>(<i>N</i>) operations,
 <i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>,
 but usually it works much more quickly.
 (So, if you implement this method yourself and there is a risk, that calculations
 can lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>, <tt>OutOfMemory</tt> or another exception due to
 extremely large number of points, you <i>must</i> return <tt>false</tt> instead of
 throwing an exception. Please compare this with <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> methods,
 which do not provide such guarantees and <i>may</i> lead to an exception.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this pattern is <i>n</i>-dimensional rectangular parallelepiped.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="gridIndexPattern()"><!-- --></A><H3>
gridIndexPattern</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>gridIndexPattern</STRONG>()</PRE>
<DL>
<DD>Returns an <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isOrdinary()"><CODE>ordinary</CODE></A> integer pattern with the same set of <i>grid indexes</i>
 <i>i</i><sub><i>j</i></sub><sup>(<i>k</i>)</sup> as this pattern.
 In other words, if this pattern is a set of points

 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>(<i>k</i>=0,1,...,<i>N</i>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>), then the returned pattern
 consists of points

 <blockquote>
 <i>y</i><sub>0</sub><sup>(<i>k</i>)</sup> = <tt>(double)</tt><i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><br>
 <i>y</i><sub>1</sub><sup>(<i>k</i>)</sup> = <tt>(double)</tt><i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><br>
 . . .<br>
 <i>y</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <tt>(double)</tt><i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>
 </blockquote>

 <p>Note: here is a guarantee, that all grid indexes <i>i</i><sub><i>j</i></sub> will be strictly
 represented by <tt>double</tt> type.
 Moreover, there is a guarantee that the returned pattern is correct, i.e. will be successfully built
 without a risk of <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.
 See the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>
 and the section "Grid index restrictions" in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface.

 <p>You can use this method to get a set of all grid indexes (integer values):
 it is enough to call <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> in the returned pattern.
 The results will be the same as the result of <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>gridIndexes()</CODE></A> method.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>This method works quickly enough: in the worst case,
 it can require <i>O</i>(<i>N</i>) operations (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>).
 <!--
 It is really so in our implementation of DirectPointSetUniformGridPattern:
 we do not eliminate checking of all coordinates -->
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>an ordinary integer pattern, consisting of all grid indexes of this pattern (represented
         by <tt>double</tt> values).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>gridIndexes()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="shiftGridIndexes(net.algart.math.IPoint)"><!-- --></A><H3>
shiftGridIndexes</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>shiftGridIndexes</STRONG>(<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&nbsp;shift)</PRE>
<DL>
<DD>Returns another uniform-grid pattern, identical to this one with the only difference, that
 the grid index
 <nobr><b>i</b><sup>(<i>k</i>)</sup> = (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>,
 <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>, ...,
 <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>)</nobr>
 for each point #<i>k</i> of the result is shifted by the argument of this method via the call
 <b>i</b><sup>(<i>k</i>)</sup><tt>.<A HREF="../../../../net/algart/math/IPoint.html#add(net.algart.math.IPoint)"><CODE>add</CODE></A>(shift)</tt>.

 In other words, if this pattern is a set of points

 <blockquote>
 <i>x</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><sup>(<i>k</i>)</sup><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><sup>(<i>k</i>)</sup><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup><i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>(<i>k</i>=0,1,...,<i>N</i>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>), then the returned pattern
 has the same <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>grid oridin</CODE></A>, the same <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>grid steps</CODE></A>
 and consists of points

 <blockquote>
 <i>y</i><sub>0</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>0</sub> + (<i>i</i><sub>0</sub><sup>(<i>k</i>)</sup>+<tt>shift.<A HREF="../../../../net/algart/math/IPoint.html#coord(int)"><CODE>coord</CODE></A>(0)</tt>)*<i>d</i><sub>0</sub><br>
 <i>y</i><sub>1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub>1</sub> + (<i>i</i><sub>1</sub><sup>(<i>k</i>)</sup>+<tt>shift.<A HREF="../../../../net/algart/math/IPoint.html#coord(int)"><CODE>coord</CODE></A>(1)</tt>)*<i>d</i><sub>1</sub><br>
 . . .<br>
 <i>y</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup> =
 <i>o</i><sub><i>n</i>&minus;1</sub>
 + (<i>i</i><sub><i>n</i>&minus;1</sub><sup>(<i>k</i>)</sup>+<tt>shift.<A HREF="../../../../net/algart/math/IPoint.html#coord(int)"><CODE>coord</CODE></A>(<i>n</i>&minus;1)</tt>)*<i>d</i><sub><i>n</i>&minus;1</sub>
 </blockquote>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all grid indexes via
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>gridIndexes()</CODE></A> call, correcting them and forming a new pattern via
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#newUniformGridPattern(net.algart.math.Point, double[], java.util.Collection)"><CODE>Patterns.newUniformGridPattern(Point, double[], java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface,
 section "Coordinate restrictions", and in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>Note: the similar results can be got with help of <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shift(net.algart.math.Point)"><CODE>shift(Point)</CODE></A> method
 with a corresponding floating-point shift. However, this method
 guarantees that the returned pattern has the same origin of the grid, but corrected <i>grid indexes</i>.
 Unlike this, a good implementation of <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#shift(net.algart.math.Point)"><CODE>shift(Point)</CODE></A> method just corrects the grid origin,
 but does not change grid indexes. This difference is important, if you are going to get
 the grid indexes from the shifted pattern via <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexPattern()"><CODE>gridIndexPattern()</CODE></A> or <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#gridIndexes()"><CODE>gridIndexes()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift of the grid indexes.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>point.<A HREF="../../../../net/algart/math/Point.html#coordCount()"><CODE>coordCount()</CODE></A>!=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the set of shifted points does not fulfil the restrictions,
                                  described in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface,
                                  section "Coordinate restrictions", and in the comments
                                  to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface,
                                  section "Coordinate restrictions".</DD></DL>
</DD>
</DL>
<HR>

<A NAME="lowerSurface(int)"><!-- --></A><H3>
lowerSurface</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>lowerSurface</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the <i>lower boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the backward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, the point
 <nobr><i>A</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 belongs to the returned pattern if and only if it belongs to this pattern and the point
 <nobr><i>B</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>&minus;<i>d</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 (corresponding to decreasing the <i>grid index</i> <i>i</i><sub><i>j</i></sub> by 1)
 does not belong to this pattern.

 <p>Please compare with <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#minBound(int)"><CODE>minBound(int)</CODE></A> method. This method can return a pattern
 containing more points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#minBound(int)"><CODE>minBound(int)</CODE></A>, in particular, if this pattern contains some "holes".</p>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>Note: if this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.
 However, this situation is possible only in custom implementation of this interface &mdash;
 all implementations, provided by this package, implement either <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 or <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lower boundary" of this pattern: new pattern consisting of all points of this pattern,
         which have no leftward neighbour along the given coordinate.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or
                                     <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - (impossible for implementations, provided by this package)
                                     if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="upperSurface(int)"><!-- --></A><H3>
upperSurface</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>upperSurface</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the <i>upper boundary</i> of this pattern along the given axis:
 a pattern consisting of all such points <i>A</i> of this pattern,
 that the neighbour point <i>B</i>,
 generated by the forward shift of point <i>A</i> along the coordinate #<i>j</i>=<tt>coordIndex</tt>
 by the corresponding grid step <nobr><i>d</i><sub><i>j</i></sub>=<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepOfGrid(int)"><CODE>stepOfGrid(coordIndex)</CODE></A></nobr>, does not belong to this pattern.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, the point
 <nobr><i>A</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 belongs to the returned pattern if and only if it belongs to this pattern and the point
 <nobr><i>B</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ...,
 <i>x</i><sub><i>j</i></sub>+<i>d</i><sub><i>j</i></sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 (corresponding to increasing the <i>grid index</i> <i>i</i><sub><i>j</i></sub> by 1)
 does not belong to this pattern.

 <p>Please compare with <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)"><CODE>maxBound(int)</CODE></A> method. This method can return a pattern
 containing more points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)"><CODE>maxBound(int)</CODE></A>, in particular, if this pattern contains some "holes".</p>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>Note: if this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.
 However, this situation is possible only in custom implementation of this interface &mdash;
 all implementations, provided by this package, implement either <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 or <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.)</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "upper boundary" of this pattern: new pattern consisting of all points of this pattern,
         which have no rightward neighbour along the given coordinate.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or
                                     <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - (impossible for implementations, provided by this package)
                                     if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="surface()"><!-- --></A><H3>
surface</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>surface</STRONG>()</PRE>
<DL>
<DD>Returns the set-theoretical union of all patterns, returned by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>lowerSurface(int)</CODE></A>
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>upperSurface(int)</CODE></A> methods for all coordinates.
 In other words, the returned pattern contains full "boundary" of this pattern.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>Note: if this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.
 However, this situation is possible only in custom implementation of this interface &mdash;
 all implementations, provided by this package, implement either <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 or <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the "boundary" of this pattern: new pattern consisting of all points of this pattern,
         which have no leftward or rightward neighbour along at least one coordinate.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - (impossible for implementations, provided by this package)
                                     if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shift(net.algart.math.Point)"><!-- --></A><H3>
shift</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>shift</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, shifted by the argument.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call <tt>point.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(shift)</tt>.

 <!--Repeat.SectionStart simple_corrections_features-->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.SectionEnd simple_corrections_features-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>However, <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> is impossible in many important cases, when
 this pattern is an <i>integer</i> pattern and each coordinate
 <nobr><i>X</i><sub><i>j</i></sub>=<tt>shift.<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(</tt><i>j</i><tt>)</tt></nobr>
 of the argument is equal to &minus;<i>x</i><sub><i>j</i></sub> for some some point
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 of this pattern.
 In particular, you can use this method for <i>integer</i> patterns without a risk of
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> in the following situations:
 <ul>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>p.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>, where <tt>p</tt> is
 some of the <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points</CODE></A> if this integer pattern.</li>
 </ul>
 <p>See more details in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", the theorem II.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">shift</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="symmetric()"><!-- --></A><H3>
symmetric</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>symmetric</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the symmetric pattern: equivalent to <A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()">symmetric</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the symmetric pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="multiply(double)"><!-- --></A><H3>
multiply</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>multiply</STRONG>(double&nbsp;multiplier)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, scaled by the specified multiplier along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#multiply(double)"><CODE>multiply</CODE></A>(multipliers)</tt>.

 <p>This method is equivalent to <A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>Pattern.scale(double... multipliers)</CODE></A>, where all
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> arguments of that method are equal to <tt>multiplier</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to a very large multiplier).
 However, such failure is obviously impossible, if the multiplier is
 in range <tt>-1.0&lt;=multiplier&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)">multiply</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multiplier</CODE> - the scale along all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>Pattern.scale(double...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="scale(double...)"><!-- --></A><H3>
scale</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>scale</STRONG>(double...&nbsp;multipliers)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, scaled by the specified multipliers along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#scale(double...)"><CODE>scale</CODE></A>(multipliers)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large multipliers).
 However, such failure is obviously impossible, if all multipliers are
 in range <tt>-1.0&lt;=multipliers[k]&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">scale</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multipliers</CODE> - the scales along coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>Pattern.multiply(double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="projectionAlongAxis(int)"><!-- --></A><H3>
projectionAlongAxis</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>projectionAlongAxis</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the projection of this pattern along the given axis.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is less by 1, than in this one.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the projection of this pattern (its <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is equal to
         <tt>thisInstance.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>-1</tt>).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minBound(int)"><!-- --></A><H3>
minBound</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>minBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the <i>minimal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with less coordinate <tt>#coordIndex</tt>
 and same other coordinates.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, this method removes some points from this pattern according the following rule:
 if this pattern contains several points <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>, ...,
 <b>p</b><sub><i>m</i>&minus;1</sub> with identical projection to the given axis
 (<b>p</b><sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex).equals(</tt><b>p</b><sub><i>j</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex))</tt> for all <i>i</i>,&nbsp;<i>j</i>),
 then the resulting pattern contains only one from these points, for which
 the given coordinate <tt><A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(coordIndex)</tt> has the minimal value.

 <p>This method is especially useful for <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> patterns.
 For example, in <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 one of the facets of the hyperparallelepiped.
 In most cases (including all <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>)
 this method returns the same result as <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>lowerSurface(int)</CODE></A>;
 but if the figure, described by this pattern, contains some "holes", the result of this method
 contains fewer points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>lowerSurface(int)</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">minBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the minimal boundary of this pattern for the given axis.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)"><CODE>Pattern.maxBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxBound(int)"><!-- --></A><H3>
maxBound</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>maxBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the <i>maximal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with greater coordinate <tt>#coordIndex</tt>
 and same other coordinates.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, this method removes some points from this pattern according the following rule:
 if this pattern contains several points <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>, ...,
 <b>p</b><sub><i>m</i>&minus;1</sub> with identical projection to the given axis
 (<b>p</b><sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex).equals(</tt><b>p</b><sub><i>j</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex))</tt> for all <i>i</i>,&nbsp;<i>j</i>),
 then the resulting pattern contains only one from these points, for which
 the given coordinate <tt><A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(coordIndex)</tt> has the maximal value.

 <p>This method is especially useful for <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> patterns.
 For example, in <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 one of the facets of the hyperparallelepiped.
 In most cases (including all <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>)
 this method returns the same result as <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>upperSurface(int)</CODE></A>;
 but if the figure, described by this pattern, contains some "holes", the result of this method
 contains fewer points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>upperSurface(int)</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">maxBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal boundary of this pattern for the given axis.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)"><CODE>Pattern.minBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="carcass()"><!-- --></A><H3>
carcass</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>carcass</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the <i>carcass</i> of this pattern.
 We define the <i>carcass</i> of the pattern P as such point set C, that, for some
 integer <i>n</i>&gt;=1:

 <ol type="I">
 <li>
 2&otimes;P = P &oplus; C;<br>
 4&otimes;P = (2&otimes;P) &oplus; 2C;<br>
 8&otimes;P = (4&otimes;P) &oplus; 4C;<br>
 ...<br>
 2<sup><i>n</i></sup>&otimes;P = (2<sup><i>n</i>&minus;1</sup>&otimes;P) &oplus;
 2<sup><i>n</i>&minus;1</sup>C;
 </li>
 <li>for any <i>m</i>=1,2,...,<i>n</i> and for any positive integer
 <i>k</i>&le;2<sup><i>m</i>&minus;1</sup>, we have<br>
 (2<sup><i>m</i>&minus;1</sup>+<i>k</i>)&otimes;P =
 (2<sup><i>m</i>&minus;1</sup>&otimes;P) &oplus; <i>k</i>C.</li>
 </ol>

 <p>Here A&oplus;B means the <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Minkowski sum</CODE></A> of patterns A and B,
 <i>k</i>&otimes;P means P&oplus;P&oplus;...&oplus;P (<i>k</i> summands),
 and <i>k</i>P means the pointwise geometrical multiplication of the pattern P by the multiplier <i>k</i>,
 i.e. <tt>P.<A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply</CODE></A>(<i>k</i>)</tt>.

 <p>This method tries to find the minimal carcass, consisting of as little as possible number of points,
 and the maximal value <i>n</i>, for which the formulas above are correct for the found carcass.
 (The value 2<sup><i>n</i></sup> is called the <i>maximal carcass multiplier</i>
 and is returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()"><CODE>Pattern.maxCarcassMultiplier()</CODE></A> method.)
 For example, for <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 the set of vertices of the hyperparallelepiped (in one-dimensional case, the pair of segment ends),
 and the corresponding <i>n</i>=+&infin;.
 But this method does not guarantee that the returned result is always the minimal possible carcass
 and that the found <i>n</i> is really maximal for this carcass.

 <p>This method allows to optimize calculation of the point set of a Minkowski multiple <i>k</i>&otimes;P.
 It is really used in the pattern implementations, returned
 by <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiMultiplePattern(net.algart.math.patterns.Pattern, int)"><CODE>Patterns.newMinkowskiMultiplePattern(Pattern, int)</CODE></A> method:
 the result of that method is not always an actual Minkowski sum of <i>N</i> equal patterns,
 but can be (in the best case) an equal Minkowski sum of ~log<sub>2</sub><i>N</i> patterns
 <nobr>P &oplus; C &oplus; 2C &oplus; ... &oplus; 2<i><sup>m</sup></i>C
 &oplus; (<i>N</i>&minus;2<sup><i>m</i></sup>C)</nobr>,
 2<sup><i>m</i></sup>&lt;<i>N</i>&le;2<sup><i>m</i>+1</sup>,
 or (in not the best case, when <i>N</i> is greater than the maximal carcass multiplier 2<sup><i>n</i></sup>)
 can be another, not so little Minkowski sum.

 <p>In the worst case (no optimization is possible), this method just returns this object (C=P),
 and <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()"><CODE>Pattern.maxCarcassMultiplier()</CODE></A> returns 2 (i.e. <i>n</i>=1).

 <p>The returned pattern has the same number of dimensions (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) as this one.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>This method can require some time and memory for execution,
 but never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <!-- below is a bug: sum of 2^ik*C is much greater, than k*C
 <p><small>
 Note: the condition II is a logical consequence from the conditions I.<br>
 Proof.<br>
 Let <i>k</i> = 2<sup><i>i</i><sub>1</sub></sup>+2<sup><i>i</i><sub>2</sub></sup>+...
 is the binary representation of the number <i>k</i>.
 According to the conditions I,
 <nobr>(2<sup><i>i<sub>k</sub></i></sup>&otimes;P) &oplus; 2<sup><i>i<sub>k</sub></i></sup>C
 = 2<sup><i>i<sub>k</sub></i>+1</sup>&otimes;P</nobr>.
 Summing these equations for all <i>i<sub>k</sub></i>, we have
 <nobr>(<i>k</i>&otimes;P) &oplus; <i>k</i>C = 2<i>k</i>&otimes;P</nobr>.
 So,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;(2<sup><i>m</i>&minus;1</sup>+<i>k</i>)&otimes;P
 = ((2<sup><i>m</i>&minus;1</sup>&minus;<i>k</i>)&otimes;P) &oplus;
 (2<i>k</i>&otimes;P)
 = ((2<sup><i>m</i>&minus;1</sup>&minus;<i>k</i>)&otimes;P) &oplus;
 (<i>k</i>&otimes;P) &oplus; <i>k</i>C
 = (2<sup><i>m</i>&minus;1</sup>&otimes;P) &oplus; <i>k</i>C.<br>
 This completes the proof.
 </small></p>
 -->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">carcass</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the <i>carcass</i> of this pattern.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/UpperHalfEllipsoidOfRevolutionFunc.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/UniformGridPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="UniformGridPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
