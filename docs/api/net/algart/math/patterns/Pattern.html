<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Pattern
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Pattern";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/ParaboloidOfRevolutionFunc.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/Patterns.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/Pattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Pattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.math.patterns</FONT>
<BR>
Interface Pattern</H2>
<DL>
<DT><STRONG>All Known Subinterfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns">DirectPointSetPattern</A>, <A HREF="../../../../net/algart/math/patterns/DirectPointSetUniformGridPattern.html" title="interface in net.algart.math.patterns">DirectPointSetUniformGridPattern</A>, <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns">QuickPointCountPattern</A>, <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns">RectangularPattern</A>, <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A>, <A HREF="../../../../net/algart/math/patterns/WeightedPattern.html" title="interface in net.algart.math.patterns">WeightedPattern</A></DD>
</DL>
<DL>
<DT><STRONG>All Known Implementing Classes:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html" title="class in net.algart.math.patterns">AbstractPattern</A>, <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns">AbstractUniformGridPattern</A>, <A HREF="../../../../net/algart/math/patterns/AbstractWeightedPattern.html" title="class in net.algart.math.patterns">AbstractWeightedPattern</A>, <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns">SimplePattern</A></DD>
</DL>
<HR>
<PRE>public interface <STRONG>Pattern</STRONG></PRE>

<P>
<p><i>Pattern</i>: non-empty set of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>real points</CODE></A> in multidimensional space
 (points with real coordinates).</p>

 <p>Usually patterns are relatively little point sets: from tens to millions of points not too far from
 the origin of coordinates. However, please note that the number of points <i>is not limited
 by any value</i>. In particular, it can be greater than <tt>Long.MAX_VALUE</tt>.
 For example, it may occur for <A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularUniformGridPattern(net.algart.math.Point, double[], net.algart.math.IRange...)"><CODE>rectangular <i>n</i>-dimensional patterns</i></CODE></A>.</p>

 <p>Patterns are the arguments of many image processing filters.
 For example, a pattern may specify the form and sizes of the aperture for a linear filter.</p>

 <h4>Integer patterns</h4>

 <p>The very important subclass among all patterns is <b><i>integer patterns</i></b>,
 consisting of points with integer coordinates. More precisely, a pattern is called <i>integer</i>,
 if for all pattern's points
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 we have <i>x</i><sub><i>j</i></sub><tt>==(double)(long)</tt><i>x</i><sub><i>j</i></sub> for any index <i>j</i>.
 There is the standard method <A HREF="../../../../net/algart/math/patterns/Pattern.html#round()"><CODE>round()</CODE></A>,
 rounding any pattern to the nearest integer pattern &mdash; the result of this method is always integer.</p>

 <p>Usually integer patterns are uniform-grid patterns (see the next section), but this condition is not absolute:
 even a pattern, not implementing <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface, is called <i>integer pattern</i>,
 if all its points are really integer. The most popular case of integer patters is so-called
 <i>ordinary integer patterns</i> &mdash; see below in the next section
 "Uniform-grid patterns".</p>

 <p>You can try to investigate, whether some pattern is integer or not, by <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()"><CODE>isSurelyInteger()</CODE></A> method.</p>

 <p>Integer patterns is the basic pattern type for image processing tasks.</p>

 <p>In this package, the following methods always create integer patterns:</p>

 <ul>
 <li><A HREF="../../../../net/algart/math/patterns/Pattern.html#round()"><CODE>round()</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(net.algart.math.IPoint...)"><CODE>Patterns.newIntegerPattern(net.algart.math.IPoint...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newSphereIntegerPattern(net.algart.math.Point, double)"><CODE>Patterns.newSphereIntegerPattern(net.algart.math.Point, double)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newEllipsoidIntegerPattern(net.algart.math.Point, double...)"><CODE>Patterns.newEllipsoidIntegerPattern(net.algart.math.Point, double...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IRange...)"><CODE>Patterns.newRectangularIntegerPattern(net.algart.math.IRange...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IPoint, net.algart.math.IPoint)"><CODE>Patterns.newRectangularIntegerPattern(net.algart.math.IPoint, net.algart.math.IPoint)</CODE></A>.</li>
 </ul>

 <h4>Uniform-grid patterns</h4>

 <p>The important subclass among all patterns is <b><i>uniform-grid patterns</i></b>, represented
 by the subinterface <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>. Uniform-grid patterns is a pattern, all points
 of which are mesh nodes of some uniform grids, i.e. have coordinates</p>

 <blockquote>
 <i>x</i><sub>0</sub> = <i>o</i><sub>0</sub> + <i>i</i><sub>0</sub><i>d</i><sub>0</sub><br>
 <i>x</i><sub>1</sub> = <i>o</i><sub>1</sub> + <i>i</i><sub>1</sub><i>d</i><sub>1</sub><br>
 . . .<br>
 <i>x</i><sub><i>n</i>&minus;1</sub> = <i>o</i><sub><i>n</i>&minus;1</sub>
 + <i>i</i><sub><i>n</i>&minus;1</sub><i>d</i><sub><i>n</i>&minus;1</sub><br>
 </blockquote>

 <p>where <i>o</i><sub><i>j</i></sub> and <i>d</i><sub><i>j</i></sub> are some constants
 (<i>d</i><sub><i>j</i></sub>&gt;0) and <i>i</i><sub><i>j</i></sub> are any integer numbers.
 The parameters <i>o</i><sub><i>j</i></sub> (named <i>origin</i>) and
 <i>d</i><sub><i>j</i></sub> (named <i>steps</i>) are specified while creating the pattern,
 and <i>they are stored inside the object and can be quickly read by the access methods
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>UniformGridPattern.originOfGrid()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>UniformGridPattern.stepsOfGrid()</CODE></A></i>.</p>

 <p>Draw attention to the last condition! You can easily create also a pattern,
 all points of which lie in mesh nodes of some uniform grid, but which will not "know" anything
 about this grid and will not implement <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface.
 The simplest way to do this is the call of the constructor</p>

 <pre>    new <A HREF="../../../../net/algart/math/patterns/SimplePattern.html#SimplePattern(java.util.Collection)"><CODE>SimplePattern</CODE></A>(pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A>),</pre>

 <p>where <tt>pattern</tt> is a uniform-grid pattern. The resulting pattern is geometrically identical
 to the original uniform-grid one, but it does not implement
 <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> and is not considered to be uniform-grid, because there are no ways
 to get information about the grid (origin and steps).</p>

 <p>It is obvious that a uniform-grid pattern is also an <i>integer</i> pattern (see above),
 if all numbers <i>o</i><sub><i>j</i></sub> and <i>d</i><sub><i>j</i></sub> are integer.
 The most important particular case: all <i>o</i><sub><i>j</i></sub>=0 and
 all <i>d</i><sub><i>j</i></sub>=1. We shall call this kind of patterns
 <b><i>ordinary integer patterns</i></b>.</p>

 <p>In this package, uniform-grid patterns are the patterns, created by one of the following ways,
 and only they:</p>

 <ul>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newUniformGridPattern(net.algart.math.Point, double[], java.util.Collection)"><CODE>Patterns.newUniformGridPattern(net.algart.math.Point, double[], java.util.Collection)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(net.algart.math.IPoint...)"><CODE>Patterns.newIntegerPattern(net.algart.math.IPoint...)</CODE></A> (creates an ordinary integer pattern),</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A> (creates an ordinary integer pattern),</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newSphereIntegerPattern(net.algart.math.Point, double)"><CODE>Patterns.newSphereIntegerPattern(net.algart.math.Point, double)</CODE></A>
 (creates an ordinary integer pattern),</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newEllipsoidIntegerPattern(net.algart.math.Point, double...)"><CODE>Patterns.newEllipsoidIntegerPattern(net.algart.math.Point, double...)</CODE></A>
 (creates an ordinary integer pattern),</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newSpaceSegment(net.algart.math.patterns.UniformGridPattern, net.algart.math.functions.Func, net.algart.math.functions.Func, double, double)"><CODE>Patterns.newSpaceSegment(UniformGridPattern, Func, Func, double, double)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularUniformGridPattern(net.algart.math.Point, double[], net.algart.math.IRange...)"><CODE>Patterns.newRectangularUniformGridPattern(net.algart.math.Point, double[], net.algart.math.IRange...)</CODE></A>,
 </li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IRange...)"><CODE>Patterns.newRectangularIntegerPattern(net.algart.math.IRange...)</CODE></A>
 (creates an ordinary integer pattern),</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IPoint, net.algart.math.IPoint)"><CODE>Patterns.newRectangularIntegerPattern(net.algart.math.IPoint, net.algart.math.IPoint)</CODE></A>
 (creates an ordinary integer pattern),</li>
 </ul>

 <p>and also, in some cases (depending on the arguments), by the following methods:</p>

 <ul>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(net.algart.math.Point...)"><CODE>Patterns.newPattern(net.algart.math.Point...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>.</li>
 </ul>

 <h4>Direct point-set patterns</h4>

 <p>One of the most popular, basic kinds of patterns is <b><i>direct point-set patterns</i></b>,
 represented by the subinterface <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.
 The pattern is called <i>direct point-set</i> or, briefly, <i>direct</i>,
 if it is internally represented as an actual set of points
 like <tt>Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>Point</CODE></A>&gt;</tt>.</p>

 <p>Of course, any pattern is a set of points. The main feature of this subclass is that
 the point-set is stored directly in a form of some collection &mdash; and, so, can be directly accessed
 at any time via <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> or <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> methods.
 As a result, direct point-set pattern cannot contain more than <tt>Integer.MAX_VALUE</tt> points
 (because Java <tt>Set</tt> object cannot contain more than <tt>Integer.MAX_VALUE</tt> elements).</p>

 <p>Unlike direct patterns, other forms of pattern, like rectangular or complex (see below),
 do not actually store the set of their points, though still can build and return it by a request,
 when you call <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> or <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A>.</p>

 <p>In this package, direct point-set patterns are the patterns,
 created by one of the following ways, and only they:</p>

 <ul>
 <li><A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A> constructor,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(net.algart.math.Point...)"><CODE>Patterns.newPattern(net.algart.math.Point...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newUniformGridPattern(net.algart.math.Point, double[], java.util.Collection)"><CODE>Patterns.newUniformGridPattern(net.algart.math.Point, double[], java.util.Collection)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(net.algart.math.IPoint...)"><CODE>Patterns.newIntegerPattern(net.algart.math.IPoint...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newSphereIntegerPattern(net.algart.math.Point, double)"><CODE>Patterns.newSphereIntegerPattern(net.algart.math.Point, double)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newEllipsoidIntegerPattern(net.algart.math.Point, double...)"><CODE>Patterns.newEllipsoidIntegerPattern(net.algart.math.Point, double...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newSurface(net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>Patterns.newSurface(Pattern, net.algart.math.functions.Func)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newSpaceSegment(net.algart.math.patterns.UniformGridPattern, net.algart.math.functions.Func, net.algart.math.functions.Func, double, double)"><CODE>Patterns.newSpaceSegment(UniformGridPattern, Func, Func, double, double)</CODE></A>.</li>
 </ul>

 <p>Direct point-set pattern may be, at the same time, uniform-grid. In this case it must implement
 <A HREF="../../../../net/algart/math/patterns/DirectPointSetUniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetUniformGridPattern</CODE></A> interface.
 This package provides an implementation of direct pattern, which is not uniform-grid: <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A>.
 Most of other direct point-set patterns, provided by this package, are uniform-grid and
 implement <A HREF="../../../../net/algart/math/patterns/DirectPointSetUniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetUniformGridPattern</CODE></A> interface.</p>

 <h4>Rectangular patterns</h4>

 <p>The second popular basic kind of patterns is <b><i>rectangular patterns</i></b>,
 represented by the subinterface <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.
 The pattern is called <i>rectangular</i>, if it is uniform-grid (implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface),
 and it consists of all points inside some hyperparallelepiped, the parameters (bounds) of which were
 specified while creating the pattern, <i>are stored inside the object and can be quickly read
 by methods like <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A></i>.</p>

 <p>Draw attention to the last condition! Of course, you can create also a <i>direct point-set</i> pattern,
 consisting of all points inside some hyperparallelepiped. The simplest way to do this is
 the call of the constructor</p>

 <pre>    new <A HREF="../../../../net/algart/math/patterns/SimplePattern.html#SimplePattern(java.util.Collection)"><CODE>SimplePattern</CODE></A>(pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A>),</pre>

 <p>where <tt>pattern</tt> is a rectangular pattern.
 However, the resulting pattern is considered to be direct, but not rectangular.</p>

 <p>The main difference between direct point-set and rectangular patterns is the behaviour of methods,
 retrieving the point set like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A>, and some methods, retrieving boundaries of the pattern,
 like <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A>, <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#maxBound(int)"><CODE>UniformGridPattern.maxBound(int)</CODE></A>, etc.
 In direct patterns, all methods always work stably, i.e. without exceptions (if the passed arguments
 are correct), but calculation of pattern boundaries can require some time, proportional to the number
 of points in the pattern.
 In rectangular patterns, an attempt to get all points by <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> or <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A>
 method can lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> or to <tt>OutOfMemoryError</tt>,
 because the number of points can be extremely large (for example, 10000x10000x10000 3-dimensional parallelepiped
 consists of 10<sup>12</sup> points); but the information about boundaries is available very quickly.
 See the details in comments to <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interfaces.</p>

 <p>The classes of direct point-set and rectangular patterns do not intersect:
 a direct point-set pattern cannot be rectangular, and a rectangular pattern cannot be direct.</p>

 <p>Direct point-set and rectangular pattern are the base, used in many algorithms and
 allowing to build more specific pattern types (see below).</p>

 <p>In this package, rectangular patterns are the patterns, created by one of the following ways,
 and only they:</p>

 <ul>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularUniformGridPattern(net.algart.math.Point, double[], net.algart.math.IRange...)"><CODE>Patterns.newRectangularUniformGridPattern(net.algart.math.Point, double[], net.algart.math.IRange...)</CODE></A>,
 </li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IRange...)"><CODE>Patterns.newRectangularIntegerPattern(net.algart.math.IRange...)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IPoint, net.algart.math.IPoint)"><CODE>Patterns.newRectangularIntegerPattern(net.algart.math.IPoint, net.algart.math.IPoint)</CODE></A>.</li>
 </ul>

 <h4>Complex patterns</h4>

 <p>Besides the basic types of patterns &mdash; direct point-set and rectangular &mdash; this package
 allows to create more complex forms of patterns. Such patterns do not actually store information
 about the point set, but contain some rules allowing to construct this point set.
 The typical examples are Minkowski sum of several patterns, created by
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A> method,
 and the union of several patterns, created by
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#newUnion(java.util.Collection)"><CODE>Patterns.newUnion(java.util.Collection)</CODE></A> method.
 An attempt to get actual information about the figure of such a pattern via its methods
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A>, and even usage of the simplest methods
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>largePointCount()</CODE></A>, <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()"><CODE>isSurelyOriginPoint()</CODE></A>
 can lead to very long calculations and even to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 However, such patterns can be used indirectly, usually via their decompositions into more simple patterns
 by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(int)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>unionDecomposition(int)</CODE></A> methods.
 For example, it is possible to perform morphological dilation filter over an image
 (see <noindex><a href="http://en.wikipedia.org/wiki/Dilation_%28morphology%29">"Dilation" article
 in Wikipedia</a></noindex>)
 with a very large pattern, created by <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>
 and consisting of millions or milliards points, via sequential dilations with the Minkowski summands
 of such a pattern, extracted by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(int)</CODE></A> call.</p>

 <h4>Coordinate restrictions</h4>

 <p>There are the following guarantees for coordinates of the points of any pattern:</p>

 <ol>
 <li>if <b>p</b>=(<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>,...,<i>x</i><sub><i>n</i>&minus;1</sub>) is some point
 of the pattern, then
 &minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>&le;<i>x</i><sub><i>j</i></sub>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>
 for all <i>j</i>; here this inequality means absolutely precise mathematical inequality;</li>

 <li>if <b>p</b>=(<i>x</i><sub>0</sub><sup>1</sup>,<i>x</i><sub>1</sub><sup>1</sup>,...,<i>x</i><sub
 ><i>n</i>&minus;1</sub><sup>1</sup>) and
 <b>q</b>=(<i>x</i><sub>0</sub><sup>2</sup>,<i>x</i><sub>1</sub><sup>2</sup>,...,<i>x</i><sub
 ><i>n</i>&minus;1</sub><sup>2</sup>)
 are some two points of the pattern, then
 |<i>x</i><sub><i>j</i></sub><sup>1</sup>&minus;<i>x</i><sub><i>j</i></sub><sup>2</sup>|&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A> for all <i>j</i>, where
 |<i>x</i><sub><i>j</i></sub><sup>1</sup>&minus;<i>x</i><sub><i>j</i></sub><sup>2</sup>| means
 <i>the absolute value of mathematically precise difference</i> (not the result of Java operators
 <tt>Math.abs(</tt><i>x</i><sub><i>j</i></sub><sup>1</sup>&minus;<i>x</i><sub><i>j</i></sub><sup>2</sup><tt>)</tt>).
 (This condition can be checked with help of
 <A HREF="../../../../net/algart/math/patterns/Patterns.html#isAllowedDifference(double, double)"><CODE>Patterns.isAllowedDifference(double, double)</CODE></A> method.)</li>
 </ol>

 <p>Each implementation of this interface <i>must</i> fulfil both restriction. The point sets,
 satisfying these requirements, are called <i>allowed points sets</i> for patterns.
 Any attempt to create a pattern, the set of points of which is not allowed,
 leads to <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.</p>

 <p>Note: though patterns are sets of real points, their coordinates are restricted by <tt>long</tt>-type constant
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>.</p>

 <p>Also note: uniform-grid patterns must fulfil, in addition, two similar restrictions for their grid indexes.
 See more details in the comments to <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A> interface,
 the section "Grid index restrictions".</p>

 <p>Below are two important theorems, following from these two restrictions.</p>

 <p><b>Theorem I.</b> If you round the coordinates of all points of a pattern, i.e. replace each pattern's point
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr> with a new point
 <nobr>(round(<i>x</i><sub>0</sub>), round(<i>x</i><sub>1</sub>), ...,
 round(<i>x</i><sub><i>n</i>&minus;1</sub>))</nobr>,
 where "round(a)" means the result of <tt>(double)StrictMath.round(a)</tt> call,
 then the resulting point set will also be allowed. The same statement is true for the point set,
 consisting of precise integer points, without type cast to <tt>double</tt>,
 i.e. for points <nobr>(<tt>StrictMath.round</tt>(<i>x</i><sub>0</sub>),
 <tt>StrictMath.round</tt>(<i>x</i><sub>1</sub>), ...,
 <tt>StrictMath.round</tt>(<i>x</i><sub><i>n</i>&minus;1</sub>))</nobr> &mdash;
 such mathematical point set also fulfils both restrictions 1 and 2.</p>

 <p>The proof of this is complex enough. The paper
 <noindex><a href="http://algart.net/ru/numeric_algorithms/rounding_theorem.html"
 >http://algart.net/ru/numeric_algorithms/rounding_theorem.html</a></noindex> (in Russian)
 contains such proof: see the theorem of rounding and the theorem of subtraction in this paper.</p>

 <p>It means that you can freely use <A HREF="../../../../net/algart/math/patterns/Pattern.html#round()"><CODE>round()</CODE></A> method for any pattern:
 it always constructs another allowed pattern,
 both in terms of this interface and in terms in <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>,
 and cannot throw <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.</p>

 <p><b>Theorem II.</b> If all points of a pattern are integer, i.e.
 for all pattern's points
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 we have <i>x</i><sub><i>j</i></sub><tt>==(double)(long)</tt><i>x</i><sub><i>j</i></sub> for any index <i>j</i>,
 and (<i>X</i><sub>0</sub>,<i>X</i><sub>1</sub>,...,<i>X</i><sub><i>n</i>&minus;1</sub>)
 is some point of this pattern, then you can subtract (using Java &ldquo;&minus;&rdquo; operator)
 the coordinate <i>X</i><sub><i>j</i></sub> (<i>j</i> is any index)
 from the corresponding coordinate of all points of this pattern, i.e. replace each pattern's point
 <nobr>(<i>x</i><sub>0</sub>, ..., <i>x</i><sub><i>j</i>&minus;1</sub>,
 <i>x</i><sub><i>j</i></sub>,
 <i>x</i><sub><i>j</i>+1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr> with
 <nobr>(<i>x</i><sub>0</sub>, ..., <i>x</i><sub><i>j</i>&minus;1</sub>,
 <i>x</i><sub><i>j</i></sub>&#x2296;<i>X</i><sub><i>j</i></sub>,
 <i>x</i><sub><i>j</i>+1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>,
 and the resulting point set will also be allowed.
 Here and below <i>a</i>&#x2296;<i>b</i> (<i>a</i> and <i>b</i> are real values of <tt>double</tt>
 Java type) means the computer difference (not strict mathematical),
 i.e. the result of execution of Java operator &ldquo;<tt><i>a</i>&minus;<i>b</i></tt>&rdquo;.</p>

 <p>Proof.</p>

 <p>First of all, let's remind that the computer difference <i>a</i>&#x2296;<i>b</i>, according
 IEEE&nbsp;754 standard and Java language specification, is the nearest <tt>double</tt> value to
 the precise mathematical difference <i>a</i>&minus;<i>b</i>.
 Because all pattern's points are integer, the restriction 2 allows to state that
 any difference <i>x</i><sub><i>j</i></sub>&minus;<i>X</i><sub><i>j</i></sub>
 can be represented precisely by <tt>double</tt> type (see the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A> constant).
 So, we have
 <nobr><i>x</i><sub><i>j</i></sub>&#x2296;<i>X</i><sub><i>j</i></sub>
 = <i>x</i><sub><i>j</i></sub>&minus;<i>X</i><sub><i>j</i></sub></nobr>:
 the computer difference is just a mathematical difference.</p>

 <p>Now the proof is simple.
 If is enough to show that the restrictions will be satisfied for the coordinate index <i>j</i>.
 The restriction 2 is obvious: (mathematical) subtracting <i>X</i><sub><i>j</i></sub> does not change
 the (mathematical!) differences
 |<i>x</i><sub><i>j</i></sub><sup>1</sup>&minus;<i>x</i><sub><i>j</i></sub><sup>2</sup>|.
 The new value of this coordinate for each point will be
 <i>x</i><sub><i>j</i></sub>&minus;<i>X</i><sub><i>j</i></sub>, where both
 (<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>,...,<i>x</i><sub><i>n</i>&minus;1</sub>) and
 (<i>X</i><sub>0</sub>,<i>X</i><sub>1</sub>,...,<i>X</i><sub><i>n</i>&minus;1</sub>) are some points of the pattern;
 according the condition 2, this difference lies in range
 &minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>&le;<i>x</i><sub><i>j</i></sub>&minus;<i>X</i><sub><i>j</i></sub>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>. In other words, the restriction 1 is also satisfied.
 This completes the proof.</p>

 <p>Note: this proof is really correct only for patterns, consisting of integer points only.
 The reason is that all integer coordinates, fulfilling the restriction 1, and all their differences
 <i>x</i><sub><i>j</i></sub>&minus;<i>X</i><sub><i>j</i></sub> are represented precisely by <tt>double</tt>
 Java type. If a pattern contains non-integer points, the statement of this theorem is not true.
 For example, for 1-dimensional pattern, consisting of three points
 <i>x</i><sub>1</sub>=2251799813685248.00 (=<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>/2),
 <i>x</i><sub>2</sub>=&minus;2251799813685248.00 (=&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>/2) and
 <i>x</i><sub>3</sub>=&minus;2251799813685247.75 (=&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>/2+0.25), subtracting
 the point <i>x</i><sub>3</sub> by Java &ldquo;&minus;&rdquo; operator leads to the pattern
 <i>x</i>'<sub>1</sub>=4503599627370496.00 (=<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>) (computer subtraction of <tt>double</tt>
 values leads to rounding here),
 <i>x</i>'<sub>2</sub>=&minus;0.25 and
 <i>x</i>'<sub>3</sub>=0.0, which obviously violates the mathematically precise restriction 2:
 |<i>x</i>'<sub>1</sub>&minus;<i>x</i>'<sub>2</sub>|&gt;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>.</p>

 <p>As a result, there is an obvious <b>conclusion</b>. If <tt>p</tt> is one of the <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points</CODE></A> of
 some <i>integer</i> <tt>pattern</tt> (see above), then the method
 <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)"><CODE>shift</CODE></A>(p.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A>)</tt> always works successfully and never throw <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.</p>


 <h4>Note about <tt>equals()</tt></h4>

 The <tt>equals()</tt> method in the classes, implementing this interface, <i>may</i> return <tt>false</tt>
 for two patterns, consisting of the same point sets,
 for example, if these patterns belong to different pattern types.
 For example, a rectangular pattern may be considered to be non-equal
 to a geometrically identical <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(net.algart.math.patterns.Pattern...)"><CODE>Minkowski sum</CODE></A> of several segments,
 because the thorough comparison of these patterns can require too long time and large memory.
 (Please consider 10000x10000x10000 3-dimensional parallelepiped, consisting of 10<sup>12</sup> points
 with integer coordinates in range 0..9999. It is geometrically equal to Minkowski sum of 3 orthogonal
 segments with 10000 integer points in every segment, but we have no resources to check this fact
 via direct comparison of the point sets.)
 However, the patterns of the same kind (for example, two rectangular patterns,
 two <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(net.algart.math.patterns.Pattern...)"><CODE>Minkowski sums</CODE></A> or
 two <A HREF="../../../../net/algart/math/patterns/Patterns.html#newUnion(net.algart.math.patterns.Pattern...)"><CODE>unions</CODE></A>) are usually compared precisely.
 In particular, there are the following guarantees:</p>

 <ul>
 <li>if both patterns are <i>direct point-set</i> (see above),
 then <tt>equals()</tt> method always returns <tt>true</tt>
 for geometrically identical patterns;</li>

 <li>if both patterns are <i>rectangular</i> (see above), then, also, <tt>equals()</tt>
 method always returns <tt>true</tt> for geometrically identical patterns;</li>

 <li>and, of course, there is the reverse guarantee, that if the <tt>equals()</tt> method returns <tt>true</tt>,
 then two patterns consists of the identical point sets.</li>
 </ul>

 <h4>Multithread compatibility</h4>

 <p>The classes, implementing this interface, are <b>immutable</b> and <b>thread-safe</b>:
 there are no ways to modify settings of the created instance.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE">MAX_COORDINATE</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximal possible absolute coordinate value and maximal absolute difference between the corresponding
 coordinates for all points in a pattern.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a non-empty list of all best or almost best
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>union decompositions</CODE></A>
 with equal or similar "quality",
 i&#46;e&#46; with the same or almost same summary number of points in all Minkowski decompositions
 of all returned patterns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">carcass</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>carcass</i> of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/RectangularArea.html" title="class in net.algart.math">RectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()">coordArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal coordinates
 among all points of this pattern for all dimensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()">coordMax</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the point, each coordinate of which
 is equal to the maximal corresponding coordinate
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()">coordMin</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the point, each coordinate of which
 is equal to the minimal corresponding coordinate
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">coordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of space dimensions of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if the Minkowski decomposition,
 returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A> call,
 consists of 2 or more patterns:
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A>.size()&gt;1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()">isSurelyInteger</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern is <i>integer</i>:
 all coordinates of all points of this pattern are integer numbers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern consists of the single point and
 this point is the origin of coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">isSurelySinglePoint</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern consists of the single point, i&#46;e&#46;
 if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()">largePointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of points in this pattern as <tt>double</tt> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">maxBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>maximal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with greater coordinate <tt>#coordIndex</tt>
 and same other coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximal multiplier <i>k</i>, for which the calculation of
 the Minkowski multiple <i>k</i>&otimes;P can be optimized by using the <i>carcass</i> of this pattern P.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">minBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <i>minimal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with less coordinate <tt>#coordIndex</tt>
 and same other coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates and returns the Minkowski sum of this and specified patterns.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Minkowski decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is a Minkowski sum of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &oplus; P<sub>1</sub> &oplus;...&oplus; P<sub><i>n</i>&minus;1</sub></nobr>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates and returns the erosion of this pattern by specified pattern
 or <tt>null</tt> if this erosion is the empty set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)">multiply</A></STRONG>(double&nbsp;multiplier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multiplier along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">pointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of points in this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">points</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the projection of this pattern along the given axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#round()">round</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, every point of which is rounded to the nearest integer point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()">roundedCoordArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>coordArea()</CODE></A> method,
 but all minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)">roundedCoordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int coordIndex)</CODE></A> method,
 but both minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()">roundedPoints</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of all <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math"><CODE>integer points</CODE></A>, obtained from the points of this pattern
 (results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method by rounding with help of
 <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">scale</A></STRONG>(double...&nbsp;multipliers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multipliers along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">shift</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, shifted by the argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()">symmetric</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the symmetric pattern: equivalent to <A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)">unionDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a union decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is the set-theoretical union of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &cup; P<sub>1</sub> &cup;...&cup; P<sub><i>n</i>&minus;1</sub></nobr>.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Field Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="MAX_COORDINATE"><!-- --></A><H3>
MAX_COORDINATE</H3>
<PRE>
static final long <STRONG>MAX_COORDINATE</STRONG></PRE>
<DL>
<DD>The maximal possible absolute coordinate value and maximal absolute difference between the corresponding
 coordinates for all points in a pattern.
 See the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section
 "Coordinate restrictions", for more details.

 <p>The value of this constant is <tt>1L &lt;&lt; 52 = 2<sup>52</sup> = 4503599627370496L ~ Long.MAX_VALUE/2048</tt>.

 <p>There is an important feature of this constant.
 Any integer values <i>x</i> (<tt>long</tt> Java type) from the range
 <tt>&minus;2*<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>&le;<i>x</i>&le;2*<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A></tt>, and also
 all half-integer values <i>x</i> inside the range
 <tt>&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>&le;<i>x</i>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A></tt>
 (i.e. values <i>x</i>=<i>k</i><tt>+0.5</tt>, where <i>k</i> is <tt>long</tt>
 integer in range <tt>&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>&le;<i>k</i>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>-1</tt>)
 are represented by <tt>double</tt> Java type precisely, without loss of precision.

 <p>As a result, we can be sure that for any integer <tt>k</tt> (<tt>long</tt> Java type), for which
 <tt>Math.abs(k)&lt;=2*<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A></tt>, the following equality is true:
 <tt>(long)(double)k==k</tt>.

 <p>See also the paper <noindex><a href="http://algart.net/ru/numeric_algorithms/rounding_theorem.html"
 >http://algart.net/ru/numeric_algorithms/rounding_theorem.html</a></noindex> (in Russian)
 about rounding <tt>double</tt> values in range
 <tt>&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A>&le;<i>x</i>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>MAX_COORDINATE</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.math.patterns.Pattern.MAX_COORDINATE">Constant Field Values</A></DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD>Returns the number of space dimensions of this pattern.
 This value is always positive (&gt;=1).

 <p>There is a guarantee, that this method always works very quickly (<i>O</i>(1) operations)
 and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of space dimensions of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pointCount()"><!-- --></A><H3>
pointCount</H3>
<PRE>
long <STRONG>pointCount</STRONG>()</PRE>
<DL>
<DD>Returns the number of points in this pattern.
 This value is always positive (&gt;=1).
 If the number of points is greater than <tt>Long.MAX_VALUE</tt>, returns <tt>Long.MAX_VALUE</tt>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points (result of this method).
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then the result of this method is not greater than <tt>Integer.MAX_VALUE</tt>.

 <p>Note: if this method returns some value greater than <tt>Integer.MAX_VALUE</tt>,
 it means that you cannot use <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> methods,
 because Java <tt>Set</tt> object cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>points</CODE></A> in this pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - for some forms of large patterns, if the number of points is greater than
                                     <tt>Integer.MAX_VALUE</tt> or, in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>largePointCount()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>isSurelySinglePoint()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="largePointCount()"><!-- --></A><H3>
largePointCount</H3>
<PRE>
double <STRONG>largePointCount</STRONG>()</PRE>
<DL>
<DD>Returns the number of points in this pattern as <tt>double</tt> value.
 In particular, if the result of <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A> method is not greater than <tt>Long.MAX_VALUE</tt>,
 there is a guarantee that this method returns the same result, cast to <tt>double</tt> type.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points (result of this method).
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>points</CODE></A> in this pattern as <tt>double</tt> value.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - for some forms of large patterns, if the number of points is greater than
                                     <tt>Integer.MAX_VALUE</tt> or, in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="points()"><!-- --></A><H3>
points</H3>
<PRE>
java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt; <STRONG>points</STRONG>()</PRE>
<DL>
<DD>Returns a set of all points of this pattern.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of this interface must be
 immutable).

 <p>The returned set is always non-empty,
 and the number of its elements is always equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.
 This method surely fails (throws one of these exception), if the total number of points
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>&gt;Integer.MAX_VALUE</tt>, because Java <tt>Set</tt> object
 cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.

 <p>For example, implementations of the <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>
 allow to successfully define a very large 3D parallelepiped
 <nobr><i>n</i> x <i>n</i> x <i>n</i></nobr>.
 Fur such pattern, this method will require a lot of memory
 for <i>n</i>=1000 and will fail (probably with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>)
 for <i>n</i>=2000 (2000<sup>3</sup>&gt;<tt>Integer.MAX_VALUE</tt>).

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>Note: this method works very quickly (<i>O</i>(1) operations) in <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if the number of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedPoints()"><!-- --></A><H3>
roundedPoints</H3>
<PRE>
java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt; <STRONG>roundedPoints</STRONG>()</PRE>
<DL>
<DD><p>Returns the set of all <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math"><CODE>integer points</CODE></A>, obtained from the points of this pattern
 (results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method by rounding with help of
 <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method.
 In other words, the results of this method is the same as the result of the following code:
 <pre>
     Set&lt;IPoint&gt; result = new HashSet&lt;IPoint&gt;(); // or another Set implementation
     for (Point p : <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A>) {
         result.add(p.<A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>toRoundedPoint()</CODE></A>);
     }
     result = Collections.unmodifiableSet(result);
 </pre>

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of this interface must be
 immutable).

 <p>The returned set is always non-empty.

 <p>Note: the number of resulting points can be less than <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>, because some
 real points can be rounded to the same integer points.</p>

 <p>According the basic restriction to pattern coordinates (see
 the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Coordinate restrictions"),
 you may be sure that you will able
 to create an integer <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> pattern by passing the result of this method
 to <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A>.

 <p><b>Warning!</b> This method can work slowly or throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 / <tt>OutOfMemoryError</tt> in the same situations as <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 Please compare with <A HREF="../../../../net/algart/math/patterns/Pattern.html#round()"><CODE>round()</CODE></A> method, which always works quickly and without exceptions also
 for the case of <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern, rounded to the nearest integer points.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if the number of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordRange(int)"><!-- --></A><H3>
coordRange</H3>
<PRE>
<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A> <STRONG>coordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.
 The minimal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#min()"><CODE>min()</CODE></A></tt>,
 the maximal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#max()"><CODE>max()</CODE></A></tt>,
 where <tt>r</tt> is the result of this method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>Moreover, all patterns, implemented in this package, have very quick implementations of this method
 (<i>O</i>(1) operations). Also, the implementations of this method in this package never throw exceptions.

 <p>It is theoretically possible, that in custom implementations of this interface
 (outside this package) this method will work slowly, up to <i>O</i>(<i>N</i>) operations,
 <i>N</i> is the number of points in this pattern.
 However, even in such implementations this method <i>must not</i> lead to
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>, like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)"><CODE>roundedCoordRange(int)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>coordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordArea()"><!-- --></A><H3>
coordArea</H3>
<PRE>
<A HREF="../../../../net/algart/math/RectangularArea.html" title="class in net.algart.math">RectangularArea</A> <STRONG>coordArea</STRONG>()</PRE>
<DL>
<DD>Returns the minimal and maximal coordinates
 among all points of this pattern for all dimensions.
 If <tt>a</tt> is the result of this method,
 then <tt>a.<A HREF="../../../../net/algart/math/RectangularArea.html#coordCount()"><CODE>coordCount()</CODE></A>==<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>
 and <tt>a.<A HREF="../../../../net/algart/math/RectangularArea.html#range(int)"><CODE>range</CODE></A>(k)</tt>
 is equal to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange</CODE></A>(k)</tt> for all <tt>k</tt>.

 <p>For example, in 2-dimensional case the result is
 the circumscribed rectangle (with sides, parallel to the axes).

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal coordinate for all space dimensions.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()"><CODE>roundedCoordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordMin()"><!-- --></A><H3>
coordMin</H3>
<PRE>
<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>coordMin</STRONG>()</PRE>
<DL>
<DD>Returns the point, each coordinate of which
 is equal to the minimal corresponding coordinate
 among all points of this pattern.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>coordArea()</CODE></A>.<A HREF="../../../../net/algart/math/RectangularArea.html#min()"><CODE>min()</CODE></A></tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>minimal coordinates for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordMax()"><!-- --></A><H3>
coordMax</H3>
<PRE>
<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>coordMax</STRONG>()</PRE>
<DL>
<DD>Returns the point, each coordinate of which
 is equal to the maximal corresponding coordinate
 among all points of this pattern.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>coordArea()</CODE></A>.<A HREF="../../../../net/algart/math/RectangularArea.html#max()"><CODE>max()</CODE></A></tt>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>maximal coordinates for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedCoordRange(int)"><!-- --></A><H3>
roundedCoordRange</H3>
<PRE>
<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A> <STRONG>roundedCoordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int coordIndex)</CODE></A> method,
 but both minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.
 Equivalent to <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange</CODE></A>(coordIndex).<A HREF="../../../../net/algart/math/Range.html#toRoundedRange()"><CODE>toRoundedRange()</CODE></A></tt>.

 <p>According the basic restriction to pattern coordinates (see
 the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Coordinate restrictions"),
 you may be sure that you will be able
 to create an integer <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular pattern</CODE></A> by passing the ranges, got by this method,
 to <A HREF="../../../../net/algart/math/patterns/Patterns.html#newRectangularIntegerPattern(net.algart.math.IRange...)"><CODE>Patterns.newRectangularIntegerPattern(IRange...)</CODE></A>.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index, rounded to the <tt>long</tt> values.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()"><CODE>roundedCoordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedCoordArea()"><!-- --></A><H3>
roundedCoordArea</H3>
<PRE>
<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A> <STRONG>roundedCoordArea</STRONG>()</PRE>
<DL>
<DD>Returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>coordArea()</CODE></A> method,
 but all minimal and maximal coordinates are rounded to integer values
 by <tt>StrictMath.round</tt> operation.
 The method <A HREF="../../../../net/algart/math/IRectangularArea.html#range(int)"><CODE>IRectangularArea.range(int coordIndex)</CODE></A> in the returned area
 returns the same result as <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)"><CODE>roundedCoordRange(int coordIndex)</CODE></A> method in this object.

 <p>All, said in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 about the speed and impossibility of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 is also true for this method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal coordinate for all space dimensions,
         rounded to the <tt>long</tt> values.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelySinglePoint()"><!-- --></A><H3>
isSurelySinglePoint</H3>
<PRE>
boolean <STRONG>isSurelySinglePoint</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pattern consists of the single point, i&#46;e&#46;
 if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>.

 <p>There are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 consist of the single point. (In some complex situations, such analysis can
 be too difficult. In particular, if the pattern is a <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Minkowski sum</CODE></A>, then limited floating-point precision can lead to equality of all points of the result.
 Simple example: a Minkowski sum of two-point one-dimensional pattern, consisting of points
 0.0 and 0.000001, and one-point 2<sup>51</sup>=2251799813685248.0, contains only 1 point 2<sup>51</sup>,
 because the computer cannot represent precise value 2251799813685248.000001 in <tt>double</tt> type
 and rounds it to 2251799813685248.0.
 In such situations, this method sometimes <i>may</i> incorrectly return <tt>false</tt>.)

 <p>But there is the reverse guarantee: if this method returns <tt>true</tt>,
 the number of points in this pattern is always&nbsp;1.</p>

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 (and, so, <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A> method is not safe in use),
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and absolutely correctly
 (always returns <tt>true</tt> if and only if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if it is one-point pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()"><CODE>isSurelyOriginPoint()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyOriginPoint()"><!-- --></A><H3>
isSurelyOriginPoint</H3>
<PRE>
boolean <STRONG>isSurelyOriginPoint</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pattern consists of the single point and
 this point is the origin of coordinates.

 <p>There are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 consist of the single point, equal to the origin of coordinates. (In some complex situations, such analysis can
 be too difficult. In such situations, this method <i>may</i> incorrectly return <tt>false</tt>.)
 But there is the reverse guarantee: if this method returns <tt>true</tt>,
 the number of points in this pattern is always 1 and its only point is the origin of coordinates,
 in terms of <A HREF="../../../../net/algart/math/Point.html#isOrigin()"><CODE>Point.isOrigin()</CODE></A> method.</p>

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 (and, so, <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A> method is not safe in use),
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and absolutely correctly.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if it is one-point pattern containing the origin of coordinates as the single point.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>isSurelySinglePoint()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyInteger()"><!-- --></A><H3>
isSurelyInteger</H3>
<PRE>
boolean <STRONG>isSurelyInteger</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pattern is <i>integer</i>:
 all coordinates of all points of this pattern are integer numbers.
 In other words, it means that for each real (<tt>double</tt>) coordinate <i>x</i> of each point
 of this pattern the Java expression <i>x</i><tt>==(long)</tt><i>x</i> is <tt>true</tt>.

 <p>More precisely, if this method returns <tt>true</tt>, then there are the following guarantees:
 <ol>
 <li>for each point, returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method, as well as by
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>/<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>, <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>Point.isInteger()</CODE></A> method returns <tt>true</tt>;</li>
 <li>each pattern, returned in the results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(int)</CODE></A>,
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>unionDecomposition(int)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)"><CODE>allUnionDecompositions(int)</CODE></A> methods, is also surely integer,
 i.e. this method also returns <tt>true</tt> for it.</li>
 </ol>

 <p>However, there are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 is really integer. In other words, if this method returns <tt>false</tt>, there is no guarantee, that
 this pattern really contains some non-integer points &mdash; but it is probable.

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 and there is a risk to fail with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>,
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>See the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Integer patterns", for more details.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this pattern and all patterns of its decomposition
         (<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>Minkowski</CODE></A> or <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>union</CODE></A>)
         assuredly contain only <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>integer</CODE></A> points.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="round()"><!-- --></A><H3>
round</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>round</STRONG>()</PRE>
<DL>
<DD>Returns this pattern, every point of which is rounded to the nearest integer point.
 The result is always <i>ordinary integer pattern</i>
 (see the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Uniform-grid patterns").

 <p>More precisely, the resulting pattern:
 <ol>
 <li>consists of all points,
 obtained from all points of this pattern by rounding by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>toRoundedPoint()</CODE></A>.<A HREF="../../../../net/algart/math/IPoint.html#toPoint()"><CODE>toPoint()</CODE></A></tt>;</li>
 <li>has zero origin <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#originOfGrid()"><CODE>UniformGridPattern.originOfGrid()</CODE></A>=(0,0,...,0)
 and unit steps <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>UniformGridPattern.stepsOfGrid()</CODE></A>={1,1,..,1}.</li>
 </ol>

 <p>Note: the number of points in the result can be less than <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>, because some
 real points can be rounded to the same integer points.</p>

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
 It is an important difference from <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method.

 <p>The theorem I, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", provides a guarantee that this method never throws
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the integer pattern, geometrically nearest to this one.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shift(net.algart.math.Point)"><!-- --></A><H3>
shift</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>shift</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</PRE>
<DL>
<DD>Returns this pattern, shifted by the argument.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call <tt>point.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(shift)</tt>.

 <!--Repeat.SectionStart simple_corrections_features-->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.SectionEnd simple_corrections_features-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>However, <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> is impossible in many important cases, when
 this pattern is an <i>integer</i> pattern and each coordinate
 <nobr><i>X</i><sub><i>j</i></sub>=<tt>shift.<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(</tt><i>j</i><tt>)</tt></nobr>
 of the argument is equal to &minus;<i>x</i><sub><i>j</i></sub> for some some point
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 of this pattern.
 In particular, you can use this method for <i>integer</i> patterns without a risk of
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> in the following situations:
 <ul>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>p.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>, where <tt>p</tt> is
 some of the <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points</CODE></A> if this integer pattern.</li>
 </ul>
 <p>See more details in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", the theorem II.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>point.<A HREF="../../../../net/algart/math/Point.html#coordCount()"><CODE>coordCount()</CODE></A>!=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the set of shifted points does not fulfil the restrictions,
                                  described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
                                  section "Coordinate restrictions".</DD></DL>
</DD>
</DL>
<HR>

<A NAME="symmetric()"><!-- --></A><H3>
symmetric</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>symmetric</STRONG>()</PRE>
<DL>
<DD>Returns the symmetric pattern: equivalent to <A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the symmetric pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="multiply(double)"><!-- --></A><H3>
multiply</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>multiply</STRONG>(double&nbsp;multiplier)</PRE>
<DL>
<DD>Returns this pattern, scaled by the specified multiplier along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#multiply(double)"><CODE>multiply</CODE></A>(multipliers)</tt>.

 <p>This method is equivalent to <A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>scale(double... multipliers)</CODE></A>, where all
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A> arguments of that method are equal to <tt>multiplier</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to a very large multiplier).
 However, such failure is obviously impossible, if the multiplier is
 in range <tt>-1.0&lt;=multiplier&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multiplier</CODE> - the scale along all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the set of scaled points does not fulfil the restrictions,
                              described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
                              section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>scale(double...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="scale(double...)"><!-- --></A><H3>
scale</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>scale</STRONG>(double...&nbsp;multipliers)</PRE>
<DL>
<DD>Returns this pattern, scaled by the specified multipliers along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#scale(double...)"><CODE>scale</CODE></A>(multipliers)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large multipliers).
 However, such failure is obviously impossible, if all multipliers are
 in range <tt>-1.0&lt;=multipliers[k]&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multipliers</CODE> - the scales along coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>multipliers.length!=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the set of scaled points does not fulfil the restrictions,
                                  described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
                                  section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply(double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="projectionAlongAxis(int)"><!-- --></A><H3>
projectionAlongAxis</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>projectionAlongAxis</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the projection of this pattern along the given axis.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is less by 1, than in this one.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the projection of this pattern (its <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A> is equal to
         <tt>thisInstance.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this pattern is 1-dimensional (<tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>==1</tt>).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minBound(int)"><!-- --></A><H3>
minBound</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the <i>minimal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with less coordinate <tt>#coordIndex</tt>
 and same other coordinates.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, this method removes some points from this pattern according the following rule:
 if this pattern contains several points <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>, ...,
 <b>p</b><sub><i>m</i>&minus;1</sub> with identical projection to the given axis
 (<b>p</b><sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex).equals(</tt><b>p</b><sub><i>j</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex))</tt> for all <i>i</i>,&nbsp;<i>j</i>),
 then the resulting pattern contains only one from these points, for which
 the given coordinate <tt><A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(coordIndex)</tt> has the minimal value.

 <p>This method is especially useful for <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> patterns.
 For example, in <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 one of the facets of the hyperparallelepiped.
 In most cases (including all <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>)
 this method returns the same result as <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>UniformGridPattern.lowerSurface(int)</CODE></A>;
 but if the figure, described by this pattern, contains some "holes", the result of this method
 contains fewer points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#lowerSurface(int)"><CODE>UniformGridPattern.lowerSurface(int)</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the minimal boundary of this pattern for the given axis.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)"><CODE>maxBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxBound(int)"><!-- --></A><H3>
maxBound</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>maxBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Returns the <i>maximal boundary</i> of this pattern along the given axis:
 a pattern consisting of all points of this pattern, for which there are
 no other points with greater coordinate <tt>#coordIndex</tt>
 and same other coordinates.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) is the same as in this one.

 <p>In other words, this method removes some points from this pattern according the following rule:
 if this pattern contains several points <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>, ...,
 <b>p</b><sub><i>m</i>&minus;1</sub> with identical projection to the given axis
 (<b>p</b><sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex).equals(</tt><b>p</b><sub><i>j</i></sub><tt>.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex))</tt> for all <i>i</i>,&nbsp;<i>j</i>),
 then the resulting pattern contains only one from these points, for which
 the given coordinate <tt><A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(coordIndex)</tt> has the maximal value.

 <p>This method is especially useful for <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>uniform-grid</CODE></A> patterns.
 For example, in <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 one of the facets of the hyperparallelepiped.
 In most cases (including all <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>)
 this method returns the same result as <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A>;
 but if the figure, described by this pattern, contains some "holes", the result of this method
 contains fewer points than <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#upperSurface(int)"><CODE>UniformGridPattern.upperSurface(int)</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p><b>Warning!</b> If this object is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and is not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>, this method can work slowly for some large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>. The situation is like in <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works quickly (<i>O</i>(1) operations) and without exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal boundary of this pattern for the given axis.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)"><CODE>minBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="carcass()"><!-- --></A><H3>
carcass</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>carcass</STRONG>()</PRE>
<DL>
<DD>Returns the <i>carcass</i> of this pattern.
 We define the <i>carcass</i> of the pattern P as such point set C, that, for some
 integer <i>n</i>&gt;=1:

 <ol type="I">
 <li>
 2&otimes;P = P &oplus; C;<br>
 4&otimes;P = (2&otimes;P) &oplus; 2C;<br>
 8&otimes;P = (4&otimes;P) &oplus; 4C;<br>
 ...<br>
 2<sup><i>n</i></sup>&otimes;P = (2<sup><i>n</i>&minus;1</sup>&otimes;P) &oplus;
 2<sup><i>n</i>&minus;1</sup>C;
 </li>
 <li>for any <i>m</i>=1,2,...,<i>n</i> and for any positive integer
 <i>k</i>&le;2<sup><i>m</i>&minus;1</sup>, we have<br>
 (2<sup><i>m</i>&minus;1</sup>+<i>k</i>)&otimes;P =
 (2<sup><i>m</i>&minus;1</sup>&otimes;P) &oplus; <i>k</i>C.</li>
 </ol>

 <p>Here A&oplus;B means the <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Minkowski sum</CODE></A> of patterns A and B,
 <i>k</i>&otimes;P means P&oplus;P&oplus;...&oplus;P (<i>k</i> summands),
 and <i>k</i>P means the pointwise geometrical multiplication of the pattern P by the multiplier <i>k</i>,
 i.e. <tt>P.<A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>multiply</CODE></A>(<i>k</i>)</tt>.

 <p>This method tries to find the minimal carcass, consisting of as little as possible number of points,
 and the maximal value <i>n</i>, for which the formulas above are correct for the found carcass.
 (The value 2<sup><i>n</i></sup> is called the <i>maximal carcass multiplier</i>
 and is returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()"><CODE>maxCarcassMultiplier()</CODE></A> method.)
 For example, for <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A> this method returns
 the set of vertices of the hyperparallelepiped (in one-dimensional case, the pair of segment ends),
 and the corresponding <i>n</i>=+&infin;.
 But this method does not guarantee that the returned result is always the minimal possible carcass
 and that the found <i>n</i> is really maximal for this carcass.

 <p>This method allows to optimize calculation of the point set of a Minkowski multiple <i>k</i>&otimes;P.
 It is really used in the pattern implementations, returned
 by <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiMultiplePattern(net.algart.math.patterns.Pattern, int)"><CODE>Patterns.newMinkowskiMultiplePattern(Pattern, int)</CODE></A> method:
 the result of that method is not always an actual Minkowski sum of <i>N</i> equal patterns,
 but can be (in the best case) an equal Minkowski sum of ~log<sub>2</sub><i>N</i> patterns
 <nobr>P &oplus; C &oplus; 2C &oplus; ... &oplus; 2<i><sup>m</sup></i>C
 &oplus; (<i>N</i>&minus;2<sup><i>m</i></sup>C)</nobr>,
 2<sup><i>m</i></sup>&lt;<i>N</i>&le;2<sup><i>m</i>+1</sup>,
 or (in not the best case, when <i>N</i> is greater than the maximal carcass multiplier 2<sup><i>n</i></sup>)
 can be another, not so little Minkowski sum.

 <p>In the worst case (no optimization is possible), this method just returns this object (C=P),
 and <A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()"><CODE>maxCarcassMultiplier()</CODE></A> returns 2 (i.e. <i>n</i>=1).

 <p>The returned pattern has the same number of dimensions (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A>) as this one.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>This method can require some time and memory for execution,
 but never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <!-- below is a bug: sum of 2^ik*C is much greater, than k*C
 <p><small>
 Note: the condition II is a logical consequence from the conditions I.<br>
 Proof.<br>
 Let <i>k</i> = 2<sup><i>i</i><sub>1</sub></sup>+2<sup><i>i</i><sub>2</sub></sup>+...
 is the binary representation of the number <i>k</i>.
 According to the conditions I,
 <nobr>(2<sup><i>i<sub>k</sub></i></sup>&otimes;P) &oplus; 2<sup><i>i<sub>k</sub></i></sup>C
 = 2<sup><i>i<sub>k</sub></i>+1</sup>&otimes;P</nobr>.
 Summing these equations for all <i>i<sub>k</sub></i>, we have
 <nobr>(<i>k</i>&otimes;P) &oplus; <i>k</i>C = 2<i>k</i>&otimes;P</nobr>.
 So,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;(2<sup><i>m</i>&minus;1</sup>+<i>k</i>)&otimes;P
 = ((2<sup><i>m</i>&minus;1</sup>&minus;<i>k</i>)&otimes;P) &oplus;
 (2<i>k</i>&otimes;P)
 = ((2<sup><i>m</i>&minus;1</sup>&minus;<i>k</i>)&otimes;P) &oplus;
 (<i>k</i>&otimes;P) &oplus; <i>k</i>C
 = (2<sup><i>m</i>&minus;1</sup>&otimes;P) &oplus; <i>k</i>C.<br>
 This completes the proof.
 </small></p>
 -->
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the <i>carcass</i> of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxCarcassMultiplier()"><!-- --></A><H3>
maxCarcassMultiplier</H3>
<PRE>
int <STRONG>maxCarcassMultiplier</STRONG>()</PRE>
<DL>
<DD>Returns the maximal multiplier <i>k</i>, for which the calculation of
 the Minkowski multiple <i>k</i>&otimes;P can be optimized by using the <i>carcass</i> of this pattern P.
 Please see <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>carcass()</CODE></A> method for more information.

 <p>Note: the returned value is always &ge;2. If the correct value is greater than <tt>Integer.MAX_VALUE</tt>
 (for example, for <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>),
 this method returns <tt>Integer.MAX_VALUE</tt>; in all other cases the returning value is a power of two.

 <p>This method can require some time and memory for execution,
 but never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 Usually an implementation caches the results of <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>carcass()</CODE></A> and this methods,
 so this method works very quickly after the first call of <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>carcass()</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal multiplier (&ge;2),
         for which the calculation of the Minkowski multiple can be optimized
         by using the <A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()"><CODE>carcass</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiAdd(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiAdd</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiAdd</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</PRE>
<DL>
<DD>Calculates and returns the Minkowski sum of this and specified patterns.
 Briefly, the returned pattern consists of all points <i>a</i>+<i>b</i>, where
 <i>a</i> is any point of this pattern, <i>b</i> is any point of the argument "<tt>added</tt>"
 and "+" means a vector sum of two points
 (the result of "<i>a</i>.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(<i>b</i>)" call).
 Please see details in
 <noindex><a href="http://en.wikipedia.org/wiki/Minkowski_addition">Wikipedia</a></noindex>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions".

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern and <tt>subtracted</tt> argument implement <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 and both patterns have identical <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>steps</CODE></A>
 (i.e. <tt>thisPattern.<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)"><CODE>stepsOfGridEqual</CODE></A>(subtracted)</tt> returns <tt>true</tt>).
 In this case, this method works very quickly and without
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> exceptions.

 <p>Please draw attention: there is another way to build a Minkowski sum,
 namely the method <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>.
 That method does not perform actual calculations and returns a special implementation
 of this interface (see <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>, section "Complex patterns").
 Unlike that method, this one tries to actually calculate the Minkowski sum, saving (when possible)
 the type of the original pattern: see above two guarantees about <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 and <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> types. If it is impossible to represent the Minkowski sum
 by Java class of this pattern, it is probable that the result will be constructed
 as <A HREF="../../../../net/algart/math/patterns/DirectPointSetUniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetUniformGridPattern</CODE></A> or as <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>added</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the Minkowski sum of this and another patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the numbers of space dimensions of both patterns are different.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - for some forms of large patterns, if the number of points in this,
                                     <tt>added</tt> or result pattern is greater than
                                     <tt>Integer.MAX_VALUE</tt> or, maybe, is near this limit</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the resulting set of points does not fulfil the restrictions,
                                     described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
                                     section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)"><CODE>minkowskiSubtract(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiSubtract(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiSubtract</H3>
<PRE>
<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiSubtract</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</PRE>
<DL>
<DD>Calculates and returns the erosion of this pattern by specified pattern
 or <tt>null</tt> if this erosion is the empty set.
 Briefly, the returned pattern consists of all such points <i>p</i>,
 that for any points <i>b</i> of the "<tt>subtracted</tt>" pattern the vector sum of two points
 <i>p</i>+<i>b</i>
 (the result of "<i>p</i>.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(<i>b</i>)" call)
 belongs to this pattern.
 Please see more details in
 <noindex><a href="http://en.wikipedia.org/wiki/Erosion_%28morphology%29">Wikipedia</a></noindex> and
 Google about the "Erosion" and "Minkowski subtraction" terms.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions". But it is obvious, that this exception
 is impossible if the passed pattern "<tt>subtracted</tt>" contains the origin of coordinates
 (in this case, the result is a subset of this pattern).

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern and <tt>subtracted</tt> argument implement <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 and both patterns have identical <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGrid()"><CODE>steps</CODE></A>
 (i.e. <tt>thisPattern.<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#stepsOfGridEqual(net.algart.math.patterns.UniformGridPattern)"><CODE>stepsOfGridEqual</CODE></A>(subtracted)</tt> returns <tt>true</tt>).
 In this case, this method works very quickly and without
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> exceptions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>subtracted</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the erosion of this pattern by the specified pattern
         or <tt>null</tt> if this erosion is the empty set.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the numbers of space dimensions of both patterns are different.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - for some forms of large patterns, if the number of points in this,
                                     <tt>subtracted</tt> or result pattern is greater than
                                     <tt>Integer.MAX_VALUE</tt> or, maybe, is near this limit</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the resulting set of points does not fulfil the restrictions,
                                     described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
                                     section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>minkowskiAdd(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiDecomposition(int)"><!-- --></A><H3>
minkowskiDecomposition</H3>
<PRE>
java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>minkowskiDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>Returns the Minkowski decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is a Minkowski sum of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &oplus; P<sub>1</sub> &oplus;...&oplus; P<sub><i>n</i>&minus;1</sub></nobr>.
 In other words, each point <b>p</b>&isin;P of this pattern is equal to a vector sum
 of some <i>n</i> points
 <b>p</b><sub>0</sub>, <b>p</b><sub>1</sub>,&nbsp;..., <b>p</b><sub><i>n</i>&minus;1</sub>,
 where <b>p</b><sub><i>i</i></sub>&isin;P<sub><i>i</i></sub>.
 Please see <noindex><a href="http://en.wikipedia.org/wiki/Minkowski_addition">Wikipedia</a></noindex>
 about the "Minkowski sum" term.

 <p>This method tries to find the best decomposition, that means the list of patterns
 with minimal summary number of points. For good pattern, the returned patterns list
 can consist of <i>O</i>(log<sub>2</sub><i>N</i>) points (sum of <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>
 values for all returned patterns),
 where <i>N</i> is the number of points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>) in this pattern.
 For example, a linear one-dimensional segment {<i>x</i>: 0&lt;=x&lt;2<i><sup>m</sup></i>}
 is a Minkowski sum of <i>m</i> point pairs {0, 2<i><sup>i</sup></i>}, <i>i</i>=0,1,...,<i>m</i>-1.

 <p>There is no guarantee that this method returns a good decomposition.
 If this method cannot find required decomposition, it returns the 1-element list containing
 this instance as the only element.

 <p>If the number of points in this pattern is less than the argument, i.e.
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>&lt;minimalPointCount</tt>, then this method probably does not
 decompose this pattern and returns the 1-element list containing this instance as its element.
 But it is not guaranteed: if the method "knows" some decomposition, but estimation of the number of points
 can require a lot of resources, this method may ignore <tt>minimalPointCount</tt> argument.

 <p>However, there is a guarantee that if the number of points is 1 or 2,
 i.e. <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>&le;2</tt>, then this method always returns
 the 1-element list containing this instance as its element.

 <p>There is a guarantee that the elements of the resulting list cannot be further decomposed:
 this method, called for them with the same or larger <tt>minimalPointCount</tt> argument,
 always returns a list consisting of one element.

 <p>The number of space dimensions in all returned patterns (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A> is the same as in this one.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableList</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the decomposition of this pattern to Minkowski sum; always contains &ge;1 elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hasMinkowskiDecomposition()"><!-- --></A><H3>
hasMinkowskiDecomposition</H3>
<PRE>
boolean <STRONG>hasMinkowskiDecomposition</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if the Minkowski decomposition,
 returned by <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A> call,
 consists of 2 or more patterns:
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A>.size()&gt;1</tt>.

 <p>In some situations this method works essentially faster then the actual
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(0)</CODE></A> call.

 <p>Note that if this method returns <tt>true</tt>, then <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A> and
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>largePointCount()</CODE></A> methods can work very slowly and even may fail with
 <tt>OutOfMemoryError</tt> or <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the Minkowski decomposition contains 2 or more elements.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unionDecomposition(int)"><!-- --></A><H3>
unionDecomposition</H3>
<PRE>
java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>unionDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>Returns a union decomposition:
 a non-empty list of patterns P<sub>0</sub>, P<sub>1</sub>,&nbsp;..., P<sub><i>n</i>&minus;1</sub>,
 such that this pattern P (the point set represented by it)
 is the set-theoretical union of them (of the point sets represented by them):
 <nobr>P = P<sub>0</sub> &cup; P<sub>1</sub> &cup;...&cup; P<sub><i>n</i>&minus;1</sub></nobr>.

 <p>This method tries to find such decomposition, that all patterns P<sub><i>i</i></sub> have good
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>Minkowski decompositions</CODE></A>
 and the summary number of points in all Minkowski decompositions
 <nobr>P<sub><i>i</i></sub><tt>.<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(minimalPointCount)</CODE></A></tt></nobr>
 of all patterns, returned by this method, is as small as possible &mdash;
 usually much less than the number of points in this instance.
 If this pattern already has a good Minkowski decompositions,
 this method should return the 1-element list containing
 this instance as the only element.

 <p>If the number of points in this pattern is less than the argument, i.e.
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>&lt;minimalPointCount</tt>, then this method probably does not
 decompose this pattern and returns the 1-element list containing this instance as its element.
 Moreover, this method tries to build such decomposition, that every element P<sub><i>i</i></sub>
 in the resulting list contains <tt>&ge;minimalPointCount</tt> elements.

 <p>There is a guarantee that the elements of the resulting list cannot be further decomposed:
 this method, called for them with the same or larger <tt>minimalPointCount</tt> argument,
 always returns a list consisting of one element.

 <p>The number of space dimensions in all returned patterns (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A> is the same as in this one.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableList</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a decomposition of this pattern into the union of patterns; always contains &ge;1 elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="allUnionDecompositions(int)"><!-- --></A><H3>
allUnionDecompositions</H3>
<PRE>
java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt; <STRONG>allUnionDecompositions</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>Returns a non-empty list of all best or almost best
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>union decompositions</CODE></A>
 with equal or similar "quality",
 i&#46;e&#46; with the same or almost same summary number of points in all Minkowski decompositions
 of all returned patterns.

 <p>This method is a useful addition to <A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)"><CODE>unionDecomposition(int)</CODE></A> method for a case,
 when there are several union decompositions with similar "quality".
 In this case an algorithm, using union decompositions, is able to choose
 the best from several variants according additional algorithm-specific criteria.

 <p>The number of space dimensions in all returned patterns (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A> is the same as in this one.

 <p>The result of this method and the elements of the result are immutable
 (<tt>Collections.unmodifiableList</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>several good variants of decomposition of this pattern to the union of patterns;
         the result always contains &ge;1 elements,
         and all its elements also contain &ge;1 elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/math/patterns/ParaboloidOfRevolutionFunc.html" title="class in net.algart.math.patterns"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/Patterns.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/Pattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="Pattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
