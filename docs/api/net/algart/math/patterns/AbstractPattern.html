<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractPattern
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractPattern";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/AbstractPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.math.patterns</FONT>
<BR>
Class AbstractPattern</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.math.patterns.AbstractPattern</STRONG>
</PRE>
<DL>
<DT><STRONG>All Implemented Interfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></DD>
</DL>
<DL>
<DT><STRONG>Direct Known Subclasses:</STRONG></DT> <DD><A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns">AbstractUniformGridPattern</A>, <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns">SimplePattern</A></DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>AbstractPattern</STRONG>
extends java.lang.Object
implements <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></PRE>

<P>
<p>A skeletal implementation of the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface to minimize
 the effort required to implement this interface.</p>

 <p>All non-abstract methods are completely implemented here and may be not overridden in subclasses.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount">dimCount</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of space dimensions of this pattern.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.algart.math.patterns.Pattern"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Fields inherited from interface net.algart.math.patterns.<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE">MAX_COORDINATE</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Constructor Summary table, listing constructors, and an explanation">
<CAPTION CLASS="TableCaption">
Constructor Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Constructor and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#AbstractPattern(int)">AbstractPattern</A></STRONG>(int&nbsp;dimCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a pattern with the given number of space dimensions.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation just returns the list containing 1 list, containing
 this instance as the only element:
 <tt>Collections.singletonList(Collections.&lt;Pattern&gt;singletonList(thisInstance))</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#carcass()">carcass</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation just returns this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#checkCoordIndex(int)">checkCoordIndex</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throws <tt>IndexOutOfBoundsException</tt>
 if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/RectangularArea.html" title="class in net.algart.math">RectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordArea()">coordArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordMax()">coordMax</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordMin()">coordMin</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)">coordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount"><CODE>dimCount</CODE></A> field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation just returns <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isAllowedCoordRange(net.algart.math.Range)">isAllowedCoordRange</A></STRONG>(<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A>&nbsp;range)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if both boundaries of the specified range,
 <i>a</i>=<tt>range.<A HREF="../../../../net/algart/math/Range.html#min()"><CODE>min()</CODE></A></tt> and <i>b</i>=<tt>range.<A HREF="../../../../net/algart/math/Range.html#max()"><CODE>max()</CODE></A></tt>,
 lie in range
 <nobr>&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>&le;<i>a</i>&le;<i>b</i>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A></nobr>
 and, at the same time, the call <tt><A HREF="../../../../net/algart/math/patterns/Patterns.html#isAllowedDifference(double, double)"><CODE>Patterns.isAllowedDifference</CODE></A>(<i>a</i>,<i>b</i>)</tt> returns <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isAllowedPoint(net.algart.math.Point)">isAllowedPoint</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if all coordinates of the specified point lie
 in range &minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>&le;<i>x</i><sub><i>j</i></sub>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isPointCountVeryLarge()">isPointCountVeryLarge</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelyInteger()">isSurelyInteger</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and checks, whether all returned points are integer,
 i&#46;e&#46; <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>Point.isInteger()</CODE></A> method returns <tt>true</tt> for all elements the returned set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation checks <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelySinglePoint()"><CODE>isSurelySinglePoint()</CODE></A>, and if it is <tt>true</tt>,
 checks, whether the only element of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> set is the origin.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelySinglePoint()">isSurelySinglePoint</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pattern consists of the single point, i&#46;e&#46;
 if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#largePointCount()">largePointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt>(double)<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#maxBound(int)">maxBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation just returns 2.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minBound(int)">minBound</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop for all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method in both patterns
 and always returns a <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>direct point-set pattern</CODE></A>,
 consisting of sums of all point pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation just returns <tt>Collections.&lt;Pattern&gt;singletonList(thisInstance)</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop for all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method in both patterns
 and always returns a <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>direct point-set pattern</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)">multiply</A></STRONG>(double&nbsp;multiplier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation creates Java array <tt>double[]</tt> by the call
 "<nobr><tt>a = new double[<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount"><CODE>dimCount</CODE></A>]</tt></nobr>", fills all its elements by
 <tt>multiplier</tt> argument and then calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#scale(double...)"><CODE>scale(a)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()">pointCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of points in this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()">points</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a set of all points of this pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the projection of this pattern along the given axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#round()">round</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method and constructs a new integer pattern on the base
 of this set, like as it is performed in <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedCoordArea()">roundedCoordArea</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedCoordRange(int)"><CODE>roundedCoordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedCoordRange(int)">roundedCoordRange</A></STRONG>(int&nbsp;coordIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange</CODE></A>(coordIndex).<A HREF="../../../../net/algart/math/Range.html#toRoundedRange()"><CODE>toRoundedRange()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()">roundedPoints</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and returns a new set, built from the returned set of
 real points by conversion of every point to an integer point via <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method,
 as written in
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>comments to this method in Pattern interface</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#scale(double...)">scale</A></STRONG>(double...&nbsp;multipliers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, scaled by the specified multipliers along all coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#shift(net.algart.math.Point)">shift</A></STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns this pattern, shifted by the argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#symmetric()">symmetric</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#unionDecomposition(int)">unionDecomposition</A></STRONG>(int&nbsp;minimalPointCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implementation returns <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#allUnionDecompositions(int)"><CODE>allUnionDecompositions(minimalPointCount)</CODE></A>.get(0)</tt>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Field Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="dimCount"><!-- --></A><H3>
dimCount</H3>
<PRE>
protected final int <STRONG>dimCount</STRONG></PRE>
<DL>
<DD>The number of space dimensions of this pattern.
<P>
</DD>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Constructor Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractPattern(int)"><!-- --></A><H3>
AbstractPattern</H3>
<PRE>
protected <STRONG>AbstractPattern</STRONG>(int&nbsp;dimCount)</PRE>
<DL>
<DD>Creates a pattern with the given number of space dimensions.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dimCount</CODE> - the number of space dimensions.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>dimCount&lt;=0</tt>.</DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
public final int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD>This implementation returns <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount"><CODE>dimCount</CODE></A> field.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()">dimCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of space dimensions of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pointCount()"><!-- --></A><H3>
pointCount</H3>
<PRE>
public abstract long <STRONG>pointCount</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">Pattern</A></CODE></STRONG></DD>
<DD>Returns the number of points in this pattern.
 This value is always positive (&gt;=1).
 If the number of points is greater than <tt>Long.MAX_VALUE</tt>, returns <tt>Long.MAX_VALUE</tt>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns:
 the required time can be <i>O</i>(<i>N</i>), where <i>N</i> is the number of points (result of this method).
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then the result of this method is not greater than <tt>Integer.MAX_VALUE</tt>.

 <p>Note: if this method returns some value greater than <tt>Integer.MAX_VALUE</tt>,
 it means that you cannot use <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> and <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>Pattern.roundedPoints()</CODE></A> methods,
 because Java <tt>Set</tt> object cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()">pointCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math"><CODE>points</CODE></A> in this pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()"><CODE>Pattern.largePointCount()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>Pattern.isSurelySinglePoint()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="largePointCount()"><!-- --></A><H3>
largePointCount</H3>
<PRE>
public double <STRONG>largePointCount</STRONG>()</PRE>
<DL>
<DD>This implementation returns <tt>(double)<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt>.
 Please override this method if the pattern can contain more than <tt>Long.MAX_VALUE</tt> points.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#largePointCount()">largePointCount</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of <A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math"><CODE>integer points</CODE></A> in this pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html#isPointCountVeryLarge()"><CODE>QuickPointCountPattern.isPointCountVeryLarge()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isPointCountVeryLarge()"><!-- --></A><H3>
isPointCountVeryLarge</H3>
<PRE>
public boolean <STRONG>isPointCountVeryLarge</STRONG>()</PRE>
<DL>
<DD>This implementation returns <tt>false</tt>.
 Please override this method if the pattern can contain more than <tt>Long.MAX_VALUE</tt> points.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the number of points in this pattern is greater than <tt>Long.MAX_VALUE</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="points()"><!-- --></A><H3>
points</H3>
<PRE>
public abstract java.util.Set&lt;<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&gt; <STRONG>points</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">Pattern</A></CODE></STRONG></DD>
<DD>Returns a set of all points of this pattern.

 <p>The result of this method is immutable (<tt>Collections.unmodifiableSet</tt>).
 Moreover, the result is always the same for different calls of this method for the same instance &mdash;
 there are no ways to change it, in particular, via any custom methods of the implementation class
 (it is a conclusion from the common requirement, that all implementations of this interface must be
 immutable).

 <p>The returned set is always non-empty,
 and the number of its elements is always equal to <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>.

 <p><b>Warning!</b> This method can work slowly for some forms of large patterns.
 In these cases, this method can also throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt>.
 This method surely fails (throws one of these exception), if the total number of points
 <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A>&gt;Integer.MAX_VALUE</tt>, because Java <tt>Set</tt> object
 cannot contain more than <tt>Integer.MAX_VALUE</tt> elements.

 <p>For example, implementations of the <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>rectangular patterns</CODE></A>
 allow to successfully define a very large 3D parallelepiped
 <nobr><i>n</i> x <i>n</i> x <i>n</i></nobr>.
 Fur such pattern, this method will require a lot of memory
 for <i>n</i>=1000 and will fail (probably with <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>)
 for <i>n</i>=2000 (2000<sup>3</sup>&gt;<tt>Integer.MAX_VALUE</tt>).

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> interface,
 then this method requires not greater than <i>O</i>(<i>N</i>) operations and memory
 (<i>N</i>=<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.

 <p>Note: this method works very quickly (<i>O</i>(1) operations) in <A HREF="../../../../net/algart/math/patterns/SimplePattern.html" title="class in net.algart.math.patterns"><CODE>SimplePattern</CODE></A> class.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#points()">points</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedPoints()"><!-- --></A><H3>
roundedPoints</H3>
<PRE>
public java.util.Set&lt;<A HREF="../../../../net/algart/math/IPoint.html" title="class in net.algart.math">IPoint</A>&gt; <STRONG>roundedPoints</STRONG>()</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and returns a new set, built from the returned set of
 real points by conversion of every point to an integer point via <A HREF="../../../../net/algart/math/Point.html#toRoundedPoint()"><CODE>Point.toRoundedPoint()</CODE></A> method,
 as written in
 <A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>comments to this method in Pattern interface</CODE></A>.
 Please override this method if there is more efficient way to get all rounded points.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()">roundedPoints</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>all points of this pattern, rounded to the nearest integer points.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method throws this exception
                                     (<tt>OutOfMemoryError</tt> can be also thrown in this case).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordRange(int)"><!-- --></A><H3>
coordRange</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A> <STRONG>coordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the minimal and maximal coordinate with the given index
 (<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>Point.coord(coordIndex)</CODE></A>)
 among all points of this pattern.
 The minimal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#min()"><CODE>min()</CODE></A></tt>,
 the maximal coordinate will be <tt>r.<A HREF="../../../../net/algart/math/Range.html#max()"><CODE>max()</CODE></A></tt>,
 where <tt>r</tt> is the result of this method.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and without exceptions.

 <p>Moreover, all patterns, implemented in this package, have very quick implementations of this method
 (<i>O</i>(1) operations). Also, the implementations of this method in this package never throw exceptions.

 <p>It is theoretically possible, that in custom implementations of this interface
 (outside this package) this method will work slowly, up to <i>O</i>(<i>N</i>) operations,
 <i>N</i> is the number of points in this pattern.
 However, even in such implementations this method <i>must not</i> lead to
 <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>, like <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordRange(int)">coordRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)"><CODE>Pattern.roundedCoordRange(int)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>Pattern.coordMin()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>Pattern.coordMax()</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()"><CODE>Pattern.coordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordArea()"><!-- --></A><H3>
coordArea</H3>
<PRE>
public <A HREF="../../../../net/algart/math/RectangularArea.html" title="class in net.algart.math">RectangularArea</A> <STRONG>coordArea</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordArea()">coordArea</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal grid index for all space dimensions.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()"><CODE>Pattern.roundedCoordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordMin()"><!-- --></A><H3>
coordMin</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>coordMin</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()">coordMin</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>minimal coordinates for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="coordMax()"><!-- --></A><H3>
coordMax</H3>
<PRE>
public <A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A> <STRONG>coordMax</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()">coordMax</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>maximal coordinates for all space dimensions as a point.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedCoordRange(int)"><!-- --></A><H3>
roundedCoordRange</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IRange.html" title="class in net.algart.math">IRange</A> <STRONG>roundedCoordRange</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>This implementation returns <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#coordRange(int)"><CODE>coordRange</CODE></A>(coordIndex).<A HREF="../../../../net/algart/math/Range.html#toRoundedRange()"><CODE>toRoundedRange()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordRange(int)">roundedCoordRange</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>, 1 for <i>y</i>, 2 for <i>z</i>, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the range from minimal to maximal coordinate with this index, rounded to the <tt>long</tt> values.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()"><CODE>Pattern.roundedCoordArea()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="roundedCoordArea()"><!-- --></A><H3>
roundedCoordArea</H3>
<PRE>
public <A HREF="../../../../net/algart/math/IRectangularArea.html" title="class in net.algart.math">IRectangularArea</A> <STRONG>roundedCoordArea</STRONG>()</PRE>
<DL>
<DD>This implementation is based on the loop of calls of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedCoordRange(int)"><CODE>roundedCoordRange(int)</CODE></A> method
 for all coordinate indexes from <tt>0</tt> to <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedCoordArea()">roundedCoordArea</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the ranges from minimal to maximal coordinate for all space dimensions,
         rounded to the <tt>long</tt> values.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelySinglePoint()"><!-- --></A><H3>
isSurelySinglePoint</H3>
<PRE>
public abstract boolean <STRONG>isSurelySinglePoint</STRONG>()</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">Pattern</A></CODE></STRONG></DD>
<DD>Returns <tt>true</tt> if this pattern consists of the single point, i&#46;e&#46;
 if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>.

 <p>There are no strict guarantees that this method <i>always</i> returns <tt>true</tt> if the pattern
 consist of the single point. (In some complex situations, such analysis can
 be too difficult. In particular, if the pattern is a <A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Minkowski sum</CODE></A>, then limited floating-point precision can lead to equality of all points of the result.
 Simple example: a Minkowski sum of two-point one-dimensional pattern, consisting of points
 0.0 and 0.000001, and one-point 2<sup>51</sup>=2251799813685248.0, contains only 1 point 2<sup>51</sup>,
 because the computer cannot represent precise value 2251799813685248.000001 in <tt>double</tt> type
 and rounds it to 2251799813685248.0.
 In such situations, this method sometimes <i>may</i> incorrectly return <tt>false</tt>.)

 <p>But there is the reverse guarantee: if this method returns <tt>true</tt>,
 the number of points in this pattern is always&nbsp;1.</p>

 <p>Unlike <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method, there is a guarantee that this method
 never works very slowly and cannot lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In situations, when the number of points is very large
 (and, so, <A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>Pattern.pointCount()</CODE></A> method is not safe in use),
 this method must detect this fact in reasonable time and return <tt>false</tt>.

 <p>There is a guarantee, that if this object implements <A HREF="../../../../net/algart/math/patterns/QuickPointCountPattern.html" title="interface in net.algart.math.patterns"><CODE>QuickPointCountPattern</CODE></A> interface,
 then this method works very quickly (<i>O</i>(1) operations) and absolutely correctly
 (always returns <tt>true</tt> if and only if <tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>==1</tt>).
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()">isSurelySinglePoint</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if it is one-point pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()"><CODE>Pattern.isSurelyOriginPoint()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyOriginPoint()"><!-- --></A><H3>
isSurelyOriginPoint</H3>
<PRE>
public boolean <STRONG>isSurelyOriginPoint</STRONG>()</PRE>
<DL>
<DD>This implementation checks <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#isSurelySinglePoint()"><CODE>isSurelySinglePoint()</CODE></A>, and if it is <tt>true</tt>,
 checks, whether the only element of <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> set is the origin.

 <p>This method caches its results: the following calls will work faster.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyOriginPoint()">isSurelyOriginPoint</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if it is one-point pattern containing the origin of coordinates as the single point.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelySinglePoint()"><CODE>Pattern.isSurelySinglePoint()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isSurelyInteger()"><!-- --></A><H3>
isSurelyInteger</H3>
<PRE>
public boolean <STRONG>isSurelyInteger</STRONG>()</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and checks, whether all returned points are integer,
 i&#46;e&#46; <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>Point.isInteger()</CODE></A> method returns <tt>true</tt> for all elements the returned set.
 If all points, returned by <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> call, are integer, this method returns <tt>true</tt>,
 in other case it returns <tt>false</tt>.

 <p>This method caches its results: the following calls will work faster.

 <p>Note: according the <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()"><CODE>comments to this method in Pattern interface</CODE></A>,
 such implementation is correct only if <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#minkowskiDecomposition(int)"><CODE>minkowskiDecomposition(int)</CODE></A>,
 <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#unionDecomposition(int)"><CODE>unionDecomposition(int)</CODE></A> and <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#allUnionDecompositions(int)"><CODE>allUnionDecompositions(int)</CODE></A> methods
 have default implementations (not overridden). If some of them are overridden and
 return some non-trivial results, this method <i>must</i> be also overridden.

 <p>Note: according the <A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()"><CODE>comments to this method in Pattern interface</CODE></A>,
 this method <i>must</i> be overridden if the number of points can be very large and a call of
 <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method leads to a risk of <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt>.
 In particular, this method should be usually overridden in implementations of <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#isSurelyInteger()">isSurelyInteger</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this pattern assuredly contain only <A HREF="../../../../net/algart/math/Point.html#isInteger()"><CODE>integer</CODE></A> points.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="round()"><!-- --></A><H3>
round</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns">UniformGridPattern</A> <STRONG>round</STRONG>()</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#roundedPoints()"><CODE>roundedPoints()</CODE></A> method and constructs a new integer pattern on the base
 of this set, like as it is performed in <A HREF="../../../../net/algart/math/patterns/Patterns.html#newIntegerPattern(java.util.Collection)"><CODE>Patterns.newIntegerPattern(java.util.Collection)</CODE></A> method.
 Please override this method if there is more efficient way to round this pattern,
 for example, if this pattern is already an integer one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#round()">round</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the integer pattern, geometrically nearest to this one.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="projectionAlongAxis(int)"><!-- --></A><H3>
projectionAlongAxis</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>projectionAlongAxis</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">Pattern</A></CODE></STRONG></DD>
<DD>Returns the projection of this pattern along the given axis.
 The number of dimensions in the resulting pattern (<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>) is less by 1, than in this one.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#projectionAlongAxis(int)"><CODE>projectionAlongAxis</CODE></A>(coordIndex)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#projectionAlongAxis(int)">projectionAlongAxis</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the projection of this pattern (its <A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A> is equal to
         <tt>thisInstance.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>Pattern.dimCount()</CODE></A>-1</tt>).</DD></DL>
</DD>
</DL>
<HR>

<A NAME="minBound(int)"><!-- --></A><H3>
minBound</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.
 Please override this method if there is more efficient way to find the result,
 for example, if this pattern is a rectangular one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)">minBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the minimal boundary of this pattern for the given axis.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)"><CODE>Pattern.maxBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxBound(int)"><!-- --></A><H3>
maxBound</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>maxBound</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method and builds the result on the base of analysis
 of the returned point set.
 Please override this method if there is more efficient way to find the result,
 for example, if this pattern is a rectangular one.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxBound(int)">maxBound</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - the index of the coordinate (0 for <i>x</i>-axis , 1 for <i>y</i>-axis,
                   2 for <i>z</i>a-xis, etc.).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal boundary of this pattern for the given axis.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - if this pattern is not <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A> and
                                     not <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A> and if, at the same time, the number
                                     of points is greater than <tt>Integer.MAX_VALUE</tt> or,
                                     in some rare situations, is near this limit
                                     (<tt>OutOfMemoryError</tt> can be also thrown instead of this exception).</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minBound(int)"><CODE>Pattern.minBound(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="carcass()"><!-- --></A><H3>
carcass</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>carcass</STRONG>()</PRE>
<DL>
<DD>This implementation just returns this object.
 Please override this method (together with <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#maxCarcassMultiplier()"><CODE>maxCarcassMultiplier()</CODE></A>),
 if your class can provide better results.

 <p>Note: <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><CODE>AbstractUniformGridPattern</CODE></A> class provides much better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#carcass()">carcass</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the <i>carcass</i> of this pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="maxCarcassMultiplier()"><!-- --></A><H3>
maxCarcassMultiplier</H3>
<PRE>
public int <STRONG>maxCarcassMultiplier</STRONG>()</PRE>
<DL>
<DD>This implementation just returns 2.
 Please override this method (together with <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#carcass()"><CODE>carcass()</CODE></A>),
 if your class can provide better results.

 <p>Note: <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><CODE>AbstractUniformGridPattern</CODE></A> class provides much better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#maxCarcassMultiplier()">maxCarcassMultiplier</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the maximal multiplier (&ge;2),
         for which the calculation of the Minkowski multiple can be optimized
         by using the <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#carcass()"><CODE>carcass</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="shift(net.algart.math.Point)"><!-- --></A><H3>
shift</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>shift</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;shift)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, shifted by the argument.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call <tt>point.<A HREF="../../../../net/algart/math/Point.html#add(net.algart.math.Point)"><CODE>add</CODE></A>(shift)</tt>.

 <!--Repeat.SectionStart simple_corrections_features-->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.SectionEnd simple_corrections_features-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large shift).

 <p>However, <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> is impossible in many important cases, when
 this pattern is an <i>integer</i> pattern and each coordinate
 <nobr><i>X</i><sub><i>j</i></sub>=<tt>shift.<A HREF="../../../../net/algart/math/Point.html#coord(int)"><CODE>coord</CODE></A>(</tt><i>j</i><tt>)</tt></nobr>
 of the argument is equal to &minus;<i>x</i><sub><i>j</i></sub> for some some point
 <nobr>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>
 of this pattern.
 In particular, you can use this method for <i>integer</i> patterns without a risk of
 <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A> in the following situations:
 <ul>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMin()"><CODE>coordMin()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>thisIntegerPattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#coordMax()"><CODE>coordMax()</CODE></A>.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>,</li>
 <li><tt>shift</tt> is <tt>p.<A HREF="../../../../net/algart/math/Point.html#symmetric()"><CODE>symmetric()</CODE></A></tt>, where <tt>p</tt> is
 some of the <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>points</CODE></A> if this integer pattern.</li>
 </ul>
 <p>See more details in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions", the theorem II.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#shift(net.algart.math.Point)">shift</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>shift</CODE> - the shift.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the shifted pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="symmetric()"><!-- --></A><H3>
symmetric</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>symmetric</STRONG>()</PRE>
<DL>
<DD>This implementation calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#multiply(double)"><CODE>multiply(-1.0)</CODE></A>.
 There are no reasons to override this method usually.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()">symmetric</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the symmetric pattern.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="multiply(double)"><!-- --></A><H3>
multiply</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>multiply</STRONG>(double&nbsp;multiplier)</PRE>
<DL>
<DD>This implementation creates Java array <tt>double[]</tt> by the call
 "<nobr><tt>a = new double[<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount"><CODE>dimCount</CODE></A>]</tt></nobr>", fills all its elements by
 <tt>multiplier</tt> argument and then calls <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#scale(double...)"><CODE>scale(a)</CODE></A>.
 There are no reasons to override this method usually.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)">multiply</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multiplier</CODE> - the scale along all coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the set of scaled points does not fulfil the restrictions,
          described in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface,
          section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)"><CODE>Pattern.scale(double...)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="scale(double...)"><!-- --></A><H3>
scale</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>scale</STRONG>(double...&nbsp;multipliers)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">Pattern</A></CODE></STRONG></DD>
<DD>Returns this pattern, scaled by the specified multipliers along all coordinates.

 <p>More precisely, the resulting pattern consists of the points,
 obtained from all points of this pattern by the call
 <tt>point.<A HREF="../../../../net/algart/math/Point.html#scale(double...)"><CODE>scale</CODE></A>(multipliers)</tt>.

 <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, simple_corrections_features)!! Auto-generated: NOT EDIT !! -->
 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>DirectPointSetPattern</CODE></A>

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/RectangularPattern.html" title="interface in net.algart.math.patterns"><CODE>RectangularPattern</CODE></A>.

 <p>The returned pattern always implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>
 if this pattern implements <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html" title="interface in net.algart.math.patterns"><CODE>UniformGridPattern</CODE></A>.

 <p>There is a guarantee, that this method does not try to allocate much more memory,
 that it is required for storing this pattern itself, and that it
 never throws <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>.
 For comparison, an attempt to do the same operation via getting all points (<A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method),
 correcting them and forming a new pattern via <A HREF="../../../../net/algart/math/patterns/Patterns.html#newPattern(java.util.Collection)"><CODE>Patterns.newPattern(java.util.Collection)</CODE></A>
 will lead to <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A> / <tt>OutOfMemoryError</tt> for some forms of large patterns.
 <!--Repeat.IncludeEnd-->

 <p>Warning: this method can fail with <A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns"><CODE>TooLargePatternCoordinatesException</CODE></A>, if some of new points
 violate restrictions, described in the <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>comments to this interface</CODE></A>,
 section "Coordinate restrictions" (for example, due to very large multipliers).
 However, such failure is obviously impossible, if all multipliers are
 in range <tt>-1.0&lt;=multipliers[k]&lt;=1.0</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#scale(double...)">scale</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>multipliers</CODE> - the scales along coordinates.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the scaled pattern.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#multiply(double)"><CODE>Pattern.multiply(double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiAdd(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiAdd</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiAdd</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;added)</PRE>
<DL>
<DD>This implementation is based on the loop for all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method in both patterns
 and always returns a <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>direct point-set pattern</CODE></A>,
 consisting of sums of all point pairs.
 This algorithm may be very slow for large patterns
 (<i>O</i>(<i>NM</i>) operations, <i>N</i>=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()"><CODE>pointCount()</CODE></A>, <i>M</i>=added.<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and does not work at all if the number of resulting points is greater than <tt>Integer.MAX_VALUE</tt>.
 Please override this method if there is better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)">minkowskiAdd</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>added</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the Minkowski sum of this and another patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the numbers of space dimensions of both patterns are different.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - for some forms of large patterns, if the number of points in this,
                                     <tt>added</tt> or result pattern is greater than
                                     <tt>Integer.MAX_VALUE</tt> or, maybe, is near this limit</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the resulting set of points does not fulfil the restrictions,
                                     described in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface,
                                     section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Patterns.html#newMinkowskiSum(java.util.Collection)"><CODE>Patterns.newMinkowskiSum(java.util.Collection)</CODE></A>, 
<A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiSubtract(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiSubtract(net.algart.math.patterns.Pattern)"><!-- --></A><H3>
minkowskiSubtract</H3>
<PRE>
public <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A> <STRONG>minkowskiSubtract</STRONG>(<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;subtracted)</PRE>
<DL>
<DD>This implementation is based on the loop for all points returned by <A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#points()"><CODE>points()</CODE></A> method in both patterns
 and always returns a <A HREF="../../../../net/algart/math/patterns/DirectPointSetPattern.html" title="interface in net.algart.math.patterns"><CODE>direct point-set pattern</CODE></A>.
 This algorithm may be very slow for large patterns
 (<i>O</i>(<i>NM</i>) operations, <i>N</i>=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()"><CODE>pointCount()</CODE></A>, <i>M</i>=added.<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#pointCount()"><CODE>pointCount()</CODE></A>)
 and does not work at all if the number of resulting points is greater than <tt>Integer.MAX_VALUE</tt>.
 Please override this method if there is better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiSubtract(net.algart.math.patterns.Pattern)">minkowskiSubtract</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>subtracted</CODE> - another pattern.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the erosion of this pattern by the specified pattern
         or <tt>null</tt> if this erosion is the empty set.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the numbers of space dimensions of both patterns are different.</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns">TooManyPointsInPatternError</A></CODE> - for some forms of large patterns, if the number of points in this,
                                     <tt>subtracted</tt> or result pattern is greater than
                                     <tt>Integer.MAX_VALUE</tt> or, maybe, is near this limit</DD>
<DD><CODE><A HREF="../../../../net/algart/math/patterns/TooLargePatternCoordinatesException.html" title="class in net.algart.math.patterns">TooLargePatternCoordinatesException</A></CODE> - if the resulting set of points does not fulfil the restrictions,
                                     described in the comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface,
                                     section "Coordinate restrictions".</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiAdd(net.algart.math.patterns.Pattern)"><CODE>Pattern.minkowskiAdd(Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="minkowskiDecomposition(int)"><!-- --></A><H3>
minkowskiDecomposition</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>minkowskiDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>This implementation just returns <tt>Collections.&lt;Pattern&gt;singletonList(thisInstance)</tt>.

 <p>Note: <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><CODE>AbstractUniformGridPattern</CODE></A> class provides much better implementation for
 patterns, recognized as rectangular by <A HREF="../../../../net/algart/math/patterns/UniformGridPattern.html#isActuallyRectangular()"><CODE>UniformGridPattern.isActuallyRectangular()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#minkowskiDecomposition(int)">minkowskiDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the decomposition of this pattern to Minkowski sum; always contains &ge;1 elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="hasMinkowskiDecomposition()"><!-- --></A><H3>
hasMinkowskiDecomposition</H3>
<PRE>
public boolean <STRONG>hasMinkowskiDecomposition</STRONG>()</PRE>
<DL>
<DD>This implementation just returns <tt>false</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#hasMinkowskiDecomposition()">hasMinkowskiDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the Minkowski decomposition contains 2 or more elements;
         always <tt>false</tt> in this implementation.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="unionDecomposition(int)"><!-- --></A><H3>
unionDecomposition</H3>
<PRE>
public java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt; <STRONG>unionDecomposition</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>This implementation returns <tt><A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#allUnionDecompositions(int)"><CODE>allUnionDecompositions(minimalPointCount)</CODE></A>.get(0)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#unionDecomposition(int)">unionDecomposition</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>a decomposition of this pattern into the union of patterns; always contains &ge;1 elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="allUnionDecompositions(int)"><!-- --></A><H3>
allUnionDecompositions</H3>
<PRE>
public java.util.List&lt;java.util.List&lt;<A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&gt;&gt; <STRONG>allUnionDecompositions</STRONG>(int&nbsp;minimalPointCount)</PRE>
<DL>
<DD>This implementation just returns the list containing 1 list, containing
 this instance as the only element:
 <tt>Collections.singletonList(Collections.&lt;Pattern&gt;singletonList(thisInstance))</tt>.

 <p>Note: <A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><CODE>AbstractUniformGridPattern</CODE></A> class provides much better implementation.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html#allUnionDecompositions(int)">allUnionDecompositions</A></CODE> in interface <CODE><A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>minimalPointCount</CODE> - this method usually does not decompose patterns that contain
                          less than <tt>minimalPointCount</tt> points.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>several good variants of decomposition of this pattern to the union of patterns;
         the result always contains &ge;1 elements,
         and all its elements also contain &ge;1 elements.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the argument is negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isAllowedPoint(net.algart.math.Point)"><!-- --></A><H3>
isAllowedPoint</H3>
<PRE>
public static boolean <STRONG>isAllowedPoint</STRONG>(<A HREF="../../../../net/algart/math/Point.html" title="class in net.algart.math">Point</A>&nbsp;point)</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if all coordinates of the specified point lie
 in range &minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>&le;<i>x</i><sub><i>j</i></sub>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>.

 <p>Actually this method checks the 1st restriction for coordinates of any pattern:
 see comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface, section "Coordinate restrictions".
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>point</CODE> - some point.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this point is an allowed point for patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isAllowedCoordRange(net.algart.math.Range)"><!-- --></A><H3>
isAllowedCoordRange</H3>
<PRE>
public static boolean <STRONG>isAllowedCoordRange</STRONG>(<A HREF="../../../../net/algart/math/Range.html" title="class in net.algart.math">Range</A>&nbsp;range)</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if both boundaries of the specified range,
 <i>a</i>=<tt>range.<A HREF="../../../../net/algart/math/Range.html#min()"><CODE>min()</CODE></A></tt> and <i>b</i>=<tt>range.<A HREF="../../../../net/algart/math/Range.html#max()"><CODE>max()</CODE></A></tt>,
 lie in range
 <nobr>&minus;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A>&le;<i>a</i>&le;<i>b</i>&le;<A HREF="../../../../net/algart/math/patterns/Pattern.html#MAX_COORDINATE"><CODE>Pattern.MAX_COORDINATE</CODE></A></nobr>
 and, at the same time, the call <tt><A HREF="../../../../net/algart/math/patterns/Patterns.html#isAllowedDifference(double, double)"><CODE>Patterns.isAllowedDifference</CODE></A>(<i>a</i>,<i>b</i>)</tt> returns <tt>true</tt>.

 <p>This method helps to check the 2nd restriction for coordinates of any pattern:
 see comments to <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> interface, section "Coordinate restrictions".
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>range</CODE> - some range.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this range is an allowed coordinate range for patterns.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="checkCoordIndex(int)"><!-- --></A><H3>
checkCoordIndex</H3>
<PRE>
protected final void <STRONG>checkCoordIndex</STRONG>(int&nbsp;coordIndex)</PRE>
<DL>
<DD>Throws <tt>IndexOutOfBoundsException</tt>
 if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.
 Does nothing in other case.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordIndex</CODE> - checked index of the coordinate.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>coordIndex&lt;0</tt> or <tt>coordIndex&gt;=<A HREF="../../../../net/algart/math/patterns/AbstractPattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../net/algart/math/patterns/AbstractUniformGridPattern.html" title="class in net.algart.math.patterns"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/math/patterns/AbstractPattern.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="AbstractPattern.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
