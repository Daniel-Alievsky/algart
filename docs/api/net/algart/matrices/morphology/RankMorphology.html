<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
RankMorphology
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="RankMorphology";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/morphology/Morphology.SubtractionMode.html" title="enum in net.algart.matrices.morphology"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/morphology/RankPrecision.html" title="enum in net.algart.matrices.morphology"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/morphology/RankMorphology.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="RankMorphology.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.matrices.morphology</FONT>
<BR>
Interface RankMorphology</H2>
<DL>
<DT><STRONG>All Superinterfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/arrays/ArrayProcessor.html" title="interface in net.algart.arrays">ArrayProcessor</A>, <A HREF="../../../../net/algart/arrays/ArrayProcessorWithContextSwitching.html" title="interface in net.algart.arrays">ArrayProcessorWithContextSwitching</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology">Morphology</A></DD>
</DL>
<DL>
<DT><STRONG>All Known Implementing Classes:</STRONG></DT> <DD><A HREF="../../../../net/algart/matrices/morphology/AbstractRankMorphology.html" title="class in net.algart.matrices.morphology">AbstractRankMorphology</A>, <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology">BasicRankMorphology</A>, <A HREF="../../../../net/algart/matrices/morphology/ContinuedRankMorphology.html" title="class in net.algart.matrices.morphology">ContinuedRankMorphology</A>, <A HREF="../../../../net/algart/matrices/morphology/TiledRankMorphology.html" title="class in net.algart.matrices.morphology">TiledRankMorphology</A></DD>
</DL>
<HR>
<PRE>public interface <STRONG>RankMorphology</STRONG>
extends <A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology">Morphology</A></PRE>

<P>
<p>Rank operations over <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays"><CODE><i>n</i>-dimensional matrices</CODE></A>:
 percentile, rank, mean between given percentiles or values, etc&#46;,
 calculated on all matrix elements in an aperture with the fixed shape, represented by <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> class.
 It is supposed that the type of matrix elements is one of primitive Java types
 (<tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt>,
 <tt>long</tt>, <tt>float</tt>, <tt>double</tt>) and, so, represents an integer or a real number,
 according to comments to <A HREF="../../../../net/algart/arrays/PFixedArray.html#getLong(long)"><CODE>PFixedArray.getLong(long)</CODE></A> and <A HREF="../../../../net/algart/arrays/PArray.html#getDouble(long)"><CODE>PArray.getDouble(long)</CODE></A> methods.
 In 2-dimensional case, these operations can be used for processing grayscale digital images.</p>

 <p>The simplest rank operation is a percentile, for example, minimum, maximum or median.
 In the case of maximum, the percentile is strictly equivalent to <i>dilation</i> &mdash; the basic
 operation of the mathematical morphology, offered by <A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology"><CODE>Morphology</CODE></A> interface.
 In the case of minimum, the percentile by some pattern <b>P</b> is equivalent to <i>erosion</i>
 by the symmetric pattern <b>P</b>.<A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()"><CODE>symmetric()</CODE></A>.
 It allows to consider rank operations as an extension of the operation set of
 the traditional mathematical morphology. Really, this interface extends
 <A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology"><CODE>Morphology</CODE></A> interface, and it is supposed, by definition, that
 <nobr><tt><A HREF="../../../../net/algart/matrices/morphology/Morphology.html#dilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>dilation</CODE></A>(m,pattern)</tt></nobr> method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile</CODE></A>(m,c*<i>N</i>,pattern)</tt></nobr> and
 <nobr><tt><A HREF="../../../../net/algart/matrices/morphology/Morphology.html#erosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>erosion</CODE></A>(m,pattern)</tt></nobr> method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile</CODE></A>(m,c*<i>N</i>,pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#symmetric()"><CODE>symmetric()</CODE></A>)</tt></nobr>, where <nobr><tt><i>N</i>=pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>-1</tt></nobr>
 and <tt>c</tt> is some constant, specified while instantiating this object
 (it is <tt>dilationLevel</tt> argument of
 <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>BasicRankMorphology.getInstance</CODE></A>
 method).</p>

 <p>Below is the formal definition of 5 basic rank operations with the given pattern <b>P</b>
 and matrix <b>M</b>: <i>percentile</i>, <i>rank</i>, <i>mean between 2 percentiles</i>,
 <i>mean between 2 ranks</i> and <i>aperture sum</i>, calculated by this class.</p>

 <ol>
 <li>For any integer point, or <i>position</i>
 <nobr><b>x</b> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>,
 <nobr><i>n</i>=<b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></nobr>, the <i>aperture</i> of this point,
 or the <i>aperture at the position</i> <b>x</b>,
 is a set of points
 <nobr><b>x</b>&minus;<b>p</b><sub><i>i</i></sub> = (<i>x</i><sub>0</sub>&minus;<i>p</i><sub><i>i</i>0</sub>,
 <i>x</i><sub>1</sub>&minus;<i>p</i><sub><i>i</i>1</sub>, ...,
 <i>x</i><sub><i>n</i>&minus;1</sub>&minus;<i>p</i><sub><i>i</i>,<i>n</i>&minus;1</sub>)</nobr>
 for all <nobr><b>p</b><sub><i>i</i></sub>&isin;<b>P</b></nobr> (<A HREF="../../../../net/algart/math/patterns/Pattern.html#roundedPoints()"><CODE>points</CODE></A>
 of the pattern&nbsp;<b>P</b>).
 We always consider that the point <b>x</b> lies inside <b>M</b> matrix
 (<nobr>0&le;<i>x</i><sub><i>k</i></sub>&lt;<b>M</b>.<tt><A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr>
 for all <i>k</i>), but this condition can be not true for points of the aperture
 <nobr><b>x</b>&minus;<b>p</b><sub><i>i</i></sub></nobr>.
 <br>&nbsp;</li>

 <li>For every point <nobr><b>x</b>' = <b>x</b>&minus;<b>p</b><sub><i>i</i></sub></nobr> of the aperture
 we consider the corresponding <i>value</i> <i>v<sub>i</sub></i> of the source matrix <b>M</b>.
 The precise definition of the value can depend on implementation of this interface.
 Usually, if the point lies inside the matrix
 (<nobr>0&le;<i>x</i><sub><i>k</i></sub>&minus;<i>p</i><sub><i>i,k</i></sub>&lt;<b>M</b>.<tt><A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr> for all <i>k</i>), it is the value of the element
 (integer: <A HREF="../../../../net/algart/arrays/PFixedArray.html#getLong(long)"><CODE>PFixedArray.getLong(long)</CODE></A>, if the type of the matrix elements is <tt>boolean</tt>, <tt>char</tt>,
 <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt>, or real: <A HREF="../../../../net/algart/arrays/PArray.html#getDouble(long)"><CODE>PArray.getDouble(long)</CODE></A>,
 if the element type is <tt>float</tt> or <tt>double</tt>) of the underlying array
 <nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></nobr> with an index
 <nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>(<i>x</i>'<sub>0</sub>, <i>x</i>'<sub>1</sub>, ..., <i>x</i>'<sub><i>n</i>&minus;1</sub>)</nobr>,
 where <nobr><i>x</i>'<sub><i>k</i></sub> = <i>x</i><sub><i>k</i></sub>&minus;<i>p</i><sub><i>i,k</i></sub></nobr>.
 In particular, it is true for all implementations offered by this package.
 If the point <nobr><b>x</b>' = <b>x</b>&minus;<b>p</b><sub><i>i</i></sub></nobr> lies outside the matrix
 (<nobr><i>x</i>'<sub><i>k</i></sub>&lt;0</nobr> or
 <nobr><i>x</i>'<sub><i>k</i></sub>&ge;<b>M</b>.<tt><A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)</tt></nobr>
 for some <i>k</i>), then:
     <ul>
     <li>in the <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>BasicRankMorphology</CODE></A> implementation, <i>v<sub>i</sub></i> is the value of the element
     (<A HREF="../../../../net/algart/arrays/PFixedArray.html#getLong(long)"><CODE>PFixedArray.getLong(long)</CODE></A> for the fixed-point case or <A HREF="../../../../net/algart/arrays/PArray.html#getDouble(long)"><CODE>PArray.getDouble(long)</CODE></A>
     for the floating-point case) of the underlying array <nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A></nobr>
     with an index <nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)"><CODE>pseudoCyclicIndex</CODE></A>(<i>x</i>'<sub>0</sub>, <i>x</i>'<sub>1</sub>, ...,
     <i>x</i>'<sub><i>n</i>&minus;1</sub>)</nobr>;</li>
     <li>in the <A HREF="../../../../net/algart/matrices/morphology/ContinuedRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>ContinuedRankMorphology</CODE></A> implementation, <i>v<sub>i</sub></i> is the
     calculated according to the continuation mode, passed to
     <A HREF="../../../../net/algart/matrices/morphology/ContinuedRankMorphology.html#getInstance(net.algart.matrices.morphology.RankMorphology, net.algart.arrays.Matrix.ContinuationMode)"><CODE>ContinuedRankMorphology.getInstance(RankMorphology, Matrix.ContinuationMode)</CODE></A>
     method;</li>
     <li>other implementations may offer other ways for calculating <i>v<sub>i</sub></i>.
     <br>&nbsp;</li>
     </ul>
 </li>

 <li>So, for every point <b>x</b> we have an aperture, consisting of
 <nobr><i>N</i>=<b>P</b>.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></nobr> "neighbour" points
 <nobr><b>x</b>&minus;<b>p</b><sub><i>i</i></sub></nobr>,
 and a corresponding set of integer or real values <i>v<sub>i</sub></i>,
 <nobr><i>i</i>=0,1,...,<i>N</i>&minus;1</nobr>. Then we consider a <i>histogram</i> built on the base of
 <i>v<sub>i</sub></i> values &mdash; the histogram, corresponding to the point <b>x</b>. Namely, this histogram
 is an array of non-negative integer numbers <nobr><b>b</b>[<i>w</i>]</nobr>, 0&le;<i>w</i>&lt;<i>M</i>,
 where every element <b>b</b>[<i>w</i>] represents the number of occurrence of the value <i>w</i>
 in array <b>A</b>, consisting of the following <i>N</i> integer elements
 <nobr><i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>, ..., <i>x</i><sub><i>N</i>&minus;1</sub></nobr>:
     <ul>
     <li><nobr><i>a<sub>i</sub></i> = min(<i>M</i>&minus;1,
     &lfloor;max(0, <i>v<sub>i</sub></i>) * &sigma;&rfloor;)</nobr>
     (here and below &lfloor;<i>y</i>&rfloor; means the integer part of <i>y</i> or <tt>(long)</tt><i>y</i>
     for non-negative numbers, <i>M</i> and &sigma; are defined below);
     in other words, <i>a<sub>i</sub></i> is an integer part of <nobr>&sigma;<i>v<sub>i</sub></i></nobr>,
     truncated to <nobr>0..<i>M</i>&minus;1</nobr> range of allowed histogram indexes;</li>

     <li>the <i>histogram length M</i> is the global parameter of this object and is equal to some power of two:
     <nobr><i>M</i>=2<sup>&mu;</sup></nobr>, <nobr>&mu;=0,1,2...</nobr> There is a guarantee that
     if the matrix is fixed-point (<nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>Matrix.elementType()</CODE></A></nobr> is
     <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt>),
     then <nobr>&mu;&le;&beta;</nobr>, where &beta; is
     the number of bits per element:
     <nobr>&beta; = <b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PArray.html#bitsPerElement()"><CODE>bitsPerElement()</CODE></A></nobr>.
     If this object is an instance of <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>BasicRankMorphology</CODE></A>, then
     <nobr>&mu; = <tt>bitLevels[bitLevels.length-1]</tt></nobr>
     for floating-point matrix elements (<nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>Matrix.elementType()</CODE></A></nobr> is
     <tt>float</tt> or <tt>double</tt>) or
     <nobr>&mu; = min(<tt>bitLevels[bitLevels.length-1]</tt>, &beta;)</nobr>
     for fixed-point matrix elements, where <tt>bitLevels</tt> is
     an array of <i><A HREF="../../../../net/algart/matrices/morphology/CustomRankPrecision.html#bitLevels()"><CODE>bit levels</CODE></A></i>, specified while instantiating
     this class via the last argument of
     <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>BasicRankMorphology.getInstance(ArrayContext, double, CustomRankPrecision)</CODE></A> method;</li>

     <li>the real number &sigma; ("scale") is equal to <i>M</i> for a floating-point matrix
     or equal to <nobr><i>M</i>/2<sup>&beta;</sup>=2<sup>&mu;&minus;&beta;</sup></nobr>,
     <nobr>&beta; = <b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PArray.html#bitsPerElement()"><CODE>bitsPerElement()</CODE></A></nobr> for a fixed-point matrix. So, in the case of a fixed-point matrix
     there is a guarantee that <nobr>1/&sigma;</nobr> is a positive integer number
     (<nobr>2<sup>&beta;&minus;&mu;</sup></nobr>).</li>
     </ul>
 In other words, the "standard" allowed range of element values
 <nobr><tt>0..<A HREF="../../../../net/algart/arrays/Arrays.html#maxPossibleValue(java.lang.Class, double)"><CODE>Arrays.maxPossibleValue</CODE></A>(<b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A>,1.0)</tt></nobr>
 is split into <nobr><i>M</i>=2<sup>&mu;</sup></nobr> histogram bars and all aperture values
 <i>v<sub>i</sub></i> are distributed between these bars; elements, which are out of the allowed range,
 are distributed between the first and last bars.
 In the simplest case of <tt>byte</tt> elements, <i>M</i> is usually chosen to be 256;
 then <nobr>&sigma;=1.0</nobr> and <nobr><i>a<sub>i</sub></i> = <i>v<sub>i</sub></i></nobr>
 (because <tt>byte</tt> elements, in terms of AlgART libraries, cannot be out of 0..255 range).
 <br>&nbsp;</li>

 <li>The histogram <nobr><b>b</b>[0], <b>b</b>[1], ..., <b>b</b>[<i>M</i>&minus;1]</nobr>, specified above,
 is interpreted in terms of <A HREF="../../../../net/algart/arrays/Histogram.html" title="class in net.algart.arrays"><CODE>Histogram</CODE></A> and <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>SummingHistogram</CODE></A> classes.
 Namely, we define the following <i>rank characteristics</i>:
     <ul>
     <li>the <b><i>percentile</i></b> with the given real index <i>r</i> is
     <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
     where <nobr><i>v</i>(<i>r</i>)</nobr> function is defined in comments to <A HREF="../../../../net/algart/arrays/Histogram.html" title="class in net.algart.arrays"><CODE>Histogram</CODE></A> class;</li>

     <li>the <b><i>rank</i></b> of the given real value <i>v</i> is <nobr><i>r</i>(<i>v</i>*&sigma;)</nobr>,
     where <nobr><i>r</i>(<i>v</i>)</nobr> function is defined in comments to <A HREF="../../../../net/algart/arrays/Histogram.html" title="class in net.algart.arrays"><CODE>Histogram</CODE></A> class;</li>

     <li>the <b><i>mean between 2 given percentiles</i></b> with the real indexes
     <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> is
     <nobr>(<i>S</i>(<i>r</i><sub>2</sub>)&minus;<i>S</i>(<i>r</i><sub>1</sub>)) /
     ((<i>r</i><sub>2</sub>&minus;<i>r</i><sub>1</sub>)*&sigma;)</nobr>
     if <nobr><i>r</i><sub>1</sub>&lt;<i>r</i><sub>2</sub></nobr> or some reserved value <i>filler</i>
     if <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>,
     where <nobr><i>S</i>(<i>r</i>)</nobr> function is defined in comments to <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>SummingHistogram</CODE></A> class;</li>

     <li>the <b><i>mean between 2 given values</i></b>, the real numbers
     <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub>, is
     <nobr>(<i>s</i>(<i>v</i><sub>2</sub>*&sigma;)&minus;<i>s</i>(<i>v</i><sub>1</sub>*&sigma;)) /
     (<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)&minus;<i>r</i>(<i>v</i><sub>1</sub>*&sigma;))*&sigma;)</nobr>
     if <nobr><i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub></nobr> and
     <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&lt;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
     where <nobr><i>r</i>(<i>v</i>)</nobr> function is defined in comments to <A HREF="../../../../net/algart/arrays/Histogram.html" title="class in net.algart.arrays"><CODE>Histogram</CODE></A> class and
     <nobr><i>s</i>(<i>v</i>)</nobr> function is defined in comments to <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>SummingHistogram</CODE></A> class.
     If the conditions <nobr><i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub></nobr> and
     <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&lt;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr> are not
     fulfilled, we use one of 4 following <i>modes of calculation</i>:
         <ol type="A">
         <li>if any of these two conditions is not fulfilled, it is equal to some reserved value <i>filler</i>;</li>
         <li>if any of these two conditions is not fulfilled, it is equal to <i>v</i><sub>1</sub>;</li>
         <li>if any of these two conditions is not fulfilled, it is equal to <i>v</i><sub>2</sub>;</li>
         <li>(most useful definition)
             <ol type="I">
             <li>if <i>v</i><sub>1</sub>&ge;<i>v</i><sub>2</sub>, it is equal to
             (<i>v</i><sub>1</sub>+<i>v</i><sub>2</sub>)/2;</li>
             <li>if <i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub> and
             <nobr><i>r</i>(<i>v</i><sub>2</sub>*&sigma;)=<i>r</i>(<i>v</i><sub>1</sub>*&sigma;)=0</nobr>,
             it is equal to <i>v</i><sub>2</sub> (see also
             <nobr><A HREF="../../../../net/algart/arrays/SummingHistogram.CountOfValues.html#isLeftBound()"><CODE>CountOfValues.isLeftBound()</CODE></A></nobr>);</li>
             <li>if <i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub> and
             <nobr><i>r</i>(<i>v</i><sub>2</sub>*&sigma;)=<i>r</i>(<i>v</i><sub>1</sub>*&sigma;)=<i>N</i></nobr>,
             it is equal to <i>v</i><sub>1</sub> (see also
             <nobr><A HREF="../../../../net/algart/arrays/SummingHistogram.CountOfValues.html#isRightBound()"><CODE>CountOfValues.isRightBound()</CODE></A></nobr>);</li>
             <li>in other cases, it is equal to
             (<i>v</i><sub>1</sub>+<i>v</i><sub>2</sub>)/2.</li>
             </ol>
         </li>
         </ol>
     Remember that <i>r</i>(<i>v</i>) is always a non-decreasing function, so, the sentence
     "the conditions <nobr><i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub></nobr> and
     <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&lt;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr> are not
     fulfilled" means, that either <nobr><i>v</i><sub>1</sub>&ge;<i>v</i><sub>2</sub></nobr>,
     or <nobr><i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub></nobr> and
     <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)=<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>.
     The last situation usually occurs "outside" the histogram, when both <i>v</i><sub>1</sub> and
     <i>v</i><sub>2</sub> values are less than (or equal to) the minimal value in the aperture
     or greater than (or equal to) the maximum value in the aperture.
     However, while using the simple histogram model, such situation is also possible on a sparse histogram
     with many zero bars;
     </li>
     <li>the <b><i>aperture sum</i></b> is just a usual sum of all values
     <nobr><i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub></nobr> &mdash;
     the only rank characteristic which does not use the histogram <b>b</b>[<i>k</i>].
     (Of course, you can also calculate the <i>mean</i> of all values on the base of this sum:
     it is enough to divide the sum by <i>N</i>.)</li>
     </ul>
 <b>Note 1:</b> it is obvious that all rank characteristics, excepting the <i>aperture sum</i>, depend on the
 <i>histogram model</i>: simple or precise (see comments to <A HREF="../../../../net/algart/arrays/Histogram.html" title="class in net.algart.arrays"><CODE>Histogram</CODE></A> and <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>SummingHistogram</CODE></A> classes).
 The used model is chosen while instantiating this class, usually via
 <A HREF="../../../../net/algart/matrices/morphology/CustomRankPrecision.html#interpolated()"><CODE>CustomRankPrecision.interpolated()</CODE></A> flag in the argument of <A HREF="../../../../net/algart/matrices/morphology/CustomRankPrecision.html" title="interface in net.algart.matrices.morphology"><CODE>CustomRankPrecision</CODE></A> class:
 <tt>true</tt> value ("interpolated") means the precise model, <tt>false</tt> means the simple one.
 <br>
 <b>Note 2</b>: for <tt>int</tt>, <tt>long</tt>, <tt>float</tt> and <tt>double</tt> element type of the source
 matrix <b>M</b> and for all characteristics, excepting the <i>aperture sum</i>, this definition supposes that
 all matrix elements lie in the "standard range": <nobr><tt>0..Integer/Long.MAX_VALUE</tt></nobr>
 (all non-negative values) for integers or <nobr><tt>0.0..1.0</tt></nobr> for floating-point elements.
 If some matrix elements are negative, they are interpreted as 0; if some elements of a floating-point
 matrix are greater than <nobr><tt>1.0</tt></nobr>, they are interpreted as <nobr><tt>1.0</tt></nobr>.
 For floating-point case, the histogram length <i>M</i> actually specifies
 the <i>precision</i> of calculations: the source elements are represented with the precision
 <nobr>1/<i>M</i></nobr>. The <i>aperture sum</i> characteristic is an exception from this rule: aperture sums
 are calculated as usual sums of the source elements <i>v<sub>i</sub></i> with <tt>double</tt> precision.
 <br>
 <b>Note 3:</b> for floating-point case, if the value of some element <i>v<sub>i</sub></i>
 of the source matrix <b>M</b> inside the aperture is <b>NaN</b>
 (<tt>Float.NaN</tt> for <tt>float</tt> type, <tt>Double.NaN</tt> for <tt>double</tt> type),
 this situation does not lead to an exception, but the resulting values of all characteristics, listed above,
 are undocumented.
 <br>
 <b>Note 4:</b> unlike this, if some arguments of the characteristics, listed above &mdash;
 the real index <i>r</i> for the percentile, the real value <i>v</i> for the rank,
 the real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> for the mean between percentiles
 or the real values <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> for the mean between values &mdash;
 are <b>NaN</b>, then any attempt to calculate these characteristics by methods of this interface
 <b>can lead to <tt>IllegalArgumentException</tt></b>.
 </li>
 </ol>

 <p>This interface provides method for calculating the described 5 rank characteristics for every
 integer point <b>x</b> lying in the matrix <b>M</b>. The resulting characteristics are returned
 in the result matrix with the same dimensions as <b>M</b>. The necessary arguments &mdash;
 the real index <i>r</i> for the percentile, the real value <i>v</i> for the rank,
 the real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> for the mean between percentiles
 or the real values <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> for the mean between values &mdash;
 are retrieved from the corresponding element (with the index
 <nobr><b>M</b>.<A HREF="../../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>(<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, ..., <i>x</i><sub><i>n</i>&minus;1</sub>)</nobr>)
 of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in array</CODE></A> of some additional matrix or pair of matrices,
 passed to the methods, by <A HREF="../../../../net/algart/arrays/PArray.html#getDouble(long)"><CODE>PArray.getDouble(long)</CODE></A> method. It is supposed that those matrices
 have the same dimensions as <b>M</b>. For the percentile and the mean between percentiles,
 there are simplified versions of the methods, which use the constant rank indexes instead of matrices of
 indexes.</p>

 <p>Most of methods of this interface allow to return not only floating-point, but also integer result matrix.
 In this case, the real rank characteristics, defined above in the section 4, are rounded by some rules,
 that are specified in comments to the concrete methods.</p>

 <p>For every rank characteristics this interface offers 3 methods for calculating it. Below are some comments
 about them.</p>
 <ul>
 <li>The first version is always called "<tt>as<i>Operation</i></tt>", for example,
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile</CODE></A>.
 This method returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the necessary rank characteristic
 of the source matrix with the specified pattern (aperture shape).
 The result of such method is usually "lazy", that means that this method finishes immediately and all
 actual calculations are performed while getting elements of the returned matrix.
 It is true for all implementations provided by this package.
 However, some implementations may not support lazy execution;
 then the method may be equivalent to the second version described below.
 Note that the sequential access to the lazy result, returned by this method
 (via <A HREF="../../../../net/algart/arrays/Array.html#getData(long, java.lang.Object, int, int)"><CODE>Array.getData</CODE></A> method, called for the
 <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in array</CODE></A> of the returned matrix), usually works much faster
 than the random access to elements of the matrix.</li>

 <li>The second version is called "<tt><i>operation</i></tt>", for example,
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile</CODE></A>.
 This method always returns actual (non-lazy) updatable result:
 <nobr><tt>Matrix&lt;? extends UpdatablePArray&gt;</tt></nobr>.
 This method can work essentially faster than an access to
 the lazy matrix returned by the first variant of the method
 (for example, than copying it into a new matrix).
 In implementations, offered by this package, there are no difference if the source
 matrix <tt>src</tt> (for rank operations, <tt>baseMatrix</tt>) is direct accessible:
 <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A> instanceof <A HREF="../../../../net/algart/arrays/DirectAccessible.html" title="interface in net.algart.arrays"><CODE>DirectAccessible</CODE></A> &&
 ((DirectAccessible)src.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>).<A HREF="../../../../net/algart/arrays/DirectAccessible.html#hasJavaArray()"><CODE>hasJavaArray()</CODE></A></tt>. If the source matrix is not direct accessible,
 the implementations, offered by this package, use <A HREF="../../../../net/algart/matrices/StreamingApertureProcessor.html" title="class in net.algart.matrices"><CODE>StreamingApertureProcessor</CODE></A> technique
 to accelerate processing. Calculating <i>aperture sums</i> is an exception:
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum</CODE></A> method uses some optimization for some kinds of
 patterns and can work much faster than accessing to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfSum</CODE></A>
 result.</li>

 <li>The third version is also called "<tt><i>operation</i></tt>", but it is a void method:
 for example, <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Matrix, Pattern)</CODE></A>.
 The result matrix is passed via first argument named <tt>dest</tt> and supposed to be allocated
 before calling the method. This way allows to save memory and time, if you need to perform several
 rank operation, because you can use the same matrices for temporary results.
 In addition, these methods allow to choose the type of element of the resulting matrix for any
 operation. The precise rules of type conversions are described in comments to concrete methods.
 </li>
 </ul>

 <p>This package provides the following basic methods for creating objects, implementing this interface:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>BasicRankMorphology.getInstance(ArrayContext, double, CustomRankPrecision)</CODE></A>;</li>
 <li><A HREF="../../../../net/algart/matrices/morphology/ContinuedRankMorphology.html#getInstance(net.algart.matrices.morphology.RankMorphology, net.algart.arrays.Matrix.ContinuationMode)"><CODE>ContinuedRankMorphology.getInstance(RankMorphology, Matrix.ContinuationMode)</CODE></A>.</li>
 </ul>

 <p><b>Warning</b>: all implementations of this interface, provided by this package, can process only patterns
 where <nobr><tt><A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A>&le;Integer.MAX_VALUE</tt></nobr>.
 More precisely, any methods of this interface (including methods, inherited from its superinterface
 <A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology"><CODE>Morphology</CODE></A>), implemented by classes of this package, which have <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns"><CODE>Pattern</CODE></A> argument,
 can throw <A HREF="../../../../net/algart/math/patterns/TooManyPointsInPatternError.html" title="class in net.algart.math.patterns"><CODE>TooManyPointsInPatternError</CODE></A>
 or <tt>OutOfMemoryError</tt> in the same situations as <A HREF="../../../../net/algart/math/patterns/Pattern.html#points()"><CODE>Pattern.points()</CODE></A> method.</p>

 <p><b>Warning</b>: the methods of this interface, which save results into the passed <tt>dest</tt>
 matrix (like <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Matrix, Pattern)</CODE></A>),
 as well as any attempts to read the "lazy" results (of the methods
 like <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, Matrix, Pattern)</CODE></A>),
 <b>can be non-atomic regarding the failure</b>, if the arguments of the calculated rank characteristics &mdash;
 the real index <i>r</i> for the percentile, the real value <i>v</i> for the rank,
 the real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> for the mean between percentiles
 or the real values <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> for the mean between values &mdash;
 are floating-point <b>NaN</b> values for some aperture positions. In this case,
 it is possible that the result will be partially filled, and only after this the <b>NaN</b> value will lead to
 <tt>IllegalArgumentException</tt>.</p>

 <p>The floating-point calculations in the implementations of this interface are usually performed
 not in <tt>strictfp</tt>, but in the usual mode.
 So, there is no guarantee that the results are absolutely identical on all platforms.
 Moreover, there is no guarantee that the same results, got by different ways, are absolutely identical:
 little mismatches in the last digits after the decimal point are possible.</p>

 <p>The classes, implementing this interface, are <b>immutable</b> and <b>thread-safe</b>:
 there are no ways to modify settings of the created instance.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Nested Class Summary table, listing nested classes, and an explanation">
<CAPTION CLASS="TableCaption">
Nested Class Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Interface and Description</TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_net.algart.matrices.morphology.Morphology"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Nested classes/interfaces inherited from interface net.algart.matrices.morphology.<A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology">Morphology</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/matrices/morphology/Morphology.SubtractionMode.html" title="enum in net.algart.matrices.morphology">Morphology.SubtractionMode</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MAX_VALUE">FILL_MAX_VALUE</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special value of <tt>filler</tt> argument of methods, calculating <i>mean between 2 values</i>,
 which activates the mode C of calculation:
 if <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
 the mean is considered to be equal <i>v</i><sub>2</sub>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MIN_VALUE">FILL_MIN_VALUE</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special value of <tt>filler</tt> argument of methods, calculating <i>mean between 2 values</i>,
 which activates the mode B of calculation:
 if <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
 the mean is considered to be equal <i>v</i><sub>1</sub>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_NEAREST_VALUE">FILL_NEAREST_VALUE</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special value of <tt>filler</tt> argument of methods, calculating <i>mean between 2 values</i>,
 which activates the mode D of calculation.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">asFunctionOfPercentilePair</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                           double&nbsp;percentileIndex1,
                           double&nbsp;percentileIndex2,
                           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                           <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">asFunctionOfPercentilePair</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes1,
                           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes2,
                           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                           <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">asFunctionOfSum</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the result of some given function
 <nobr><i>f</i>(<i>S</i>)</nobr> of the <i>aperture sum S</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">asMean</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)">asMeanBetweenPercentiles</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                         double&nbsp;fromPercentileIndex,
                         double&nbsp;toPercentileIndex,
                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                         double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)">asMeanBetweenPercentiles</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;fromPercentileIndexes,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;toPercentileIndexes,
                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                         double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)">asMeanBetweenValues</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;minValues,
                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;maxValues,
                    <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                    double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean between 2 values</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)">asPercentile</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
             double&nbsp;percentileIndex,
             <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>percentile</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">asPercentile</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
             <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes,
             <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>percentile</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; 
<BR>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asRank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">asRank</A></STRONG>(java.lang.Class&lt;? extends T&gt;&nbsp;requiredType,
       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;baseMatrix,
       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;rankedMatrix,
       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed <tt>baseMatrix</tt> matrix,
 such that any reading data from it calculates and returns the <i>ranks</i>
 of some given values <i>v</i> regarding the source matrix <tt>baseMatrix</tt> with the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology">RankMorphology</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#context(net.algart.arrays.ArrayContext)">context</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;newContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Switches the context: returns an instance, identical to this one excepting
 that it uses the specified <tt>newContext</tt> for all operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">functionOfPercentilePair</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                         double&nbsp;percentileIndex1,
                         double&nbsp;percentileIndex2,
                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                         <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">functionOfPercentilePair</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes1,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes2,
                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                         <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">functionOfPercentilePair</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                         double&nbsp;percentileIndex1,
                         double&nbsp;percentileIndex2,
                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                         <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">functionOfPercentilePair</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes1,
                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes2,
                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                         <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">functionOfSum</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
              <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
              <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the result of some given function
 <nobr><i>f</i>(<i>S</i>)</nobr> of the <i>aperture sum S</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)">functionOfSum</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
              <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
              <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
              <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum(Matrix, Pattern, Func)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">mean</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
     <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>mean</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">mean</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
     <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Pattern)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)">meanBetweenPercentiles</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                       double&nbsp;fromPercentileIndex,
                       double&nbsp;toPercentileIndex,
                       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                       double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)">meanBetweenPercentiles</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;fromPercentileIndexes,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;toPercentileIndexes,
                       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                       double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)">meanBetweenPercentiles</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                       double&nbsp;fromPercentileIndex,
                       double&nbsp;toPercentileIndex,
                       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                       double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)">meanBetweenPercentiles</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;fromPercentileIndexes,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;toPercentileIndexes,
                       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                       double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)">meanBetweenValues</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;minValues,
                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;maxValues,
                  <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                  double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>mean between 2 values</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)">meanBetweenValues</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;minValues,
                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;maxValues,
                  <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                  double&nbsp;filler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)">percentile</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
           double&nbsp;percentileIndex,
           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>percentile</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">percentile</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes,
           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>percentile</i>
 of the source matrix by the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)">percentile</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
           double&nbsp;percentileIndex,
           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, double, Pattern)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">percentile</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes,
           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; 
<BR>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">rank</A></STRONG>(java.lang.Class&lt;? extends T&gt;&nbsp;requiredType,
     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;baseMatrix,
     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;rankedMatrix,
     <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new updatable matrix, containing the <i>rank</i>
 of some given values <i>v</i> regarding the source matrix <tt>baseMatrix</tt> with the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">rank</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;baseMatrix,
     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;rankedMatrix,
     <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank(Class, Matrix, Matrix, Pattern)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument and the required type will be chosen automatically
 as <nobr><tt>dest.<A HREF="../../../../net/algart/arrays/Matrix.html#type(java.lang.Class)"><CODE>type</CODE></A>(PArray.class)</tt></nobr>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.algart.matrices.morphology.Morphology"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from interface net.algart.matrices.morphology.<A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology">Morphology</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/matrices/morphology/Morphology.html#asDilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">asDilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#asErosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">asErosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#beucherGradient(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">beucherGradient</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#closing(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.matrices.morphology.Morphology.SubtractionMode)">closing</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#dilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">dilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#dilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.matrices.morphology.Morphology.SubtractionMode)">dilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#dilation(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">dilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#dilation(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, boolean)">dilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#dilationErosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.patterns.Pattern, net.algart.matrices.morphology.Morphology.SubtractionMode)">dilationErosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#erosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">erosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#erosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.matrices.morphology.Morphology.SubtractionMode)">erosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#erosion(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">erosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#erosion(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, boolean)">erosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#erosionDilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.patterns.Pattern, net.algart.matrices.morphology.Morphology.SubtractionMode)">erosionDilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#isPseudoCyclic()">isPseudoCyclic</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#maskedDilationErosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.patterns.Pattern)">maskedDilationErosion</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#maskedErosionDilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.patterns.Pattern)">maskedErosionDilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#opening(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.matrices.morphology.Morphology.SubtractionMode)">opening</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#weakDilation(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">weakDilation</A>, <A HREF="../../../../net/algart/matrices/morphology/Morphology.html#weakErosion(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)">weakErosion</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.algart.arrays.ArrayProcessor"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from interface net.algart.arrays.<A HREF="../../../../net/algart/arrays/ArrayProcessor.html" title="interface in net.algart.arrays">ArrayProcessor</A></STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../net/algart/arrays/ArrayProcessor.html#context()">context</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Field Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="FILL_MIN_VALUE"><!-- --></A><H3>
FILL_MIN_VALUE</H3>
<PRE>
static final double <STRONG>FILL_MIN_VALUE</STRONG></PRE>
<DL>
<DD>Special value of <tt>filler</tt> argument of methods, calculating <i>mean between 2 values</i>,
 which activates the mode B of calculation:
 if <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
 the mean is considered to be equal <i>v</i><sub>1</sub>.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 values</i>" term.

 <p>This constant can be used with <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>,
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> and
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A> methods.

 <p>This constant contains <tt>Double.NEGATIVE_INFINITY</tt> value,
 which is usually useless in a role of the ordinary <i>filler</i> for the mode A of calculations.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.morphology.RankMorphology.FILL_MIN_VALUE">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="FILL_MAX_VALUE"><!-- --></A><H3>
FILL_MAX_VALUE</H3>
<PRE>
static final double <STRONG>FILL_MAX_VALUE</STRONG></PRE>
<DL>
<DD>Special value of <tt>filler</tt> argument of methods, calculating <i>mean between 2 values</i>,
 which activates the mode C of calculation:
 if <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
 the mean is considered to be equal <i>v</i><sub>2</sub>.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 values</i>" term.

 <p>This constant can be used with <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>,
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> and
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A> methods.

 <p>This constant contains <tt>Double.POSITIVE_INFINITY</tt> value,
 which is usually useless in a role of the ordinary <i>filler</i> for the mode A of calculations.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.morphology.RankMorphology.FILL_MAX_VALUE">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="FILL_NEAREST_VALUE"><!-- --></A><H3>
FILL_NEAREST_VALUE</H3>
<PRE>
static final double <STRONG>FILL_NEAREST_VALUE</STRONG></PRE>
<DL>
<DD>Special value of <tt>filler</tt> argument of methods, calculating <i>mean between 2 values</i>,
 which activates the mode D of calculation.
 In this case:
 <ol type="I">
 <li>if <i>v</i><sub>1</sub>&ge;<i>v</i><sub>2</sub>, the mean is considered to be equal to
 (<i>v</i><sub>1</sub>+<i>v</i><sub>2</sub>)/2;</li>
 <li>if <i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub> and
 <nobr><i>r</i>(<i>v</i><sub>2</sub>*&sigma;)=<i>r</i>(<i>v</i><sub>1</sub>*&sigma;)=0</nobr>,
 the mean is considered to be equal to <i>v</i><sub>2</sub> (see also
 <nobr><A HREF="../../../../net/algart/arrays/SummingHistogram.CountOfValues.html#isLeftBound()"><CODE>CountOfValues.isLeftBound()</CODE></A></nobr>);</li>
 <li>if <i>v</i><sub>1</sub>&lt;<i>v</i><sub>2</sub> and
 <nobr><i>r</i>(<i>v</i><sub>2</sub>*&sigma;)=<i>r</i>(<i>v</i><sub>1</sub>*&sigma;)=<i>N</i></nobr>,
 the mean is considered to be equal to <i>v</i><sub>1</sub> (see also
 <nobr><A HREF="../../../../net/algart/arrays/SummingHistogram.CountOfValues.html#isRightBound()"><CODE>CountOfValues.isRightBound()</CODE></A></nobr>);</li>
 <li>in other cases,
 if <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)=<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
 the mean is considered to be equal to
 (<i>v</i><sub>1</sub>+<i>v</i><sub>2</sub>)/2.</li>
 </ol>

 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 values</i>" term.

 <p>This constant can be used with <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>,
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> and
 <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A> methods.

 <p>This constant contains <tt>Double.NaN</tt> value, which is usually useless in a role of the ordinary
 <i>filler</i> for the mode A of calculations.

 <p><b>Warning:</b> because this constant is <tt>Double.NaN</tt>, according to rules of Java language,
 you <b>must not compare any numbers with this constant</b>! A check like
 <pre>
 if (x == <tt>RankMorphology.FILL_NEAREST_VALUE</tt>) {
     ...
 }
 </pre>
 always returns <tt>false</tt>. You should use <tt>Double.isNaN(x)</tt> call instead.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.morphology.RankMorphology.FILL_NEAREST_VALUE">Constant Field Values</A></DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="context(net.algart.arrays.ArrayContext)"><!-- --></A><H3>
context</H3>
<PRE>
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology">RankMorphology</A> <STRONG>context</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;newContext)</PRE>
<DL>
<DD><STRONG>Description copied from interface: <CODE><A HREF="../../../../net/algart/arrays/ArrayProcessorWithContextSwitching.html#context(net.algart.arrays.ArrayContext)">ArrayProcessorWithContextSwitching</A></CODE></STRONG></DD>
<DD>Switches the context: returns an instance, identical to this one excepting
 that it uses the specified <tt>newContext</tt> for all operations.
 The returned instance is usually a clone of this one, but there is no guarantees
 that it is a deep clone.
 Usually, the returned instance is used only for performing a
 <A HREF="../../../../net/algart/arrays/ArrayContext.html#part(double, double)"><CODE>subtask</CODE></A> of the full task.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/arrays/ArrayProcessorWithContextSwitching.html#context(net.algart.arrays.ArrayContext)">context</A></CODE> in interface <CODE><A HREF="../../../../net/algart/arrays/ArrayProcessorWithContextSwitching.html" title="interface in net.algart.arrays">ArrayProcessorWithContextSwitching</A></CODE></DD>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/matrices/morphology/Morphology.html#context(net.algart.arrays.ArrayContext)">context</A></CODE> in interface <CODE><A HREF="../../../../net/algart/matrices/morphology/Morphology.html" title="interface in net.algart.matrices.morphology">Morphology</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>newContext</CODE> - another context, used by the returned instance; may be <tt>null</tt>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance with another context.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
asPercentile</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asPercentile</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                      <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes,
                                      <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>percentile</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real index <i>r</i> of the percentile for every element of the result is equal
 to the corresponding element of <tt>percentileIndexes</tt> matrix.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

     <!--Repeat.SectionStart percentile_fixed_point_note-->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real percentile <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 defined in the comments to this class.
 In this case, this method, instead of the real value <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 returns an integer <nobr><i>w</i>/&sigma;</nobr>, where <i>w</i> is:
 <ul>
 <li>either the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iValue(long[], long)"><CODE>Histogram.iValue</CODE></A> (<b>b</b>, <tt>(long)Math.floor</tt>(<i>r</i>))</nobr>,
 if this object works in the simple histogram model
 (where <b>b</b> is the histogram, corresponding to every aperture position),</li>
 <li>or the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iPreciseValue(long[], double)"><CODE>Histogram.iPreciseValue</CODE></A> (<b>b</b>, <i>r</i>)</nobr>,
 if it works in the precise histogram model.</li>
 </ul>
 It is necessary to remind: in a case of fixed-point elements
 there is a guarantee that <nobr>1/&sigma;</nobr> is a positive integer number, and
 <nobr><i>w</i>/&sigma;=<i>w</i>*2<sup>&beta;&minus;&mu;</sup></nobr>,
 <nobr>&beta; = <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PArray.html#bitsPerElement()"><CODE>bitsPerElement()</CODE></A></tt></nobr>,
 &mu; is the binary logarithm of the histogram length <i>M</i> &mdash;
 see the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 3.
 So, if &mu; is chosen less than the precision of this matrix &beta;
 (8 for <tt>byte</tt>, 16 for <tt>short</tt>, etc.), then <nobr>&beta;&minus;&mu;</nobr>
 lowest bits in the result will be always zero.
 For <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>BasicRankMorphology</CODE></A> object, &mu; is chosen while
 <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>instantiating this object</CODE></A>
 as <nobr>min(<tt>bitLevels[bitLevels.length-1]</tt>, &beta;)</nobr>.
     <!--Repeat.SectionEnd percentile_fixed_point_note-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndexes</CODE> - the matrix containing <i>r</i> argument: the indexes of the percentile
                          for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the percentile of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, double, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asPercentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
asPercentile</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asPercentile</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                      double&nbsp;percentileIndex,
                                      <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>percentile</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real index <i>r</i> of the percentile is equal to <tt>percentileIndex</tt> argument for
 all aperture positions. The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile</CODE></A>(src, src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex), pattern)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, percentile_fixed_point_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real percentile <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 defined in the comments to this class.
 In this case, this method, instead of the real value <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 returns an integer <nobr><i>w</i>/&sigma;</nobr>, where <i>w</i> is:
 <ul>
 <li>either the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iValue(long[], long)"><CODE>Histogram.iValue</CODE></A> (<b>b</b>, <tt>(long)Math.floor</tt>(<i>r</i>))</nobr>,
 if this object works in the simple histogram model
 (where <b>b</b> is the histogram, corresponding to every aperture position),</li>
 <li>or the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iPreciseValue(long[], double)"><CODE>Histogram.iPreciseValue</CODE></A> (<b>b</b>, <i>r</i>)</nobr>,
 if it works in the precise histogram model.</li>
 </ul>
 It is necessary to remind: in a case of fixed-point elements
 there is a guarantee that <nobr>1/&sigma;</nobr> is a positive integer number, and
 <nobr><i>w</i>/&sigma;=<i>w</i>*2<sup>&beta;&minus;&mu;</sup></nobr>,
 <nobr>&beta; = <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PArray.html#bitsPerElement()"><CODE>bitsPerElement()</CODE></A></tt></nobr>,
 &mu; is the binary logarithm of the histogram length <i>M</i> &mdash;
 see the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 3.
 So, if &mu; is chosen less than the precision of this matrix &beta;
 (8 for <tt>byte</tt>, 16 for <tt>short</tt>, etc.), then <nobr>&beta;&minus;&mu;</nobr>
 lowest bits in the result will be always zero.
 For <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>BasicRankMorphology</CODE></A> object, &mu; is chosen while
 <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>instantiating this object</CODE></A>
 as <nobr>min(<tt>bitLevels[bitLevels.length-1]</tt>, &beta;)</nobr>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndex</CODE> - <i>r</i> argument of the percentile.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the percentile of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, double, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, double, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
percentile</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>percentile</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                             <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes,
                                             <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>percentile</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real index <i>r</i> of the percentile for every element of the result is equal
 to the corresponding element of <tt>percentileIndexes</tt> matrix.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, percentile_fixed_point_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real percentile <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 defined in the comments to this class.
 In this case, this method, instead of the real value <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 returns an integer <nobr><i>w</i>/&sigma;</nobr>, where <i>w</i> is:
 <ul>
 <li>either the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iValue(long[], long)"><CODE>Histogram.iValue</CODE></A> (<b>b</b>, <tt>(long)Math.floor</tt>(<i>r</i>))</nobr>,
 if this object works in the simple histogram model
 (where <b>b</b> is the histogram, corresponding to every aperture position),</li>
 <li>or the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iPreciseValue(long[], double)"><CODE>Histogram.iPreciseValue</CODE></A> (<b>b</b>, <i>r</i>)</nobr>,
 if it works in the precise histogram model.</li>
 </ul>
 It is necessary to remind: in a case of fixed-point elements
 there is a guarantee that <nobr>1/&sigma;</nobr> is a positive integer number, and
 <nobr><i>w</i>/&sigma;=<i>w</i>*2<sup>&beta;&minus;&mu;</sup></nobr>,
 <nobr>&beta; = <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PArray.html#bitsPerElement()"><CODE>bitsPerElement()</CODE></A></tt></nobr>,
 &mu; is the binary logarithm of the histogram length <i>M</i> &mdash;
 see the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 3.
 So, if &mu; is chosen less than the precision of this matrix &beta;
 (8 for <tt>byte</tt>, 16 for <tt>short</tt>, etc.), then <nobr>&beta;&minus;&mu;</nobr>
 lowest bits in the result will be always zero.
 For <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>BasicRankMorphology</CODE></A> object, &mu; is chosen while
 <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>instantiating this object</CODE></A>
 as <nobr>min(<tt>bitLevels[bitLevels.length-1]</tt>, &beta;)</nobr>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndexes</CODE> - the matrix containing <i>r</i> argument: the indexes of the percentile
                          for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the percentile of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, double, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
percentile</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>percentile</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                             double&nbsp;percentileIndex,
                                             <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>percentile</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real index <i>r</i> of the percentile is equal to <tt>percentileIndex</tt> argument for
 all aperture positions. The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile</CODE></A>(src, src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex), pattern)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, percentile_fixed_point_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real percentile <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 defined in the comments to this class.
 In this case, this method, instead of the real value <nobr><i>v</i>(<i>r</i>)/&sigma;</nobr>,
 returns an integer <nobr><i>w</i>/&sigma;</nobr>, where <i>w</i> is:
 <ul>
 <li>either the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iValue(long[], long)"><CODE>Histogram.iValue</CODE></A> (<b>b</b>, <tt>(long)Math.floor</tt>(<i>r</i>))</nobr>,
 if this object works in the simple histogram model
 (where <b>b</b> is the histogram, corresponding to every aperture position),</li>
 <li>or the integer result of <nobr><A HREF="../../../../net/algart/arrays/Histogram.html#iPreciseValue(long[], double)"><CODE>Histogram.iPreciseValue</CODE></A> (<b>b</b>, <i>r</i>)</nobr>,
 if it works in the precise histogram model.</li>
 </ul>
 It is necessary to remind: in a case of fixed-point elements
 there is a guarantee that <nobr>1/&sigma;</nobr> is a positive integer number, and
 <nobr><i>w</i>/&sigma;=<i>w</i>*2<sup>&beta;&minus;&mu;</sup></nobr>,
 <nobr>&beta; = <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PArray.html#bitsPerElement()"><CODE>bitsPerElement()</CODE></A></tt></nobr>,
 &mu; is the binary logarithm of the histogram length <i>M</i> &mdash;
 see the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 3.
 So, if &mu; is chosen less than the precision of this matrix &beta;
 (8 for <tt>byte</tt>, 16 for <tt>short</tt>, etc.), then <nobr>&beta;&minus;&mu;</nobr>
 lowest bits in the result will be always zero.
 For <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html" title="class in net.algart.matrices.morphology"><CODE>BasicRankMorphology</CODE></A> object, &mu; is chosen while
 <A HREF="../../../../net/algart/matrices/morphology/BasicRankMorphology.html#getInstance(net.algart.arrays.ArrayContext, double, net.algart.matrices.morphology.CustomRankPrecision)"><CODE>instantiating this object</CODE></A>
 as <nobr>min(<tt>bitLevels[bitLevels.length-1]</tt>, &beta;)</nobr>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndex</CODE> - <i>r</i> argument of the percentile.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the percentile of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, double, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, double, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
percentile</H3>
<PRE>
void <STRONG>percentile</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes,
                <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument.

 <p>If the <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A> of the passed <tt>dest</tt> matrix
 is the same as the element type of the source one, the result, saved in <tt>dest</tt>, will be identically
 equal to the result of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A> method with the same
 <tt>src</tt>, <tt>percentileIndexes</tt> and <tt>pattern</tt> arguments. In other case,
 the result, saved in <tt>dest</tt>, will be equal to

 <pre><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix</CODE></A>(true, <A HREF="../../../../net/algart/math/functions/Func.html#IDENTITY"><CODE>Func.IDENTITY</CODE></A>,
 &#32;   dest.array().<A HREF="../../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A>, <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile</CODE></A>(src, percentileIndexes, pattern))</pre>

 <p>So, even if the precision of <tt>dest</tt> matrix is better than the precision of <tt>src</tt> &mdash;
 for example, if <nobr><tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr> is <tt>byte</tt>, but
 <nobr><tt>dest.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr> is <tt>double</tt> &mdash;
 this method does not try to calculate more precise percentile and rounds results like
 <nobr><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, Matrix, Pattern)</CODE></A></nobr> and
 <nobr><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A></nobr> methods.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndexes</CODE> - the matrix containing <i>r</i> argument: the indexes of the percentile
                          for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, double, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
percentile</H3>
<PRE>
void <STRONG>percentile</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                double&nbsp;percentileIndex,
                <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, double, Pattern)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile</CODE></A>(dest, src, src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex), pattern)</pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndex</CODE> - <i>r</i> argument of the percentile.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix, double, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix, double, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asRank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
asRank</H3>
<PRE>
&lt;T extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;T&gt; <STRONG>asRank</STRONG>(java.lang.Class&lt;? extends T&gt;&nbsp;requiredType,
                                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;baseMatrix,
                                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;rankedMatrix,
                                    <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns an immutable view of the passed <tt>baseMatrix</tt> matrix,
 such that any reading data from it calculates and returns the <i>ranks</i>
 of some given values <i>v</i> regarding the source matrix <tt>baseMatrix</tt> with the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>rank</i>" term.
 The real value <i>v</i> for every element of the result is equal
 to the corresponding element of <tt>rankedMatrix</tt> matrix.

 <p>The matrix, returned by this method, is immutable, and the class of its built-in array
 implements one of the basic interfaces
 <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>, <A HREF="../../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>, <A HREF="../../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>, <A HREF="../../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A> or <A HREF="../../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>.
 The class of desired interface (one of 8 possible classes) must be passed as <tt>requiredType</tt> argument.
 So, it defines the element type of the returned matrix.
 The rules of casting the floating-point ranks to the desired element type are the same as in
 <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.

     <!--Repeat.SectionStart rank_casting_note-->
 <p>The element types of <tt>baseMatrix</tt> and <tt>rankedMatrix</tt> are usually equal.
 If they are different (<nobr><tt>baseMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A>!=rankedMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>),
 this method replaces <tt>rankedMatrix</tt> with

 <pre><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix</CODE></A>(true, <A HREF="../../../../net/algart/math/functions/Func.html#IDENTITY"><CODE>Func.IDENTITY</CODE></A>, baseMatrix.array().<A HREF="../../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A>, rankedMatrix)</pre>

 <p>before all other calculations. In other words, this method always casts the type of
 the ranked elements to the type of <tt>baseMatrix</tt> elements.
 As a result, we can be sure, that if the source <tt>baseMatrix</tt> matrix is fixed-point
 (<tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> elements),
 then the rank <nobr><i>r</i>(<i>v</i>*&sigma;)</nobr>, according to the definition of the "rank" term,
 will be an integer number. In this case, you can specify <tt>requiredType=IntArray.class</tt> and
 get the precise rank without precision loss. Moreover, if you know that the number of points in the pattern
 (<nobr><tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>) is less than
 <nobr>2<sup>16</sup>=65536</nobr> or <nobr>2<sup>8</sup>=256</nobr>, it is enough to specify correspondingly
 <tt>requiredType=ShortArray.class</tt> or <tt>ByteArray.class</tt>.
     <!--Repeat.SectionEnd rank_casting_note-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>requiredType</CODE> - the desired type of the built-in array in the returned matrix.</DD><DD><CODE>baseMatrix</CODE> - the source matrix.</DD><DD><CODE>rankedMatrix</CODE> - the matrix containing <i>v</i> argument: the values,
                     the rank of which should be calculated.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the rank of the given values.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>baseMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>,
                                  or if <tt>requiredType</tt> is not one of classes
                                  <tt><A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>.class</tt>, <tt><A HREF="../../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>.class</tt>, <tt><A HREF="../../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>.class</tt>, <tt><A HREF="../../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>.class</tt> or <tt><A HREF="../../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>.class</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank(Class, Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank(Matrix, Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
rank</H3>
<PRE>
&lt;T extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends T&gt; <STRONG>rank</STRONG>(java.lang.Class&lt;? extends T&gt;&nbsp;requiredType,
                                            <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;baseMatrix,
                                            <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;rankedMatrix,
                                            <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>rank</i>
 of some given values <i>v</i> regarding the source matrix <tt>baseMatrix</tt> with the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>rank</i>" term.
 The real value <i>v</i> for every element of the result is equal
 to the corresponding element of <tt>rankedMatrix</tt> matrix.

 <p>The matrix, returned by this method, is updatable, and the class of its built-in array
 implements one of the basic interfaces
 <A HREF="../../../../net/algart/arrays/UpdatableBitArray.html" title="interface in net.algart.arrays"><CODE>UpdatableBitArray</CODE></A>, <A HREF="../../../../net/algart/arrays/UpdatableCharArray.html" title="interface in net.algart.arrays"><CODE>UpdatableCharArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/UpdatableByteArray.html" title="interface in net.algart.arrays"><CODE>UpdatableByteArray</CODE></A>, <A HREF="../../../../net/algart/arrays/UpdatableShortArray.html" title="interface in net.algart.arrays"><CODE>UpdatableShortArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/UpdatableIntArray.html" title="interface in net.algart.arrays"><CODE>UpdatableIntArray</CODE></A>, <A HREF="../../../../net/algart/arrays/UpdatableLongArray.html" title="interface in net.algart.arrays"><CODE>UpdatableLongArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/UpdatableFloatArray.html" title="interface in net.algart.arrays"><CODE>UpdatableFloatArray</CODE></A> or <A HREF="../../../../net/algart/arrays/UpdatableDoubleArray.html" title="interface in net.algart.arrays"><CODE>UpdatableDoubleArray</CODE></A>.
 The class of desired interface (one of 8 possible classes) must be passed as <tt>requiredType</tt> argument.
 So, it defines the element type of the returned matrix.
 Instead of these classes, you can also pass one of corresponding immutable interfaces
 <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>, <A HREF="../../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>, <A HREF="../../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>, <A HREF="../../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>,
 <A HREF="../../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A> or <A HREF="../../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>:
 the result will be the same.
 The rules of casting the floating-point ranks to the desired element type are the same as in
 <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, rank_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>The element types of <tt>baseMatrix</tt> and <tt>rankedMatrix</tt> are usually equal.
 If they are different (<nobr><tt>baseMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A>!=rankedMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>),
 this method replaces <tt>rankedMatrix</tt> with

 <pre><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix</CODE></A>(true, <A HREF="../../../../net/algart/math/functions/Func.html#IDENTITY"><CODE>Func.IDENTITY</CODE></A>, baseMatrix.array().<A HREF="../../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A>, rankedMatrix)</pre>

 <p>before all other calculations. In other words, this method always casts the type of
 the ranked elements to the type of <tt>baseMatrix</tt> elements.
 As a result, we can be sure, that if the source <tt>baseMatrix</tt> matrix is fixed-point
 (<tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> elements),
 then the rank <nobr><i>r</i>(<i>v</i>*&sigma;)</nobr>, according to the definition of the "rank" term,
 will be an integer number. In this case, you can specify <tt>requiredType=IntArray.class</tt> and
 get the precise rank without precision loss. Moreover, if you know that the number of points in the pattern
 (<nobr><tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>) is less than
 <nobr>2<sup>16</sup>=65536</nobr> or <nobr>2<sup>8</sup>=256</nobr>, it is enough to specify correspondingly
 <tt>requiredType=ShortArray.class</tt> or <tt>ByteArray.class</tt>.
     <!--Repeat.IncludeEnd-->
 The less result precision allows you to save memory.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>requiredType</CODE> - the desired type of the built-in array in the returned matrix.</DD><DD><CODE>baseMatrix</CODE> - the source matrix.</DD><DD><CODE>rankedMatrix</CODE> - the matrix containing <i>v</i> argument: the values,
                     the rank of which should be calculated.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the rank of the given values.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>baseMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>,
                                  or if <tt>requiredType</tt> is not one of classes
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableBitArray.html" title="interface in net.algart.arrays"><CODE>UpdatableBitArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays"><CODE>BitArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableCharArray.html" title="interface in net.algart.arrays"><CODE>UpdatableCharArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/CharArray.html" title="interface in net.algart.arrays"><CODE>CharArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableByteArray.html" title="interface in net.algart.arrays"><CODE>UpdatableByteArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/ByteArray.html" title="interface in net.algart.arrays"><CODE>ByteArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableShortArray.html" title="interface in net.algart.arrays"><CODE>UpdatableShortArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/ShortArray.html" title="interface in net.algart.arrays"><CODE>ShortArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableIntArray.html" title="interface in net.algart.arrays"><CODE>UpdatableIntArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/IntArray.html" title="interface in net.algart.arrays"><CODE>IntArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableLongArray.html" title="interface in net.algart.arrays"><CODE>UpdatableLongArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/LongArray.html" title="interface in net.algart.arrays"><CODE>LongArray</CODE></A>.class</tt>,
                                  <tt><A HREF="../../../../net/algart/arrays/UpdatableFloatArray.html" title="interface in net.algart.arrays"><CODE>UpdatableFloatArray</CODE></A>.class</tt> / <tt><A HREF="../../../../net/algart/arrays/FloatArray.html" title="interface in net.algart.arrays"><CODE>FloatArray</CODE></A>.class</tt>
                                  or <tt><A HREF="../../../../net/algart/arrays/UpdatableDoubleArray.html" title="interface in net.algart.arrays"><CODE>UpdatableDoubleArray</CODE></A>.class</tt> /
                                  <tt><A HREF="../../../../net/algart/arrays/DoubleArray.html" title="interface in net.algart.arrays"><CODE>DoubleArray</CODE></A>.class</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asRank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asRank(Class, Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank(Matrix, Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="rank(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
rank</H3>
<PRE>
void <STRONG>rank</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
          <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;baseMatrix,
          <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;rankedMatrix,
          <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank(Class, Matrix, Matrix, Pattern)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument and the required type will be chosen automatically
 as <nobr><tt>dest.<A HREF="../../../../net/algart/arrays/Matrix.html#type(java.lang.Class)"><CODE>type</CODE></A>(PArray.class)</tt></nobr>.
 More precisely, the result, saved in <tt>dest</tt>, will be equal to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank</CODE></A>(dest.array().<A HREF="../../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A>, baseMatrix, rankedMatrix, pattern)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, rank_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>The element types of <tt>baseMatrix</tt> and <tt>rankedMatrix</tt> are usually equal.
 If they are different (<nobr><tt>baseMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A>!=rankedMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>),
 this method replaces <tt>rankedMatrix</tt> with

 <pre><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix</CODE></A>(true, <A HREF="../../../../net/algart/math/functions/Func.html#IDENTITY"><CODE>Func.IDENTITY</CODE></A>, baseMatrix.array().<A HREF="../../../../net/algart/arrays/Array.html#type()"><CODE>type()</CODE></A>, rankedMatrix)</pre>

 <p>before all other calculations. In other words, this method always casts the type of
 the ranked elements to the type of <tt>baseMatrix</tt> elements.
 As a result, we can be sure, that if the source <tt>baseMatrix</tt> matrix is fixed-point
 (<tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> elements),
 then the rank <nobr><i>r</i>(<i>v</i>*&sigma;)</nobr>, according to the definition of the "rank" term,
 will be an integer number. In this case, you can specify <tt>requiredType=IntArray.class</tt> and
 get the precise rank without precision loss. Moreover, if you know that the number of points in the pattern
 (<nobr><tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>) is less than
 <nobr>2<sup>16</sup>=65536</nobr> or <nobr>2<sup>8</sup>=256</nobr>, it is enough to specify correspondingly
 <tt>requiredType=ShortArray.class</tt> or <tt>ByteArray.class</tt>.
     <!--Repeat.IncludeEnd-->
 The less result precision allows you to save memory.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>baseMatrix</CODE> - the source matrix.</DD><DD><CODE>rankedMatrix</CODE> - the matrix containing <i>v</i> argument: the values,
                     the rank of which should be calculated.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>baseMatrix.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asRank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asRank(Class, Matrix, Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#rank(java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>rank(Class, Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asMeanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
asMeanBetweenPercentiles</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asMeanBetweenPercentiles</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;fromPercentileIndexes,
                                                  <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;toPercentileIndexes,
                                                  <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                  double&nbsp;filler)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 percentiles</i>" term.
 The real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> of the percentiles
 for every element of the result are equal to the corresponding elements of
 <tt>fromPercentileIndexes</tt> and <tt>toPercentileIndexes</tt> matrices.
 The reserved value <i>filler</i> is specified by the last argument of this method.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

     <!--Repeat.SectionStart mean_casting_note-->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.SectionEnd mean_casting_note-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>fromPercentileIndexes</CODE> - the matrix containing <i>r</i><sub>1</sub> argument: the indexes of
                              the less percentile of the averaged range for every element of the result.</DD><DD><CODE>toPercentileIndexes</CODE> - the matrix containing <i>r</i><sub>2</sub> argument: the indexes of
                              the greater percentile of the averaged range for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                              <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the mean between 2 given percentiles
                              of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asMeanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
asMeanBetweenPercentiles</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asMeanBetweenPercentiles</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                  double&nbsp;fromPercentileIndex,
                                                  double&nbsp;toPercentileIndex,
                                                  <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                  double&nbsp;filler)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 percentiles</i>" term.
 The real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> of the percentiles
 for every element of the result are equal to <tt>fromPercentileIndex</tt>
 and <tt>toPercentileIndex</tt> arguments for all aperture positions.
 The reserved value <i>filler</i> is specified by the last argument of this method.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles</CODE></A>(src,
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), fromPercentileIndex),
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), toPercentileIndex),
 &#32;   pattern, filler)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>fromPercentileIndex</CODE> - <i>r</i><sub>1</sub> argument: the index of
                            the less percentile of the averaged range for every element of the result.</DD><DD><CODE>toPercentileIndex</CODE> - <i>r</i><sub>2</sub> argument: the indexes of
                            the greater percentile of the averaged range for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                            <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the mean between 2 given percentiles
                            of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, double, double, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
meanBetweenPercentiles</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>meanBetweenPercentiles</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;fromPercentileIndexes,
                                                         <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;toPercentileIndexes,
                                                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                         double&nbsp;filler)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 percentiles</i>" term.
 The real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> of the percentiles
 for every element of the result are equal to the corresponding elements of
 <tt>fromPercentileIndexes</tt> and <tt>toPercentileIndexes</tt> matrices.
 The reserved value <i>filler</i> is specified by the last argument of this method.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

     <!--Repeat.SectionStart mean_casting_note-->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.SectionEnd mean_casting_note-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>fromPercentileIndexes</CODE> - the matrix containing <i>r</i><sub>1</sub> argument: the indexes of
                              the less percentile of the averaged range for every element of the result.</DD><DD><CODE>toPercentileIndexes</CODE> - the matrix containing <i>r</i><sub>2</sub> argument: the indexes of
                              the greater percentile of the averaged range for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                              <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the mean between 2 given percentiles of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
meanBetweenPercentiles</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>meanBetweenPercentiles</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                         double&nbsp;fromPercentileIndex,
                                                         double&nbsp;toPercentileIndex,
                                                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                         double&nbsp;filler)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>mean between 2 percentiles</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 percentiles</i>" term.
 The real indexes <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> of the percentiles
 for every element of the result are equal to <tt>fromPercentileIndex</tt>
 and <tt>toPercentileIndex</tt> arguments for all aperture positions.
 The reserved value <i>filler</i> is specified by the last argument of this method.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles</CODE></A>(src,
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), fromPercentileIndex),
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), toPercentileIndex),
 &#32;   pattern, filler)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>fromPercentileIndex</CODE> - <i>r</i><sub>1</sub> argument: the index of
                            the less percentile of the averaged range for every element of the result.</DD><DD><CODE>toPercentileIndex</CODE> - <i>r</i><sub>2</sub> argument: the indexes of
                            the greater percentile of the averaged range for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                            <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the mean between 2 given percentiles of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, double, double, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
meanBetweenPercentiles</H3>
<PRE>
void <STRONG>meanBetweenPercentiles</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                            <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                            <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;fromPercentileIndexes,
                            <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;toPercentileIndexes,
                            <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                            double&nbsp;filler)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>fromPercentileIndexes</CODE> - the matrix containing <i>r</i><sub>1</sub> argument: the indexes of
                              the less percentile of the averaged range for every element of the result.</DD><DD><CODE>toPercentileIndexes</CODE> - the matrix containing <i>r</i><sub>2</sub> argument: the indexes of
                              the greater percentile of the averaged range for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                              <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, double, double, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
meanBetweenPercentiles</H3>
<PRE>
void <STRONG>meanBetweenPercentiles</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                            <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                            double&nbsp;fromPercentileIndex,
                            double&nbsp;toPercentileIndex,
                            <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                            double&nbsp;filler)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>fromPercentileIndex</CODE> - <i>r</i><sub>1</sub> argument: the index of
                            the less percentile of the averaged range for every element of the result.</DD><DD><CODE>toPercentileIndex</CODE> - <i>r</i><sub>2</sub> argument: the indexes of
                            the greater percentile of the averaged range for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                            <nobr><i>r</i><sub>1</sub>&ge;<i>r</i><sub>2</sub></nobr>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles(Matrix, double, double, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
asMeanBetweenValues</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asMeanBetweenValues</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                             <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;minValues,
                                             <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;maxValues,
                                             <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                             double&nbsp;filler)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean between 2 values</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 values</i>" term.
 The real numbers <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub>
 for every element of the result are equal to the corresponding elements of
 <tt>minValues</tt> and <tt>maxValues</tt> matrices.
 The reserved value <i>filler</i> and the <i>mode of calculation</i> (for the case
 <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>)
 are specified by the last <tt>filler</tt> argument of this method:
 <ul>
 <li>if <tt>filler</tt> argument is <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MIN_VALUE"><CODE>FILL_MIN_VALUE</CODE></A> (<tt>Double.NEGATIVE_INFINITY</tt>),
 the mode B is used;</li>
 <li>if <tt>filler</tt> argument is <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MAX_VALUE"><CODE>FILL_MAX_VALUE</CODE></A> (<tt>Double.POSITIVE_INFINITY</tt>),
 the mode C is used;</li>
 <li>if <tt>filler</tt> argument is <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_NEAREST_VALUE"><CODE>FILL_NEAREST_VALUE</CODE></A> (<tt>Double.NaN</tt>),
 the mode D is used;</li>
 <li>if <tt>filler</tt> argument contains any other value, the mode A is used and this argument specifies
 the reserved value <i>filler</i>.</li>
 </ul>
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>minValues</CODE> - the matrix containing <i>v</i><sub>1</sub> argument: the low bound
                  of the averaged range of values for every element of the result.</DD><DD><CODE>maxValues</CODE> - the matrix containing <i>v</i><sub>2</sub> argument: the high bound
                  of the averaged range of values for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                  <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
                  or one of the special keys <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MIN_VALUE"><CODE>FILL_MIN_VALUE</CODE></A>, <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MAX_VALUE"><CODE>FILL_MAX_VALUE</CODE></A>,
                  <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_NEAREST_VALUE"><CODE>FILL_NEAREST_VALUE</CODE></A>, which mean using of special calculation modes B, C, D.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the mean between 2 given values of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
meanBetweenValues</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>meanBetweenValues</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;minValues,
                                                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;maxValues,
                                                    <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                    double&nbsp;filler)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>mean between 2 values</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>mean between 2 values</i>" term.
 The real numbers <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub>
 for every element of the result are equal to the corresponding elements of
 <tt>minValues</tt> and <tt>maxValues</tt> matrices.
 The reserved value <i>filler</i> and the <i>mode of calculation</i> (for the case
 <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>)
 are specified by the last <tt>filler</tt> argument of this method:
 <ul>
 <li>if <tt>filler</tt> argument is <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MIN_VALUE"><CODE>FILL_MIN_VALUE</CODE></A> (<tt>Double.NEGATIVE_INFINITY</tt>),
 the mode B is used;</li>
 <li>if <tt>filler</tt> argument is <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MAX_VALUE"><CODE>FILL_MAX_VALUE</CODE></A> (<tt>Double.POSITIVE_INFINITY</tt>),
 the mode C is used;</li>
 <li>if <tt>filler</tt> argument is <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_NEAREST_VALUE"><CODE>FILL_NEAREST_VALUE</CODE></A> (<tt>Double.NaN</tt>),
 the mode D is used;</li>
 <li>if <tt>filler</tt> argument contains any other value, the mode A is used and this argument specifies
 the reserved value <i>filler</i>.</li>
 </ul>
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>minValues</CODE> - the matrix containing <i>v</i><sub>1</sub> argument: the low bound
                  of the averaged range of values for every element of the result.</DD><DD><CODE>maxValues</CODE> - the matrix containing <i>v</i><sub>2</sub> argument: the high bound
                  of the averaged range of values for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                  <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
                  or one of the special keys <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MIN_VALUE"><CODE>FILL_MIN_VALUE</CODE></A>, <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MAX_VALUE"><CODE>FILL_MAX_VALUE</CODE></A>,
                  <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_NEAREST_VALUE"><CODE>FILL_NEAREST_VALUE</CODE></A>, which mean using of special calculation modes B, C, D.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the mean between 2 given values of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Matrix, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><!-- --></A><H3>
meanBetweenValues</H3>
<PRE>
void <STRONG>meanBetweenValues</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;minValues,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;maxValues,
                       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                       double&nbsp;filler)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A> method, but the result matrix
 will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined in the comments to this class.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>minValues</CODE> - the matrix containing <i>v</i><sub>1</sub> argument: the low bound
                  of the averaged range of values for every element of the result.</DD><DD><CODE>maxValues</CODE> - the matrix containing <i>v</i><sub>2</sub> argument: the high bound
                  of the averaged range of values for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>filler</CODE> - the reserved value, returned when
                  <nobr><i>r</i>(<i>v</i><sub>1</sub>*&sigma;)&ge;<i>r</i>(<i>v</i><sub>2</sub>*&sigma;)</nobr>,
                  or one of the special keys <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MIN_VALUE"><CODE>FILL_MIN_VALUE</CODE></A>, <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_MAX_VALUE"><CODE>FILL_MAX_VALUE</CODE></A>,
                  <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#FILL_NEAREST_VALUE"><CODE>FILL_NEAREST_VALUE</CODE></A>, which mean using of special calculation modes B, C, D.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenValues(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenValues(Matrix, Matrix, Matrix, Pattern, double)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asMean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
asMean</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asMean</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the <i>mean</i>
 of the source matrix by the specified pattern.

 <p>More precisely, this method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfSum</CODE></A>(src, pattern, meanFunc)</tt></nobr>,
 where the function <tt>meanFunc</tt> is:
 <ul>
 <li><tt><A HREF="../../../../net/algart/math/functions/LinearFunc.html#getInstance(double, double...)"><CODE>LinearFunc.getInstance</CODE></A>(0.0, 1.0/<i>N</i>)</tt>,
 <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the source matrix is floating-point (<nobr><tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>
 is <tt>float</tt> or <tt>double</tt>) &mdash;
 in other words, this method calculates the usual mean of all elements in the aperture:
 <nobr>(<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) /
 <i>N</i></nobr>;</li>

 <li><tt><A HREF="../../../../net/algart/math/functions/LinearFunc.html#getInstance(double, double...)"><CODE>LinearFunc.getInstance</CODE></A>(0.5, 1.0/<i>N</i>)</tt>,
 <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the source matrix is fixed-point (<nobr><tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>
 is <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt>) &mdash;
 in other words, this method calculates the mean of all elements in the aperture plus 0.5:
 <nobr>(<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) /
 <i>N</i></nobr> + 0.5.</li>
 </ul>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)
         in\s+the\s+comments\s+to\s+this\s+class ==> above  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined above.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

     <!--Repeat.SectionStart usual_mean_notes-->
 <p>The described rounding rule explains, why we add 0.5 to the mean in the case of a fixed-point source
 elements. Namely, in this case the combination of adding 0.5 and further truncation to the integer part
 works as rounding to the nearest integer:
 <nobr>&lfloor;<i>m</i>+0.5&rfloor;=<tt>Math.round(</tt><i>m</i><tt>)</tt></nobr>
 (excepting some rare cases when the real mean <i>m</i> is a strictly half-integer:
 <nobr><i>m</i>=2<i>k</i>+&frac12;</nobr>, <i>k</i>&isin;<b>Z</b>). In other words,
 this behaviour provides the maximal possible precision of the returned integer mean.

 <p>Note: the behaviour of this method is similar to
 <tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMeanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>asMeanBetweenPercentiles</CODE></A>(src, 0, <i>N</i>, pattern, <i>anyFiller</i>)</tt>,
 where <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the histogram is processed in the simple histogram model (see
 <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>comments to SummingHistogram class</CODE></A>).
 Really, in this case the mean between 2 percentiles is equal to

 <blockquote>(<i>S</i>(<i>r</i><sub>2</sub>)&minus;<i>S</i>(<i>r</i><sub>1</sub>)) /
     ((<i>r</i><sub>2</sub>&minus;<i>r</i><sub>1</sub>)*&sigma;) = <i>S</i>(<i>N</i>) / (<i>N</i>*&sigma;) =
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>j</i>&lt;<i>M</i></sub>(<i>j</i>+0.5)*<b>b</b>[<i>j</i>])
     / (<i>N</i>*&sigma;)
 </blockquote>

 <p>In the simplest case, when the source elements are real numbers in the "standard" allowed range
 <nobr><tt>0.0..1.0</tt></nobr>,
 we have <nobr>&sigma; = <i>M</i></nobr> (the histogram length),
 <nobr><i>a<sub>i</sub></i> = &lfloor;<i>v<sub>i</sub></i>*<i>M</i>&rfloor;</nobr>,
 and this expression is equal to

 <blockquote>
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>i</i>&lt;<i>N</i></sub>(<i>a<sub>i</sub></i>+0.5)) / (<i>NM</i>) =
     (<i>v'</i><sub>0</sub>+<i>v'</i><sub>1</sub>+...+<i>v'</i><sub><i>N</i>&minus;1</sub>) / <i>N</i>
     + 0.5 / <i>M</i> &asymp;
     (<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) / <i>N</i>
 </blockquote>

 <p>where <nobr><i>v'<sub>i</sub></i> = <i>a<sub>i</sub></i>/<i>M</i></nobr> is an attempt
 to represent the real number <i>v<sub>i</sub></i> with the given precision &mu;=log<sub>2</sub><i>M</i> bits
 and a correction <nobr>0.5/<i>M</i></nobr> is very little for large <i>M</i>.

 <p>In another simplest case, when the source elements are integer numbers, &sigma;=1 and
 the elements <i>v<sub>i</sub></i> are non-negative integers,
 we have <nobr><i>a<sub>i</sub></i> = <i>v<sub>i</sub></i></nobr>, and this expression is equal to

 <blockquote>
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>i</i>&lt;<i>N</i></sub>(<i>v<sub>i</sub></i>+0.5)) / <i>N</i> =
     (<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) / <i>N</i> + 0.5
 </blockquote>
     <!--Repeat.SectionEnd usual_mean_notes-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the mean of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
mean</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>mean</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                       <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the <i>mean</i>
 of the source matrix by the specified pattern.

 <p>More precisely, this method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum</CODE></A>(src, pattern, meanFunc)</tt></nobr>,
 where the function <tt>meanFunc</tt> is:
 <ul>
 <li><tt><A HREF="../../../../net/algart/math/functions/LinearFunc.html#getInstance(double, double...)"><CODE>LinearFunc.getInstance</CODE></A>(0.0, 1.0/<i>N</i>)</tt>,
 <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the source matrix is floating-point (<nobr><tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>
 is <tt>float</tt> or <tt>double</tt>) &mdash;
 in other words, this method calculates the usual mean of all elements in the aperture:
 <nobr>(<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) /
 <i>N</i></nobr>;</li>

 <li><tt><A HREF="../../../../net/algart/math/functions/LinearFunc.html#getInstance(double, double...)"><CODE>LinearFunc.getInstance</CODE></A>(0.5, 1.0/<i>N</i>)</tt>,
 <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the source matrix is fixed-point (<nobr><tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>elementType()</CODE></A></tt></nobr>
 is <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt>) &mdash;
 in other words, this method calculates the mean of all elements in the aperture plus 0.5:
 <nobr>(<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) /
 <i>N</i></nobr> + 0.5.</li>
 </ul>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)
         in\s+the\s+comments\s+to\s+this\s+class ==> above  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined above.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, usual_mean_notes)
         asMeanBetweenPercentiles ==> meanBetweenPercentiles  !! Auto-generated: NOT EDIT !! -->
 <p>The described rounding rule explains, why we add 0.5 to the mean in the case of a fixed-point source
 elements. Namely, in this case the combination of adding 0.5 and further truncation to the integer part
 works as rounding to the nearest integer:
 <nobr>&lfloor;<i>m</i>+0.5&rfloor;=<tt>Math.round(</tt><i>m</i><tt>)</tt></nobr>
 (excepting some rare cases when the real mean <i>m</i> is a strictly half-integer:
 <nobr><i>m</i>=2<i>k</i>+&frac12;</nobr>, <i>k</i>&isin;<b>Z</b>). In other words,
 this behaviour provides the maximal possible precision of the returned integer mean.

 <p>Note: the behaviour of this method is similar to
 <tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles</CODE></A>(src, 0, <i>N</i>, pattern, <i>anyFiller</i>)</tt>,
 where <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the histogram is processed in the simple histogram model (see
 <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>comments to SummingHistogram class</CODE></A>).
 Really, in this case the mean between 2 percentiles is equal to

 <blockquote>(<i>S</i>(<i>r</i><sub>2</sub>)&minus;<i>S</i>(<i>r</i><sub>1</sub>)) /
     ((<i>r</i><sub>2</sub>&minus;<i>r</i><sub>1</sub>)*&sigma;) = <i>S</i>(<i>N</i>) / (<i>N</i>*&sigma;) =
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>j</i>&lt;<i>M</i></sub>(<i>j</i>+0.5)*<b>b</b>[<i>j</i>])
     / (<i>N</i>*&sigma;)
 </blockquote>

 <p>In the simplest case, when the source elements are real numbers in the "standard" allowed range
 <nobr><tt>0.0..1.0</tt></nobr>,
 we have <nobr>&sigma; = <i>M</i></nobr> (the histogram length),
 <nobr><i>a<sub>i</sub></i> = &lfloor;<i>v<sub>i</sub></i>*<i>M</i>&rfloor;</nobr>,
 and this expression is equal to

 <blockquote>
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>i</i>&lt;<i>N</i></sub>(<i>a<sub>i</sub></i>+0.5)) / (<i>NM</i>) =
     (<i>v'</i><sub>0</sub>+<i>v'</i><sub>1</sub>+...+<i>v'</i><sub><i>N</i>&minus;1</sub>) / <i>N</i>
     + 0.5 / <i>M</i> &asymp;
     (<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) / <i>N</i>
 </blockquote>

 <p>where <nobr><i>v'<sub>i</sub></i> = <i>a<sub>i</sub></i>/<i>M</i></nobr> is an attempt
 to represent the real number <i>v<sub>i</sub></i> with the given precision &mu;=log<sub>2</sub><i>M</i> bits
 and a correction <nobr>0.5/<i>M</i></nobr> is very little for large <i>M</i>.

 <p>In another simplest case, when the source elements are integer numbers, &sigma;=1 and
 the elements <i>v<sub>i</sub></i> are non-negative integers,
 we have <nobr><i>a<sub>i</sub></i> = <i>v<sub>i</sub></i></nobr>, and this expression is equal to

 <blockquote>
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>i</i>&lt;<i>N</i></sub>(<i>v<sub>i</sub></i>+0.5)) / <i>N</i> =
     (<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) / <i>N</i> + 0.5
 </blockquote>
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the mean of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asMean(Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="mean(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><!-- --></A><H3>
mean</H3>
<PRE>
void <STRONG>mean</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
          <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
          <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Pattern)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, mean_casting_note)
         in\s+the\s+comments\s+to\s+this\s+class ==> above ;;
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real mean, defined above.
 In this case, the found mean value <i>m</i> is usually truncated to its integer part
 <nobr>&lfloor;<i>m</i>&rfloor;=<tt>(long)</tt><i>m</i></nobr>
 (remember that the mean value, according to our definition, is always &ge;0).
 More precisely, the rules of casting the floating-point means to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, usual_mean_notes)
         asMeanBetweenPercentiles\(Matrix ==> meanBetweenPercentiles(Matrix, Matrix ;;
         asMeanBetweenPercentiles ==> meanBetweenPercentiles  !! Auto-generated: NOT EDIT !! -->
 <p>The described rounding rule explains, why we add 0.5 to the mean in the case of a fixed-point source
 elements. Namely, in this case the combination of adding 0.5 and further truncation to the integer part
 works as rounding to the nearest integer:
 <nobr>&lfloor;<i>m</i>+0.5&rfloor;=<tt>Math.round(</tt><i>m</i><tt>)</tt></nobr>
 (excepting some rare cases when the real mean <i>m</i> is a strictly half-integer:
 <nobr><i>m</i>=2<i>k</i>+&frac12;</nobr>, <i>k</i>&isin;<b>Z</b>). In other words,
 this behaviour provides the maximal possible precision of the returned integer mean.

 <p>Note: the behaviour of this method is similar to
 <tt><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#meanBetweenPercentiles(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, double)"><CODE>meanBetweenPercentiles</CODE></A>(src, 0, <i>N</i>, pattern, <i>anyFiller</i>)</tt>,
 where <nobr><tt><i>N</i> = pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#pointCount()"><CODE>pointCount()</CODE></A></tt></nobr>,
 if the histogram is processed in the simple histogram model (see
 <A HREF="../../../../net/algart/arrays/SummingHistogram.html" title="class in net.algart.arrays"><CODE>comments to SummingHistogram class</CODE></A>).
 Really, in this case the mean between 2 percentiles is equal to

 <blockquote>(<i>S</i>(<i>r</i><sub>2</sub>)&minus;<i>S</i>(<i>r</i><sub>1</sub>)) /
     ((<i>r</i><sub>2</sub>&minus;<i>r</i><sub>1</sub>)*&sigma;) = <i>S</i>(<i>N</i>) / (<i>N</i>*&sigma;) =
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>j</i>&lt;<i>M</i></sub>(<i>j</i>+0.5)*<b>b</b>[<i>j</i>])
     / (<i>N</i>*&sigma;)
 </blockquote>

 <p>In the simplest case, when the source elements are real numbers in the "standard" allowed range
 <nobr><tt>0.0..1.0</tt></nobr>,
 we have <nobr>&sigma; = <i>M</i></nobr> (the histogram length),
 <nobr><i>a<sub>i</sub></i> = &lfloor;<i>v<sub>i</sub></i>*<i>M</i>&rfloor;</nobr>,
 and this expression is equal to

 <blockquote>
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>i</i>&lt;<i>N</i></sub>(<i>a<sub>i</sub></i>+0.5)) / (<i>NM</i>) =
     (<i>v'</i><sub>0</sub>+<i>v'</i><sub>1</sub>+...+<i>v'</i><sub><i>N</i>&minus;1</sub>) / <i>N</i>
     + 0.5 / <i>M</i> &asymp;
     (<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) / <i>N</i>
 </blockquote>

 <p>where <nobr><i>v'<sub>i</sub></i> = <i>a<sub>i</sub></i>/<i>M</i></nobr> is an attempt
 to represent the real number <i>v<sub>i</sub></i> with the given precision &mu;=log<sub>2</sub><i>M</i> bits
 and a correction <nobr>0.5/<i>M</i></nobr> is very little for large <i>M</i>.

 <p>In another simplest case, when the source elements are integer numbers, &sigma;=1 and
 the elements <i>v<sub>i</sub></i> are non-negative integers,
 we have <nobr><i>a<sub>i</sub></i> = <i>v<sub>i</sub></i></nobr>, and this expression is equal to

 <blockquote>
     (<big>&Sigma;</big>&nbsp;<sub>0&le;<i>i</i>&lt;<i>N</i></sub>(<i>v<sub>i</sub></i>+0.5)) / <i>N</i> =
     (<i>v</i><sub>0</sub>+<i>v</i><sub>1</sub>+...+<i>v</i><sub><i>N</i>&minus;1</sub>) / <i>N</i> + 0.5
 </blockquote>
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asMean(Matrix, Pattern)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Pattern)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asFunctionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
asFunctionOfSum</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asFunctionOfSum</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                         <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                         <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the result of some given function
 <nobr><i>f</i>(<i>S</i>)</nobr> of the <i>aperture sum S</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>aperture sum</i>" term.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>The function, applied to each calculated aperture sum <i>S</i>, is specified via
 <tt>processingFunc</tt> argument. Namely, for each aperture position this method
 calculates the aperture sum <i>S</i> of the source matrix and returns
 <nobr><tt>processingFunc.<A HREF="../../../../net/algart/math/functions/Func.html#get(double)"><CODE>get</CODE></A>(</tt><i>S</i><tt>)</tt></nobr>
 in the corresponding element of the resulting matrix.

     <!--Repeat.SectionStart function_casting_note-->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.SectionEnd function_casting_note-->

 <p>This method can be considered as a generalization of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asMean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asMean(Matrix, Pattern)</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated aperture sum.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the result of the given function for
                              the aperture sum of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum(Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum(Matrix, Matrix, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
functionOfSum</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>functionOfSum</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the result of some given function
 <nobr><i>f</i>(<i>S</i>)</nobr> of the <i>aperture sum S</i>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the
 "<i>aperture sum</i>" term.
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>The function, applied to each calculated aperture sum <i>S</i>, is specified via
 <tt>processingFunc</tt> argument. Namely, for each aperture position this method
 calculates the aperture sum <i>S</i> of the source matrix and returns
 <nobr><tt>processingFunc.<A HREF="../../../../net/algart/math/functions/Func.html#get(double)"><CODE>get</CODE></A>(</tt><i>S</i><tt>)</tt></nobr>
 in the corresponding element of the resulting matrix.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)   !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

 <p>This method can be considered as a generalization of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Pattern)</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated aperture sum.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the result of the given function for the aperture sum of the source matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfSum(Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum(Matrix, Matrix, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="functionOfSum(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
functionOfSum</H3>
<PRE>
void <STRONG>functionOfSum</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                   <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                   <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                   <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum(Matrix, Pattern, Func)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

 <p>This method can be considered as a generalization of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#mean(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>mean(Matrix, Matrix, Pattern)</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated aperture sum.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfSum(Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfSum(net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfSum(Matrix, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asFunctionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
asFunctionOfPercentilePair</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asFunctionOfPercentilePair</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes1,
                                                    <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes2,
                                                    <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                    <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real indexes <i>r</i> of two percentiles for every element of the result are equal
 to the corresponding elements of <tt>percentileIndexes1</tt> (for <i>v</i><sub>1</sub>)
 or <tt>percentileIndexes2</tt> matrix (for <i>v</i><sub>2</sub>).
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>The function, applied to each calculated three
 <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>, is specified via
 <tt>processingFunc</tt> argument. Namely, for each aperture position <b>x</b> this method takes
 the value <i>v</i> &mdash; the element of the source matrix <tt>src</tt> at this aperture position <b>x</b>,
 calculates two percentiles <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> of the source matrix and returns
 <nobr><tt>processingFunc.<A HREF="../../../../net/algart/math/functions/Func.html#get(double, double, double)"><CODE>get</CODE></A>(</tt><i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub><tt>)</tt></nobr>
 in the corresponding element of the resulting matrix.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

 <p>You can get the same results by 2 calls of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix,  Matrix, Pattern)</CODE></A> method
 for both matrices of percentile indexes and applying the function to them and to the source matrix via
 <nobr><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix(Func, Class, Matrix, Matrix, Matrix)</CODE></A></nobr> method.
 But such a way works slower and is less convenient, than this method. A typical application of this method
 in image processing area is the contrasting image &mdash; in this case, we recommend using
 <A HREF="../../../../net/algart/math/functions/ContrastingFunc.html" title="class in net.algart.math.functions"><CODE>ContrastingFunc</CODE></A> object as <tt>processingFunc</tt> argument.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndexes1</CODE> - the 1st matrix containing <i>r</i> argument: the indexes of the 1st percentile
                           <i>v</i><sub>1</sub> for every element of the result.</DD><DD><CODE>percentileIndexes2</CODE> - the 2nd matrix containing <i>r</i> argument: the indexes of the 2nd percentile
                           <i>v</i><sub>2</sub> for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated three
                           <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>,
                           where <i>v</i> is the element of the source matrix,
                           <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> are the corresponding percentiles.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the result of the given function.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Matrix, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="asFunctionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
asFunctionOfPercentilePair</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt; <STRONG>asFunctionOfPercentilePair</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                    double&nbsp;percentileIndex1,
                                                    double&nbsp;percentileIndex2,
                                                    <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                    <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Returns an immutable view of the passed source matrix,
 such that any reading data from it calculates and returns the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real indexes <i>r</i> of two percentiles for every element of the result are equal
 to <tt>percentileIndex1</tt> (for <i>v</i><sub>1</sub>)
 or <tt>percentileIndex2</tt> argument (for <i>v</i><sub>2</sub>).
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair</CODE></A>(src,
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex1),
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex1),
 &#32;   pattern, processingFunc)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

 <p>You can get the same results by 2 calls of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asPercentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>asPercentile(Matrix,  double, Pattern)</CODE></A> method
 for both matrices of percentile indexes and applying the function to them and to the source matrix via
 <nobr><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix(Func, Class, Matrix, Matrix, Matrix)</CODE></A></nobr> method.
 But such a way works slower and is less convenient, than this method. A typical application of this method
 in image processing area is the contrasting image &mdash; in this case, we recommend using
 <A HREF="../../../../net/algart/math/functions/ContrastingFunc.html" title="class in net.algart.math.functions"><CODE>ContrastingFunc</CODE></A> object as <tt>processingFunc</tt> argument.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndex1</CODE> - the 1st <i>r</i> argument: the index of the 1st percentile <i>v</i><sub>1</sub>.</DD><DD><CODE>percentileIndex2</CODE> - the 2nd <i>r</i> argument: the index of the 2nd percentile <i>v</i><sub>2</sub>.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated three
                         <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>,
                         where <i>v</i> is the element of the source matrix,
                         <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> are the corresponding percentiles.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the "lazy" matrix containing the result of the given function.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, double, double, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
functionOfPercentilePair</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>functionOfPercentilePair</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes1,
                                                           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes2,
                                                           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                           <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real indexes <i>r</i> of two percentiles for every element of the result are equal
 to the corresponding elements of <tt>percentileIndexes1</tt> (for <i>v</i><sub>1</sub>)
 or <tt>percentileIndexes2</tt> matrix (for <i>v</i><sub>2</sub>).
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>The function, applied to each calculated three
 <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>, is specified via
 <tt>processingFunc</tt> argument. Namely, for each aperture position <b>x</b> this method takes
 the value <i>v</i> &mdash; the element of the source matrix <tt>src</tt> at this aperture position <b>x</b>,
 calculates two percentiles <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> of the source matrix and returns
 <nobr><tt>processingFunc.<A HREF="../../../../net/algart/math/functions/Func.html#get(double, double, double)"><CODE>get</CODE></A>(</tt><i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub><tt>)</tt></nobr>
 in the corresponding element of the resulting matrix.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

 <p>You can get the same results by 2 calls of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix,  Matrix, Pattern)</CODE></A> method
 for both matrices of percentile indexes and applying the function to them and to the source matrix via
 <nobr><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix(Func, Class, Matrix, Matrix, Matrix)</CODE></A></nobr> method.
 But such a way works slower and is less convenient, than this method. A typical application of this method
 in image processing area is the contrasting image &mdash; in this case, we recommend using
 <A HREF="../../../../net/algart/math/functions/ContrastingFunc.html" title="class in net.algart.math.functions"><CODE>ContrastingFunc</CODE></A> object as <tt>processingFunc</tt> argument.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndexes1</CODE> - the 1st matrix containing <i>r</i> argument: the indexes of the 1st percentile
                           <i>v</i><sub>1</sub> for every element of the result.</DD><DD><CODE>percentileIndexes2</CODE> - the 2nd matrix containing <i>r</i> argument: the indexes of the 2nd percentile
                           <i>v</i><sub>2</sub> for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated three
                           <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>,
                           where <i>v</i> is the element of the source matrix,
                           <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> are the corresponding percentiles.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the result of the given function.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Matrix, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
functionOfPercentilePair</H3>
<PRE>
<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt; <STRONG>functionOfPercentilePair</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                                                           double&nbsp;percentileIndex1,
                                                           double&nbsp;percentileIndex2,
                                                           <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                                                           <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Returns a new updatable matrix, containing the result of some given function
 <nobr><i>f</i>(<i>v</i>, <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr> of the source matrix <i>v</i>
 and two <i>percentiles</i> <i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>
 of the source matrix by the specified pattern.
 See the <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html" title="interface in net.algart.matrices.morphology"><CODE>comments to this class</CODE></A>, section 4 about the "<i>percentile</i>" term.
 The real indexes <i>r</i> of two percentiles for every element of the result are equal
 to <tt>percentileIndex1</tt> (for <i>v</i><sub>1</sub>)
 or <tt>percentileIndex2</tt> argument (for <i>v</i><sub>2</sub>).
 The <A HREF="../../../../net/algart/arrays/Matrix.html#elementType()"><CODE>element type</CODE></A>
 of the created matrix is the same as the element type of the source one.

 <p>This method is equivalent to

 <pre><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair</CODE></A>(src,
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex1),
 &#32;   src.matrix(<A HREF="../../../../net/algart/arrays/Arrays.html#nDoubleCopies(long, double)"><CODE>Arrays.nDoubleCopies</CODE></A>(src.size(), percentileIndex1),
 &#32;   pattern, processingFunc)</pre>

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of the source matrix (and, thus, of the result) is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->

 <p>You can get the same results by 2 calls of <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#percentile(net.algart.arrays.Matrix, double, net.algart.math.patterns.Pattern)"><CODE>percentile(Matrix,  double, Pattern)</CODE></A> method
 for both matrices of percentile indexes and applying the function to them and to the source matrix via
 <nobr><A HREF="../../../../net/algart/arrays/Matrices.html#asFuncMatrix(net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix)"><CODE>Matrices.asFuncMatrix(Func, Class, Matrix, Matrix, Matrix)</CODE></A></nobr> method.
 But such a way works slower and is less convenient, than this method. A typical application of this method
 in image processing area is the contrasting image &mdash; in this case, we recommend using
 <A HREF="../../../../net/algart/math/functions/ContrastingFunc.html" title="class in net.algart.math.functions"><CODE>ContrastingFunc</CODE></A> object as <tt>processingFunc</tt> argument.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndex1</CODE> - the 1st <i>r</i> argument: the index of the 1st percentile <i>v</i><sub>1</sub>.</DD><DD><CODE>percentileIndex2</CODE> - the 2nd <i>r</i> argument: the index of the 2nd percentile <i>v</i><sub>2</sub>.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated three
                         <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>,
                         where <i>v</i> is the element of the source matrix,
                         <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> are the corresponding percentiles.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the result of the given function.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, double, double, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
functionOfPercentilePair</H3>
<PRE>
void <STRONG>functionOfPercentilePair</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                              <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                              <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes1,
                              <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;percentileIndexes2,
                              <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                              <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndexes1</CODE> - the 1st matrix containing <i>r</i> argument: the indexes of the 1st percentile
                           <i>v</i><sub>1</sub> for every element of the result.</DD><DD><CODE>percentileIndexes2</CODE> - the 2nd matrix containing <i>r</i> argument: the indexes of the 2nd percentile
                           <i>v</i><sub>2</sub> for every element of the result.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated three
                           <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>,
                           where <i>v</i> is the element of the source matrix,
                           <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> are the corresponding percentiles.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, double, double, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><!-- --></A><H3>
functionOfPercentilePair</H3>
<PRE>
void <STRONG>functionOfPercentilePair</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/UpdatablePArray.html" title="interface in net.algart.arrays">UpdatablePArray</A>&gt;&nbsp;dest,
                              <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PArray.html" title="interface in net.algart.arrays">PArray</A>&gt;&nbsp;src,
                              double&nbsp;percentileIndex1,
                              double&nbsp;percentileIndex2,
                              <A HREF="../../../../net/algart/math/patterns/Pattern.html" title="interface in net.algart.math.patterns">Pattern</A>&nbsp;pattern,
                              <A HREF="../../../../net/algart/math/functions/Func.html" title="interface in net.algart.math.functions">Func</A>&nbsp;processingFunc)</PRE>
<DL>
<DD>Equivalent to <A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A> method,
 but the result matrix will be placed in the <tt>dest</tt> argument.

     <!--Repeat(INCLUDE_FROM_FILE, THIS_FILE, function_casting_note)
         the element type of the source matrix \(.*?\) ==>
         the element type of <tt>dest</tt> matrix  !! Auto-generated: NOT EDIT !! -->
 <p>If the element type of <tt>dest</tt> matrix is fixed-point &mdash;
 <tt>boolean</tt>, <tt>char</tt>, <tt>byte</tt>, <tt>short</tt>, <tt>int</tt> or <tt>long</tt> &mdash;
 then we need to round the real function result.
 In this case, the found function result <i>f</i> is usually truncated to its integer part
 <nobr><tt>(long)</tt><i>f</i></nobr>.
 More precisely, the rules of casting the floating-point function results to the desired element type
 are the same as in <A HREF="../../../../net/algart/arrays/Arrays.html#asFuncArray(boolean, net.algart.math.functions.Func, java.lang.Class, net.algart.arrays.PArray...)"><CODE>Arrays.asFuncArray(boolean, Func, Class, PArray...)</CODE></A>
 method with the argument <tt>truncateOverflows=true</tt>.
     <!--Repeat.IncludeEnd-->
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dest</CODE> - the target matrix.</DD><DD><CODE>src</CODE> - the source matrix.</DD><DD><CODE>percentileIndex1</CODE> - the 1st <i>r</i> argument: the index of the 1st percentile <i>v</i><sub>1</sub>.</DD><DD><CODE>percentileIndex2</CODE> - the 2nd <i>r</i> argument: the index of the 2nd percentile <i>v</i><sub>2</sub>.</DD><DD><CODE>pattern</CODE> - the pattern: the shape of the aperture.</DD><DD><CODE>processingFunc</CODE> - the function, which should be applied to every calculated three
                         <nobr>(<i>v</i>,<i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>)</nobr>,
                         where <i>v</i> is the element of the source matrix,
                         <i>v</i><sub>1</sub> and <i>v</i><sub>2</sub> are the corresponding percentiles.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if one of the arguments is <tt>null</tt>.</DD>
<DD><CODE><A HREF="../../../../net/algart/arrays/SizeMismatchException.html" title="class in net.algart.arrays">SizeMismatchException</A></CODE> - if the passed matrices have different dimensions.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the number of the pattern dimensions
                                  <tt>pattern.<A HREF="../../../../net/algart/math/patterns/Pattern.html#dimCount()"><CODE>dimCount()</CODE></A></tt> is not equal
                                  to <tt>src.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.arrays.Matrix, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, Matrix, Matrix, Matrix, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#asFunctionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>asFunctionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/morphology/RankMorphology.html#functionOfPercentilePair(net.algart.arrays.Matrix, double, double, net.algart.math.patterns.Pattern, net.algart.math.functions.Func)"><CODE>functionOfPercentilePair(Matrix, double, double, Pattern, Func)</CODE></A></DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/morphology/Morphology.SubtractionMode.html" title="enum in net.algart.matrices.morphology"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/morphology/RankPrecision.html" title="enum in net.algart.matrices.morphology"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/morphology/RankMorphology.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="RankMorphology.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
