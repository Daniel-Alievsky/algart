<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SkeletonPixelClassifier
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SkeletonPixelClassifier";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/skeletons/SkeletonPixelClassifier.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="SkeletonPixelClassifier.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.matrices.skeletons</FONT>
<BR>
Class SkeletonPixelClassifier</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.matrices.skeletons.SkeletonPixelClassifier</STRONG>
</PRE>
<DL>
<DT><STRONG>Direct Known Subclasses:</STRONG></DT> <DD><A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">ApertureBasedSkeletonPixelClassifier</A></DD>
</DL>
<HR>
<PRE>public abstract class <STRONG>SkeletonPixelClassifier</STRONG>
extends java.lang.Object</PRE>

<P>
<p>Classifier of pixels of skeletons (bit matrices, generated by skeletonization algorithms),
 separating them into "nodes", "branch pixels" and other groups.
 This class can be used together with <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A> class,
 providing a full solution of analysing the structure of a skeleton.</p>

 <p>Note, that every type of skeletonization algorithm, generally speaking, requires a specific
 pixel classifier, which "knows" all pixel configuration, that can appear in the results of that algorithm.
 The class <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> offers ready pixel classifiers for
 <A HREF="../../../../net/algart/matrices/skeletons/OctupleThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>OctupleThinningSkeleton2D</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>Quadruple3x5ThinningSkeleton2D</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>StrongQuadruple3x5ThinningSkeleton2D</CODE></A> algorithms.</p>

 <h4>Pixel types</h4>

 <p>The main purpose of this class is detecting the <i>type</i> of each skeleton pixel:
 is it a node, a branch pixel, an isolated pixel, or, maybe,
 an "illegal" pixel which cannot appear in a correct skeleton.
 More precisely:</p>

 <ol>
 <li>we call a pixel (a unit element of the skeleton matrix)
 <i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixel</CODE></A></i>, if this element
 of the skeleton has strictly 2 unit neighbour elements;</li>
 <li>we call a pixel <i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A></i>,
 if this element of the skeleton has strictly 1 unit neighbour element;</li>
 <li>we call a pixel <i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated</CODE></A></i>, if this element
 of the skeleton has no neighbour elements;</li>
 <li>we call a pixel "<i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A></i>", if analysis of some close neighbourhood of this pixel
 (usually 3x3 or 5x5) allows to conclude, that this pixel cannot belong to a skeleton of the concrete
 analysed kind;</li>
 <li><a name="groupAttachable"></a>in other cases, i.e. if a unit pixel has <i>k</i>&ge;3 neighbours
 and is not "illegal", we call it either <i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A></i>, or an
 <i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A></i>.
 The concrete implementation of this abstract class defines, which of such pixels are considered to be nodes,
 and which are considered to be attachable branch ends. For each attachable branch end <i>E</i>,
 this class also detects two from its <i>k</i> neighbours with special roles:
     <ol type="A">
     <li>the 1st of them, <i>A</i>, is always <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> and is called "<i>attached node</i>"
     (so there is a guarantee that an attachable branch end is always have a node among neighbours),</li>
     <li>the 2nd, <i>B</i>, is called "an element of <i>attaching branch</i>" and it is:<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&mdash; either really a branch pixel: <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual</CODE></A>,
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free end</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable</CODE></A>
     (that means: this branch is "extended" with this attachable pixel <i>E</i> to achieve the node <i>A</i>),<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&mdash; or another <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> (that means:
     we have 1-pixel branch <i>A</i>&ndash;<i>E</i>&ndash;<i>B</i>, connecting nodes <i>A</i> and <i>B</i>).</li>
     </ol>
 (Note that if the skeleton contains "illegal" pixels, they also may be detected as "attached node"
 and "an element of attaching branch");</li>
 <li>the last possible case is trivial: <i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>zero</CODE></A></i> element of the skeleton matrix.
 </ol>

 <h4>Nodes, branches, degenerated branches</h4>

 <p>As a result of detecting pixel types, this class separates all unit pixels of the correct skeleton,
 generated by some skeletonization algorithm (and, so, not containing "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A>" pixels),
 into the following categories:</p>

 <ul>
 <li><i><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A></i>, detected in the 5th group above,</li>
 <li><i>branches</i>, consisting of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixels</CODE></A>,
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch ends</CODE></A>,</li>
 <li>and also <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixels</CODE></A>: a special case,
 that can be considered as a special kind of nodes without incident branches.</li>
 </ul>

 <p>If two <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A> are neighbours
 (in straight-and-diagonal connectivity terms, see <a href="#connectivity">below</a>),
 then they may be considered to be connected with a <i>degenerated branch</i>, consisting of 0 pixels.
 If at least one of them is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>,
 then we always consider them to be connected with a degenerated branch.
 If both are <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>, then the decision, whether these neighbouring nodes
 are connected with a degenerated branch, is made by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><CODE>markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])</CODE></A> method;
 it is used in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>SkeletonScanner.adjacentBranches()</CODE></A> method.</p>

 <h4>About the nonoriented graph, formed by the skeleton</h4>

 <p>This class guarantees that if the skeleton is correct (contains no "illegal" pixels),
 then the nodes and branches form a <i>correct skeleton nonoriented graph</i>,
 with skeleton <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixels</CODE></A> in a role of graph nodes,
 and skeleton branches (excluding free branch ends) in a role of graph edges.
 "Correct" graph means that:</p>

 <ol type="I">
 <li>each connected component of the skeleton (bit matrix) corresponds to a connected component of this graph;</li>
 <li>any branch is a connected series of 0, 1 or more unit pixels, connecting strictly 2 different
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A> (playing the role
 of graph nodes: ends of the corresponding graph edge).
 For nondegenerate branches (containing at least 1 pixel between ending nodes or
 free branch ends), all their pixels belong to "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixels</CODE></A>" type
 (strictly 2 unit neighbours) or "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>" type
 (having 3 or more unit neighbours), and only the first and the last among them can be attachable ends.
 If the first or the last pixel, really, is an attachable end,
 then it is considered that the <i>attached node A</i>, defined above in the
 <a href="#groupAttachable">description of group 5</a> of pixel types,
 plays the role of the corresponding graph node, incident with the given branch/edge.
 The pixel <i>B</i> (see the <a href="#groupAttachable">description of group 5</a>) plays the role of
 the second graph node, incident with the given branch/edge, if it is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>: it means that we have 1-pixel branch;</li>
 <li>there is the only possible exception from the rules I and II: if a skeleton contains <i>cyclic branches</i>,
 i.e. connected components consisting of usual branch pixels only (thin 1-pixel closed lines, where every pixel
 has strictly 2 unit neighbours), then such branches do not connect any nodes and
 do not form any elements of the graph (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A> class recognizes
 such branches separately);</li>
 <li>nodes of the graph have 0, 1 or &ge;3 incident edges, but never have 2 incident edges.</li>
 </ol>

 <p>See more detailed and formal definition of the nonoriented graph, formed by the skeleton, in the comments
 to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A> class.</p>

 <h4>Base functions of this class</h4>

 <p>One instance of this class can process different skeletons (bit matrices), but all they
 must have the fixed number of dimensions, returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A> method.</p>

 <p>The main method of this class is</p>
 <blockquote><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes(Matrix, SkeletonPixelClassifier.AttachmentInformation)</CODE></A>,
 </blockquote>
 <p>which performs classification of pixels of the given skeleton matrix. The second important method of
 this class is</p>
 <blockquote><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><CODE>markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])</CODE></A>,
 </blockquote>
 <p>which allows to decide, whether two neighbouring nodes should be considered as connected with a degenerated
 0-pixel branch. (It is the only situation, when the results of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> are
 not enough to recognize, whether two nodes of skeleton nonoriented graph should be connected with an edge.)
 This class also provides <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method, which specifies
 some order of the <nobr>3<sup><i>n</i></sup>&minus;1</nobr> neighbours, <i>n</i>=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>,
 of each matrix element and is necessary for interpretation of non-negative values, returned by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</p>

 <h4><a name="connectivity"></a>Connectivity model (straight-and-diagonal) and "neighbour" term</h4>

 <p>Note that this class, as well as <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A>, supposes
 the <i>straight-and-diagonal</i> connectivity kind: see
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>ConnectivityType.STRAIGHT_AND_DIAGONAL</CODE></A>. It means, that all skeletons
 are supposed to be connected in terms of this connectivity: every connected component of the skeleton matrix
 is a "carcass" or "skeleton" of some connected component of the original matrix, for which this skeleton
 was built.</p>

 <p>So, the term "<b><i>neighbour</i></b>" of some pixel (matrix element) in this class
 and in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A> always means another pixel (matrix element), so that</p>

 <blockquote>max&nbsp;(|<i>i</i><sub><i>k</i></sub>&minus;<i>j</i><sub><i>k</i></sub>|)=1</blockquote>

 <p>where <nobr><i>i</i><sub>0</sub>, <i>i</i><sub>1</sub>, ..., <i>i</i><sub><i>n</i>-1</sub></nobr>
 are coordinates of the first pixel and
 <nobr><i>j</i><sub>0</sub>, <i>j</i><sub>1</sub>, ..., <i>j</i><sub><i>n</i>-1</sub></nobr>
 are coordinates of the second pixel (a neighbour of the first one). In 2-dimensional case,
 such connectivity kind is also called <i>8-connectivity</i>.</p>

 <h4>Example of results</h4>

 <p>Below is a simple example of 2-dimensional skeleton, the pixels of which are classified by this class
 into nodes (<tt>N</tt>), usual branch pixels (<tt>b</tt>), free branch ends (<tt>E</tt>),
 attachable branch ends (<tt>a</tt>) and isolated pixels (<tt>I</tt>):</p>

 <pre>
 . . . . . . . . . . . . . . . . .
 . . . . . . <b>E</b> . . . . . . . . . .
 . . <b>E</b> . . . b . . <b>E</b> . . <b>I</b> . <b>E</b> <b>E</b> .
 . . . b a <b>N</b> . . b . . . . . . . .
 . . . . . a . . a . b <b>E</b> . . . <b>I</b> .
 . . . . . . b a <b>N</b> <b>N</b> . . . . . . .
 . . . . . . . . a . . . . <b>E</b> . . .
 . . b b . . . . b . . . . b . . .
 . b . . b . . <b>E</b> . . . . . <b>E</b> . . .
 . b . . . b . . . . . . . . . <b>E</b> .
 . b . . . b . . . . . . . b b . .
 . . b b b . . . . <b>E</b> b b b . . . .
 . . . . . . . . . . . . . . . . .</pre>

 <p>In the left bottom part you can see an example of a cyclic branch, consisting only of usual branch pixels
 (<tt>b</tt>).</p>

 <h4>Creating instances of this class</h4>

 <p>This class is designed for a case of any number of dimensions, though, of course, the most popular
 case is 2-dimensional. This package provides the following 2-dimensional full implementation of this class:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A></li>
 </ul>

 <p>You can also extend the skeletal implementation of this class:
 <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>ApertureBasedSkeletonPixelClassifier</CODE></A>.</p>

 <h4>Pseudo-cyclic continuation</h4>

 <p>This class supposes that the processed matrix is infinitely pseudo-cyclically continued, as well
 <A HREF="../../../../net/algart/arrays/Matrices.html#asShifted(net.algart.arrays.Matrix, long...)"><CODE>Matrices.asShifted</CODE></A> method supposes it.
 You can change this behavior by appending the source matrix with zero elements
 by calling <nobr><A HREF="../../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], Matrix.ContinuationMode)</CODE></A></nobr> method,
 where the dimensions of the "submatrix" are greater than dimensions of the source one by 1
 and the <tt>continuationMode</tt> argument is <A HREF="../../../../net/algart/arrays/Matrix.ContinuationMode.html#ZERO_CONSTANT"><CODE>Matrix.ContinuationMode.ZERO_CONSTANT</CODE></A>.</p>

 <h4>Multithread compatibility</h4>

 <p>This class and its inheritors from this package are <b>immutable</b> and <b>thread-safe</b>:
 there are no ways to modify settings of the created instance.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A></DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Nested Class Summary table, listing nested classes, and an explanation">
<CAPTION CLASS="TableCaption">
Nested Class Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Class and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Style of interpretation of non-negative results while detecting pixel types of the skeleton.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Field Summary table, listing fields, and an explanation">
<CAPTION CLASS="TableCaption">
Field Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Field and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount">dimCount</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of dimensions, returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours">numberOfNeighbours</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of neighbours of each matrix element, returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MAX">TYPE_BRANCH_MAX</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximal from 2 adjacent values
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MIN">TYPE_BRANCH_MIN</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimal from 2 adjacent values
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END">TYPE_FREE_BRANCH_END</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Free branch end</i> pixel type for a skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL">TYPE_ILLEGAL</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>"Illegal"</i> pixel type for a skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED">TYPE_ISOLATED</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Isolated</i> pixel type for a skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MAX">TYPE_NODE_OR_BRANCH_END_MAX</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximal from 3 adjacent values <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MIN">TYPE_NODE_OR_BRANCH_END_MIN</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimal from 3 adjacent values <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH">TYPE_USUAL_BRANCH</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Usual branch</i> pixel type for a skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE">TYPE_USUAL_NODE</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Node</i> pixel type for a skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO">TYPE_ZERO</A></STRONG></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>Zero</i> element type for a skeleton matrix.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Constructor Summary table, listing constructors, and an explanation">
<CAPTION CLASS="TableCaption">
Constructor Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Constructor and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#SkeletonPixelClassifier(int)">SkeletonPixelClassifier</A></STRONG>(int&nbsp;dimCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new instance of this class, allowing to process skeletons with the given number of dimensions.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)">asPixelTypes</A></STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
             <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A>&nbsp;attachmentInformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an immutable view of the passed skeleton matrix, where each element is an integer,
 specifying the type of the corresponding pixel of the skeleton.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of dimensions of the matrices, which can be processed by this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)">isAttachableBranchEndPixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type indicates an <i>attachable branch end</i>,
 i&#46;e&#46; a unit pixel having 3 or more unit neighbours,
 which this class considers to be not a node, but an ending pixel of some branch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isBranchPixelType(int)">isBranchPixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type is indicates a branch element: usual
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isUsualBranchPixelType(int)"><CODE>isUsualBranchPixelType</CODE></A>(pixelType)</tt>
 returns <tt>true</tt>), free branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)"><CODE>isFreeBranchEndPixelType</CODE></A>(pixelType)</tt>
 returns <tt>true</tt>) or attachable branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>isAttachablePixelType</CODE></A>(pixelType)</tt>
 returns <tt>true</tt>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)">isFreeBranchEndPixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type indicates a free branch end,
 i&#46;e&#46; a unit pixel having exactly 1 unit neighbour.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isIllegalPixelType(int)">isIllegalPixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type indicates that the pixel is a center of an impossible configuration
 for a correct result of the given skeletonization algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodeOrFreeBranchEndPixelType(int)">isNodeOrFreeBranchEndPixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type is indicates a node
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)"><CODE>isNodePixelType</CODE></A>(pixelType)</tt> returns <tt>true</tt>)
 or a free branch end
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)"><CODE>isFreeBranchEndPixelType</CODE></A>(pixelType)</tt> returns <tt>true</tt>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)">isNodePixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type is indicates a node, i&#46;e&#46; a unit element
 where 3 or more thin connected 1-pixel branches meet or, as a degenerated case, an isolated pixel:
 a unit element having no unit neighbours.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isUsualBranchPixelType(int)">isUsualBranchPixelType</A></STRONG>(int&nbsp;pixelType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this pixel type indicates a usual branch pixel,
 i&#46;e&#46; a unit pixel having exactly 2 unit neighbours.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])">markNeighbouringNodesNotConnectedViaDegeneratedBranches</A></STRONG>(int[]&nbsp;pixelTypesOfAllNeighbours)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds and marks, by assigning <tt>Integer.MIN_VALUE</tt> to corresponding elements of the passed Java array,
 all neighbours of some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, which are also <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>
 and are considered to be <i>not</i> connected with this node via a degenerated 0-pixel branch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)">neighbourOffset</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the differences of all coordinates of the neighbour of some (central) element with the given index
 and the coordinates of this central element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(long[], int)">neighbourOffset</A></STRONG>(long[]&nbsp;coordinateIncrements,
                int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method,
 which stores the results in the passed Java array instead of creating new Java array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()">numberOfNeighbours</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of neighbours of each element of a skeleton matrix, in terms
 of straight-and-diagonal connectivity kind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#reverseNeighbourIndex(int)">reverseNeighbourIndex</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an index of such neighbour <i>B</i> of some element <i>A</i> of a skeleton matrix,
 so that the element <i>A</i> is the neighbour with the specified index <tt>neighbourIndex</tt>
 of its neighbour <i>B</i>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Field Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="TYPE_USUAL_NODE"><!-- --></A><H3>
TYPE_USUAL_NODE</H3>
<PRE>
public static final int <STRONG>TYPE_USUAL_NODE</STRONG></PRE>
<DL>
<DD><i>Node</i> pixel type for a skeleton matrix.
 (This value can appear in the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Such matrix element is always unit and also has &ge;3 unit neighbours,
 but these conditions are not enough: unit element with &ge;3 unit neighbours may be not only a node,
 but also an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>.
 Strict definition of node pixels may depend on the implementation of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method,
 &mdash; but it is chosen in such a way, that the nodes and branches form a correct skeleton nonoriented graph,
 as written in the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
 Informally, this pixel type indicates the situation
 when 3 or more thin connected 1-pixel branches meet.

 <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as a node of the graph,
 where 3 or more edges meet.

 <p>Below are typical examples for 2D case:
 <pre>
 . . . . 1      . . 1 . .
 1 1 . 1 .      . . 1 . .
 . . <b>1</b> . .  or  1 1 <b>1</b> 1 1
 . . 1 . .      . . 1 . .
 . . 1 . .      . . 1 . .</pre>

 <p>This constant is -1.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_USUAL_NODE">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_ISOLATED"><!-- --></A><H3>
TYPE_ISOLATED</H3>
<PRE>
public static final int <STRONG>TYPE_ISOLATED</STRONG></PRE>
<DL>
<DD><i>Isolated</i> pixel type for a skeleton matrix.
 (This value can appear in the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Formal definition: a matrix element is an isolated pixel
 if and only if this element is unit and has no unit neighbours.

 <p>In the nonoriented graph, formed by the skeleton, such pixel
 is treated as a special degenerated case of a node.

 <p>This situation is shown below for 2D case:
 <pre>
 . . . . .
 . . . . .
 . . <b>1</b> . .
 . . . . .
 . . . . .</pre>

 <p>This constant is -2.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_ISOLATED">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_FREE_BRANCH_END"><!-- --></A><H3>
TYPE_FREE_BRANCH_END</H3>
<PRE>
public static final int <STRONG>TYPE_FREE_BRANCH_END</STRONG></PRE>
<DL>
<DD><i>Free branch end</i> pixel type for a skeleton matrix.
 (This value can appear in the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Formal definition: a matrix element is a free branch end
 if and only if this element is unit and has exactly 1 unit neighbour.

 <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as a node of the graph,
 having 1 incident edge.

 <p>Below is a typical example for 2D case:
 <pre>
 . . . . .
 1 1 . . .
 . . <b>1</b> . .
 . . . . .
 . . . . .</pre>

 <p>This constant is -3.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_FREE_BRANCH_END">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_USUAL_BRANCH"><!-- --></A><H3>
TYPE_USUAL_BRANCH</H3>
<PRE>
public static final int <STRONG>TYPE_USUAL_BRANCH</STRONG></PRE>
<DL>
<DD><i>Usual branch</i> pixel type for a skeleton matrix.
 (This value can appear in the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Formal definition: a matrix element is a usual branch pixel
 if and only if this element is unit and has exactly 2 unit neighbours.

 <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as an internal pixel
 of an edge of the graph.

 <p>Below is a typical example for 2D case:
 <pre>
 . . . . .
 1 1 . . .
 . . <b>1</b> 1 .
 . . . . 1
 . . . . .</pre>

 <p>This constant is -4.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_USUAL_BRANCH">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_ILLEGAL"><!-- --></A><H3>
TYPE_ILLEGAL</H3>
<PRE>
public static final int <STRONG>TYPE_ILLEGAL</STRONG></PRE>
<DL>
<DD><i>"Illegal"</i> pixel type for a skeleton matrix.
 (This value can appear in the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Strict definition of "illegal" pixels may depend on the implementation
 of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method,
 &mdash; but it is chosen in such a way, that the unit elements of a correct skeleton,
 built by the corresponding skeletonization algorithm (on which this implementation
 of this class is oriented), cannot be "illegal".
 Informally, this pixel type indicates an impossible configuration
 for a correct result of the given skeletonization algorithm,
 where it is impossible to decide, is it a node or an element of a branch.

 <p>Below is a possible example for 2D case:
 <pre>
 1 1 1 1 1
 1 1 1 1 1
 1 1 <b>1</b> 1 1
 . . . . .
 . . . . .</pre>
 <p>(in most skeletonization algorithms, the bottom row of unit pixels should be removed here).

 <p>This value is negative; the concrete value is undocumented and can be changed in future versions.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_ILLEGAL">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_ZERO"><!-- --></A><H3>
TYPE_ZERO</H3>
<PRE>
public static final int <STRONG>TYPE_ZERO</STRONG></PRE>
<DL>
<DD><i>Zero</i> element type for a skeleton matrix.
 (This value can appear in the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Formal definition: any zero matrix element.

 <p>Obviously, such pixels are not used while forming the skeleton nonoriented graph.

 <p>This value is negative; the concrete value is undocumented and can be changed in future versions.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_ZERO">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_NODE_OR_BRANCH_END_MIN"><!-- --></A><H3>
TYPE_NODE_OR_BRANCH_END_MIN</H3>
<PRE>
public static final int <STRONG>TYPE_NODE_OR_BRANCH_END_MIN</STRONG></PRE>
<DL>
<DD>Minimal from 3 adjacent values <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>.
 This constant is -3.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_NODE_OR_BRANCH_END_MIN">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_NODE_OR_BRANCH_END_MAX"><!-- --></A><H3>
TYPE_NODE_OR_BRANCH_END_MAX</H3>
<PRE>
public static final int <STRONG>TYPE_NODE_OR_BRANCH_END_MAX</STRONG></PRE>
<DL>
<DD>Maximal from 3 adjacent values <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>.
 This constant is -1.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_NODE_OR_BRANCH_END_MAX">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_BRANCH_MIN"><!-- --></A><H3>
TYPE_BRANCH_MIN</H3>
<PRE>
public static final int <STRONG>TYPE_BRANCH_MIN</STRONG></PRE>
<DL>
<DD>Minimal from 2 adjacent values
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A>.
 This constant is -4.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_BRANCH_MIN">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="TYPE_BRANCH_MAX"><!-- --></A><H3>
TYPE_BRANCH_MAX</H3>
<PRE>
public static final int <STRONG>TYPE_BRANCH_MAX</STRONG></PRE>
<DL>
<DD>Maximal from 2 adjacent values
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A>.
 This constant is -3.
<P>
</DD>
<DD><DL>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../constant-values.html#net.algart.matrices.skeletons.SkeletonPixelClassifier.TYPE_BRANCH_MAX">Constant Field Values</A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimCount"><!-- --></A><H3>
dimCount</H3>
<PRE>
protected final int <STRONG>dimCount</STRONG></PRE>
<DL>
<DD>The number of dimensions, returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A> method.
<P>
</DD>
</DL>
<HR>

<A NAME="numberOfNeighbours"><!-- --></A><H3>
numberOfNeighbours</H3>
<PRE>
protected final int <STRONG>numberOfNeighbours</STRONG></PRE>
<DL>
<DD>The number of neighbours of each matrix element, returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> method.
 Equal to 3<sup><i>n</i></sup>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount"><CODE>dimCount</CODE></A>
 (the number of elements of 3x3x...x3 hypercube without the central element).
<P>
</DD>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Constructor Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="SkeletonPixelClassifier(int)"><!-- --></A><H3>
SkeletonPixelClassifier</H3>
<PRE>
protected <STRONG>SkeletonPixelClassifier</STRONG>(int&nbsp;dimCount)</PRE>
<DL>
<DD>Creates new instance of this class, allowing to process skeletons with the given number of dimensions.
 The number of dimensions must not be greater than
 <nobr><tt>(int)</tt>log<sub>3</sub>(2<sup>31</sup>&minus;1)=19</nobr>:
 this condition provides a guarantee that the number of neighbours, returned by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> method, can be represented by <tt>int</tt> Java type.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>dimCount</CODE> - the number of dimensions, which will be returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A> method.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>dimCount &le; 0</tt> or
                                  if 3<sup><tt>dimCount</tt></sup> &gt;
                                  <tt>Integer.MAX_VALUE</tt>=2<sup>31</sup>&minus;1.</DD></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="isNodePixelType(int)"><!-- --></A><H3>
isNodePixelType</H3>
<PRE>
public static boolean <STRONG>isNodePixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type is indicates a node, i&#46;e&#46; a unit element
 where 3 or more thin connected 1-pixel branches meet or, as a degenerated case, an isolated pixel:
 a unit element having no unit neighbours.
 Equivalent to
 <nobr><tt>pixelType == <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A> || pixelType == <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A></tt></nobr>.

 <p>Note that all unit pixels in the skeleton, excepting <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isIllegalPixelType(int)"><CODE>"illegal"</CODE></A>,
 are separated into 2 groups:
 nodes (including isolated pixels as a degenerated case),
 for which this method returns <tt>true</tt>,
 and branch pixels, for which <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isBranchPixelType(int)"><CODE>isBranchPixelType(int)</CODE></A> returns <tt>true</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates a node,
                  including the degenerated case of an isolated pixel.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isUsualBranchPixelType(int)"><!-- --></A><H3>
isUsualBranchPixelType</H3>
<PRE>
public static boolean <STRONG>isUsualBranchPixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type indicates a usual branch pixel,
 i&#46;e&#46; a unit pixel having exactly 2 unit neighbours.
 Equivalent to
 <nobr><tt>pixelType == <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A></tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates a usual (non-ending) branch pixel.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isFreeBranchEndPixelType(int)"><!-- --></A><H3>
isFreeBranchEndPixelType</H3>
<PRE>
public static boolean <STRONG>isFreeBranchEndPixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type indicates a free branch end,
 i&#46;e&#46; a unit pixel having exactly 1 unit neighbour.
 Equivalent to
 <nobr><tt>pixelType == <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A></tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates a free branch end.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isAttachableBranchEndPixelType(int)"><!-- --></A><H3>
isAttachableBranchEndPixelType</H3>
<PRE>
public static boolean <STRONG>isAttachableBranchEndPixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type indicates an <i>attachable branch end</i>,
 i&#46;e&#46; a unit pixel having 3 or more unit neighbours,
 which this class considers to be not a node, but an ending pixel of some branch.
 Equivalent to
 <nobr><tt>pixelType >= 0</tt></nobr>.
 (The value of <tt>pixelType</tt> argument can appear in the result of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.)

 <p>Such matrix element is always unit and also has &ge;3 unit neighbours, as <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>,
 but it is not considered to be a node.
 Strict definition of attachable branch ends may depend on the implementation of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method,
 &mdash; but it is chosen in such a way, that the nodes and branches form a correct skeleton nonoriented graph,
 as written in the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
 Informally, this pixel type indicates an ending pixel of
 a thin connected 1-pixel branch, which approaches a node,
 when the number of neighbours of this pixel is greater than 2.

 <p>In the nonoriented graph, formed by the skeleton, such pixel is treated as an internal pixel
 of an edge of the graph, as well as <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixels</CODE></A>.

 <p>Below is a typical example for 2D case:
 <pre>
 . . 1 . .
 . . <b>1</b> . .
 1 <b>1</b> <i>1</i> <b>1</b> 1
 . . <b>1</b> . .
 . . 1 . .</pre>

 <p>4 unit pixels near the center can be considered as attachable branch ends.
 All they have 4 unit neighbours, but it is clear that there is no sense
 to consider them as nodes &mdash; unlike the center, which also has 4 unit neighbours and is an obvious node.

 <p>Another example:
 <pre>
 1 1 . . . 1 1
 . . 1 . <b>1</b> . .
 . . . <b>1</b> <i>1</i> . .
 . . . . . 1 .
 . . . . . . 1</pre>
 <p>The central unit pixel and its right diagonal neighbour (marked out by bold font)
 can be considered as attachable branch ends. They have 3 unit neighbours,
 but it is clear that they may be treated as end elements of the corresponding branches &mdash;
 unlike the true node to the right from the center (marked out by italic font).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates an attachable branch end,
                  i.e. if it is non-negative.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isNodeOrFreeBranchEndPixelType(int)"><!-- --></A><H3>
isNodeOrFreeBranchEndPixelType</H3>
<PRE>
public static boolean <STRONG>isNodeOrFreeBranchEndPixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type is indicates a node
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)"><CODE>isNodePixelType</CODE></A>(pixelType)</tt> returns <tt>true</tt>)
 or a free branch end
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)"><CODE>isFreeBranchEndPixelType</CODE></A>(pixelType)</tt> returns <tt>true</tt>).
 Equivalent to<br>
 <nobr><tt>pixelType &gt;= <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MIN"><CODE>TYPE_NODE_OR_BRANCH_END_MIN</CODE></A> &&
 pixelType &lt;= <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MAX"><CODE>TYPE_NODE_OR_BRANCH_END_MAX</CODE></A></tt></nobr>.

 <p>Note that all such pixels (nodes and free branch ends) corresponds to
 nodes of a graph, describing the geometric structure of the skeleton
 (branches correspond to edges in that graph).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates a node or a free branch end.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isBranchPixelType(int)"><!-- --></A><H3>
isBranchPixelType</H3>
<PRE>
public static boolean <STRONG>isBranchPixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type is indicates a branch element: usual
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isUsualBranchPixelType(int)"><CODE>isUsualBranchPixelType</CODE></A>(pixelType)</tt>
 returns <tt>true</tt>), free branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)"><CODE>isFreeBranchEndPixelType</CODE></A>(pixelType)</tt>
 returns <tt>true</tt>) or attachable branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>isAttachablePixelType</CODE></A>(pixelType)</tt>
 returns <tt>true</tt>).
 Equivalent to<br>
 <nobr><tt>pixelType &gt;= 0 ||
 (pixelType &gt;= <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MIN"><CODE>TYPE_BRANCH_MIN</CODE></A> && pixelType &lt;= <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MAX"><CODE>TYPE_BRANCH_MAX</CODE></A>)</tt></nobr>.

 <p>Note that all unit pixels in the skeleton, excepting <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isIllegalPixelType(int)"><CODE>"illegal"</CODE></A>,
 are separated into 2 groups:
 nodes (including isolated pixels as a degenerated case),
 for which <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)"><CODE>isNodePixelType(int)</CODE></A> returns <tt>true</tt>,
 and branch pixels, for which this method returns <tt>true</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates some element of a branch.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isIllegalPixelType(int)"><!-- --></A><H3>
isIllegalPixelType</H3>
<PRE>
public static boolean <STRONG>isIllegalPixelType</STRONG>(int&nbsp;pixelType)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this pixel type indicates that the pixel is a center of an impossible configuration
 for a correct result of the given skeletonization algorithm.
 Equivalent to
 <nobr><tt>pixelType == <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>TYPE_ILLEGAL</CODE></A></tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelType</CODE> - pixel type: possible element of the result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this type indicates an incorrect configuration of the pixel's neighbours.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
public final int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD>Returns the number of dimensions of the matrices, which can be processed by this object.
 In <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A>, equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of dimensions of the matrices, which can be processed by this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="numberOfNeighbours()"><!-- --></A><H3>
numberOfNeighbours</H3>
<PRE>
public final int <STRONG>numberOfNeighbours</STRONG>()</PRE>
<DL>
<DD>Returns the number of neighbours of each element of a skeleton matrix, in terms
 of straight-and-diagonal connectivity kind.
 Equal to 3<sup><i>n</i></sup>&minus;1, <i>n</i>=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>
 (the number of elements of 3x3x...x3 hypercube without the central element).
 In particular, in 2-dimensional case this method returns 3<sup>2</sup>-1=8,
 and in 3-dimensional case this method returns 3<sup>3</sup>-1=26.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of neighbours of every element.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourOffset(int)"><!-- --></A><H3>
neighbourOffset</H3>
<PRE>
public final long[] <STRONG>neighbourOffset</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns the differences of all coordinates of the neighbour of some (central) element with the given index
 and the coordinates of this central element.
 In other words, if <nobr><i>i</i><sub>0</sub>, <i>i</i><sub>1</sub>, ..., <i>i</i><sub><i>n</i>-1</sub></nobr>
 are coordinates of the some element of a skeleton matrix (<i>n</i>=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>),
 and we need to find the coordinates
 <nobr><i>j</i><sub>0</sub>, <i>j</i><sub>1</sub>, ..., <i>j</i><sub><i>n</i>-1</sub></nobr>
 of its neighbour #<i>k</i>, 0&le;<i>k</i>&lt;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>,
 we should use the following formula:
 <blockquote>
 <i>j<sub>i</sub></i> = <i>i<sub>i</sub></i> + <tt>offset[</tt><i>i</i><tt>]</tt>,
 </blockquote>
 <p>where <tt>offset</tt> is the result of calling this method with <tt>neighbourIndex</tt>=<i>k</i>.

 <p>The returned array is always a newly allocated Java array.
 Its length is always equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>.
 Its elements will be always same while different calls of this method for the same object
 (implementing this class) with the same <tt>neighbourIndex</tt> argument.
 The elements of the returned array are always equal to <tt>-1</tt>, <tt>0</tt> or <tt>+1</tt>,
 and all they cannot be <tt>0</tt> simultaneously.

 <p>This method defines some <i>order</i> of enumerating neighbours.
 This order can be different in different implementations.
 In <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> implementation,
 the order of neighbours is described by the following diagram:
 <pre>
 0 1 2
 7 <b><i>C</i></b> 3
 6 5 4</pre>
 <p>(the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).
 It means that the results of this method in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> are the following:
 for <tt>neighbourIndex=0</tt> it returns two-element array <tt><nobr>{-1,-1}</nobr></tt>,
 for <tt>neighbourIndex=1</tt> it returns two-element array <tt><nobr>{0,-1}</nobr></tt>,
 for <tt>neighbourIndex=2</tt> it returns two-element array <tt><nobr>{1,-1}</nobr></tt>,
 for <tt>neighbourIndex=3</tt> it returns two-element array <tt><nobr>{1,0}</nobr></tt>,
 for <tt>neighbourIndex=4</tt> it returns two-element array <tt><nobr>{1,1}</nobr></tt>,
 for <tt>neighbourIndex=5</tt> it returns two-element array <tt><nobr>{0,1}</nobr></tt>,
 for <tt>neighbourIndex=6</tt> it returns two-element array <tt><nobr>{-1,1}</nobr></tt>,
 for <tt>neighbourIndex=7</tt> it returns two-element array <tt><nobr>{-1,0}</nobr></tt>.
 In other words, <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> class enumerates
 the neighbours along the perimeter of 3x3 square.

 <p>This method is completely implemented via <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(long[], int)"><CODE>neighbourOffset(long[], int)</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - an index if the neighbour of some central element of a matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>shifts along all coordinates from the central element to this neighbour.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>SkeletonScanner.neighbourOffsetInArray(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourOffset(long[], int)"><!-- --></A><H3>
neighbourOffset</H3>
<PRE>
public abstract void <STRONG>neighbourOffset</STRONG>(long[]&nbsp;coordinateIncrements,
                                     int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>More efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method,
 which stores the results in the passed Java array instead of creating new Java array.
 This method is equivalent to calling that method and copying its result into
 <tt>coordinateIncrements</tt> argument, but does not allocate any arrays.
 It is a better solution if we need to calculate neighbour offsets in a long loop,
 because allows to avoid allocating a lot of short arrays.

 <p>The length of the passed array must be equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>the number of dimensions</CODE></A>
 of processed matrices.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>coordinateIncrements</CODE> - Java array for storing the differences of all coordinates of
                             the neighbour #<tt>neighbourIndex</tt> of some (central) element
                             and the coordinates of this central element.</DD><DD><CODE>neighbourIndex</CODE> - an index if the neighbour of some central element of the matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>coordinateIncrements</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>coordinateIncrements.length!=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>SkeletonScanner.neighbourOffsetInArray(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="reverseNeighbourIndex(int)"><!-- --></A><H3>
reverseNeighbourIndex</H3>
<PRE>
public abstract int <STRONG>reverseNeighbourIndex</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns an index of such neighbour <i>B</i> of some element <i>A</i> of a skeleton matrix,
 so that the element <i>A</i> is the neighbour with the specified index <tt>neighbourIndex</tt>
 of its neighbour <i>B</i>.
 Both neighbour indexes are considered in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 It means, that if <tt>k1</tt> is the argument of this method and <tt>k2</tt> is the result of this method,
 <nobr><tt>offset1=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset</CODE></A>(k1)</tt></nobr> and
 <nobr><tt>offset2=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset</CODE></A>(k2)</tt></nobr>,
 then
 <blockquote>
 <tt>offset2[<i>i</i>] = -offset1[<i>i</i>]</tt> for all <i>i</i>.
 </blockquote>

 <p>For example, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A> class (which enumerates 8 neighbours along
 the perimeter of 3x3 square) this method returns <tt>(neighbourIndex+4)%8</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - an index of some neighbour <i>B</i> of some central element <i>A</i>.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>an index of the central element <i>A</i> as a neighbour of the element <i>B</i>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><!-- --></A><H3>
asPixelTypes</H3>
<PRE>
public abstract <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt; <STRONG>asPixelTypes</STRONG>(<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
                                                             <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A>&nbsp;attachmentInformation)</PRE>
<DL>
<DD>Returns an immutable view of the passed skeleton matrix, where each element is an integer,
 specifying the type of the corresponding pixel of the skeleton. The number of dimensions of
 the passed matrix must be equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A>.

 <p>More precisely, let's consider that <tt>skeleton</tt> matrix is the result of some skeletonization
 algorithm (chosen while creating an instance of this class). The resulting matrix will
 contain the following values:

 <ol>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>TYPE_ZERO</CODE></A>, if the corresponding element of the skeleton is zero (no pixel);</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>TYPE_ILLEGAL</CODE></A>, if here is an impossible configuration for a correct result of the given
 skeletonization algorithm (probable case, if the passed matrix is really not a skeleton);</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, if the corresponding element of the skeleton is a node, where 3 or more
 branches meet;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A>, if the corresponding element of the skeleton is an isolated unit pixel,
 having no unit neighbour elements;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>, if the corresponding element of the skeleton is an end of some branch,
 having 1 unit neighbour elements;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A>, if the corresponding element of the skeleton has 2
 unit neighbour elements;</li>
 <li>some non-negative value in <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt> range,
 if the corresponding element of the skeleton has &ge;3 unit neighbour elements, but this class recommends
 to consider this pixel not a node, but an additional <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>"attached" element</CODE></A> of some branch. In this case, this value means the following:
     <ol type=A>
     <li>if <tt>attachmentInformation</tt> argument is
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A>,
     this value specifies the direction (neighbour index) towards the neighbouring node,
     which is one of the ends of this branch;
     there is a guarantee that this neighbour is either really <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or, maybe,
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>TYPE_ILLEGAL</CODE></A>;</li>
     <li>if <tt>attachmentInformation</tt> argument is
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A>,
     this value specifies the direction (neighbour index) towards the branch,
     to which this pixel should be attached as its ending element;
     there is no guarantee that this neighbour is really a branch element, but it cannot be
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>zero</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated</CODE></A>, and if it is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>,
     it is supposed that we have a short branch to it, consisting of 1 pixel.</li>
     </ol>
 See also the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>,
 section "Pixel types", group 5.<br>
 The direction is specified in terms of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 In <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A>, it can be 0,1,2,3,4,5,6,7, corresponding to the following diagram:
 <pre>
 0 1 2
 7 <b><i>C</i></b> 3
 6 5 4</pre>
 <p>(the <i>x</i>-axis is directed rightward, the <i>y</i>-axis is directed downward).
 Namely, if the current element has coordinates <nobr>(<i>x</i>,<i>y</i>)</nobr>,
 then "0" value means attaching of the node with coordinates
 <nobr>(<i>x</i>&minus;1,<i>y</i>&minus;1)</nobr> (the case A)
 or attaching of the node to the branch containing the pixel
 <nobr>(<i>x</i>&minus;1,<i>y</i>&minus;1)</nobr> (the case B),
 "1" value means attaching of the node / to the branch <nobr>(<i>x</i>,<i>y</i>&minus;1)</nobr>,
 "2" value means attaching of the node / to the branch <nobr>(<i>x</i>+1,<i>y</i>&minus;1)</nobr>,
 "3" value means attaching of the node / to the branch  <nobr>(<i>x</i>+1,<i>y</i>)</nobr>,
 "4" value means attaching of the node / to the branch  <nobr>(<i>x</i>+1,<i>y</i>+1)</nobr>,
 "5" value means attaching of the node / to the branch  <nobr>(<i>x</i>,<i>y</i>+1)</nobr>,
 "6" value means attaching of the node / to the branch  <nobr>(<i>x</i>&minus;1,<i>y</i>+1)</nobr>,
 "7" value means attaching of the node / to the branch  <nobr>(<i>x</i>&minus;1,<i>y</i>)</nobr>.
 </li>
 </ol>

 <p>Note, that the situation, when some neighbouring elements are out of ranges of the matrix coordinates,
 is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>.

 <p>Note, that all values, specified by constants of this class
 (all cases 1-6 above, excepting the last case 7), are different negative integers.
 Then, note that <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A>
 are adjacent integers <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MIN">-3</A>..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_NODE_OR_BRANCH_END_MAX">-1</A>.
 Then, note that two constants, corresponding to branches and their ends &mdash;
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>TYPE_FREE_BRANCH_END</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>TYPE_USUAL_BRANCH</CODE></A> &mdash;
 are also adjacent integers <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MIN">-4</A>..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_BRANCH_MAX">-3</A>.
 Then, note that two constants, corresponding to nodes and isolated pixels &mdash;
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>TYPE_ISOLATED</CODE></A> &mdash;
 are also adjacent integers <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED">-2</A>..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE">-1</A>.
 This can be useful for extracting special kinds of skeleton pixels into bit matrices.</p>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>skeleton</CODE> - the skeleton matrix that should be processed.</DD><DD><CODE>attachmentInformation</CODE> - what should this method return for attachable pixels.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the matrix of integer codes with the same sizes, describing the types
                              of all skeleton pixels.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>skeleton</tt> or <tt>attachmentInformation</tt> is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.dimCount()!=<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><!-- --></A><H3>
markNeighbouringNodesNotConnectedViaDegeneratedBranches</H3>
<PRE>
public abstract void <STRONG>markNeighbouringNodesNotConnectedViaDegeneratedBranches</STRONG>(int[]&nbsp;pixelTypesOfAllNeighbours)</PRE>
<DL>
<DD>Finds and marks, by assigning <tt>Integer.MIN_VALUE</tt> to corresponding elements of the passed Java array,
 all neighbours of some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, which are also <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>
 and are considered to be <i>not</i> connected with this node via a degenerated 0-pixel branch.
 Neighbouring nodes, which are considered to be connected with the central node
 via 0-pixel branch, stay unchanged.

 <p>More precisely, this method analyses the Java array <tt>pixelTypesOfAllNeighbours</tt>,
 which contains the pixel types of all neighbours of some "central" pixel, which is supposed to be
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, in the order, defined by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method.
 This method finds among them all values, equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A>, and, if this class considers
 that they should not be connected with the central node via degenerated branches, such values are
 replaced with <tt>Integer.MIN_VALUE</tt> (which means "removing" these neighbours from candidates to
 connection with the central node). So, if some elements of the passed array are
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A> after calling this method as before,
 it means that such neighbouring nodes should be considered as connected
 with the central node via degenerated branches.

 <p>This method is used in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>SkeletonScanner.adjacentBranches()</CODE></A> to correctly find all degenerated
 branches, originating in the current node.

 <p>The passed array must contain at least <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> elements.
 If it contains more elements, this method processes only first
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A> elements and ignores others.

 <p>In <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>ApertureBasedSkeletonPixelClassifier</CODE></A> for 2-dimensional case and,
 in particular, in <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A>,
 the neighbouring node <i>Q</i> of the central node <i>P</i>
 is not marked for removing (not replaced with <tt>Integer.MIN_VALUE</tt>),
 if the segment <i>PQ</i> is not diagonal (4-connected neighbour) or if it is diagonal,
 but the two adjacent pixels, which are 4-connected neighbours
 of both <i>P</i> and <i>Q</i>, are not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>:
 <pre>
     . . * . . .      . . . * . .
     . . * . . .      . . . * . .
     * * . * * *      . . . Q * *
     . . P Q . .  or  * * P . . .
     . . * . * .      . . * . . .
     . . * . . *      . . * . . .
 </pre>
 In other situations, a diagonal degenerated branch between <i>P</i> and <i>Q</i> would be extra, because
 they are connected via two horizontal and vertical degenerated 0-pixel branches.
 (In <A HREF="../../../../net/algart/matrices/skeletons/ApertureBasedSkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>ApertureBasedSkeletonPixelClassifier</CODE></A> class for the number of dimensions, other than 2,
 the implementation of this method does nothing.)
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>pixelTypesOfAllNeighbours</CODE> - an array of the pixel types of all neighbours of some given element,
                                  supposed to be a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>; this method will replace
                                  some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>TYPE_USUAL_NODE</CODE></A> values in this array with
                                  <tt>Integer.MIN_VALUE</tt>.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if the argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the length of the passed array is less than <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/skeletons/SkeletonPixelClassifier.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="SkeletonPixelClassifier.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
