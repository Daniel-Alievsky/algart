<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML lang="en">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SkeletonScanner
</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SkeletonScanner";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--algartHeader-->
<div align="center" style="margin:0 0 8px 0">
<noindex>
<script type="text/javascript">
  // Google Analytics

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8233371-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!--Openstat-->
<span id="openstat877799"></span>
<script type="text/javascript">
var openstat = { counter: 877799, next: openstat };
(function(d, t, p) {
var j = d.createElement(t); j.async = true; j.type = "text/javascript";
j.src = ("https:" == p ? "https:" : "http:") + "//openstat.net/cnt.js";
var s = d.getElementsByTagName(t)[0]; s.parentNode.insertBefore(j, s);
})(document, "script", document.location.protocol);
</script>
<!--/Openstat-->
</noindex>

<!--#include virtual="/ad_top_utf8.php"-->
</div>
<div style="margin:0"><noindex><a target="_top" href="http://algart.net/"><i>AlgART Home</i></a></noindex></div>
<!--/algartHeader-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/skeletons/SkeletonScanner.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="SkeletonScanner.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.algart.matrices.skeletons</FONT>
<BR>
Class SkeletonScanner</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><STRONG>net.algart.matrices.skeletons.SkeletonScanner</STRONG>
</PRE>
<DL>
<DT><STRONG>All Implemented Interfaces:</STRONG></DT> <DD><A HREF="../../../../net/algart/arrays/ArrayProcessor.html" title="interface in net.algart.arrays">ArrayProcessor</A></DD>
</DL>
<HR>
<PRE>public final class <STRONG>SkeletonScanner</STRONG>
extends java.lang.Object
implements <A HREF="../../../../net/algart/arrays/ArrayProcessor.html" title="interface in net.algart.arrays">ArrayProcessor</A></PRE>

<P>
<p>Scanner of skeletons (bit matrices, generated by skeletonization algorithms), allowing
 to scan a skeleton, find and traverse all its structural elements like nodes and branches.
 This class works on the base of results of classifying skeleton pixels, performed by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonPixelClassifier</CODE></A> class, and requires an object of that class for creating an instance.</p>

 <h4><a name="graph"></a>The nonoriented graph, formed by the skeleton</h4>

 <p>The base goal of this class is building and scanning the <b><i>skeleton nonoriented graph</i></b>,
 formed by nodes and branches of the given <i>skeleton</i> (bit matrix).
 Below is the formal definition of this graph for some <i>n</i>-dimensional <i>skeleton bit matrix</i>
 (or, briefly, <i>skeleton</i>) and some <i>skeleton pixel classifier</i>: an instance of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonPixelClassifier</CODE></A> class, used by this class
 (it is returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A> method).</p>

 <p>Let's define a <i>pixel</i> with integer coordinates (<i>x</i>,&nbsp;<i>y</i>,&nbsp;<i>z</i>,...)
 as a set of points of the <i>n</i>-dimensional space with such coordinates
 (<i>x'</i>,&nbsp;<i>y'</i>,&nbsp;<i>z'</i>,...) that
 <nobr><i>x</i>&minus;0.5&le;<i>x'</i>&le;<i>x</i>+0.5,</nobr>
 <nobr><i>y</i>&minus;0.5&le;<i>y'</i>&le;<i>y</i>+0.5,</nobr>
 <nobr><i>z</i>&minus;0.5&le;<i>z'</i>&le;<i>z</i>+0.5,</nobr> ...
 In other words, pixel is a hypercube with the center (<i>x</i>,&nbsp;<i>y</i>,&nbsp;<i>z</i>,...)
 and the edge 1.0 (in 2-dimensional case, it is a square 1x1).
 Every unit element of the skeleton  matrix with <A HREF="../../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>coordinates</CODE></A>
 (<i>x</i>,&nbsp;<i>y</i>,&nbsp;<i>z</i>,...) corresponds to a pixel (<i>x</i>,&nbsp;<i>y</i>,&nbsp;<i>z</i>,...)
 in the <i>n</i>-dimensional Euclidean space.</p>

 <p>The <i>skeleton nonoriented graph</i> is a set of <i>n</i>-dimensional points-<i>nodes</i>,
 connected by polylines-<i>edges</i>.
 Namely:</p>

 <ol>
 <li>The <b><i>nodes</i></b> of the graph are geometrical centers of all pixels of the skeleton, classified as
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>,
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixels</CODE></A> by the
 current skeleton pixel classifier.
 Such types of nodes have correspondingly &ge;3, 1 and 0 incident edges.
 <br>&nbsp;
 <br>
 Warning: <i>nodes</i> of the graph and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE><i>node</i> pixel type</CODE></A> in the skeleton matrix are different
 concepts! Nodes of the graph are points of the <i>n</i>-dimensional Euclidean space, namely centers of pixels
 (centers of 1x1 squares in 2-dimensional case), while node pixel type describes matrix elements,
 corresponding to pixels in the space (1x1 squares in 2-dimensional case).
 And nodes of the graphs are formed not only by node pixel type, but also by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixels</CODE></A>.
 <br>&nbsp;</li>

 <li>The <b><i>edges</i></b> of the graph are polylines
 <i>E</i><sub>0</sub><i>E</i><sub>1</sub>...<i>E</i><sub><i>m</i></sub>, <i>m</i>&ge;1,
 connecting some pairs of graph nodes <i>E</i><sub>0</sub> and <i>E</i><sub><i>m</i></sub>.
 Every such edge consists of a sequences of segments <i>E</i><sub><i>i</i></sub>&nbsp;<i>E</i><sub><i>i</i>+1</sub>
 with length 1, &radic;2, ... or &radic;<i>n</i>, connecting geometrical centers of 2 pixels
 <i>E</i><sub><i>i</i></sub> and <i>E</i><sub><i>i</i>+1</sub>,
 corresponding to 2 neighbouring unit matrix elements
 (in straight-and-diagonal connectivity terms, see <a href="#connectivity">below</a>).
 Both ends <i>E</i><sub>0</sub> and <i>E</i><sub><i>m</i></sub> of each edge are always nodes of the graph.
 <br>&nbsp;
 <br>
 The sequence of skeleton pixels, corresponding to points
 <nobr><i>E</i><sub>1</sub>, <i>E</i><sub>2</sub>, .., .<i>E</i><sub><i>m</i>&minus;1</sub></nobr>,
 is also called a <b><i>skeleton branch</i></b>. In a case <i>m</i>=1, we also say that
 the nodes of the graph <i>E</i><sub>0</sub> and <i>E</i><sub><i>m</i></sub> are connected
 with a <b><i>degenerated 0-pixel skeleton branch</i></b> (or, briefly, a <i>degenerated branch</i>).
 <br>&nbsp;</li>

 <li>If an edge <i>E</i><sub>0</sub><i>E</i><sub>1</sub>...<i>E</i><sub><i>m</i></sub>
 consist of more than 1 segment (<i>m</i>&ge;2), then all points
 <i>E</i><sub>1</sub>, <i>E</i><sub>2</sub>, ..., <i>E</i><sub><i>m</i>&minus;1</sub>
 are geometrical centers of the pixels of the skeleton, classified as
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixels</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch ends</CODE></A>
 by the current skeleton pixel classifier.
 Only the first and the last among points <i>E</i><sub>1</sub> and <i>E</i><sub><i>m</i>&minus;1</sub>
 can correspond to attachable branch ends (but also can be centers of usual branch pixels);
 all other points <i>E</i><sub><i>k</i></sub>, 2&le;<i>k</i>&le;<i>m</i>&minus;2,
 always correspond to usual branch pixels.
 <br>&nbsp;
 <br>
 Every skeleton pixel, classified as a usual branch pixel or an attachable branch end
 by the current skeleton pixel classifier,
 is always an element of some skeleton branch, i.e. its center is a point
 <i>E</i><sub><i>k</i></sub> with 1&le;<i>k</i>&le;<i>m</i>&minus;1 for some graph edge.
 There is the only exception from this rule, described below in the paragraph 7.
 <br>&nbsp;</li>

 <li>If <i>m</i>&ge;3 and the point <i>E</i><sub>1</sub> corresponds to a pixel, classified as
 an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>,
 then <i>E</i><sub>0</sub> pixel is detected as the attached branch node <i>A</i> and
 <i>E</i><sub>2</sub> pixel is detected as an element of attaching branch <i>B</i>
 for this branch end <i>E</i><sub>1</sub> by the current skeleton pixel classifier
 &mdash;&nbsp;see <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>,
 section "Pixel types", group 5. In other words, the main classifying method
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>SkeletonPixelClassifier.asPixelTypes</CODE></A>
 returns for pixel <i>E</i><sub>1</sub> an index of its neighbour <i>E</i><sub>0</sub>,
 when it is called in the mode
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A>,
 or an index of its neighbour <i>E</i><sub>2</sub>,
 when it is called in the mode
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A>.
 <br>&nbsp;
 <br>
 Analogously, if <i>m</i>&ge;3 and the point <i>E</i><sub><i>m</i>&minus;1</sub>
 corresponds to a pixel, classified as
 an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>,
 then <i>E</i><sub><i>m</i></sub> pixel is detected as the attached branch node <i>A</i> and
 <i>E</i><sub><i>m</i>&minus;2</sub> pixel is detected as an element of attaching branch <i>B</i>
 for this branch end <i>E</i><sub><i>m</i>&minus;1</sub> by the current skeleton pixel classifier.
 <br>&nbsp;</li>

 <li>If <i>m</i>=2 and the only "internal" point <i>E</i><sub>1</sub> corresponds to a pixel, classified as
 an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>,
 then, for this branch end,
 either <i>E</i><sub>0</sub> pixel is detected as the attached branch node <i>A</i> and
 <i>E</i><sub>2</sub> pixel is detected as an element of attaching branch <i>B</i>,
 or <i>E</i><sub>2</sub> pixel is detected as the attached branch node <i>A</i> and
 <i>E</i><sub>0</sub> pixel is detected as an element of attaching branch <i>B</i>
 by the current skeleton pixel classifier
 &mdash;&nbsp;see <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>,
 section "Pixel types", group 5.
 <br>&nbsp;</li>

 <li>In addition to the situations 4 and 5, this graph contains edges without "internal" points (<i>m</i>=1),
 corresponding to degenerated 0-pixel branches.
 Such edges connect:
     <ul>
     <li>any pairs of neighbouring graph nodes, where both nodes are the centers of pixels, classified as
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch ends</CODE></A>
     (it is a very simple case of a short 2-pixel branch);</li>
     <li>any pairs of neighbouring graph nodes, where one node is the center of a pixel, classified as
     a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, and another is the center of a pixel, classified as
     a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>;</li>
     <li>any pairs of neighbouring graph nodes, where both nodes are the centers of pixels, classified as
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>nodes</CODE></A>,
     when the connecting them with a degenerated branch is not prohibited by
     <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><CODE>SkeletonPixelClassifier.markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])</CODE></A></nobr>
     method (and, so, when each from these 2 nodes appears in the list of neighbour indexes,
     returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> method for the second node).
     <br>&nbsp;</li>
     </ul>
 </li>

 <li>The skeleton can also contain specific kind of branches, called <b><i>cyclic branches</i></b>,
 consisting of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixels</CODE></A> only and containing no
 nodes; such branches do not correspond to any elements of the graph and are recognized separately
 by this class.
 <br>&nbsp;</li>

 <li>We can conclude from statements 1, 2 and 3, that each connected component of the skeleton,
 excepting cyclic branches, corresponds to a connected component of the graph, and vice versa.</li>
 </ol>

 <p>All said above is correct only if the processed skeleton matrix does not contain
 "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A>" unit elements. If it contains them,
 the skeleton nonoriented graph can be partially incorrect.</p>

 <p>It is easy to note, that this graph does not contain nodes with 2 incident edges and
 has no self-loops (though we could interpret the case 7 in this manner).</p>

 <p>This class contains methods, allowing to scan this graph, i.e. to find all branches, incident with
 some node of the graph, i.e.
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A> pixel type,
 and to scan any branch from one its end (node of the graph) to another.
 Thus, you can use this class to vectorize a skeleton by transforming this graph into some
 geometrical vector model, consisting of points (nodes) and curves (lines connecting nodes).
 The main methods, which you need to use for full scanning the graph, are the following:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> &mdash; you should call this method to start scanning
 the next part of the skeleton;</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A> &mdash; starts scanning a branch from
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> (but not
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>);</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> &mdash; starts scanning a branch from a branch pixel
 (including <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>);</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> &mdash; continues scanning the current branch.</li>
 </ul>

 <p>See comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> about possible strategies of scanning, such as recursive
 depth-first search. See also comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch(boolean, boolean)</CODE></A> methods to understand, how to fully scan every branch.
 And see below a <a href="#example">full example</a> of breadth-first traversal algorithm.</p>

 <h4>Skeleton matrix, pixel classifier, current position</h4>

 <p>This class always processes some fixed bit matrix, which is called <i>the scanned skeleton</i>
 and can be retrieved by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A> method, and uses some fixed
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>skeleton pixel classifier</CODE></A>, which has the same number of dimensions
 and can be retrieved by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A> method.
 Inside the scanned skeleton, this class always supports some <i>current position</i>:
 it is just some set of coordinates, which can be set by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A> or
 retrieved by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A>.
 After creation or calling <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#reset()"><CODE>reset()</CODE></A> method, this object is considered to be <i>not
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned</CODE></A></i>, that is the current position is considered to be not set yet and
 most methods throw <tt>IllegalStateException</tt>.</p>

 <h4>Remembering and lightweight skeleton scanners</h4>

 <p>In addition to storing the current position, this class may support storing information about
 visiting some pixels (probably in a form of an internal bit matrix, allocated while instantiation of this object).
 Instances of this class, that support storing this information,
 are called <i>remembering skeleton scanners</i>;
 instances, that do not support this, are called <i>lightweight skeleton scanners</i>.</p>

 <p><b><i>Lightweight skeleton scanners</i></b> do not occupy a lot of memory and can be created quickly,
 and their functionality is enough for scanning a concrete skeleton branch or for classifying
 all skeleton pixels by their types
 (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes(SkeletonPixelClassifier.AttachmentInformation)</CODE></A> method).
 But they do not allow to scan the nonoriented graph, formed by the skeleton, without additional
 efforts for storing visited nodes and branches in some external data structures.</p>

 <p><b><i>Remembering skeleton scanners</i></b> is what you should use in most cases.
 They allow to correctly build a nonoriented graph from nodes and branches, described <a href="#graph">above</a>,
 while a single pass through the skeleton, for example, by a simple loop or by a breadth-first search,
 as shown in the <a href="#example">example of usage</a> below.
 The main feature of a remembering scanner is that it allocates additional memory
 (probably a bit matrix with the same sizes as the scanned skeleton), where it can store the fact of visiting
 some pixels by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> methods,
 and this information is used by some other methods (see the following list of differences in behaviour
 of the methods).</p>

 <p>You can find out, is a skeleton scanner lightweight or remembering, by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>isRemembering()</CODE></A> method.
 Besides this, the following methods work differently in lightweight and remembering skeleton scanners:</p>

 <ul>
 <li>in lightweight scanners, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> do nothing;<br>
 in remembering scanners, these methods mark the corresponding pixels as "visited" and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#reset()"><CODE>reset()</CODE></A> method
 clears this information (makes all pixels "unvisited");</li>
 <li>in lightweight scanners, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()"><CODE>pixelVisitRemembered()</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourVisitRemembered(int)"><CODE>neighbourVisitRemembered(int)</CODE></A>
 always return <tt>false</tt>;<br>
 in remembering scanners, these methods return <tt>true</tt> if
 the corresponding pixels are marked as "visited" by previous calls of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A>;</li>
 <li>in lightweight scanners, <tt>onlyToUnvisited</tt> argument of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>,
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch(boolean, boolean)</CODE></A> methods,
 as well as <tt>withVisiting</tt> argument of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch(boolean, boolean)</CODE></A> methods
 do not matter (as if they would be <tt>false</tt>);<br>
 in remembering scanners, these arguments affect the behaviour (see comments to those methods).</li>
 </ul>

 <p>Note, that in remembering scanners the only ways to mark some pixels as "visited" are explicit direct calls
 of the corresponding methods <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A>.
 You should call these methods manually: this class does not try to mark pixels as "visited" indirectly,
 inside other methods, scanning the skeleton.
 The only exception from this is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch</CODE></A> / <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch</CODE></A>
 methods, which calls <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> when their <tt>withVisiting</tt> argument
 is <tt>true</tt>.</p>

 <h4><a name="connectivity"></a>Connectivity model (straight-and-diagonal) and "neighbour" term</h4>

 <p>Note, that this class, as well as <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonPixelClassifier</CODE></A>, supposes
 the <i>straight-and-diagonal</i> connectivity kind: see
 <A HREF="../../../../net/algart/matrices/scanning/ConnectivityType.html#STRAIGHT_AND_DIAGONAL"><CODE>ConnectivityType.STRAIGHT_AND_DIAGONAL</CODE></A>. It means, that all skeletons
 are supposed to be connected in terms of this connectivity: every connected component of the skeleton matrix
 is a "carcass" or "skeleton" of some connected component of the original matrix, for which this skeleton
 was built.</p>

 <p>So, the term "<b><i>neighbour</i></b>" of some pixel (matrix element) in this class
 and in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonScanner</CODE></A> always means another pixel (matrix element), so that</p>

 <blockquote>max&nbsp;(|<i>i</i><sub><i>k</i></sub>&minus;<i>j</i><sub><i>k</i></sub>|)=1</blockquote>

 <p>where <nobr><i>i</i><sub>0</sub>, <i>i</i><sub>1</sub>, ..., <i>i</i><sub><i>n</i>-1</sub></nobr>
 are coordinates of the first pixel and
 <nobr><i>j</i><sub>0</sub>, <i>j</i><sub>1</sub>, ..., <i>j</i><sub><i>n</i>-1</sub></nobr>
 are coordinates of the second pixel (a neighbour of the first one). In 2-dimensional case,
 such connectivity kind is also called <i>8-connectivity</i>.</p>

 <h4><a name="example"></a>Example of usage</h4>

 <p>Below is a complete example of code, using a remembering skeleton scanner <tt>ss</tt> for breadth-first
 traversal of the nonoriented graph, formed by the skeleton.</p>

 <pre>
 while (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>) {
     ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#checkInterruption()"><CODE>checkInterruption()</CODE></A>;
     ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#updateProgress()"><CODE>updateProgress()</CODE></A>;
     long saveBaseIndex = ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>;
     if (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isUsualBranch()"><CODE>isUsualBranch()</CODE></A>) { // should check cyclic loops here
         ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch</CODE></A>(true, false);
         boolean cyclicBranch = ss.isUsualBranch(); // in particular, not TYPE_ILLEGAL
         if (cyclicBranch) {
             assert ss.currentIndexInArray() == saveBaseIndex; // should return to the same position
             if (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch</CODE></A>(true)) { // can be false if this pixel or its neighbour was visited
                 do {
                     // some processing the cyclic branch segment
                     // from ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previousCoordinates()</CODE></A> to ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A>...
                     ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A>;
                 } while (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>);
             }
             continue;
         } // else we shall now start from the nearest node, but after all return to saveBaseIndex
     }

     if (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNodeOrFreeBranchEnd()"><CODE>isNodeOrFreeBranchEnd()</CODE></A> // necessary check: it is also possible an attached or illegal pixel
         && !ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()"><CODE>pixelVisitRemembered()</CODE></A>) // necessary for correct processing degenerated 0-pixel branches
     {
         Queue<Long> queue = new LinkedList<Long>();
         ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A>;
         queue.add(ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>);
         while (!queue.isEmpty()) {
             long saveIndex = queue.poll();
             ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray</CODE></A>(saveIndex);
             if (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isIllegal()"><CODE>isIllegal()</CODE></A>) {
                 continue; // why not?
             }
             assert ss.isNodeOrFreeBranchEnd() : ss;
             int[] adjacentBranches = ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A> ? ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> : new int[]{-1};
             for (int nb : adjacentBranches) {
                 ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray</CODE></A>(saveIndex);
                 int dnb = nb == -1 ? ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranchNeighbourIndex(boolean)"><CODE>firstStepFromBranchNeighbourIndex</CODE></A>(false) : nb;
                 boolean degeneratedBranch = ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNeighbourNodeOrFreeBranchEnd(int)"><CODE>isNeighbourNodeOrFreeBranchEnd</CODE></A>(dnb);
                 // Special case: we cannot mark 0-pixel degenerated branches between 2 neighbouring nodes
                 // as "visited", because they contain no internal pixels, and we can store visiting
                 // information in the remembering scanner for pixels only.
                 // However, we still need to process degenerated branches, and only 1 time for each branch.
                 // Let's scan such a branch if and only if the neighbour:
                 // 1) is not visited yet or
                 // 2) is inside the queue.
                 // Then every degenerated branch PQ will be processed strictly 1 time.
                 // Proof.
                 // Note that pixels are visited at the moment when they are added to the queue.
                 // Let's suppose that P appears the first in this loop (as the pixel at "saveIndex").
                 // At this moment, Q is either not visited, or added to the queue, but not removed
                 // from it yet (because P appears here before it). So, we'll really process PQ branch.
                 // On the other hand, when Q will appear in this loop (as the pixel at "saveIndex"),
                 // P will be already removed from the queue, so we'll not process PQ branch twice.
                 // This completes the proof.
                 if (degeneratedBranch && (
                     !ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourVisitRemembered(int)"><CODE>neighbourVisitRemembered</CODE></A>(dnb) || queue.contains(ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourIndexInArray(int)"><CODE>neighbourIndexInArray</CODE></A>(dnb))))
                 {
                     // some processing the degenerated branch
                     // from ss.currentCoordinates() to ss.neighbourCoordinates(nb)...
                 }
                 if (!(nb == -1 ? ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch</CODE></A>(true) : ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep</CODE></A>(nb, true))) {
                     continue;
                 }
                 if (!degeneratedBranch) {
                     do {
                         // some processing the branch segment
                         // from ss.previousCoordinates() to ss.currentCoordinates()...
                         ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A>;
                     } while (ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>);
                 }
                 if (!ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()"><CODE>pixelVisitRemembered()</CODE></A>) {
                     ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A>;
                     queue.add(ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>);
                 }
             }
         }
     }
     ss.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray</CODE></A>(saveBaseIndex);
 }
 </pre>

 <p>Of course, you can use another order of graph traversal, for example, depth-first.
 Note that some applications do not need depth-first or breadth-first order at all:
 it can be enough to find and detect nodes and edges in any order.
 In this case, you can just remove all operations with the queue.</p>

 <p>Also note: you can process degenerated 0-pixel branches in a common way, just by assigning
 <tt>degeneratedBranch=false</tt> instead of calling <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNeighbourNodeOrFreeBranchEnd(int)"><CODE>isNeighbourNodeOrFreeBranchEnd</CODE></A> method in the example above.
 In this case, breadth-first traversal algorithm will form slightly incorrect graph, namely, some degenerated
 branches will not be processed, and it can lead to appearing graph nodes with 2 incident edges
 (with low probability). However, the resulting graph will still be good enough, with connected components
 corresponding to connected components of the skeleton, maybe even better than the full correct graph
 with all degenerated branches in a role of edges.</p>

 <h4>Creating instances of this class</h4>

 <p>This class is designed for a case of any number of dimensions, though, of course, the most popular
 case is 2-dimensional. You can create an instance of this class by the following basic methods:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getRememberingInstance(ArrayContext, Matrix, SkeletonPixelClassifier)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getLightweightInstance(ArrayContext, Matrix, SkeletonPixelClassifier)</CODE></A></li>
 </ul>

 <p>and also by the following methods, designed for using 2-dimensional pixel classifier
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html" title="class in net.algart.matrices.skeletons"><CODE>BasicSkeletonPixelClassifier2D</CODE></A>:</p>

 <ul>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingOctupleThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><CODE>getRememberingOctupleThinningInstance2D(ArrayContext, Matrix)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightOctupleThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><CODE>getLightweightOctupleThinningInstance2D(ArrayContext, Matrix)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><CODE>getRememberingQuadruple3x5ThinningInstance2D(ArrayContext, Matrix)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><CODE>getLightweightQuadruple3x5ThinningInstance2D(ArrayContext, Matrix)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingStrongQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><CODE>getRememberingStrongQuadruple3x5ThinningInstance2D(ArrayContext, Matrix)</CODE></A>,</li>
 <li><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightStrongQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><CODE>getLightweightStrongQuadruple3x5ThinningInstance2D(ArrayContext, Matrix)</CODE></A>.</li>
 </ul>

 <h4>Pseudo-cyclic continuation</h4>

 <p>This class supposes that the processed matrix is infinitely pseudo-cyclically continued, as well
 <A HREF="../../../../net/algart/arrays/Matrices.html#asShifted(net.algart.arrays.Matrix, long...)"><CODE>Matrices.asShifted</CODE></A> method supposes it.
 You can change this behavior by appending the source matrix with zero elements
 by calling <nobr><A HREF="../../../../net/algart/arrays/Matrix.html#subMatrix(long[], long[], net.algart.arrays.Matrix.ContinuationMode)"><CODE>Matrix.subMatrix(long[], long[], Matrix.ContinuationMode)</CODE></A></nobr> method,
 where the dimensions of the "submatrix" are greater than dimensions of the source one by 1
 and the <tt>continuationMode</tt> argument is <A HREF="../../../../net/algart/arrays/Matrix.ContinuationMode.html#ZERO_CONSTANT"><CODE>Matrix.ContinuationMode.ZERO_CONSTANT</CODE></A>.</p>

 <h4>Multithread compatibility</h4>

 <p>This class is not thread-safe, but <b>is thread-compatible</b>
 and can be synchronized manually, if multithread access is necessary.</p>

 <p>AlgART Laboratory 2007&ndash;2014</p>
<P>

<P>
<DL>
<DT><STRONG>Since:</STRONG></DT>
  <DD>JDK 1.5</DD>
<DT><STRONG>Version:</STRONG></DT>
  <DD>1.2</DD>
<DT><STRONG>Author:</STRONG></DT>
  <DD>Daniel Alievsky</DD>
<DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>SkeletonPixelClassifier</CODE></A></DD></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="Method Summary table, listing methods, and an explanation">
<CAPTION CLASS="TableCaption">
Method Summary</CAPTION>
<TR>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Modifier and Type</TH>
<TH CLASS="TableHeader" SCOPE="col" NOWRAP>Method and Description</TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()">adjacentBranches</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>node</CODE></A>,
 returns indexes of all its neighbours, which are the starting pixels of branches, incident with this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches(int[])">adjacentBranches</A></STRONG>(int[]&nbsp;result)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> method, which stores the results
 in the passed Java array instead of creating new Java array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)">asPixelTypes</A></STRONG>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A>&nbsp;attachmentInformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>, attachmentInformation)</tt>,
 but probably works faster.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#checkInterruption()">checkInterruption</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt>
 or does nothing if <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>==null</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()">context</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current context used by this instance for some operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()">currentCoordinates</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current coordinates (or throws <tt>IllegalStateException</tt> if the scanner
 was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()">currentIndexInArray</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()">currentPixelTypeOrAttachedNode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of the current pixel of the skeleton matrix or, if it is an attachable branch end,
 returns the index of its neighbour, which is a node, which is one of the ends of the branch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()">currentPixelTypeOrAttachingBranch</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of the current pixel of the skeleton matrix or, if it is an attachable branch end,
 returns the index of its neighbour, which lies at the branch, to which this pixel should be attached.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelValue()">currentPixelValue</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the element of the skeleton matrix at
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current coordinates</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#dimCount()">dimCount</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)">firstStep</A></STRONG>(int&nbsp;neighbourIndex,
          boolean&nbsp;onlyToUnvisited)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is a
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>node or isolated pixel</CODE></A>,
 checks whether we have a skeleton branch, originating at this node and going towards its neighbour
 with the index <tt>neighbourIndex</tt>, and, if so, moves the current position to this neighbour and
 returns <tt>true</tt>, if not, does nothing and returns <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)">firstStepFromBranch</A></STRONG>(boolean&nbsp;onlyToUnvisited)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>some branch pixel</CODE></A>,
 moves the current position to a neighbour along this skeleton branch and returns <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranchNeighbourIndex(boolean)">firstStepFromBranchNeighbourIndex</A></STRONG>(boolean&nbsp;onlyToUnvisited)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the index of the neighbour, to which <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean onlyToUnvisited)</CODE></A> moves
 when called with the same <tt>onlyToUnvisited</tt> argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getCompatibleLightweightInstance()">getCompatibleLightweightInstance</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new instance of this class with the identical behaviour, excepting
 that the returned object is always lightweight skeleton scanner (not remembering visits of pixels).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getCompatibleRememberingInstance()">getCompatibleRememberingInstance</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new instance of this class with the identical behaviour, excepting
 that the returned object is always remembering skeleton scanner (remembering visits of pixels).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)">getLightweightInstance</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
                       <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A>&nbsp;pixelClassifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix
 on the base of the given pixel classifier.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightOctupleThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)">getLightweightOctupleThinningInstance2D</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                        <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/OctupleThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>OctupleThinningSkeleton2D</CODE></A> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)">getLightweightQuadruple3x5ThinningInstance2D</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                             <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>Quadruple3x5ThinningSkeleton2D</CODE></A> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightStrongQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)">getLightweightStrongQuadruple3x5ThinningInstance2D</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                   <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>StrongQuadruple3x5ThinningSkeleton2D</CODE></A> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)">getRememberingInstance</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                       <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
                       <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A>&nbsp;pixelClassifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix
 on the base of the given pixel classifier.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingOctupleThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)">getRememberingOctupleThinningInstance2D</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                        <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/OctupleThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>OctupleThinningSkeleton2D</CODE></A> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)">getRememberingQuadruple3x5ThinningInstance2D</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                             <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>Quadruple3x5ThinningSkeleton2D</CODE></A> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingStrongQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)">getRememberingStrongQuadruple3x5ThinningInstance2D</A></STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                   <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>StrongQuadruple3x5ThinningSkeleton2D</CODE></A> algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)">goTo</A></STRONG>(long...&nbsp;newCurrentCoordinates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current position in the skeleton matrix to the specified coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)">goToIndexInArray</A></STRONG>(long&nbsp;newIndexInArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToNeighbour(int)">goToNeighbour</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the current position in the skeleton matrix to the given neighbour of the current element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isAttachableBranchEnd()">isAttachableBranchEnd</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>,
 i&#46;e&#46; a unit pixel having 3 or more unit neighbours,
 which this class considers to be not a node, but an ending pixel of some branch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()">isBranch</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a branch element: usual
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isUsualBranch()"><CODE>isUsualBranch()</CODE></A></tt>
 returns <tt>true</tt>), free branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isFreeBranchEnd()"><CODE>isFreeBranchEnd()</CODE></A></tt> returns <tt>true</tt>)
 or attachable branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isAttachableBranchEnd()"><CODE>isAttachableBranchEnd()</CODE></A></tt>
 returns <tt>true</tt>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isFreeBranchEnd()">isFreeBranchEnd</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>,
 i&#46;e&#46; a unit pixel having exactly 1 unit neighbour.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isIllegal()">isIllegal</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illtegal</CODE></A>", i&#46;e&#46; a center of
 an impossible configuration for a correct result of the given skeletonization algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()">isInitialized</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if and only if this instance was positioned to some coordinates in the skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNeighbourNodeOrFreeBranchEnd(int)">isNeighbourNodeOrFreeBranchEnd</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the neighbour with the given index of
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>
 or a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()">isNode</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, i&#46;e&#46; a unit element
 where 3 or more thin connected 1-pixel branches meet or, as a degenerated case,
 an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixel</CODE></A>:
 a unit element having no unit neighbours.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNodeOrFreeBranchEnd()">isNodeOrFreeBranchEnd</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a node
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A></tt> returns <tt>true</tt>)
 or a free branch end
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isFreeBranchEnd()"><CODE>isFreeBranchEnd()</CODE></A></tt> returns <tt>true</tt>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()">isRemembering</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this scanner is remembering or <tt>false</tt> if it is lightweight.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isUsualBranch()">isUsualBranch</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixel</CODE></A>,
 i&#46;e&#46; a unit pixel having exactly 2 unit neighbours.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourCoordinates(int)">neighbourCoordinates</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coordinates of the element of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourIndexInArray(int)">neighbourIndexInArray</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourCoordinates(int)"><CODE>neighbourCoordinates(int)</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)">neighbourOffsetInArray</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixel classifier</CODE></A>,
 designed for indexing elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachedNode(int)">neighbourTypeOrAttachedNode</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of the pixel of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>, or, if it is an attachable branch end,
 returns the index of a neighbour of this neighbour, which is a node, which is one of the ends of the branch.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)">neighbourTypeOrAttachingBranch</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of the pixel of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>, or, if it is an attachable branch end,
 returns the index of a neighbour of this neighbour, which lies at the branch,
 to which this neighbour should be attached.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourValue(int)">neighbourValue</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the element of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourVisitRemembered(int)">neighbourVisitRemembered</A></STRONG>(int&nbsp;neighbourIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> and
 the neighbour of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> with the given index
 was already visited by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()">nextNodeOrBranch</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the next unit element in the skeleton matrix (in natural order of elements) <i>after</i>
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current position</CODE></A>, the type of which is
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated</CODE></A>
 or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>some branch pixel</CODE></A>, and moves the current position to this element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranchPixelType()">nextNodeOrBranchPixelType</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enhanced version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>, which returns the type of the successfully found element
 in the result or return <tt>null</tt> if the required element is not found.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()">nextStep</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continues movement along the skeleton branch, started by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> method, and returns <tt>true</tt>,
 if the end of the current branch is not reached yet, or does nothing and returns <tt>false</tt>
 if we have reached the end of the branch (usually a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()">numberOfNeighbours</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A></tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A></CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()">pixelClassifier</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the pixel classifier, used by this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()">pixelVisitRemembered</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <tt>true</tt> if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> and
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> was already visited by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousBranchStepDirection()">previousBranchStepDirection</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an index of the neighbour, towards which the current position was moved
 by the previous change of the current position via
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> method,
 or <tt>-1</tt> if the previous change of the current position was performed by some other method
 like <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()">previousCoordinates</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coordinates of the neighbour of the current element, which was current before the last change
 of the current position, if this change was performed via
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> method,
 or throws <tt>IllegalStateException</tt> if the previous change of the current position was performed
 by some other method like <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousIndexInArray()">previousIndexInArray</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previousCoordinates()</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#reset()">reset</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the state of this scanner: resets the current position to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>not positioned</CODE></A> state
 and, in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanners, resets the state of all pixels to
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()"><CODE>unvisited</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)">scanBranch</A></STRONG>(int&nbsp;neighbourIndex,
           boolean&nbsp;onlyToUnvisited,
           boolean&nbsp;withVisiting)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is a
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>node or isolated pixel</CODE></A>,
 completely scans the branch, originating at this node and going towards its neighbour with the given index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)">scanBranchFromBranch</A></STRONG>(boolean&nbsp;onlyToUnvisited,
                     boolean&nbsp;withVisiting)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>some branch pixel</CODE></A>,
 scans the part of this branch towards one of the sides of the current pixel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()">skeleton</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the skeleton, scanned by this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#toString()">toString</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a brief string description of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#updateProgress()">updateProgress</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>.<A HREF="../../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress(event)</CODE></A></tt>
 with an event, created by the following operator:
 <nobr><tt>new ArrayContext.Event(boolean.class, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>)</tt></nobr>,
 or does nothing if <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>==null</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()">visit</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanners,
 marks the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton matrix as "visited".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><STRONG><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()">visitPreviousBranchPixel</A></STRONG>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanners,
 marks the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previous visited element</CODE></A> of the skeleton matrix as "visited".</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><STRONG>Methods inherited from class java.lang.Object</STRONG></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<STRONG>Method Detail</STRONG></FONT></TH>
</TR>
</TABLE>

<A NAME="getRememberingInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><!-- --></A><H3>
getRememberingInstance</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getRememberingInstance</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
                                                     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A>&nbsp;pixelClassifier)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix
 on the base of the given pixel classifier.
 See the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A> about remembering and lightweight skeleton scanners.

 <p>The passed matrix is supposed to be a final result of some skeletonization algorithm, for example,
 provided by this package. If it is not so, the passed pixel classifier scanner will probably consider many
 unit pixels of this matrix as "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A>", so
 the branches and nodes found by this class will not form a correct skeletal graph.
 The same situation is also possible if the passed pixel classifier does not match the algorithm,
 used for skeletonization.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                        may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD><DD><CODE>pixelClassifier</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixel classifier</CODE></A>, which will be used by this scanner
                        for detecting types of all pixels.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> or <tt>pixelClassifier</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=pixelClassifier.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getRememberingOctupleThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><!-- --></A><H3>
getRememberingOctupleThinningInstance2D</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getRememberingOctupleThinningInstance2D</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                                      <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/OctupleThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>OctupleThinningSkeleton2D</CODE></A> algorithm.
 Equivalent to<br>
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getRememberingInstance</CODE></A>(context, skeleton,
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html#getOctupleThinningInstance()"><CODE>BasicSkeletonPixelClassifier2D.getOctupleThinningInstance()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                  may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getRememberingQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><!-- --></A><H3>
getRememberingQuadruple3x5ThinningInstance2D</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getRememberingQuadruple3x5ThinningInstance2D</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                                           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>Quadruple3x5ThinningSkeleton2D</CODE></A> algorithm.
 Equivalent to<br>
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getRememberingInstance</CODE></A>(context, skeleton,
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html#getQuadruple3x5ThinningInstance()"><CODE>BasicSkeletonPixelClassifier2D.getQuadruple3x5ThinningInstance()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                  may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getRememberingStrongQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><!-- --></A><H3>
getRememberingStrongQuadruple3x5ThinningInstance2D</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getRememberingStrongQuadruple3x5ThinningInstance2D</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                                                 <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>StrongQuadruple3x5ThinningSkeleton2D</CODE></A> algorithm.
 Equivalent to<br>
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getRememberingInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getRememberingInstance</CODE></A>(context, skeleton,
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html#getStrongQuadruple3x5ThinningInstance()"><CODE>BasicSkeletonPixelClassifier2D.getStrongQuadruple3x5ThinningInstance()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                  may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getLightweightInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><!-- --></A><H3>
getLightweightInstance</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getLightweightInstance</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                     <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton,
                                                     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A>&nbsp;pixelClassifier)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix
 on the base of the given pixel classifier.
 See the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A> about remembering and lightweight skeleton scanners.

 <p>The passed matrix is supposed to be a final result of some skeletonization algorithm, for example,
 provided by this package. If it is not so, the passed pixel classifier scanner will probably consider many
 unit pixels of this matrix as "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A>", so
 the branches and nodes found by this class will not form a correct skeletal graph.
 The same situation is also possible if the passed pixel classifier does not match the algorithm,
 used for skeletonization.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                        may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD><DD><CODE>pixelClassifier</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixel classifier</CODE></A>, which will be used by this scanner
                        for detecting types of all pixels.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> or <tt>pixelClassifier</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=pixelClassifier.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getLightweightOctupleThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><!-- --></A><H3>
getLightweightOctupleThinningInstance2D</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getLightweightOctupleThinningInstance2D</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                                      <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/OctupleThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>OctupleThinningSkeleton2D</CODE></A> algorithm.
 Equivalent to<br>
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getLightweightInstance</CODE></A>(context, skeleton,
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html#getOctupleThinningInstance()"><CODE>BasicSkeletonPixelClassifier2D.getOctupleThinningInstance()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                  may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getLightweightQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><!-- --></A><H3>
getLightweightQuadruple3x5ThinningInstance2D</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getLightweightQuadruple3x5ThinningInstance2D</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                                           <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/Quadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>Quadruple3x5ThinningSkeleton2D</CODE></A> algorithm.
 Equivalent to<br>
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getLightweightInstance</CODE></A>(context, skeleton,
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html#getQuadruple3x5ThinningInstance()"><CODE>BasicSkeletonPixelClassifier2D.getQuadruple3x5ThinningInstance()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                  may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getLightweightStrongQuadruple3x5ThinningInstance2D(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix)"><!-- --></A><H3>
getLightweightStrongQuadruple3x5ThinningInstance2D</H3>
<PRE>
public static <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getLightweightStrongQuadruple3x5ThinningInstance2D</STRONG>(<A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A>&nbsp;context,
                                                                                 <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt;&nbsp;skeleton)</PRE>
<DL>
<DD>Creates new remembering skeleton scanner, which will process the given <tt>skeleton</tt> matrix,
 supposed to be the final result of skeletonization by <A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><CODE>StrongQuadruple3x5ThinningSkeleton2D</CODE></A> algorithm.
 Equivalent to<br>
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#getLightweightInstance(net.algart.arrays.ArrayContext, net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier)"><CODE>getLightweightInstance</CODE></A>(context, skeleton,
 <A HREF="../../../../net/algart/matrices/skeletons/BasicSkeletonPixelClassifier2D.html#getStrongQuadruple3x5ThinningInstance()"><CODE>BasicSkeletonPixelClassifier2D.getStrongQuadruple3x5ThinningInstance()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>context</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context</CODE></A> that will be used by this object;
                  may be <tt>null</tt>, then it will be ignored.</DD><DD><CODE>skeleton</CODE> - the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton</CODE></A>: a bit matrix that should be processed by this scanner.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>new instance of this class.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>matrix</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>skeleton.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A>!=2</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="context()"><!-- --></A><H3>
context</H3>
<PRE>
public <A HREF="../../../../net/algart/arrays/ArrayContext.html" title="interface in net.algart.arrays">ArrayContext</A> <STRONG>context</STRONG>()</PRE>
<DL>
<DD>Returns the current context used by this instance for some operations.
 This context is specified while creating an instance of this class.
 It is used, for example, in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch(boolean, boolean)</CODE></A> methods.
<P>
</DD>
<DD><DL>
<DT><STRONG>Specified by:</STRONG></DT><DD><CODE><A HREF="../../../../net/algart/arrays/ArrayProcessor.html#context()">context</A></CODE> in interface <CODE><A HREF="../../../../net/algart/arrays/ArrayProcessor.html" title="interface in net.algart.arrays">ArrayProcessor</A></CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current context used by this instance; may be <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getCompatibleRememberingInstance()"><!-- --></A><H3>
getCompatibleRememberingInstance</H3>
<PRE>
public <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getCompatibleRememberingInstance</STRONG>()</PRE>
<DL>
<DD>Creates new instance of this class with the identical behaviour, excepting
 that the returned object is always remembering skeleton scanner (remembering visits of pixels).
 See the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A> about remembering and lightweight skeleton scanners.

 <p>The returned scanner is always newly created instance (in particular,
 not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned</CODE></A>), even if this instance is remembering.
 So, this method usually leads to allocating necessary amount of memory.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the remembering version of this scanner.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="getCompatibleLightweightInstance()"><!-- --></A><H3>
getCompatibleLightweightInstance</H3>
<PRE>
public <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons">SkeletonScanner</A> <STRONG>getCompatibleLightweightInstance</STRONG>()</PRE>
<DL>
<DD>Creates new instance of this class with the identical behaviour, excepting
 that the returned object is always lightweight skeleton scanner (not remembering visits of pixels).
 See the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A> about remembering and lightweight skeleton scanners.

 <p>The returned scanner is always newly created instance (in particular,
 not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned</CODE></A>), even if this instance is lightweight.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the lightweight version of this scanner.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="skeleton()"><!-- --></A><H3>
skeleton</H3>
<PRE>
public <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/BitArray.html" title="interface in net.algart.arrays">BitArray</A>&gt; <STRONG>skeleton</STRONG>()</PRE>
<DL>
<DD>Returns a reference to the skeleton, scanned by this object.
 It is usually specified while creating an instance of this object.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the skeleton, scanned by this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pixelClassifier()"><!-- --></A><H3>
pixelClassifier</H3>
<PRE>
public <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons">SkeletonPixelClassifier</A> <STRONG>pixelClassifier</STRONG>()</PRE>
<DL>
<DD>Returns a reference to the pixel classifier, used by this object.
 It is usually specified while creating an instance of this object.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a reference to the pixel classifier, used by this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="dimCount()"><!-- --></A><H3>
dimCount</H3>
<PRE>
public int <STRONG>dimCount</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.
 Always equal to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#dimCount()"><CODE>dimCount()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of dimensions of the matrices, which can be processed by this object.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="numberOfNeighbours()"><!-- --></A><H3>
numberOfNeighbours</H3>
<PRE>
public int <STRONG>numberOfNeighbours</STRONG>()</PRE>
<DL>
<DD>Equivalent to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A></tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of neighbours of each element of a skeleton matrix.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourOffsetInArray(int)"><!-- --></A><H3>
neighbourOffsetInArray</H3>
<PRE>
public long <STRONG>neighbourOffsetInArray</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A> method of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixel classifier</CODE></A>,
 designed for indexing elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.
 This method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#pseudoCyclicIndex(long...)"><CODE>pseudoCyclicIndex</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset</CODE></A>(neighbourIndex))</tt></nobr>,
 but usually works much faster (in particular, does not allocate any arrays).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - an index if the neighbour of some central element of the matrix.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>non-negative increment of the index in the built-in AlgART array of the skeleton matrix,
                       corresponding to the shift from the central element to this neighbour.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><!-- --></A><H3>
asPixelTypes</H3>
<PRE>
public <A HREF="../../../../net/algart/arrays/Matrix.html" title="interface in net.algart.arrays">Matrix</A>&lt;? extends <A HREF="../../../../net/algart/arrays/PIntegerArray.html" title="interface in net.algart.arrays">PIntegerArray</A>&gt; <STRONG>asPixelTypes</STRONG>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons">SkeletonPixelClassifier.AttachmentInformation</A>&nbsp;attachmentInformation)</PRE>
<DL>
<DD>Equivalent to
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>, attachmentInformation)</tt>,
 but probably works faster.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>attachmentInformation</CODE> - what should this method return for attachable pixels.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the matrix of integer codes with the same sizes as the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>scanned skeleton matrix</CODE></A>, describing the types of all skeleton pixels.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>attachmentInformation</tt> is <tt>null</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isInitialized()"><!-- --></A><H3>
isInitialized</H3>
<PRE>
public boolean <STRONG>isInitialized</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if and only if this instance was positioned to some coordinates in the skeleton matrix.
 More precisely, returns <tt>false</tt> if this instance was newly created and none from
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranchPixelType()"><CODE>nextNodeOrBranchPixelType()</CODE></A>,
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray(long)</CODE></A> methods were called yet,
 or <tt>true</tt> in all other cases.
 If this object is not positioned, most of methods, processing pixels in the current position,
 throw <tt>IllegalStateException</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if and only if this instance was already positioned by
                       <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> / <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranchPixelType()"><CODE>nextNodeOrBranchPixelType()</CODE></A>
                       or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A> / <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray(long)</CODE></A> methods.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="currentCoordinates()"><!-- --></A><H3>
currentCoordinates</H3>
<PRE>
public long[] <STRONG>currentCoordinates</STRONG>()</PRE>
<DL>
<DD>Returns the current coordinates (or throws <tt>IllegalStateException</tt> if the scanner
 was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>).

 <p>The returned array is always a newly allocated Java array.
 Its length is always equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#dimCount()"><CODE>dimCount()</CODE></A>.
 The returned coordinates are always in ranges
 <pre>
 0 &le; result[<i>k</i>] &lt; <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>),
 </pre>where <tt>result[<i>k</i>]</tt> is the element <tt>#<i>k</i></tt> in the returned array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current coordinates in the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="currentIndexInArray()"><!-- --></A><H3>
currentIndexInArray</H3>
<PRE>
public long <STRONG>currentIndexInArray</STRONG>()</PRE>
<DL>
<DD>Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.
 This method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A>)</tt></nobr>,
 but usually works much faster (in particular, does not allocate any arrays).
 It is very possible that the implementation really stores the current index, returned by this method,
 and does not store an array of current coordinates: so, this method just returns an internal field,
 but <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A> calculates results on the base on this value.

 <p>The result of this method is always in range
 <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the current index in the built-in AlgART array of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray(long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="currentPixelValue()"><!-- --></A><H3>
currentPixelValue</H3>
<PRE>
public boolean <STRONG>currentPixelValue</STRONG>()</PRE>
<DL>
<DD>Returns the value of the element of the skeleton matrix at
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current coordinates</CODE></A>.
 Equivalent to <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton"><CODE>skeleton()()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/BitArray.html#getBit(long)"><CODE>getBit</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>)</tt></nobr>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the value of the current element of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="currentPixelTypeOrAttachingBranch()"><!-- --></A><H3>
currentPixelTypeOrAttachingBranch</H3>
<PRE>
public int <STRONG>currentPixelTypeOrAttachingBranch</STRONG>()</PRE>
<DL>
<DD>Returns the type of the current pixel of the skeleton matrix or, if it is an attachable branch end,
 returns the index of its neighbour, which lies at the branch, to which this pixel should be attached.
 Equivalent to <nobr><tt>m.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PFixedArray.html#getInt(long)"><CODE>getInt</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>)</tt></nobr>, where
 <pre>
 m = <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A>)
 </pre>
 but probably works faster.
 See comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method for more details.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of the current pixel of the skeleton matrix or (for attachable branch end)
         the direction towards the branch, to which this pixel should be attached.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)"><CODE>neighbourTypeOrAttachingBranch(int)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachedNode(int)"><CODE>neighbourTypeOrAttachedNode(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="currentPixelTypeOrAttachedNode()"><!-- --></A><H3>
currentPixelTypeOrAttachedNode</H3>
<PRE>
public int <STRONG>currentPixelTypeOrAttachedNode</STRONG>()</PRE>
<DL>
<DD>Returns the type of the current pixel of the skeleton matrix or, if it is an attachable branch end,
 returns the index of its neighbour, which is a node, which is one of the ends of the branch.
 Equivalent to <nobr><tt>m.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PFixedArray.html#getInt(long)"><CODE>getInt</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>)</tt></nobr>, where
 <pre>
 m = <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A>)
 </pre>
 but probably works faster.
 See comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#asPixelTypes(net.algart.arrays.Matrix, net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> method for more details.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of the current pixel of the skeleton matrix or (for attachable branch end)
         the direction towards the node, which is one of the branch ends.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)"><CODE>neighbourTypeOrAttachingBranch(int)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachedNode(int)"><CODE>neighbourTypeOrAttachedNode(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourCoordinates(int)"><!-- --></A><H3>
neighbourCoordinates</H3>
<PRE>
public long[] <STRONG>neighbourCoordinates</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns the coordinates of the element of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>.
 Equivalent to <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#coordinates(long, long[])"><CODE>coordinates</CODE></A>(index, null)</tt></nobr>, where
 <pre>
 index = (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A> + <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>neighbourOffsetInArray</CODE></A>(neighbourIndex)) % <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>
 </pre>
 Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.

 <p>The returned array is always a newly allocated Java array.
 Its length is always equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#dimCount()"><CODE>dimCount()</CODE></A>.
 The returned coordinates are always in ranges
 <pre>
 0 &le; result[<i>k</i>] &lt; <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>),
 </pre>where <tt>result[<i>k</i>]</tt> is the element <tt>#<i>k</i></tt> in the returned array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the coordinates of the given neighbour of the current element of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourIndexInArray(int)"><CODE>neighbourIndexInArray(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourIndexInArray(int)"><!-- --></A><H3>
neighbourIndexInArray</H3>
<PRE>
public long <STRONG>neighbourIndexInArray</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourCoordinates(int)"><CODE>neighbourCoordinates(int)</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.
 Equivalent to
 <pre>
 (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A> + <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>neighbourOffsetInArray</CODE></A>(neighbourIndex)) % <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>
 </pre>
 Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.

 <p>The result of this method is always in range
 <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the index in the built-in AlgART array of the given neighbour of the current element
                       of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray(long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourValue(int)"><!-- --></A><H3>
neighbourValue</H3>
<PRE>
public boolean <STRONG>neighbourValue</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns the value of the element of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>.
 Equivalent to <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/BitArray.html#getBit(long)"><CODE>getBit</CODE></A>(index)</tt></nobr>, where
 <pre>
 index = (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A> + <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>neighbourOffsetInArray</CODE></A>(neighbourIndex)) % <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>
 </pre>
 Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the value of the given neighbour of the current element of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourTypeOrAttachingBranch(int)"><!-- --></A><H3>
neighbourTypeOrAttachingBranch</H3>
<PRE>
public int <STRONG>neighbourTypeOrAttachingBranch</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns the type of the pixel of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>, or, if it is an attachable branch end,
 returns the index of a neighbour of this neighbour, which lies at the branch,
 to which this neighbour should be attached.
 Equivalent to <nobr><tt>m.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PFixedArray.html#getInt(long)"><CODE>getInt</CODE></A>(index)</tt></nobr>, where
 <pre>
 m = <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHING_BRANCH</CODE></A>)
 index = (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A> + <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>neighbourOffsetInArray</CODE></A>(neighbourIndex)) % <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>
 </pre>
 Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the value of the given neighbour of the current element of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachedNode(int)"><CODE>neighbourTypeOrAttachedNode(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourTypeOrAttachedNode(int)"><!-- --></A><H3>
neighbourTypeOrAttachedNode</H3>
<PRE>
public int <STRONG>neighbourTypeOrAttachedNode</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns the type of the pixel of the skeleton matrix, which is a neighbour with the given index
 of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A>, or, if it is an attachable branch end,
 returns the index of a neighbour of this neighbour, which is a node, which is one of the ends of the branch.
 Equivalent to <nobr><tt>m.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PFixedArray.html#getInt(long)"><CODE>getInt</CODE></A>(index)</tt></nobr>, where
 <pre>
 m = <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html#NEIGHBOUR_INDEX_OF_ATTACHED_NODE"><CODE>SkeletonPixelClassifier.AttachmentInformation.NEIGHBOUR_INDEX_OF_ATTACHED_NODE</CODE></A>)
 index = (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A> + <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>neighbourOffsetInArray</CODE></A>(neighbourIndex)) % <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>
 </pre>
 Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the value of the given neighbour of the current element of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)"><CODE>neighbourTypeOrAttachingBranch(int)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="isNode()"><!-- --></A><H3>
isNode</H3>
<PRE>
public boolean <STRONG>isNode</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, i&#46;e&#46; a unit element
 where 3 or more thin connected 1-pixel branches meet or, as a degenerated case,
 an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixel</CODE></A>:
 a unit element having no unit neighbours.
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)"><CODE>SkeletonPixelClassifier.isNodePixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodePixelType(int)"><CODE>SkeletonPixelClassifier.isNodePixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is a node,
         including the degenerated case of an isolated pixel.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isUsualBranch()"><!-- --></A><H3>
isUsualBranch</H3>
<PRE>
public boolean <STRONG>isUsualBranch</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixel</CODE></A>,
 i&#46;e&#46; a unit pixel having exactly 2 unit neighbours.
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isUsualBranchPixelType(int)"><CODE>SkeletonPixelClassifier.isUsualBranchPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isUsualBranchPixelType(int)"><CODE>SkeletonPixelClassifier.isUsualBranchPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is
         a usual (non-ending) branch pixel.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isFreeBranchEnd()"><!-- --></A><H3>
isFreeBranchEnd</H3>
<PRE>
public boolean <STRONG>isFreeBranchEnd</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>,
 i&#46;e&#46; a unit pixel having exactly 1 unit neighbour.
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isFreeBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isFreeBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isFreeBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is
         a free branch end.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isAttachableBranchEnd()"><!-- --></A><H3>
isAttachableBranchEnd</H3>
<PRE>
public boolean <STRONG>isAttachableBranchEnd</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>,
 i&#46;e&#46; a unit pixel having 3 or more unit neighbours,
 which this class considers to be not a node, but an ending pixel of some branch.
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isAttachableBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isAttachableBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is
         an attachable branch end.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isNodeOrFreeBranchEnd()"><!-- --></A><H3>
isNodeOrFreeBranchEnd</H3>
<PRE>
public boolean <STRONG>isNodeOrFreeBranchEnd</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a node
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A></tt> returns <tt>true</tt>)
 or a free branch end
 (<tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isFreeBranchEnd()"><CODE>isFreeBranchEnd()</CODE></A></tt> returns <tt>true</tt>).
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodeOrFreeBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isNodeOrFreeBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodeOrFreeBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isNodeOrFreeBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is
         a node or a free branch end.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isBranch()"><!-- --></A><H3>
isBranch</H3>
<PRE>
public boolean <STRONG>isBranch</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a branch element: usual
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isUsualBranch()"><CODE>isUsualBranch()</CODE></A></tt>
 returns <tt>true</tt>), free branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isFreeBranchEnd()"><CODE>isFreeBranchEnd()</CODE></A></tt> returns <tt>true</tt>)
 or attachable branch end
 (where <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isAttachableBranchEnd()"><CODE>isAttachableBranchEnd()</CODE></A></tt>
 returns <tt>true</tt>).
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isBranchPixelType(int)"><CODE>SkeletonPixelClassifier.isBranchPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isBranchPixelType(int)"><CODE>SkeletonPixelClassifier.isBranchPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is
         some element of a branch.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isIllegal()"><!-- --></A><H3>
isIllegal</H3>
<PRE>
public boolean <STRONG>isIllegal</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illtegal</CODE></A>", i&#46;e&#46; a center of
 an impossible configuration for a correct result of the given skeletonization algorithm.
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isIllegalPixelType(int)"><CODE>SkeletonPixelClassifier.isIllegalPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isIllegalPixelType(int)"><CODE>SkeletonPixelClassifier.isIllegalPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>)</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton is
         a part of pixel configuration which is incorrect for the given type of skeleton.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isNeighbourNodeOrFreeBranchEnd(int)"><!-- --></A><H3>
isNeighbourNodeOrFreeBranchEnd</H3>
<PRE>
public boolean <STRONG>isNeighbourNodeOrFreeBranchEnd</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns <tt>true</tt> if the neighbour with the given index of
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton
 is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>
 or a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>.
 Equivalent both to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodeOrFreeBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isNodeOrFreeBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)"><CODE>neighbourTypeOrAttachingBranch(neighbourIndex)</CODE></A>)</tt>
 and to <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isNodeOrFreeBranchEndPixelType(int)"><CODE>SkeletonPixelClassifier.isNodeOrFreeBranchEndPixelType</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachedNode(int)"><CODE>neighbourTypeOrAttachedNode(neighbourIndex)</CODE></A>)</tt>.

 <p>This method is helpful when <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNodeOrFreeBranchEnd()"><CODE>isNodeOrFreeBranchEnd()</CODE></A> method returns <tt>true</tt>,
 i.e. the current position is a node or a free branch end (and corresponds to a node in the nonoriented graph,
 formed by the skeleton), and we need to check, is it connected via a degenerated 0-pixel branch with
 a possible neighbouring node or free branch end (also corresponding to a node in the nonoriented graph).
 It is necessary in algorithms which process degenerated 0-pixel branches in some special way,
 like an algorithm, given in the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the given neighbour of the current element of the skeleton matrix is
                       a node or a free branch end.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="goTo(long...)"><!-- --></A><H3>
goTo</H3>
<PRE>
public void <STRONG>goTo</STRONG>(long...&nbsp;newCurrentCoordinates)</PRE>
<DL>
<DD>Sets the current position in the skeleton matrix to the specified coordinates.

 <p>In simple applications, you do not need this method: it is enough to implement a loop of calls of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>newCurrentCoordinates</CODE> - new current coordinates: the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A> method will return
                              an identical array after this call.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>newCurrentCoordinates</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the length of <tt>newCurrentCoordinates</tt> array is not equal to
                                   <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#dimCount()"><CODE>dimCount()</CODE></A>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if one of new coordinates <tt>newCurrentCoordinates[<i>k</i>]</tt>
                                   is out of range <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>)-1</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>currentCoordinates()</CODE></A>, 
<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray(long)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="goToIndexInArray(long)"><!-- --></A><H3>
goToIndexInArray</H3>
<PRE>
public void <STRONG>goToIndexInArray</STRONG>(long&nbsp;newIndexInArray)</PRE>
<DL>
<DD>Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.
 This method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goto</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#coordinates(long, long[])"><CODE>coordinates</CODE></A>(newIndexInArray, null))</tt></nobr>,
 but usually works much faster (in particular, does not allocate any arrays).
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>newIndexInArray</CODE> - new current index in the built-in AlgART array of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>newIndexInArray</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>-1</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="goToNeighbour(int)"><!-- --></A><H3>
goToNeighbour</H3>
<PRE>
public void <STRONG>goToNeighbour</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Moves the current position in the skeleton matrix to the given neighbour of the current element.
 The neighbour index is specified in terms of
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.
 This method is equivalent to <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray(index)</CODE></A></nobr>,
 where
 <pre>
 index = (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A> + <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourOffsetInArray(int)"><CODE>neighbourOffsetInArray</CODE></A>(neighbourIndex)) % <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>
 </pre>
 Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="nextNodeOrBranch()"><!-- --></A><H3>
nextNodeOrBranch</H3>
<PRE>
public boolean <STRONG>nextNodeOrBranch</STRONG>()</PRE>
<DL>
<DD>Finds the next unit element in the skeleton matrix (in natural order of elements) <i>after</i>
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current position</CODE></A>, the type of which is
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated</CODE></A>
 or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>some branch pixel</CODE></A>, and moves the current position to this element.
 If this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>, finds the first such element.
 Returns <tt>true</tt> if this method has successfully found the required element, or <tt>false</tt>
 if there is no required position, i.e. if the matrix scanning is finished. In the second case,
 the current position is not changed.

 <p>More precisely, this method finds the minimal <i>k</i>, so that<ul>
 <li><nobr><i>k</i> &ge; <tt>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>isInitialized()</CODE></A> ? 0 : <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>+1)</tt></nobr>
 and</li>
 <li><nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes(...)</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>array()</CODE></A>.<A HREF="../../../../net/algart/arrays/PFixedArray.html#getInt(long)"><CODE>getInt</CODE></A>(</tt><i>k</i><tt>)</tt></nobr> is not equal to
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>TYPE_ZERO</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>TYPE_ILLEGAL</CODE></A> (the argument of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#asPixelTypes(net.algart.matrices.skeletons.SkeletonPixelClassifier.AttachmentInformation)"><CODE>asPixelTypes</CODE></A> is not important here).</li>
 </ul>

 <p>If this index <i>k</i> exists, this method performs
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToIndexInArray(long)"><CODE>goToIndexInArray</CODE></A>(<i>k</i>)</tt></nobr> and returns <tt>true</tt>,
 in other case doesn't change the state of this object and returns <tt>false</tt>.

 <p>Note, that if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>, it becomes positioned
 if this method returns <tt>true</tt>, but stays not positioned if it returns <tt>false</tt>.

 <p>After successful call of this method, you can be sure that the current position corresponds:
 <ol>
 <li>either to a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or, maybe,
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixel</CODE></A> (as a degenerated case of the node),</li>
 <li>or to a skeleton branch (including possible case of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>).</li>
 </ol>

 <p>In the first case, i.e. if <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A>, you can find all branches, originating at this node,
 by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> method, which returns indexes of all corresponding neighbours.
 Then you can scan all these branches in a loop, starting the scanning of each branch by<br>
 &nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int neighbourIndex, boolean onlyToUnvisited)</CODE></A><br>
 method, where <tt>neighbourIndex</tt> is an element of the array &mdash; result of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A>.
 If necessary, you can scan each branch until its end by a loop of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> calls,
 like in <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A></nobr> method, and, if the end will be
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> again, for example,
 recursively process this node in the same manner (that means deapth-first graph traversal).

 <p>Note, that the recursion should be used only
 if you remember all visited nodes (to avoid infinite recursion), for example, by using
 a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanner with the argument <tt>onlyToUnvisited=true</tt>.
 Also note, that even remembering scanner does not allow to remember a fact of visiting
 degenerated 0-pixel branches: you should keep this in mind and process degenerated branches,
 if necessary, by some other mechanism.

 <p>In the second case, i.e. if <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>isBranch()</CODE></A>, you should start scanning the found branch by<br>
 &nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean onlyToUnvisited)</CODE></A><br>
 method. But here it is important to distinguish two situations:
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>
 and all other variants (usual branch elements and attachable branch ends).
 The first situation is similar to the first case (a&nbsp;node): it is a node of the skeleton
 nonoriented graph (see the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>), having only one incident edge (branch).
 In the second situation, you can try to move to some <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>
 / <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A> (one of 2 ends of this branch),
 for example, by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch</CODE></A> method with
 <tt>withVisiting=false</tt> argument, but you should remember, that it can be also a <i>cyclic branch</i>
 (the case 7 in the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>). This case can be identified
 via the current pixel type after <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch</CODE></A> call:
 it will be <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isUsualBranch()"><CODE>usual branch pixel</CODE></A> only in a case of a cyclic branch.

 <p>Generally speaking, we do not recommend using Java recursion for graph traversal,
 because the internal JVM stack can be not enough for processing complex skeletons.
 Another approach is using breadth-first algorithm, based on some form of queue.

 <p>A full example of implementation of the breadth-first algorithm,
 with correct processing degenerated 0-pixel branches and cyclic branches,
 is given in the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if this method has successfully found new node or branch pixel.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranchPixelType()"><CODE>nextNodeOrBranchPixelType()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="nextNodeOrBranchPixelType()"><!-- --></A><H3>
nextNodeOrBranchPixelType</H3>
<PRE>
public java.lang.Integer <STRONG>nextNodeOrBranchPixelType</STRONG>()</PRE>
<DL>
<DD>Enhanced version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>, which returns the type of the successfully found element
 in the result or return <tt>null</tt> if the required element is not found.
 More precisely, it is equivalent to
 <pre>
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> ? Integer.valueOf(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A>) : null
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the type of the found pixel (or, for attachable branch end,
         the index of its neighbouring node, which is one of the ends of the branch),
         or <tt>null</tt> if this method does not found the required element.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="adjacentBranches()"><!-- --></A><H3>
adjacentBranches</H3>
<PRE>
public int[] <STRONG>adjacentBranches</STRONG>()
                       throws java.lang.IllegalStateException</PRE>
<DL>
<DD>On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>node</CODE></A>,
 returns indexes of all its neighbours, which are the starting pixels of branches, incident with this node.
 In particular, if some of neighbours of this node are also nodes, this method detects and returns
 in the result the indexes of such from them, which are connected with this node by degenerated
 branches (consisting of 0 pixels).
 If the current pixel is not a node (or isolated pixel), this method throws <tt>IllegalStateException</tt>.

 <p>More precisely, the neighbour index <i>k</i> is an element of the returned array, if and only if:
 <ol>
 <li>the <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep</CODE></A>(<i>k</i>,false)</tt> call, performed at this position,
 would be successful (would return <tt>true</tt> and successfully move the position to that neighbour);</li>
 <li>and, in a case when this neighbour is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>,
 this neighbour is not marked (set to <tt>Integer.MIN_VALUE</tt>) by
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#markNeighbouringNodesNotConnectedViaDegeneratedBranches(int[])"><CODE>markNeighbouringNodesNotConnectedViaDegeneratedBranches</CODE></A></tt></nobr> method, called
 for an array of types of all neighbours of the current node.</li>
 </ol>

 <p>The returned array is always a newly allocated Java array.
 Its length is always not greater than <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>;
 it can be also empty, if the current element is an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ISOLATED"><CODE>isolated pixel</CODE></A>.
 The returned indexes specify neighbours in terms of
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.
 If you need maximal performance, you can eliminate memory allocation in a scanning loop
 by using <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches(int[])"><CODE>adjacentBranches(int[])</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the list of indexes of neighbours of the current pixel (node), towards which this class supposes
         existence of a branch, originating from this node.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                               if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="adjacentBranches(int[])"><!-- --></A><H3>
adjacentBranches</H3>
<PRE>
public int <STRONG>adjacentBranches</STRONG>(int[]&nbsp;result)
                     throws java.lang.IllegalStateException</PRE>
<DL>
<DD>More efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> method, which stores the results
 in the passed Java array instead of creating new Java array.
 This method is equivalent to calling that method and copying its result into
 the beginning of <tt>result</tt> Java array, but does not allocate any arrays.
 It is a better solution if we need to calculate adjacent branches in a long loop,
 because allows to avoid allocating a lot of short arrays.

 <p>The length of the passed array must be greater than or equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>result</CODE> - Java array for storing the results.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the number of found neighbours (which are the starting pixels of branches,
               incident with this node): after calling this method,
               you should use this number of first elements of the <tt>result</tt> array.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>result</tt> argument is <tt>null</tt>.</DD>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>result.length&lt;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A></tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                               if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="firstStep(int, boolean)"><!-- --></A><H3>
firstStep</H3>
<PRE>
public boolean <STRONG>firstStep</STRONG>(int&nbsp;neighbourIndex,
                         boolean&nbsp;onlyToUnvisited)
                  throws java.lang.IllegalStateException</PRE>
<DL>
<DD>On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is a
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>node or isolated pixel</CODE></A>,
 checks whether we have a skeleton branch, originating at this node and going towards its neighbour
 with the index <tt>neighbourIndex</tt>, and, if so, moves the current position to this neighbour and
 returns <tt>true</tt>, if not, does nothing and returns <tt>false</tt>.
 The neighbour index is specified in terms of
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.
 If the current pixel is not a node (or isolated pixel), this method throws <tt>IllegalStateException</tt>.
 The movement along the branch, started by this method, can be continued by a loop of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> calls:
 see an example in comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch</CODE></A> method.

 <p>Warning: unlike <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> and in violation of the definition of the nonoriented graph,
 formed by the skeleton, this method works as if every neighbouring node (when such nodes exist)
 is connected with this one via a degenerated 0-pixel branch.
 So, you should use it together with <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A>.

 <p>More precisely, this method checks the type of the given neighbour:
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)"><CODE>neighbourTypeOrAttachingBranch(neighbourIndex)</CODE></A>.
 <ol>
 <li>If it is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A>,
 this method always moves the current position to that node and returns <tt>true</tt>
 (it can lead to extra degenerated branches, but you can use <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#adjacentBranches()"><CODE>adjacentBranches()</CODE></A> method
 to avoid this);</li>

 <li>If the type of the given neighbour is a
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch element</CODE></A>
 or a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>,
 this method moves the current position to this neighbour and returns <tt>true</tt>.</li>

 <li>If the given neighbour is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#isAttachableBranchEndPixelType(int)"><CODE>attachable branch end</CODE></A>, this method checks its <i>attached node A</i> (returned by
 <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachedNode(int)"><CODE>neighbourTypeOrAttachedNode(neighbourIndex)</CODE></A>)</nobr>
 and the element of <i>attaching branch B</i> (returned by
 <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourTypeOrAttachingBranch(int)"><CODE>neighbourTypeOrAttachingBranch(neighbourIndex)</CODE></A>)</nobr>
 &mdash; see the description of group 5 of pixel types in the
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html" title="class in net.algart.matrices.skeletons"><CODE>comments to SkeletonPixelClassifier</CODE></A>.
 If one of pixels <i>A</i> or <i>B</i> is the current node, this method moves the current position to
 this neighbour and returns <tt>true</tt>, in other case if does nothing and returns <tt>false</tt>.</li>

 <li>In all other situations (the given neighbour is zero or
 "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A>" unit element),
 this method does nothing and returns <tt>false</tt>.</li>
 </ol>

 <p>The rules, listed above, are used as described if the argument <tt>onlyToUnvisited</tt> is <tt>false</tt>.
 If it is <tt>true</tt> and if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>, this method also checks,
 whether the given neighbour was already visited, i.e. checks the result of
 <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourVisitRemembered(int)"><CODE>neighbourVisitRemembered(neighbourIndex)</CODE></A></nobr> call.
 If that call returns <tt>true</tt>, this method does nothing and returns <tt>false</tt>,
 in other case it works as described above.

 <p>Note, that even if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>, this method does not store
 information about visiting pixels. If you want, you should do this manually by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.

 <p>Note, that we allow a situation when the neighbouring elements are out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                        <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD><DD><CODE>onlyToUnvisited</CODE> - whether this method should go only to neighbours, which were never be visited before
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the current position has been successfully moved to the neighbour.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                                   if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A></tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="firstStepFromBranch(boolean)"><!-- --></A><H3>
firstStepFromBranch</H3>
<PRE>
public boolean <STRONG>firstStepFromBranch</STRONG>(boolean&nbsp;onlyToUnvisited)
                            throws java.lang.IllegalStateException</PRE>
<DL>
<DD>On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>some branch pixel</CODE></A>,
 moves the current position to a neighbour along this skeleton branch and returns <tt>true</tt>.
 If the current pixel is not a branch pixel, this method throws <tt>IllegalStateException</tt>.
 In a case of success (this method successfully changes the position and returns <tt>true</tt>),
 the previous current position is internally stored: it will be used in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> method
 to finish scanning a cyclic branch.
 The movement along the branch, started by this method, can be continued by a loop of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> calls:
 see an example in comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch</CODE></A> method.

 <p>More precisely:
 <ol>
 <li>if the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>,
 this method moves the current position to its only unit neighbour <i>Q</i>;</li>

 <li>if the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch element</CODE></A>,
 this method moves the current position to some of 2 its unit neighbours
 <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>;</li>

 <li>if the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isAttachableBranchEnd()"><CODE>attachable branch end</CODE></A>,
 this method moves the current position to some of 2 its neighbours
 <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>, indexes of which
 are returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A> methods.</li>
 </ol>

 <p>The rules, listed above, are used as described if the argument <tt>onlyToUnvisited</tt> is <tt>false</tt>.
 If it is <tt>true</tt> and if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>, this method also checks,
 whether the neighbours were already visited, i.e. checks the result of
 <nobr><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#neighbourVisitRemembered(int)"><CODE>neighbourVisitRemembered(...)</CODE></A></nobr> call
 for the one (case 1) or for both (cases 2 and 3) neighbours.
 If that call returns <tt>false</tt> for the only neighbour <i>Q</i> (case 1) or for some of two neighbours
 <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub> (cases 2 and 3),
 this method moves to that neighbour and returns <tt>true</tt>.
 In other case it does nothing and returns <tt>false</tt>.

 <p>Note, that even if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>, this method does not store
 information about visiting pixels. If you want, you should do this manually by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.

 <p>Note, that it is undocumented, which of two neighbours <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>
 is selected in cases 2 and 3 (if one of them is not disabled because <tt>onlyToUnvisited=true</tt>
 and it was already visited).

 <p>Note, that we allow a situation when the neighbouring elements are out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.

 <p>This method is implemented in the following way:
 <pre>
     int nextNeighbourIndex = <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranchNeighbourIndex(boolean)"><CODE>firstStepFromBranchNeighbourIndex</CODE></A>(onlyToUnvisited);
     if (nextNeighbourIndex == -1) {
         return false;
     }
     this.startIndexInArray = <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>;
     // - an internal field; it will be used in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> to finish scanning a cyclic branch
     <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToNeighbour(int)"><CODE>goToNeighbour</CODE></A>(nextNeighbourIndex);
     this.previousBranchStepDirection = nextNeighbourIndex;
     // - an internal field, returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousBranchStepDirection()"><CODE>previousBranchStepDirection()</CODE></A> method
     return true;
 </pre>
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>onlyToUnvisited</CODE> - whether this method should go only to neighbours, which were never be visited before
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the current position has been successfully moved to the neighbour.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                               if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>isBranch()</CODE></A></tt>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch(boolean, boolean)</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="firstStepFromBranchNeighbourIndex(boolean)"><!-- --></A><H3>
firstStepFromBranchNeighbourIndex</H3>
<PRE>
public int <STRONG>firstStepFromBranchNeighbourIndex</STRONG>(boolean&nbsp;onlyToUnvisited)
                                      throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Returns the index of the neighbour, to which <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean onlyToUnvisited)</CODE></A> moves
 when called with the same <tt>onlyToUnvisited</tt> argument.
 If that method returns <tt>false</tt> and does not move anywhere, this method returns <tt>-1</tt>.
 If that method throws <tt>IllegalStateException</tt>, this method also throws this exception.
 Unlike <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>, this method does not change anything in the internal state
 of the object.

 <p>See comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> method for more details.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>onlyToUnvisited</CODE> - whether this method should check only neighbours, which were never be visited before
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>the index of the neighbour <tt>true</tt>, to which <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>
                        will move if it will be called.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                               if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>isBranch()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="nextStep()"><!-- --></A><H3>
nextStep</H3>
<PRE>
public boolean <STRONG>nextStep</STRONG>()
                 throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Continues movement along the skeleton branch, started by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> method, and returns <tt>true</tt>,
 if the end of the current branch is not reached yet, or does nothing and returns <tt>false</tt>
 if we have reached the end of the branch (usually a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>).

 <p>This method may be called only if the previous change of the current position was performed
 by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or this method.
 In other case (for example, if the last change of the current position was performed by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A>
 or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>), this method throws <tt>IllegalStateException</tt>.

 <p>More precisely:
 <ol>
 <li>if the current position is equal to the position, stored in the beginning of the last
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> call, this method does nothing and returns <tt>false</tt>
 (it means that we've finished scanning of this cyclic branch and returned to the original position);</li>

 <li>if the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>,
 this method does nothing and returns <tt>false</tt>
 (it means that we've reached the free end of this branch);</li>

 <li>if the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch element</CODE></A>,
 this method moves the current position to that from its 2 unit neighbours
 <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>,
 which was not current before the previous change of the current position via
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or this method,
 and returns <tt>true</tt>;</li>

 <li>if the current pixel is an <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isAttachableBranchEnd()"><CODE>attachable branch end</CODE></A>,
 this method finds 2 its neighbours <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>, indexes of which
 are returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachingBranch()"><CODE>currentPixelTypeOrAttachingBranch()</CODE></A> and
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentPixelTypeOrAttachedNode()"><CODE>currentPixelTypeOrAttachedNode()</CODE></A> methods,
 and moves the current position to that from <i>Q</i><sub>1</sub> and <i>Q</i><sub>2</sub>,
 which was not current before the previous change of the current position via
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or this method,
 and returns <tt>true</tt>;</li>

 <li>if the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_NODE"><CODE>node</CODE></A> or an
 "<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ILLEGAL"><CODE>illegal</CODE></A>" pixel, this method does nothing
 and returns <tt>false</tt> (it means that we've reached the node at the end of this branch
 or we cannot continue scanning because this pixel cannot belong to a correct skeleton);</li>

 <li>if the current element is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_ZERO"><CODE>zero</CODE></A>,
 this method throws <tt>IllegalStateException</tt>.</li>
 </ol>

 <p>Note, that this method does not use information about possible previous visits of the pixels, probably
 remembered if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>.

 <p>Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD><tt>true</tt> if the current position has been successfully moved to the neighbour.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>,
                               or if the previous change of the current position was performed not by
                               this method and not by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A> or
                               <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="scanBranch(int, boolean, boolean)"><!-- --></A><H3>
scanBranch</H3>
<PRE>
public void <STRONG>scanBranch</STRONG>(int&nbsp;neighbourIndex,
                       boolean&nbsp;onlyToUnvisited,
                       boolean&nbsp;withVisiting)
                throws java.lang.IllegalStateException</PRE>
<DL>
<DD>On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is a
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>node or isolated pixel</CODE></A>,
 completely scans the branch, originating at this node and going towards its neighbour with the given index.
 If <tt>onlyToUnvisited</tt> argument is <tt>true</tt>, this method does not try to scan a branch,
 the first pixel of which was already visited.
 If <tt>withVisiting</tt> argument is <tt>true</tt>, this method marks all visited and left pixels
 (including the starting node, but excluding the finish pixel) by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.
 Both arguments <tt>onlyToUnvisited</tt> and <tt>withVisiting</tt> have no effect if this
 scanner is not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>.

 <p>More precisely, this method is equivalent to the following code:
 <pre>
 if (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep</CODE></A>(neighbourIndex, onlyToUnvisited)) {
     do {
         if (withVisiting) {
             <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A>;
         }
     } while (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>);
 }
 </pre>
 with the only addition that this method also calls
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt>
 method from time to time (if <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>!=null</tt></nobr>)
 to allow interruption of scanning very long branches.
 No other methods of the context are called.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                        <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD><DD><CODE>onlyToUnvisited</CODE> - whether this method should go only to neighbours, which were never be visited before
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD><DD><CODE>withVisiting</CODE> - whether this method should call <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> after each step
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                                   if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isNode()"><CODE>isNode()</CODE></A></tt>.</DD>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="scanBranchFromBranch(boolean, boolean)"><!-- --></A><H3>
scanBranchFromBranch</H3>
<PRE>
public void <STRONG>scanBranchFromBranch</STRONG>(boolean&nbsp;onlyToUnvisited,
                                 boolean&nbsp;withVisiting)
                          throws java.lang.IllegalStateException</PRE>
<DL>
<DD>On the assumption that the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current pixel</CODE></A> is
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>some branch pixel</CODE></A>,
 scans the part of this branch towards one of the sides of the current pixel.
 If the current pixel is a <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_FREE_BRANCH_END"><CODE>free branch end</CODE></A>
 or if this branch is cyclic (consists of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#TYPE_USUAL_BRANCH"><CODE>usual branch pixels</CODE></A>
 only), this method completely scans whole this branch.
 If <tt>onlyToUnvisited</tt> argument is <tt>true</tt>, this method does not try to scan a branch,
 if the first scanned pixel was already visited.
 If <tt>withVisiting</tt> argument is <tt>true</tt>, this method marks all visited and left pixels
 (including the starting pixel, but excluding the finish one) by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.
 Both arguments <tt>onlyToUnvisited</tt> and <tt>withVisiting</tt> have no effect if this
 scanner is not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>.

 <p>More precisely, this method is equivalent to the following code:
 <pre>
 if (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch</CODE></A>(onlyToUnvisited)) {
     do {
         if (withVisiting) {
             <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A>;
         }
     } while (<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>);
 }
 </pre>
 with the only addition that this method also calls
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt>
 method from time to time (if <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>!=null</tt></nobr>)
 to allow interruption of scanning very long branches.
 No other methods of the context are called.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>onlyToUnvisited</CODE> - whether this method should go only to neighbours, which were never be visited before
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD><DD><CODE>withVisiting</CODE> - whether this method should call <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> after each step
                        (this argument affects only if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A>).</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A> or
                                   if <tt>!<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isBranch()"><CODE>isBranch()</CODE></A></tt>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="previousBranchStepDirection()"><!-- --></A><H3>
previousBranchStepDirection</H3>
<PRE>
public int <STRONG>previousBranchStepDirection</STRONG>()</PRE>
<DL>
<DD>Returns an index of the neighbour, towards which the current position was moved
 by the previous change of the current position via
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> method,
 or <tt>-1</tt> if the previous change of the current position was performed by some other method
 like <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>.
 This neighbour index is specified in terms of
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr>
 method. So, if <tt>direction</tt> is the result of this method and it is not <tt>-1</tt>,
 then <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#reverseNeighbourIndex(int)"><CODE>reverseNeighbourIndex(direction)</CODE></A></tt></nobr> is an index
 of the neighbour of the current element, which was current before the last movement.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the direction of the last movement of the current position along a branch,
         performed by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>
         or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> method, or <tt>-1</tt> if the last movement was performed by another method.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="previousCoordinates()"><!-- --></A><H3>
previousCoordinates</H3>
<PRE>
public long[] <STRONG>previousCoordinates</STRONG>()</PRE>
<DL>
<DD>Returns the coordinates of the neighbour of the current element, which was current before the last change
 of the current position, if this change was performed via
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A> method,
 or throws <tt>IllegalStateException</tt> if the previous change of the current position was performed
 by some other method like <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goTo(long...)"><CODE>goTo(long...)</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A>.

 <p>The returned array is always a newly allocated Java array.
 Its length is always equal to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#dimCount()"><CODE>dimCount()</CODE></A>.
 The returned coordinates are always in ranges
 <pre>
 0 &le; result[<i>k</i>] &lt; <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#dim(int)"><CODE>dim</CODE></A>(<i>k</i>),
 </pre>where <tt>result[<i>k</i>]</tt> is the element <tt>#<i>k</i></tt> in the returned array.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the coordinates of the previous current pixel.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>,
                               or if the previous change of the current position was performed not by
                               not by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>
                               or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>.</DD><DT><STRONG>See Also:</STRONG></DT><DD><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousIndexInArray()"><CODE>previousIndexInArray()</CODE></A></DD></DL>
</DD>
</DL>
<HR>

<A NAME="previousIndexInArray()"><!-- --></A><H3>
previousIndexInArray</H3>
<PRE>
public long <STRONG>previousIndexInArray</STRONG>()</PRE>
<DL>
<DD>Reduced and more efficient version of <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previousCoordinates()</CODE></A>, designed for indexing
 elements of the <A HREF="../../../../net/algart/arrays/Matrix.html#array()"><CODE>built-in AlgART array</CODE></A> of the skeleton matrix.
 This method is equivalent to
 <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#index(long...)"><CODE>index</CODE></A>(<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previousCoordinates()</CODE></A>)</tt></nobr>,
 but usually works much faster (in particular, does not allocate any arrays).

 <p>The result of this method is always in range
 <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>-1</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>the previous current index in the built-in AlgART array of the skeleton matrix.</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>,
                               or if the previous change of the current position was performed not by
                               not by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>
                               or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="isRemembering()"><!-- --></A><H3>
isRemembering</H3>
<PRE>
public boolean <STRONG>isRemembering</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this scanner is remembering or <tt>false</tt> if it is lightweight.
 See the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A> about remembering and lightweight skeleton scanners.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether this class is remembering.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="pixelVisitRemembered()"><!-- --></A><H3>
pixelVisitRemembered</H3>
<PRE>
public boolean <STRONG>pixelVisitRemembered</STRONG>()</PRE>
<DL>
<DD>Returns <tt>true</tt> if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> and
 the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> was already visited by
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.

 <p>If this scanner is lightweight, this method always returns <tt>false</tt>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>whether the current pixel is marked as "visited".</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="neighbourVisitRemembered(int)"><!-- --></A><H3>
neighbourVisitRemembered</H3>
<PRE>
public boolean <STRONG>neighbourVisitRemembered</STRONG>(int&nbsp;neighbourIndex)</PRE>
<DL>
<DD>Returns <tt>true</tt> if this scanner is <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> and
 the neighbour of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> with the given index
 was already visited by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visit()"><CODE>visit()</CODE></A> or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#visitPreviousBranchPixel()"><CODE>visitPreviousBranchPixel()</CODE></A> method.
 The result will be the same as if we would call
 <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#goToNeighbour(int)"><CODE>goToNeighbour</CODE></A>(neighbourIndex)</tt> and then call
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()"><CODE>pixelVisitRemembered()</CODE></A>, but this method does not change the current position.

 <p>If this scanner is lightweight, this method always returns <tt>false</tt>.

 <p>Note, that we allow a situation when the neighbouring element is out of ranges of the matrix coordinates.
 This situation is processed according to the model of infinite pseudo-cyclical continuation &mdash;
 see the end of the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html" title="class in net.algart.matrices.skeletons"><CODE>comments to this class</CODE></A>.
<P>
</DD>
<DD><DL>
<DT><STRONG>Parameters:</STRONG></DT><DD><CODE>neighbourIndex</CODE> - the index of the neighbour, in terms of
                       <nobr><tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelClassifier()"><CODE>pixelClassifier()</CODE></A>.<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.html#neighbourOffset(int)"><CODE>neighbourOffset(int)</CODE></A></tt></nobr> method.</DD>
<DT><STRONG>Returns:</STRONG></DT><DD>whether the given neighbour of the current pixel is marked as "visited".</DD>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <tt>neighbourIndex</tt> is out of range
                                   <tt>0..<A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#numberOfNeighbours()"><CODE>numberOfNeighbours()</CODE></A>-1</tt>.</DD>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="visit()"><!-- --></A><H3>
visit</H3>
<PRE>
public void <STRONG>visit</STRONG>()</PRE>
<DL>
<DD>In <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanners,
 marks the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentCoordinates()"><CODE>current element</CODE></A> of the skeleton matrix as "visited".
 In lightweight scanners, this method does nothing.

 <p>Note that the only way to "unmark" the visited element (i.e. to change its state back to "unvisited")
 is calling <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#reset()"><CODE>reset()</CODE></A> method.
<P>
</DD>
<DD><DL>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="visitPreviousBranchPixel()"><!-- --></A><H3>
visitPreviousBranchPixel</H3>
<PRE>
public void <STRONG>visitPreviousBranchPixel</STRONG>()</PRE>
<DL>
<DD>In <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanners,
 marks the <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previous visited element</CODE></A> of the skeleton matrix as "visited".
 In lightweight scanners, this method does nothing.
 The "previous visited element" means the neighbour of the current element, coordinates of which
 are returned by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#previousCoordinates()"><CODE>previousCoordinates()</CODE></A> method.

 <p>Note that the only way to "unmark" the visited element (i.e. to change its state back to "unvisited")
 is calling <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#reset()"><CODE>reset()</CODE></A> method.

 <p>This methods is useful in loops of scanning skeleton branches: see examples of such loops
 in comments to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranch(int, boolean, boolean)"><CODE>scanBranch(int, boolean, boolean)</CODE></A> and <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#scanBranchFromBranch(boolean, boolean)"><CODE>scanBranchFromBranch(boolean, boolean)</CODE></A>
 methods.
<P>
</DD>
<DD><DL>
<DT><STRONG>Throws:</STRONG></DT>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this scanner was not <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>positioned yet</CODE></A>,
                               or if the previous change of the current position was performed not by
                               not by <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStep(int, boolean)"><CODE>firstStep(int, boolean)</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#firstStepFromBranch(boolean)"><CODE>firstStepFromBranch(boolean)</CODE></A>
                               or <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextStep()"><CODE>nextStep()</CODE></A>.</DD></DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <STRONG>reset</STRONG>()</PRE>
<DL>
<DD>Clears the state of this scanner: resets the current position to <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isInitialized()"><CODE>not positioned</CODE></A> state
 and, in <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#isRemembering()"><CODE>remembering</CODE></A> scanners, resets the state of all pixels to
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#pixelVisitRemembered()"><CODE>unvisited</CODE></A>.
<P>
</DD>
</DL>
<HR>

<A NAME="updateProgress()"><!-- --></A><H3>
updateProgress</H3>
<PRE>
public void <STRONG>updateProgress</STRONG>()</PRE>
<DL>
<DD>Calls <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>.<A HREF="../../../../net/algart/arrays/ArrayContext.html#updateProgress(net.algart.arrays.ArrayContext.Event)"><CODE>updateProgress(event)</CODE></A></tt>
 with an event, created by the following operator:
 <nobr><tt>new ArrayContext.Event(boolean.class, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#currentIndexInArray()"><CODE>currentIndexInArray()</CODE></A>, <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#skeleton()"><CODE>skeleton()</CODE></A>.<A HREF="../../../../net/algart/arrays/Matrix.html#size()"><CODE>size()</CODE></A>)</tt></nobr>,
 or does nothing if <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>==null</tt>.

 <p>The method can be useful while sequentially scanning the skeleton via a usual loop of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> calls.
<P>
</DD>
</DL>
<HR>

<A NAME="checkInterruption()"><!-- --></A><H3>
checkInterruption</H3>
<PRE>
public void <STRONG>checkInterruption</STRONG>()</PRE>
<DL>
<DD>Calls <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>.<A HREF="../../../../net/algart/arrays/ArrayContext.html#checkInterruption()"><CODE>checkInterruption()</CODE></A></tt>
 or does nothing if <tt><A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#context()"><CODE>context()</CODE></A>==null</tt>.

 <p>The method can be useful while sequentially scanning the skeleton via a usual loop of
 <A HREF="../../../../net/algart/matrices/skeletons/SkeletonScanner.html#nextNodeOrBranch()"><CODE>nextNodeOrBranch()</CODE></A> calls.
<P>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <STRONG>toString</STRONG>()</PRE>
<DL>
<DD>Returns a brief string description of this object.

 <p>The result of this method may depend on implementation and usually contains
 a short description of the current state of the scanner.
<P>
</DD>
<DD><DL>
<DT><STRONG>Overrides:</STRONG></DT><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DD>
</DL>
</DD>
<DD><DL>
<DT><STRONG>Returns:</STRONG></DT><DD>a brief string description of this object.</DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Overview</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><STRONG>Package</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><STRONG>Class</STRONG></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><STRONG>Tree</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><STRONG>Deprecated</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><STRONG>Index</STRONG></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><STRONG>Help</STRONG></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

<!--(removed by JavaDocCorrector)-->
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/SkeletonPixelClassifier.AttachmentInformation.html" title="enum in net.algart.matrices.skeletons"><STRONG>PREV CLASS</STRONG></A>&nbsp;
&nbsp;<A HREF="../../../../net/algart/matrices/skeletons/StrongQuadruple3x5ThinningSkeleton2D.html" title="class in net.algart.matrices.skeletons"><STRONG>NEXT CLASS</STRONG></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/algart/matrices/skeletons/SkeletonScanner.html" target="_top"><STRONG>FRAMES</STRONG></A>  &nbsp;
&nbsp;<A HREF="SkeletonScanner.html" target="_top"><STRONG>NO FRAMES</STRONG></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><STRONG>All Classes</STRONG></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

<!--algartBottom-->
<div align="center" style="margin-top:32px;margin-bottom:8px">
<!--#include virtual="/ad_bottom_utf8.php"-->
</div>
<!--/algartBottom-->

</BODY>
</HTML>
